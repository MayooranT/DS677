{"content":{"code":"IL2CPP_EXTERN_C IL2CPP_METHOD_ATTR void List_1__ctor_m2716C5BEDCDB58D5B0C144DA4837DAF99E86D871_gshared (List_1_t2DB9B7314D41FB8C9F99391E55195E3865AB0C35 * __this, RuntimeObject* ___collection0, const RuntimeMethod* method)\n{\n\tstatic bool s_Il2CppMethodInitialized;\n\tif (!s_Il2CppMethodInitialized)\n\t{\n\t\til2cpp_codegen_initialize_runtime_metadata((uintptr_t*)&IDisposable_t099785737FC6A1E3699919A94109383715A8D807_il2cpp_TypeInfo_var);\n\t\til2cpp_codegen_initialize_runtime_metadata((uintptr_t*)&IEnumerator_t5956F3AFB7ECF1117E3BC5890E7FC7B7F7A04105_il2cpp_TypeInfo_var);\n\t\ts_Il2CppMethodInitialized = true;\n\t}\n\tRuntimeObject* V_0 = NULL;\n\tint32_t V_1 = 0;\n\tRuntimeObject* V_2 = NULL;\n\tException_t * __last_unhandled_exception = 0;\n\til2cpp::utils::ExceptionSupportStack<int32_t, 1> __leave_targets;\n\t{\n\t\tNullCheck((RuntimeObject *)__this);\n\t\tObject__ctor_m88880E0413421D13FD95325EDCE231707CE1F405((RuntimeObject *)__this, \/*hidden argument*\/NULL);\n\t\tRuntimeObject* L_0 = ___collection0;\n\t\tif (L_0)\n\t\t{\n\t\t\tgoto IL_000f;\n\t\t}\n\t}\n\t{\n\t\tThrowHelper_ThrowArgumentNullException_m539081110B94B71D92C9761B273E617B23B4BBA5((int32_t)6, \/*hidden argument*\/NULL);\n\t}\n\nIL_000f:\n\t{\n\t\tRuntimeObject* L_1 = ___collection0;\n\t\tV_0 = (RuntimeObject*)((RuntimeObject*)IsInst((RuntimeObject*)L_1, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 2)));\n\t\tRuntimeObject* L_2 = V_0;\n\t\tif (!L_2)\n\t\t{\n\t\t\tgoto IL_0050;\n\t\t}\n\t}\n\t{\n\t\tRuntimeObject* L_3 = V_0;\n\t\tNullCheck((RuntimeObject*)L_3);\n\t\tint32_t L_4;\n\t\tL_4 = InterfaceFuncInvoker0< int32_t >::Invoke(0 \/* System.Int32 System.Collections.Generic.ICollection`1<kcp2k.Kcp\/AckItem>::get_Count() *\/, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 2), (RuntimeObject*)L_3);\n\t\tV_1 = (int32_t)L_4;\n\t\tint32_t L_5 = V_1;\n\t\tif (L_5)\n\t\t{\n\t\t\tgoto IL_002f;\n\t\t}\n\t}\n\t{\n\t\tIL2CPP_RUNTIME_CLASS_INIT(IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 0));\n\t\tAckItemU5BU5D_t16E6F0F8EDCAD3760512E2474ED18BA9CF03862C* L_6 = ((List_1_t2DB9B7314D41FB8C9F99391E55195E3865AB0C35_StaticFields*)il2cpp_codegen_static_fields_for(IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 0)))->get__emptyArray_5();\n\t\t__this->set__items_1(L_6);\n\t\treturn;\n\t}\n\nIL_002f:\n\t{\n\t\tint32_t L_7 = V_1;\n\t\tAckItemU5BU5D_t16E6F0F8EDCAD3760512E2474ED18BA9CF03862C* L_8 = (AckItemU5BU5D_t16E6F0F8EDCAD3760512E2474ED18BA9CF03862C*)(AckItemU5BU5D_t16E6F0F8EDCAD3760512E2474ED18BA9CF03862C*)SZArrayNew(IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 1), (uint32_t)L_7);\n\t\t__this->set__items_1(L_8);\n\t\tRuntimeObject* L_9 = V_0;\n\t\tAckItemU5BU5D_t16E6F0F8EDCAD3760512E2474ED18BA9CF03862C* L_10 = (AckItemU5BU5D_t16E6F0F8EDCAD3760512E2474ED18BA9CF03862C*)__this->get__items_1();\n\t\tNullCheck((RuntimeObject*)L_9);\n\t\tInterfaceActionInvoker2< AckItemU5BU5D_t16E6F0F8EDCAD3760512E2474ED18BA9CF03862C*, int32_t >::Invoke(5 \/* System.Void System.Collections.Generic.ICollection`1<kcp2k.Kcp\/AckItem>::CopyTo(T[],System.Int32) *\/, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 2), (RuntimeObject*)L_9, (AckItemU5BU5D_t16E6F0F8EDCAD3760512E2474ED18BA9CF03862C*)L_10, (int32_t)0);\n\t\tint32_t L_11 = V_1;\n\t\t__this->set__size_2(L_11);\n\t\treturn;\n\t}\n\nIL_0050:\n\t{\n\t\t__this->set__size_2(0);\n\t\tIL2CPP_RUNTIME_CLASS_INIT(IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 0));\n\t\tAckItemU5BU5D_t16E6F0F8EDCAD3760512E2474ED18BA9CF03862C* L_12 = ((List_1_t2DB9B7314D41FB8C9F99391E55195E3865AB0C35_StaticFields*)il2cpp_codegen_static_fields_for(IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 0)))->get__emptyArray_5();\n\t\t__this->set__items_1(L_12);\n\t\tRuntimeObject* L_13 = ___collection0;\n\t\tNullCheck((RuntimeObject*)L_13);\n\t\tRuntimeObject* L_14;\n\t\tL_14 = InterfaceFuncInvoker0< RuntimeObject* >::Invoke(0 \/* System.Collections.Generic.IEnumerator`1<T> System.Collections.Generic.IEnumerable`1<kcp2k.Kcp\/AckItem>::GetEnumerator() *\/, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 3), (RuntimeObject*)L_13);\n\t\tV_2 = (RuntimeObject*)L_14;\n\t}\n\nIL_0069:\n\ttry\n\t{ \/\/ begin try (depth: 1)\n\t\t{\n\t\t\tgoto IL_0077;\n\t\t}\n\nIL_006b:\n\t\t{\n\t\t\tRuntimeObject* L_15 = V_2;\n\t\t\tNullCheck((RuntimeObject*)L_15);\n\t\t\tAckItem_tD2ED0619A5C91987CDF01FD4C960708EF1524475  L_16;\n\t\t\tL_16 = InterfaceFuncInvoker0< AckItem_tD2ED0619A5C91987CDF01FD4C960708EF1524475  >::Invoke(0 \/* T System.Collections.Generic.IEnumerator`1<kcp2k.Kcp\/AckItem>::get_Current() *\/, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 4), (RuntimeObject*)L_15);\n\t\t\tNullCheck((List_1_t2DB9B7314D41FB8C9F99391E55195E3865AB0C35 *)__this);\n\t\t\t((  void (*) (List_1_t2DB9B7314D41FB8C9F99391E55195E3865AB0C35 *, AckItem_tD2ED0619A5C91987CDF01FD4C960708EF1524475 , const RuntimeMethod*))IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 5)->methodPointer)((List_1_t2DB9B7314D41FB8C9F99391E55195E3865AB0C35 *)__this, (AckItem_tD2ED0619A5C91987CDF01FD4C960708EF1524475 )L_16, \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 5));\n\t\t}\n\nIL_0077:\n\t\t{\n\t\t\tRuntimeObject* L_17 = V_2;\n\t\t\tNullCheck((RuntimeObject*)L_17);\n\t\t\tbool L_18;\n\t\t\tL_18 = InterfaceFuncInvoker0< bool >::Invoke(0 \/* System.Boolean System.Collections.IEnumerator::MoveNext() *\/, IEnumerator_t5956F3AFB7ECF1117E3BC5890E7FC7B7F7A04105_il2cpp_TypeInfo_var, (RuntimeObject*)L_17);\n\t\t\tif (L_18)\n\t\t\t{\n\t\t\t\tgoto IL_006b;\n\t\t\t}\n\t\t}\n\nIL_007f:\n\t\t{\n\t\t\tIL2CPP_LEAVE(0x8B, FINALLY_0081);\n\t\t}\n\t} \/\/ end try (depth: 1)\n\tcatch(Il2CppExceptionWrapper& e)\n\t{\n\t\t__last_unhandled_exception = (Exception_t *)e.ex;\n\t\tgoto FINALLY_0081;\n\t}\n\nFINALLY_0081:\n\t{ \/\/ begin finally (depth: 1)\n\t\t{\n\t\t\tRuntimeObject* L_19 = V_2;\n\t\t\tif (!L_19)\n\t\t\t{\n\t\t\t\tgoto IL_008a;\n\t\t\t}\n\t\t}\n\nIL_0084:\n\t\t{\n\t\t\tRuntimeObject* L_20 = V_2;\n\t\t\tNullCheck((RuntimeObject*)L_20);\n\t\t\tInterfaceActionInvoker0::Invoke(0 \/* System.Void System.IDisposable::Dispose() *\/, IDisposable_t099785737FC6A1E3699919A94109383715A8D807_il2cpp_TypeInfo_var, (RuntimeObject*)L_20);\n\t\t}\n\nIL_008a:\n\t\t{\n\t\t\tIL2CPP_END_FINALLY(129)\n\t\t}\n\t} \/\/ end finally (depth: 1)\n\tIL2CPP_CLEANUP(129)\n\t{\n\t\tIL2CPP_RETHROW_IF_UNHANDLED(Exception_t *)\n\t\tIL2CPP_JUMP_TBL(0x8B, IL_008b)\n\t}\n\nIL_008b:\n\t{\n\t\treturn;\n\t}\n}","docstring":"\/\/ end finally (depth: 1)","function_name":"List_1_InsertRange_mDEF514565A34924F191DBC38F0E98BE48AD1AB6A_gshared"},"id":1,"seed":"IL2CPP_EXTERN_C IL2CPP_METHOD_ATTR void List_1__ctor_m2716C5BEDCDB58D5B0C144DA4837DAF99E86D871_gshared (List_1_t2DB9B7314D41FB8C9F99391E55195E3865AB0C35 * __this, RuntimeObject* ___collection0, const RuntimeMethod* method)\n{\n\tstatic bool s_Il2CppMethodInitialized;\n\tif (!s_Il2CppMethodInitialized)\n\t{\n\t\til2cpp_codegen_initialize_runtime_metadata((uintptr_t*)&IDisposable_t099785737FC6A1E3699919A94109383715A8D807_il2cpp_TypeInfo_var);\n\t\til2cpp_codegen_initialize_runtime_metadata((uintptr_t*)&IEnumerator_t5956F3AFB7ECF1117E3BC5890E7FC7B7F7A04105_il2cpp_TypeInfo_var);\n\t\ts_Il2CppMethodInitialized = true;\n\t}\n\tRuntimeObject* V_0 = NULL;\n\tint32_t V_1 = 0;\n\tRuntimeObject* V_2 = NULL;\n\tException_t * __last_unhandled_exception = 0;\n\til2cpp::utils::ExceptionSupportStack<int32_t, 1> __leave_targets;\n\t{\n\t\tNullCheck((RuntimeObject *)__this);\n\t\tObject__ctor_m88880E0413421D13FD95325EDCE231707CE1F405((RuntimeObject *)__this, \/*hidden argument*\/NULL);\n\t\tRuntimeObject* L_0 = ___collection0;\n\t\tif (L_0)\n\t\t{\n\t\t\tgoto IL_000f;\n\t\t}\n\t}\n\t{\n\t\tThrowHelper_ThrowArgumentNullException_m539081110B94B71D92C9761B273E617B23B4BBA5((int32_t)6, \/*hidden argument*\/NULL);\n\t}\n\nIL_000f:\n\t{\n\t\tRuntimeObject* L_1 = ___collection0;\n\t\tV_0 = (RuntimeObject*)((RuntimeObject*)IsInst((RuntimeObject*)L_1, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 2)));\n\t\tRuntimeObject* L_2 = V_0;\n\t\tif (!L_2)\n\t\t{\n\t\t\tgoto IL_0050;\n\t\t}\n\t}\n\t{\n\t\tRuntimeObject* L_3 = V_0;\n\t\tNullCheck((RuntimeObject*)L_3);\n\t\tint32_t L_4;\n\t\tL_4 = InterfaceFuncInvoker0< int32_t >::Invoke(0 \/* System.Int32 System.Collections.Generic.ICollection`1<kcp2k.Kcp\/AckItem>::get_Count() *\/, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 2), (RuntimeObject*)L_3);\n\t\tV_1 = (int32_t)L_4;\n\t\tint32_t L_5 = V_1;\n\t\tif (L_5)\n\t\t{\n\t\t\tgoto IL_002f;\n\t\t}\n\t}\n\t{\n\t\tIL2CPP_RUNTIME_CLASS_INIT(IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 0));\n\t\tAckItemU5BU5D_t16E6F0F8EDCAD3760512E2474ED18BA9CF03862C* L_6 = ((List_1_t2DB9B7314D41FB8C9F99391E55195E3865AB0C35_StaticFields*)il2cpp_codegen_static_fields_for(IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 0)))->get__emptyArray_5();\n\t\t__this->set__items_1(L_6);\n\t\treturn;\n\t}\n\nIL_002f:\n\t{\n\t\tint32_t L_7 = V_1;\n\t\tAckItemU5BU5D_t16E6F0F8EDCAD3760512E2474ED18BA9CF03862C* L_8 = (AckItemU5BU5D_t16E6F0F8EDCAD3760512E2474ED18BA9CF03862C*)(AckItemU5BU5D_t16E6F0F8EDCAD3760512E2474ED18BA9CF03862C*)SZArrayNew(IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 1), (uint32_t)L_7);\n\t\t__this->set__items_1(L_8);\n\t\tRuntimeObject* L_9 = V_0;\n\t\tAckItemU5BU5D_t16E6F0F8EDCAD3760512E2474ED18BA9CF03862C* L_10 = (AckItemU5BU5D_t16E6F0F8EDCAD3760512E2474ED18BA9CF03862C*)__this->get__items_1();\n\t\tNullCheck((RuntimeObject*)L_9);\n\t\tInterfaceActionInvoker2< AckItemU5BU5D_t16E6F0F8EDCAD3760512E2474ED18BA9CF03862C*, int32_t >::Invoke(5 \/* System.Void System.Collections.Generic.ICollection`1<kcp2k.Kcp\/AckItem>::CopyTo(T[],System.Int32) *\/, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 2), (RuntimeObject*)L_9, (AckItemU5BU5D_t16E6F0F8EDCAD3760512E2474ED18BA9CF03862C*)L_10, (int32_t)0);\n\t\tint32_t L_11 = V_1;\n\t\t__this->set__size_2(L_11);\n\t\treturn;\n\t}\n\nIL_0050:\n\t{\n\t\t__this->set__size_2(0);\n\t\tIL2CPP_RUNTIME_CLASS_INIT(IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 0));\n\t\tAckItemU5BU5D_t16E6F0F8EDCAD3760512E2474ED18BA9CF03862C* L_12 = ((List_1_t2DB9B7314D41FB8C9F99391E55195E3865AB0C35_StaticFields*)il2cpp_codegen_static_fields_for(IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 0)))->get__emptyArray_5();\n\t\t__this->set__items_1(L_12);\n\t\tRuntimeObject* L_13 = ___collection0;\n\t\tNullCheck((RuntimeObject*)L_13);\n\t\tRuntimeObject* L_14;\n\t\tL_14 = InterfaceFuncInvoker0< RuntimeObject* >::Invoke(0 \/* System.Collections.Generic.IEnumerator`1<T> System.Collections.Generic.IEnumerable`1<kcp2k.Kcp\/AckItem>::GetEnumerator() *\/, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 3), (RuntimeObject*)L_13);\n\t\tV_2 = (RuntimeObject*)L_14;\n\t}\n\nIL_0069:\n\ttry\n\t{ \/\/ begin try (depth: 1)\n\t\t{\n\t\t\tgoto IL_0077;\n\t\t}\n\nIL_006b:\n\t\t{\n\t\t\tRuntimeObject* L_15 = V_2;\n\t\t\tNullCheck((RuntimeObject*)L_15);\n\t\t\tAckItem_tD2ED0619A5C91987CDF01FD4C960708EF1524475  L_16;\n\t\t\tL_16 = InterfaceFuncInvoker0< AckItem_tD2ED0619A5C91987CDF01FD4C960708EF1524475  >::Invoke(0 \/* T System.Collections.Generic.IEnumerator`1<kcp2k.Kcp\/AckItem>::get_Current() *\/, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 4), (RuntimeObject*)L_15);\n\t\t\tNullCheck((List_1_t2DB9B7314D41FB8C9F99391E55195E3865AB0C35 *)__this);\n\t\t\t((  void (*) (List_1_t2DB9B7314D41FB8C9F99391E55195E3865AB0C35 *, AckItem_tD2ED0619A5C91987CDF01FD4C960708EF1524475 , const RuntimeMethod*))IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 5)->methodPointer)((List_1_t2DB9B7314D41FB8C9F99391E55195E3865AB0C35 *)__this, (AckItem_tD2ED0619A5C91987CDF01FD4C960708EF1524475 )L_16, \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 5));\n\t\t}\n\nIL_0077:\n\t\t{\n\t\t\tRuntimeObject* L_17 = V_2;\n\t\t\tNullCheck((RuntimeObject*)L_17);\n\t\t\tbool L_18;\n\t\t\tL_18 = InterfaceFuncInvoker0< bool >::Invoke(0 \/* System.Boolean System.Collections.IEnumerator::MoveNext() *\/, IEnumerator_t5956F3AFB7ECF1117E3BC5890E7FC7B7F7A04105_il2cpp_TypeInfo_var, (RuntimeObject*)L_17);\n\t\t\tif (L_18)\n\t\t\t{\n\t\t\t\tgoto IL_006b;\n\t\t\t}\n\t\t}\n\nIL_007f:\n\t\t{\n\t\t\tIL2CPP_LEAVE(0x8B, FINALLY_0081);\n\t\t}\n\t} \/\/ end try (depth: 1)\n\tcatch(Il2CppExceptionWrapper& e)\n\t{\n\t\t__last_unhandled_exception = (Exception_t *)e.ex;\n\t\tgoto FINALLY_0081;\n\t}\n\nFINALLY_0081:\n\t{ \/\/ begin finally (depth: 1)\n\t\t{\n\t\t\tRuntimeObject* L_19 = V_2;\n\t\t\tif (!L_19)\n\t\t\t{\n\t\t\t\tgoto IL_008a;\n\t\t\t}\n\t\t}\n\nIL_0084:\n\t\t{\n\t\t\tRuntimeObject* L_20 = V_2;\n\t\t\tNullCheck((RuntimeObject*)L_20);\n\t\t\tInterfaceActionInvoker0::Invoke(0 \/* System.Void System.IDisposable::Dispose() *\/, IDisposable_t099785737FC6A1E3699919A94109383715A8D807_il2cpp_TypeInfo_var, (RuntimeObject*)L_20);\n\t\t}\n\nIL_008a:\n\t\t{\n\t\t\tIL2CPP_END_FINALLY(129)\n\t\t}\n\t} \/\/ end finally (depth: 1)\n\tIL2CPP_CLEANUP(129)\n\t{\n\t\tIL2CPP_RETHROW_IF_UNHANDLED(Exception_t *)\n\t\tIL2CPP_JUMP_TBL(0x8B, IL_008b)\n\t}\n\nIL_008b:\n\t{\n\t\treturn;\n\t}\n}"}
{"content":{"code":"bool testUnpacker(){\r\n\tuint32 inst = 0xdeadface;\r\n\tsize_t unpackerSize = sizeof(Instruction::UNPACKER);\r\n\t\/\/std::cout << \"sizeof(Instruction::UNPACKER) = \" << unpackerSize << endl;\r\n\tif(unpackerSize != sizeof(uint32)){\r\n\t\treturn false;\r\n\t}\r\n\r\n\tInstruction::UNPACKER &inst2= reinterpret_cast<Instruction::UNPACKER &>(inst);\r\n\r\n\tif(inst2.i.op != inst2.j.op){\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}","docstring":"\/\/char *buffer = new char[length];\r","function_name":"readFile"},"id":3,"seed":"bool testUnpacker(){\r\n\tuint32 inst = 0xdeadface;\r\n\tsize_t unpackerSize = sizeof(Instruction::UNPACKER);\r\n\t\/\/std::cout << \"sizeof(Instruction::UNPACKER) = \" << unpackerSize << endl;\r\n\tif(unpackerSize != sizeof(uint32)){\r\n\t\treturn false;\r\n\t}\r\n\r\n\tInstruction::UNPACKER &inst2= reinterpret_cast<Instruction::UNPACKER &>(inst);\r\n\r\n\tif(inst2.i.op != inst2.j.op){\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}"}
{"content":{"code":"IL2CPP_EXTERN_C IL2CPP_METHOD_ATTR void List_1_System_Collections_ICollection_CopyTo_mE384ED5CFB72BD40E4ED9118312BBCCA784A85A8_gshared (List_1_t4172DDD081E8C31E82629AD17BC2912ECE329CCD * __this, RuntimeArray * ___array0, int32_t ___arrayIndex1, const RuntimeMethod* method)\n{\n\til2cpp::utils::ExceptionSupportStack<RuntimeObject*, 1> __active_exceptions;\n\til2cpp::utils::ExceptionSupportStack<int32_t, 2> __leave_targets;\n\t{\n\t\tRuntimeArray * L_0 = ___array0;\n\t\tif (!L_0)\n\t\t{\n\t\t\tgoto IL_0012;\n\t\t}\n\t}\n\t{\n\t\tRuntimeArray * L_1 = ___array0;\n\t\tNullCheck((RuntimeArray *)L_1);\n\t\tint32_t L_2;\n\t\tL_2 = Array_get_Rank_mE9E4804EA433AA2265F9D9CA3B1B5082ECD757D0((RuntimeArray *)L_1, \/*hidden argument*\/NULL);\n\t\tif ((((int32_t)L_2) == ((int32_t)1)))\n\t\t{\n\t\t\tgoto IL_0012;\n\t\t}\n\t}\n\t{\n\t\tThrowHelper_ThrowArgumentException_m49831D19CFA6026A62C5D52FA7A8E162EBD4DD6A((int32_t)7, \/*hidden argument*\/NULL);\n\t}\n\nIL_0012:\n\t{\n\t}\n\nIL_0013:\n\ttry\n\t{ \/\/ begin try (depth: 1)\n\t\tCachedShadowRecordU5BU5D_tFB0A186B518D32E07B7026306DEA9081F967962E* L_3 = (CachedShadowRecordU5BU5D_tFB0A186B518D32E07B7026306DEA9081F967962E*)__this->get__items_1();\n\t\tRuntimeArray * L_4 = ___array0;\n\t\tint32_t L_5 = ___arrayIndex1;\n\t\tint32_t L_6 = (int32_t)__this->get__size_2();\n\t\tArray_Copy_m3F127FFB5149532135043FFE285F9177C80CB877((RuntimeArray *)(RuntimeArray *)L_3, (int32_t)0, (RuntimeArray *)L_4, (int32_t)L_5, (int32_t)L_6, \/*hidden argument*\/NULL);\n\t\tgoto IL_0033;\n\t} \/\/ end try (depth: 1)\n\tcatch(Il2CppExceptionWrapper& e)\n\t{\n\t\tif(il2cpp_codegen_class_is_assignable_from (((RuntimeClass*)il2cpp_codegen_initialize_runtime_metadata_inline((uintptr_t*)&ArrayTypeMismatchException_tFD610FDA00012564CB75AFCA3A489F29CF628784_il2cpp_TypeInfo_var)), il2cpp_codegen_object_class(e.ex)))\n\t\t{\n\t\t\tIL2CPP_PUSH_ACTIVE_EXCEPTION(e.ex);\n\t\t\tgoto CATCH_0029;\n\t\t}\n\t\tthrow e;\n\t}\n\nCATCH_0029:\n\t{ \/\/ begin catch(System.ArrayTypeMismatchException)\n\t\tThrowHelper_ThrowArgumentException_m49831D19CFA6026A62C5D52FA7A8E162EBD4DD6A((int32_t)((int32_t)18), \/*hidden argument*\/NULL);\n\t\tIL2CPP_POP_ACTIVE_EXCEPTION();\n\t\tgoto IL_0033;\n\t} \/\/ end catch (depth: 1)\n\nIL_0033:\n\t{\n\t\treturn;\n\t}\n}","docstring":"\/\/ end catch (depth: 1)","function_name":"List_1_System_Collections_IList_Add_mB11B0BE086058B75AABAFE706CC3AAA0012259E8_gshared"},"id":4,"seed":"IL2CPP_EXTERN_C IL2CPP_METHOD_ATTR void List_1_System_Collections_ICollection_CopyTo_mE384ED5CFB72BD40E4ED9118312BBCCA784A85A8_gshared (List_1_t4172DDD081E8C31E82629AD17BC2912ECE329CCD * __this, RuntimeArray * ___array0, int32_t ___arrayIndex1, const RuntimeMethod* method)\n{\n\til2cpp::utils::ExceptionSupportStack<RuntimeObject*, 1> __active_exceptions;\n\til2cpp::utils::ExceptionSupportStack<int32_t, 2> __leave_targets;\n\t{\n\t\tRuntimeArray * L_0 = ___array0;\n\t\tif (!L_0)\n\t\t{\n\t\t\tgoto IL_0012;\n\t\t}\n\t}\n\t{\n\t\tRuntimeArray * L_1 = ___array0;\n\t\tNullCheck((RuntimeArray *)L_1);\n\t\tint32_t L_2;\n\t\tL_2 = Array_get_Rank_mE9E4804EA433AA2265F9D9CA3B1B5082ECD757D0((RuntimeArray *)L_1, \/*hidden argument*\/NULL);\n\t\tif ((((int32_t)L_2) == ((int32_t)1)))\n\t\t{\n\t\t\tgoto IL_0012;\n\t\t}\n\t}\n\t{\n\t\tThrowHelper_ThrowArgumentException_m49831D19CFA6026A62C5D52FA7A8E162EBD4DD6A((int32_t)7, \/*hidden argument*\/NULL);\n\t}\n\nIL_0012:\n\t{\n\t}\n\nIL_0013:\n\ttry\n\t{ \/\/ begin try (depth: 1)\n\t\tCachedShadowRecordU5BU5D_tFB0A186B518D32E07B7026306DEA9081F967962E* L_3 = (CachedShadowRecordU5BU5D_tFB0A186B518D32E07B7026306DEA9081F967962E*)__this->get__items_1();\n\t\tRuntimeArray * L_4 = ___array0;\n\t\tint32_t L_5 = ___arrayIndex1;\n\t\tint32_t L_6 = (int32_t)__this->get__size_2();\n\t\tArray_Copy_m3F127FFB5149532135043FFE285F9177C80CB877((RuntimeArray *)(RuntimeArray *)L_3, (int32_t)0, (RuntimeArray *)L_4, (int32_t)L_5, (int32_t)L_6, \/*hidden argument*\/NULL);\n\t\tgoto IL_0033;\n\t} \/\/ end try (depth: 1)\n\tcatch(Il2CppExceptionWrapper& e)\n\t{\n\t\tif(il2cpp_codegen_class_is_assignable_from (((RuntimeClass*)il2cpp_codegen_initialize_runtime_metadata_inline((uintptr_t*)&ArrayTypeMismatchException_tFD610FDA00012564CB75AFCA3A489F29CF628784_il2cpp_TypeInfo_var)), il2cpp_codegen_object_class(e.ex)))\n\t\t{\n\t\t\tIL2CPP_PUSH_ACTIVE_EXCEPTION(e.ex);\n\t\t\tgoto CATCH_0029;\n\t\t}\n\t\tthrow e;\n\t}\n\nCATCH_0029:\n\t{ \/\/ begin catch(System.ArrayTypeMismatchException)\n\t\tThrowHelper_ThrowArgumentException_m49831D19CFA6026A62C5D52FA7A8E162EBD4DD6A((int32_t)((int32_t)18), \/*hidden argument*\/NULL);\n\t\tIL2CPP_POP_ACTIVE_EXCEPTION();\n\t\tgoto IL_0033;\n\t} \/\/ end catch (depth: 1)\n\nIL_0033:\n\t{\n\t\treturn;\n\t}\n}"}
{"content":{"code":"constexpr int foo(int a) {\n    return -a << 2; \/\/ cxx17-note {{left shift of negative value -10}} \\\n                    \/\/ ref-cxx17-note {{left shift of negative value -10}} \\\n                    \/\/ cxx17-note {{left shift of negative value -2}} \\\n                    \/\/ ref-cxx17-note {{left shift of negative value -2}}\n  }","docstring":"\/\/ cxx17-warning {{shifting a negative signed value is undefined}} \\\n                    \/\/ ref-cxx17-warning {{shifting a negative signed value is undefined}} \\\n                    \/\/ cxx17-note {{left shift of negative value -1}} \\\n                    \/\/ ref-cxx17-note {{left shift of negative value -1}}","function_name":"negativeShift"},"id":7,"seed":"constexpr int foo(int a) {\n    return -a << 2; \/\/ cxx17-note {{left shift of negative value -10}} \\\n                    \/\/ ref-cxx17-note {{left shift of negative value -10}} \\\n                    \/\/ cxx17-note {{left shift of negative value -2}} \\\n                    \/\/ ref-cxx17-note {{left shift of negative value -2}}\n  }"}
{"content":{"code":"boolean isButtonPressed(void) {\n  \/\/ read the state of the switch into a local variable:\n  int reading = digitalRead(buttonPin);\n\n  \/\/ check to see if you just pressed the button \n  \/\/ (i.e. the input went from LOW to HIGH),  and you've waited \n  \/\/ long enough since the last press to ignore any noise:  \n\n  \/\/ If the switch changed, due to noise or pressing:\n  if (reading != lastButtonState) {\n    \/\/ reset the debouncing timer\n    lastDebounceTime = millis();\n  } \n  \n  if ((millis() - lastDebounceTime) > debounceDelay) {\n    \/\/ whatever the reading is at, it's been there for longer\n    \/\/ than the debounce delay, so take it as the actual current state:\n\n    \/\/ if the button state has changed:\n    if (reading != buttonState) {\n      buttonState = reading;\n\n      \/\/ only toggle the LED if the new button state is HIGH\n      if (buttonState == HIGH) {\n        lastButtonState = reading;\n        setRegisterPin(LCD_BTN, HIGH);\n        return true;\n      }else{\n        setRegisterPin(LCD_BTN, LOW);\n      }\n    }\n  }\n\n  \/\/ save the reading.  Next time through the loop,\n  \/\/ it'll be the lastButtonState:\n  lastButtonState = reading;\n  return false;\n}","docstring":"\/\/Serial.println(\" Fahrenheit\");","function_name":"getTemp"},"id":14,"seed":"boolean isButtonPressed(void) {\n  \/\/ read the state of the switch into a local variable:\n  int reading = digitalRead(buttonPin);\n\n  \/\/ check to see if you just pressed the button \n  \/\/ (i.e. the input went from LOW to HIGH),  and you've waited \n  \/\/ long enough since the last press to ignore any noise:  \n\n  \/\/ If the switch changed, due to noise or pressing:\n  if (reading != lastButtonState) {\n    \/\/ reset the debouncing timer\n    lastDebounceTime = millis();\n  } \n  \n  if ((millis() - lastDebounceTime) > debounceDelay) {\n    \/\/ whatever the reading is at, it's been there for longer\n    \/\/ than the debounce delay, so take it as the actual current state:\n\n    \/\/ if the button state has changed:\n    if (reading != buttonState) {\n      buttonState = reading;\n\n      \/\/ only toggle the LED if the new button state is HIGH\n      if (buttonState == HIGH) {\n        lastButtonState = reading;\n        setRegisterPin(LCD_BTN, HIGH);\n        return true;\n      }else{\n        setRegisterPin(LCD_BTN, LOW);\n      }\n    }\n  }\n\n  \/\/ save the reading.  Next time through the loop,\n  \/\/ it'll be the lastButtonState:\n  lastButtonState = reading;\n  return false;\n}"}
{"content":{"code":"IL2CPP_METHOD_ATTR void PairingListener_Dispose_mEAC62A7FCA1528D07EC6D329F96D82F76A3E9C87 (PairingListener_tA9A6FFE27AE743A53F7ED4CB1E3FA257B968F694 * __this, const RuntimeMethod* method)\n{\n\tstatic bool s_Il2CppMethodInitialized;\n\tif (!s_Il2CppMethodInitialized)\n\t{\n\t\til2cpp_codegen_initialize_method (PairingListener_Dispose_mEAC62A7FCA1528D07EC6D329F96D82F76A3E9C87_MetadataUsageId);\n\t\ts_Il2CppMethodInitialized = true;\n\t}\n\tPairingListener_tA9A6FFE27AE743A53F7ED4CB1E3FA257B968F694 * V_0 = NULL;\n\tbool V_1 = false;\n\tbool V_2 = false;\n\tbool V_3 = false;\n\tException_t * __last_unhandled_exception = 0;\n\tNO_UNUSED_WARNING (__last_unhandled_exception);\n\tException_t * __exception_local = 0;\n\tNO_UNUSED_WARNING (__exception_local);\n\tint32_t __leave_target = -1;\n\tNO_UNUSED_WARNING (__leave_target);\n\t{\n\t\t\/\/ lock(this) {\n\t\tV_0 = __this;\n\t\tV_1 = (bool)0;\n\t}\n\nIL_0005:\n\ttry\n\t{ \/\/ begin try (depth: 1)\n\t\t{\n\t\t\tPairingListener_tA9A6FFE27AE743A53F7ED4CB1E3FA257B968F694 * L_0 = V_0;\n\t\t\tMonitor_Enter_mC5B353DD83A0B0155DF6FBCC4DF5A580C25534C5(L_0, (bool*)(&V_1), \/*hidden argument*\/NULL);\n\t\t\t\/\/ if (swigCPtr.Handle != global::System.IntPtr.Zero) {\n\t\t\tHandleRef_t876E76124F400D12395BF61D562162AB6822204A * L_1 = __this->get_address_of_swigCPtr_2();\n\t\t\tintptr_t L_2 = HandleRef_get_Handle_m095712F299EA36BF75975343C726FA160EE38277((HandleRef_t876E76124F400D12395BF61D562162AB6822204A *)L_1, \/*hidden argument*\/NULL);\n\t\t\tbool L_3 = IntPtr_op_Inequality_mB4886A806009EA825EFCC60CD2A7F6EB8E273A61((intptr_t)L_2, (intptr_t)(0), \/*hidden argument*\/NULL);\n\t\t\tV_2 = L_3;\n\t\t\tbool L_4 = V_2;\n\t\t\tif (!L_4)\n\t\t\t{\n\t\t\t\tgoto IL_005a;\n\t\t\t}\n\t\t}\n\nIL_0028:\n\t\t{\n\t\t\t\/\/ if (swigCMemOwn) {\n\t\t\tbool L_5 = ((Listener_t3466CE06B278C6B8D8CC0655DF5EC0000BF962C2 *)__this)->get_swigCMemOwn_1();\n\t\t\tV_3 = L_5;\n\t\t\tbool L_6 = V_3;\n\t\t\tif (!L_6)\n\t\t\t{\n\t\t\t\tgoto IL_0048;\n\t\t\t}\n\t\t}\n\nIL_0033:\n\t\t{\n\t\t\t\/\/ swigCMemOwn = false;\n\t\t\t((Listener_t3466CE06B278C6B8D8CC0655DF5EC0000BF962C2 *)__this)->set_swigCMemOwn_1((bool)0);\n\t\t\t\/\/ SharingClientPINVOKE.delete_PairingListener(swigCPtr);\n\t\t\tHandleRef_t876E76124F400D12395BF61D562162AB6822204A  L_7 = __this->get_swigCPtr_2();\n\t\t\tIL2CPP_RUNTIME_CLASS_INIT(SharingClientPINVOKE_tFF4292D2BC5A9EB345172E6D4F8BE281B3799A1F_il2cpp_TypeInfo_var);\n\t\t\tSharingClientPINVOKE_delete_PairingListener_m3062D45600088FD3230AF5587AC8AB7A4C246B64(L_7, \/*hidden argument*\/NULL);\n\t\t}\n\nIL_0048:\n\t\t{\n\t\t\t\/\/ swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);\n\t\t\tHandleRef_t876E76124F400D12395BF61D562162AB6822204A  L_8;\n\t\t\tmemset(&L_8, 0, sizeof(L_8));\n\t\t\tHandleRef__ctor_mCD64E7F91766FE7602EE34A8CEEF6C1EF4C943BB((&L_8), NULL, (intptr_t)(0), \/*hidden argument*\/NULL);\n\t\t\t__this->set_swigCPtr_2(L_8);\n\t\t}\n\nIL_005a:\n\t\t{\n\t\t\t\/\/ global::System.GC.SuppressFinalize(this);\n\t\t\tIL2CPP_RUNTIME_CLASS_INIT(GC_tC1D7BD74E8F44ECCEF5CD2B5D84BFF9AAE02D01D_il2cpp_TypeInfo_var);\n\t\t\tGC_SuppressFinalize_m037319A9B95A5BA437E806DE592802225EE5B425(__this, \/*hidden argument*\/NULL);\n\t\t\t\/\/ base.Dispose();\n\t\t\tListener_Dispose_mF59F4962F238FD2A986747D0092EC14293296D30(__this, \/*hidden argument*\/NULL);\n\t\t\tIL2CPP_LEAVE(0x76, FINALLY_006b);\n\t\t}\n\t} \/\/ end try (depth: 1)\n\tcatch(Il2CppExceptionWrapper& e)\n\t{\n\t\t__last_unhandled_exception = (Exception_t *)e.ex;\n\t\tgoto FINALLY_006b;\n\t}\n\nFINALLY_006b:\n\t{ \/\/ begin finally (depth: 1)\n\t\t{\n\t\t\tbool L_9 = V_1;\n\t\t\tif (!L_9)\n\t\t\t{\n\t\t\t\tgoto IL_0075;\n\t\t\t}\n\t\t}\n\nIL_006e:\n\t\t{\n\t\t\tPairingListener_tA9A6FFE27AE743A53F7ED4CB1E3FA257B968F694 * L_10 = V_0;\n\t\t\tMonitor_Exit_m49A1E5356D984D0B934BB97A305E2E5E207225C2(L_10, \/*hidden argument*\/NULL);\n\t\t}\n\nIL_0075:\n\t\t{\n\t\t\tIL2CPP_RESET_LEAVE(0x76);\n\t\t\tIL2CPP_END_FINALLY(107)\n\t\t}\n\t} \/\/ end finally (depth: 1)\n\tIL2CPP_CLEANUP(107)\n\t{\n\t\tIL2CPP_JUMP_TBL(0x76, IL_0076)\n\t\tIL2CPP_RETHROW_IF_UNHANDLED(Exception_t *)\n\t}\n\nIL_0076:\n\t{\n\t\t\/\/ }\n\t\treturn;\n\t}\n}","docstring":"\/\/ end finally (depth: 1)","function_name":"PairingListener_Finalize_m82AB68AB825ECE83AA5351C4FBB3A5568D9D1B96"},"id":18,"seed":"IL2CPP_METHOD_ATTR void PairingListener_Dispose_mEAC62A7FCA1528D07EC6D329F96D82F76A3E9C87 (PairingListener_tA9A6FFE27AE743A53F7ED4CB1E3FA257B968F694 * __this, const RuntimeMethod* method)\n{\n\tstatic bool s_Il2CppMethodInitialized;\n\tif (!s_Il2CppMethodInitialized)\n\t{\n\t\til2cpp_codegen_initialize_method (PairingListener_Dispose_mEAC62A7FCA1528D07EC6D329F96D82F76A3E9C87_MetadataUsageId);\n\t\ts_Il2CppMethodInitialized = true;\n\t}\n\tPairingListener_tA9A6FFE27AE743A53F7ED4CB1E3FA257B968F694 * V_0 = NULL;\n\tbool V_1 = false;\n\tbool V_2 = false;\n\tbool V_3 = false;\n\tException_t * __last_unhandled_exception = 0;\n\tNO_UNUSED_WARNING (__last_unhandled_exception);\n\tException_t * __exception_local = 0;\n\tNO_UNUSED_WARNING (__exception_local);\n\tint32_t __leave_target = -1;\n\tNO_UNUSED_WARNING (__leave_target);\n\t{\n\t\t\/\/ lock(this) {\n\t\tV_0 = __this;\n\t\tV_1 = (bool)0;\n\t}\n\nIL_0005:\n\ttry\n\t{ \/\/ begin try (depth: 1)\n\t\t{\n\t\t\tPairingListener_tA9A6FFE27AE743A53F7ED4CB1E3FA257B968F694 * L_0 = V_0;\n\t\t\tMonitor_Enter_mC5B353DD83A0B0155DF6FBCC4DF5A580C25534C5(L_0, (bool*)(&V_1), \/*hidden argument*\/NULL);\n\t\t\t\/\/ if (swigCPtr.Handle != global::System.IntPtr.Zero) {\n\t\t\tHandleRef_t876E76124F400D12395BF61D562162AB6822204A * L_1 = __this->get_address_of_swigCPtr_2();\n\t\t\tintptr_t L_2 = HandleRef_get_Handle_m095712F299EA36BF75975343C726FA160EE38277((HandleRef_t876E76124F400D12395BF61D562162AB6822204A *)L_1, \/*hidden argument*\/NULL);\n\t\t\tbool L_3 = IntPtr_op_Inequality_mB4886A806009EA825EFCC60CD2A7F6EB8E273A61((intptr_t)L_2, (intptr_t)(0), \/*hidden argument*\/NULL);\n\t\t\tV_2 = L_3;\n\t\t\tbool L_4 = V_2;\n\t\t\tif (!L_4)\n\t\t\t{\n\t\t\t\tgoto IL_005a;\n\t\t\t}\n\t\t}\n\nIL_0028:\n\t\t{\n\t\t\t\/\/ if (swigCMemOwn) {\n\t\t\tbool L_5 = ((Listener_t3466CE06B278C6B8D8CC0655DF5EC0000BF962C2 *)__this)->get_swigCMemOwn_1();\n\t\t\tV_3 = L_5;\n\t\t\tbool L_6 = V_3;\n\t\t\tif (!L_6)\n\t\t\t{\n\t\t\t\tgoto IL_0048;\n\t\t\t}\n\t\t}\n\nIL_0033:\n\t\t{\n\t\t\t\/\/ swigCMemOwn = false;\n\t\t\t((Listener_t3466CE06B278C6B8D8CC0655DF5EC0000BF962C2 *)__this)->set_swigCMemOwn_1((bool)0);\n\t\t\t\/\/ SharingClientPINVOKE.delete_PairingListener(swigCPtr);\n\t\t\tHandleRef_t876E76124F400D12395BF61D562162AB6822204A  L_7 = __this->get_swigCPtr_2();\n\t\t\tIL2CPP_RUNTIME_CLASS_INIT(SharingClientPINVOKE_tFF4292D2BC5A9EB345172E6D4F8BE281B3799A1F_il2cpp_TypeInfo_var);\n\t\t\tSharingClientPINVOKE_delete_PairingListener_m3062D45600088FD3230AF5587AC8AB7A4C246B64(L_7, \/*hidden argument*\/NULL);\n\t\t}\n\nIL_0048:\n\t\t{\n\t\t\t\/\/ swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);\n\t\t\tHandleRef_t876E76124F400D12395BF61D562162AB6822204A  L_8;\n\t\t\tmemset(&L_8, 0, sizeof(L_8));\n\t\t\tHandleRef__ctor_mCD64E7F91766FE7602EE34A8CEEF6C1EF4C943BB((&L_8), NULL, (intptr_t)(0), \/*hidden argument*\/NULL);\n\t\t\t__this->set_swigCPtr_2(L_8);\n\t\t}\n\nIL_005a:\n\t\t{\n\t\t\t\/\/ global::System.GC.SuppressFinalize(this);\n\t\t\tIL2CPP_RUNTIME_CLASS_INIT(GC_tC1D7BD74E8F44ECCEF5CD2B5D84BFF9AAE02D01D_il2cpp_TypeInfo_var);\n\t\t\tGC_SuppressFinalize_m037319A9B95A5BA437E806DE592802225EE5B425(__this, \/*hidden argument*\/NULL);\n\t\t\t\/\/ base.Dispose();\n\t\t\tListener_Dispose_mF59F4962F238FD2A986747D0092EC14293296D30(__this, \/*hidden argument*\/NULL);\n\t\t\tIL2CPP_LEAVE(0x76, FINALLY_006b);\n\t\t}\n\t} \/\/ end try (depth: 1)\n\tcatch(Il2CppExceptionWrapper& e)\n\t{\n\t\t__last_unhandled_exception = (Exception_t *)e.ex;\n\t\tgoto FINALLY_006b;\n\t}\n\nFINALLY_006b:\n\t{ \/\/ begin finally (depth: 1)\n\t\t{\n\t\t\tbool L_9 = V_1;\n\t\t\tif (!L_9)\n\t\t\t{\n\t\t\t\tgoto IL_0075;\n\t\t\t}\n\t\t}\n\nIL_006e:\n\t\t{\n\t\t\tPairingListener_tA9A6FFE27AE743A53F7ED4CB1E3FA257B968F694 * L_10 = V_0;\n\t\t\tMonitor_Exit_m49A1E5356D984D0B934BB97A305E2E5E207225C2(L_10, \/*hidden argument*\/NULL);\n\t\t}\n\nIL_0075:\n\t\t{\n\t\t\tIL2CPP_RESET_LEAVE(0x76);\n\t\t\tIL2CPP_END_FINALLY(107)\n\t\t}\n\t} \/\/ end finally (depth: 1)\n\tIL2CPP_CLEANUP(107)\n\t{\n\t\tIL2CPP_JUMP_TBL(0x76, IL_0076)\n\t\tIL2CPP_RETHROW_IF_UNHANDLED(Exception_t *)\n\t}\n\nIL_0076:\n\t{\n\t\t\/\/ }\n\t\treturn;\n\t}\n}"}
{"content":{"code":"static bool js_cc_scene_Pass_resetTextures(se::State& s)\n{\n    \/\/ js_function\n    \n    CC_UNUSED bool ok = true;\n    const auto& args = s.args();\n    size_t argc = args.size();\n    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;\n    \n    if(argc != 0) {\n        SE_REPORT_ERROR(\"wrong number of arguments: %d, was expecting %d\", (int)argc, 0);\n        return false;\n    }\n    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    (arg1)->resetTextures();\n    \n    \n    return true;\n}","docstring":"\/\/ js_function","function_name":"js_cc_scene_Pass_resetUBOs"},"id":19,"seed":"static bool js_cc_scene_Pass_resetTextures(se::State& s)\n{\n    \/\/ js_function\n    \n    CC_UNUSED bool ok = true;\n    const auto& args = s.args();\n    size_t argc = args.size();\n    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;\n    \n    if(argc != 0) {\n        SE_REPORT_ERROR(\"wrong number of arguments: %d, was expecting %d\", (int)argc, 0);\n        return false;\n    }\n    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    (arg1)->resetTextures();\n    \n    \n    return true;\n}"}
{"content":{"code":"soap_instantiate_ns3__FEDetRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)\n{\n\tDBGLOG(TEST, SOAP_MESSAGE(fdebug, \"soap_instantiate_ns3__FEDetRequest(%p, %d, %s, %s)\\n\", (void*)soap, n, type?type:\"\", arrayType?arrayType:\"\"));\n\t(void)type; (void)arrayType; \/* appease -Wall -Werror *\/\n\tif (soap && type && !soap_match_tag(soap, type, \"ns3:FECAEDetRequest\"))\n\t\treturn soap_instantiate_ns3__FECAEDetRequest(soap, n, NULL, NULL, size);\n\tif (soap && type && !soap_match_tag(soap, type, \"ns3:FECAEADetRequest\"))\n\t\treturn soap_instantiate_ns3__FECAEADetRequest(soap, n, NULL, NULL, size);\n\tif (soap && type && !soap_match_tag(soap, type, \"ns3:FECompConsResponse\"))\n\t\treturn soap_instantiate_ns3__FECompConsResponse(soap, n, NULL, NULL, size);\n\tns3__FEDetRequest *p;\n\tsize_t k = sizeof(ns3__FEDetRequest);\n\tstruct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FEDetRequest, n, afip_fdelete);\n\tif (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)\n\t\treturn NULL;\n\tif (n < 0)\n\t{\tp = SOAP_NEW(soap, ns3__FEDetRequest);\n\t\tif (p)\n\t\t\tp->soap = soap;\n\t}\n\telse\n\t{\tp = SOAP_NEW_ARRAY(soap, ns3__FEDetRequest, n);\n\t\tk *= n;\n\t\tif (p)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tp[i].soap = soap;\n\t}\n\tDBGLOG(TEST, SOAP_MESSAGE(fdebug, \"Instantiated ns3__FEDetRequest location=%p n=%d\\n\", (void*)p, n));\n\tif (size)\n\t\t*size = k;\n\tif (!p)\n\t\tsoap->error = SOAP_EOM;\n\telse if (cp)\n\t\tcp->ptr = (void*)p;\n\treturn p;\n}","docstring":"\/* appease -Wall -Werror *\/","function_name":"soap_in_ns3__FEDetRequest"},"id":22,"seed":"soap_instantiate_ns3__FEDetRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)\n{\n\tDBGLOG(TEST, SOAP_MESSAGE(fdebug, \"soap_instantiate_ns3__FEDetRequest(%p, %d, %s, %s)\\n\", (void*)soap, n, type?type:\"\", arrayType?arrayType:\"\"));\n\t(void)type; (void)arrayType; \/* appease -Wall -Werror *\/\n\tif (soap && type && !soap_match_tag(soap, type, \"ns3:FECAEDetRequest\"))\n\t\treturn soap_instantiate_ns3__FECAEDetRequest(soap, n, NULL, NULL, size);\n\tif (soap && type && !soap_match_tag(soap, type, \"ns3:FECAEADetRequest\"))\n\t\treturn soap_instantiate_ns3__FECAEADetRequest(soap, n, NULL, NULL, size);\n\tif (soap && type && !soap_match_tag(soap, type, \"ns3:FECompConsResponse\"))\n\t\treturn soap_instantiate_ns3__FECompConsResponse(soap, n, NULL, NULL, size);\n\tns3__FEDetRequest *p;\n\tsize_t k = sizeof(ns3__FEDetRequest);\n\tstruct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FEDetRequest, n, afip_fdelete);\n\tif (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)\n\t\treturn NULL;\n\tif (n < 0)\n\t{\tp = SOAP_NEW(soap, ns3__FEDetRequest);\n\t\tif (p)\n\t\t\tp->soap = soap;\n\t}\n\telse\n\t{\tp = SOAP_NEW_ARRAY(soap, ns3__FEDetRequest, n);\n\t\tk *= n;\n\t\tif (p)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tp[i].soap = soap;\n\t}\n\tDBGLOG(TEST, SOAP_MESSAGE(fdebug, \"Instantiated ns3__FEDetRequest location=%p n=%d\\n\", (void*)p, n));\n\tif (size)\n\t\t*size = k;\n\tif (!p)\n\t\tsoap->error = SOAP_EOM;\n\telse if (cp)\n\t\tcp->ptr = (void*)p;\n\treturn p;\n}"}
{"content":{"code":"IL2CPP_EXTERN_C IL2CPP_METHOD_ATTR bool KeyHandler_ValueExists_mF5375C620ADF2D5B81AFA657D39C7DFB42F73EFF (KeyHandler_tB9094857C733957C9D709512D2AD478828B119FF * __this, String_t* ___name0, const RuntimeMethod* method)\n{\n\tstatic bool s_Il2CppMethodInitialized;\n\tif (!s_Il2CppMethodInitialized)\n\t{\n\t\til2cpp_codegen_initialize_runtime_metadata((uintptr_t*)&String_t_il2cpp_TypeInfo_var);\n\t\ts_Il2CppMethodInitialized = true;\n\t}\n\tHashtable_t7565AB92A12227AD5BADD6911F10D87EE52509AC * V_0 = NULL;\n\tbool V_1 = false;\n\tbool V_2 = false;\n\tException_t * __last_unhandled_exception = 0;\n\til2cpp::utils::ExceptionSupportStack<int32_t, 1> __leave_targets;\n\t{\n\t\tString_t* L_0 = ___name0;\n\t\tif (L_0)\n\t\t{\n\t\t\tgoto IL_000a;\n\t\t}\n\t}\n\t{\n\t\tString_t* L_1 = ((String_t_StaticFields*)il2cpp_codegen_static_fields_for(String_t_il2cpp_TypeInfo_var))->get_Empty_5();\n\t\t___name0 = L_1;\n\t}\n\nIL_000a:\n\t{\n\t\tHashtable_t7565AB92A12227AD5BADD6911F10D87EE52509AC * L_2 = __this->get_values_5();\n\t\tV_0 = L_2;\n\t\tV_1 = (bool)0;\n\t}\n\nIL_0013:\n\ttry\n\t{ \/\/ begin try (depth: 1)\n\t\tHashtable_t7565AB92A12227AD5BADD6911F10D87EE52509AC * L_3 = V_0;\n\t\tMonitor_Enter_mBEB6CC84184B46F26375EC3FC8921D16E48EA4C4(L_3, (bool*)(&V_1), \/*hidden argument*\/NULL);\n\t\tHashtable_t7565AB92A12227AD5BADD6911F10D87EE52509AC * L_4 = __this->get_values_5();\n\t\tString_t* L_5 = ___name0;\n\t\tNullCheck(L_4);\n\t\tbool L_6;\n\t\tL_6 = VirtFuncInvoker1< bool, RuntimeObject * >::Invoke(19 \/* System.Boolean System.Collections.Hashtable::Contains(System.Object) *\/, L_4, L_5);\n\t\tV_2 = L_6;\n\t\tIL2CPP_LEAVE(0x34, FINALLY_002a);\n\t} \/\/ end try (depth: 1)\n\tcatch(Il2CppExceptionWrapper& e)\n\t{\n\t\t__last_unhandled_exception = (Exception_t *)e.ex;\n\t\tgoto FINALLY_002a;\n\t}\n\nFINALLY_002a:\n\t{ \/\/ begin finally (depth: 1)\n\t\t{\n\t\t\tbool L_7 = V_1;\n\t\t\tif (!L_7)\n\t\t\t{\n\t\t\t\tgoto IL_0033;\n\t\t\t}\n\t\t}\n\nIL_002d:\n\t\t{\n\t\t\tHashtable_t7565AB92A12227AD5BADD6911F10D87EE52509AC * L_8 = V_0;\n\t\t\tMonitor_Exit_mA776B403DA88AC77CDEEF67AB9F0D0E77ABD254A(L_8, \/*hidden argument*\/NULL);\n\t\t}\n\nIL_0033:\n\t\t{\n\t\t\tIL2CPP_END_FINALLY(42)\n\t\t}\n\t} \/\/ end finally (depth: 1)\n\tIL2CPP_CLEANUP(42)\n\t{\n\t\tIL2CPP_RETHROW_IF_UNHANDLED(Exception_t *)\n\t\tIL2CPP_JUMP_TBL(0x34, IL_0034)\n\t}\n\nIL_0034:\n\t{\n\t\tbool L_9 = V_2;\n\t\treturn L_9;\n\t}\n}","docstring":"\/\/ end finally (depth: 1)","function_name":"KeyHandler_Flush_m56255985F7D2CBDE0231B579C9795A56B516F3C7"},"id":26,"seed":"IL2CPP_EXTERN_C IL2CPP_METHOD_ATTR bool KeyHandler_ValueExists_mF5375C620ADF2D5B81AFA657D39C7DFB42F73EFF (KeyHandler_tB9094857C733957C9D709512D2AD478828B119FF * __this, String_t* ___name0, const RuntimeMethod* method)\n{\n\tstatic bool s_Il2CppMethodInitialized;\n\tif (!s_Il2CppMethodInitialized)\n\t{\n\t\til2cpp_codegen_initialize_runtime_metadata((uintptr_t*)&String_t_il2cpp_TypeInfo_var);\n\t\ts_Il2CppMethodInitialized = true;\n\t}\n\tHashtable_t7565AB92A12227AD5BADD6911F10D87EE52509AC * V_0 = NULL;\n\tbool V_1 = false;\n\tbool V_2 = false;\n\tException_t * __last_unhandled_exception = 0;\n\til2cpp::utils::ExceptionSupportStack<int32_t, 1> __leave_targets;\n\t{\n\t\tString_t* L_0 = ___name0;\n\t\tif (L_0)\n\t\t{\n\t\t\tgoto IL_000a;\n\t\t}\n\t}\n\t{\n\t\tString_t* L_1 = ((String_t_StaticFields*)il2cpp_codegen_static_fields_for(String_t_il2cpp_TypeInfo_var))->get_Empty_5();\n\t\t___name0 = L_1;\n\t}\n\nIL_000a:\n\t{\n\t\tHashtable_t7565AB92A12227AD5BADD6911F10D87EE52509AC * L_2 = __this->get_values_5();\n\t\tV_0 = L_2;\n\t\tV_1 = (bool)0;\n\t}\n\nIL_0013:\n\ttry\n\t{ \/\/ begin try (depth: 1)\n\t\tHashtable_t7565AB92A12227AD5BADD6911F10D87EE52509AC * L_3 = V_0;\n\t\tMonitor_Enter_mBEB6CC84184B46F26375EC3FC8921D16E48EA4C4(L_3, (bool*)(&V_1), \/*hidden argument*\/NULL);\n\t\tHashtable_t7565AB92A12227AD5BADD6911F10D87EE52509AC * L_4 = __this->get_values_5();\n\t\tString_t* L_5 = ___name0;\n\t\tNullCheck(L_4);\n\t\tbool L_6;\n\t\tL_6 = VirtFuncInvoker1< bool, RuntimeObject * >::Invoke(19 \/* System.Boolean System.Collections.Hashtable::Contains(System.Object) *\/, L_4, L_5);\n\t\tV_2 = L_6;\n\t\tIL2CPP_LEAVE(0x34, FINALLY_002a);\n\t} \/\/ end try (depth: 1)\n\tcatch(Il2CppExceptionWrapper& e)\n\t{\n\t\t__last_unhandled_exception = (Exception_t *)e.ex;\n\t\tgoto FINALLY_002a;\n\t}\n\nFINALLY_002a:\n\t{ \/\/ begin finally (depth: 1)\n\t\t{\n\t\t\tbool L_7 = V_1;\n\t\t\tif (!L_7)\n\t\t\t{\n\t\t\t\tgoto IL_0033;\n\t\t\t}\n\t\t}\n\nIL_002d:\n\t\t{\n\t\t\tHashtable_t7565AB92A12227AD5BADD6911F10D87EE52509AC * L_8 = V_0;\n\t\t\tMonitor_Exit_mA776B403DA88AC77CDEEF67AB9F0D0E77ABD254A(L_8, \/*hidden argument*\/NULL);\n\t\t}\n\nIL_0033:\n\t\t{\n\t\t\tIL2CPP_END_FINALLY(42)\n\t\t}\n\t} \/\/ end finally (depth: 1)\n\tIL2CPP_CLEANUP(42)\n\t{\n\t\tIL2CPP_RETHROW_IF_UNHANDLED(Exception_t *)\n\t\tIL2CPP_JUMP_TBL(0x34, IL_0034)\n\t}\n\nIL_0034:\n\t{\n\t\tbool L_9 = V_2;\n\t\treturn L_9;\n\t}\n}"}
{"content":{"code":"LinearQuadraticStage approximateStage(OptimalControlProblem& optimalControProblem, TrajectoryRef start, StateTrajectoryRef end,\n                                      bool isInitialTime) {\n  const auto modelData = approximateIntermediateLQ(optimalControProblem, start.t, start.x, start.u, MultiplierCollection());\n\n  \/\/ checking the numerical properties\n  const auto errSize = checkSize(modelData, start.x.rows(), start.u.rows());\n  if (!errSize.empty()) {\n    throw std::runtime_error(\"[[qp_solver::approximateStage] Ill-posed problem at intermediate time: \" + std::to_string(start.t) + \"\\n\" +\n                             errSize);\n  }\n  const std::string errProperties =\n      checkDynamicsProperties(modelData) + checkCostProperties(modelData) + checkConstraintProperties(modelData);\n  if (!errProperties.empty()) {\n    throw std::runtime_error(\"[qp_solver::approximateStage] Ill-posed problem at intermediate time: \" + std::to_string(start.t) + \"\\n\" +\n                             errProperties);\n  }\n\n  LinearQuadraticStage lqStage;\n  const auto dt = end.t - start.t;\n\n  lqStage.cost = modelData.cost;\n  lqStage.cost *= dt;\n\n  \/\/ Linearized Dynamics after discretization: x0[k+1] + dx[k+1] = A dx[k] + B du[k] + F(x0[k], u0[k])\n  lqStage.dynamics = approximateDynamics(modelData, start, dt);\n  \/\/ Adapt the offset to account for discretization and the nominal trajectory :\n  \/\/ dx[k+1] = A dx[k] + B du[k] + F(x0[k], u0[k]) - x0[k+1]\n  lqStage.dynamics.f -= end.x;\n\n  lqStage.constraints = approximateConstraints(modelData, isInitialTime);\n\n  return lqStage;\n}","docstring":"\/\/ checking the numerical properties","function_name":"getLinearQuadraticApproximation"},"id":29,"seed":"LinearQuadraticStage approximateStage(OptimalControlProblem& optimalControProblem, TrajectoryRef start, StateTrajectoryRef end,\n                                      bool isInitialTime) {\n  const auto modelData = approximateIntermediateLQ(optimalControProblem, start.t, start.x, start.u, MultiplierCollection());\n\n  \/\/ checking the numerical properties\n  const auto errSize = checkSize(modelData, start.x.rows(), start.u.rows());\n  if (!errSize.empty()) {\n    throw std::runtime_error(\"[[qp_solver::approximateStage] Ill-posed problem at intermediate time: \" + std::to_string(start.t) + \"\\n\" +\n                             errSize);\n  }\n  const std::string errProperties =\n      checkDynamicsProperties(modelData) + checkCostProperties(modelData) + checkConstraintProperties(modelData);\n  if (!errProperties.empty()) {\n    throw std::runtime_error(\"[qp_solver::approximateStage] Ill-posed problem at intermediate time: \" + std::to_string(start.t) + \"\\n\" +\n                             errProperties);\n  }\n\n  LinearQuadraticStage lqStage;\n  const auto dt = end.t - start.t;\n\n  lqStage.cost = modelData.cost;\n  lqStage.cost *= dt;\n\n  \/\/ Linearized Dynamics after discretization: x0[k+1] + dx[k+1] = A dx[k] + B du[k] + F(x0[k], u0[k])\n  lqStage.dynamics = approximateDynamics(modelData, start, dt);\n  \/\/ Adapt the offset to account for discretization and the nominal trajectory :\n  \/\/ dx[k+1] = A dx[k] + B du[k] + F(x0[k], u0[k]) - x0[k+1]\n  lqStage.dynamics.f -= end.x;\n\n  lqStage.constraints = approximateConstraints(modelData, isInitialTime);\n\n  return lqStage;\n}"}
{"content":{"code":"static bool js_cc_scene_Model_updateLightingmap(se::State& s)\n{\n    \/\/ js_function\n    \n    CC_UNUSED bool ok = true;\n    const auto& args = s.args();\n    size_t argc = args.size();\n    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;\n    cc::Texture2D *arg2 = (cc::Texture2D *) NULL ;\n    cc::Vec4 *arg3 = 0 ;\n    cc::Vec4 temp3 ;\n    \n    if(argc != 2) {\n        SE_REPORT_ERROR(\"wrong number of arguments: %d, was expecting %d\", (int)argc, 2);\n        return false;\n    }\n    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    \/\/ %typemap(in) SWIGTYPE*\n    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());\n    SE_PRECONDITION2(ok, false, \"Model_updateLightingmap,2,SWIGTYPE_p_cc__Texture2D\"); \n    \/\/ %typemap(in) SWIGTYPE&\n    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());\n    SE_PRECONDITION2(ok, false, \"Model_updateLightingmap,3,SWIGTYPE_p_cc__Vec4\");\n    arg3 = &temp3;\n    \n    (arg1)->updateLightingmap(arg2,(cc::Vec4 const &)*arg3);\n    \n    \n    return true;\n}","docstring":"\/\/ %typemap(in) SWIGTYPE*","function_name":"js_cc_scene_Model_updateWorldBoundsForJSBakedSkinningModel"},"id":38,"seed":"static bool js_cc_scene_Model_updateLightingmap(se::State& s)\n{\n    \/\/ js_function\n    \n    CC_UNUSED bool ok = true;\n    const auto& args = s.args();\n    size_t argc = args.size();\n    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;\n    cc::Texture2D *arg2 = (cc::Texture2D *) NULL ;\n    cc::Vec4 *arg3 = 0 ;\n    cc::Vec4 temp3 ;\n    \n    if(argc != 2) {\n        SE_REPORT_ERROR(\"wrong number of arguments: %d, was expecting %d\", (int)argc, 2);\n        return false;\n    }\n    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    \/\/ %typemap(in) SWIGTYPE*\n    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());\n    SE_PRECONDITION2(ok, false, \"Model_updateLightingmap,2,SWIGTYPE_p_cc__Texture2D\"); \n    \/\/ %typemap(in) SWIGTYPE&\n    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());\n    SE_PRECONDITION2(ok, false, \"Model_updateLightingmap,3,SWIGTYPE_p_cc__Vec4\");\n    arg3 = &temp3;\n    \n    (arg1)->updateLightingmap(arg2,(cc::Vec4 const &)*arg3);\n    \n    \n    return true;\n}"}
{"content":{"code":"GTEST_TEST(AabbTest, PlaneOverlap) {\n  \/\/ The aabb is *not* defined at the origin of the hierarchy frame.\n  const Vector3d p_HoBo_H = Vector3d{0.5, 0.25, -0.75};\n  const Vector3d half_width{1, 2, 3};\n  Aabb aabb_H{p_HoBo_H, half_width};\n\n  \/\/ Use brute force to find the position of the \"lowest\" corner of the box\n  \/\/ measured from Ho and expressed in frame P. \"Lowest\" means the corner with\n  \/\/ the smallest z-component. Note: the \"z-component\" trick only works because\n  \/\/ we expect the plane to be Pz = 0.\n  auto lowest_corner = [&half_width, &p_HoBo_H](const RotationMatrixd& R_PH) {\n    Vector3d p_HoCmin_P =\n        Vector3d::Constant(std::numeric_limits<double>::infinity());\n    for (const double x_sign : {-1.0, 1.0}) {\n      for (const double y_sign : {-1.0, 1.0}) {\n        for (const double z_sign : {-1.0, 1.0}) {\n          const Vector3d signs{x_sign, y_sign, z_sign};\n          const Vector3d p_BoC_H = half_width.cwiseProduct(signs);\n          const Vector3d p_HoC_P = R_PH * (p_HoBo_H + p_BoC_H);\n          if (p_HoC_P(2) < p_HoCmin_P(2)) {\n            p_HoCmin_P = p_HoC_P;\n          }\n        }\n      }\n    }\n    return p_HoCmin_P;\n  };\n\n  \/\/ Test epsilon is the product of three factors:\n  \/\/  - machine epsilon\n  \/\/  - Two orders of magnitude attributed to the various transformations.\n  \/\/  - A scale factor that is the maximum of (box size, p_HoBo, p_PoHo)\n  const double kEps = 300 * std::numeric_limits<double>::epsilon();\n  \/\/ An arbitrary collection of orientations for the box's hierarchy frame H\n  \/\/ in the plane frame P.\n  std::vector<AngleAxisd> R_PHs{\n      AngleAxisd{0, Vector3d::UnitX()},\n      AngleAxisd{M_PI \/ 2, Vector3d::UnitX()},\n      AngleAxisd{M_PI \/ 2, Vector3d::UnitY()},\n      AngleAxisd{M_PI \/ 2, Vector3d::UnitZ()},\n      AngleAxisd{M_PI \/ 4, Vector3d::UnitX()},\n      AngleAxisd{M_PI \/ 4, Vector3d::UnitY()},\n      AngleAxisd{M_PI \/ 7, Vector3d{1, 2, 3}.normalized()},\n      AngleAxisd{7 * M_PI \/ 6, Vector3d{-1, 2, -3}.normalized()},\n      AngleAxisd{12 * M_PI \/ 7, Vector3d{1, -2, 3}.normalized()}\n  };\n  \/\/ An arbitrary collection of poses of the plane in the query frame Q.\n  std::vector<RigidTransformd> X_QPs{\n      RigidTransformd{},  \/\/ Identity matrix.\n      RigidTransformd{\n          RotationMatrixd{AngleAxisd{M_PI \/ 4, Vector3d{1, 2, 3}.normalized()}},\n          Vector3d{1, 2, 3}},\n      RigidTransformd{RotationMatrixd{AngleAxisd{\n                          12 * M_PI \/ 7, Vector3d{-1, -1, 3}.normalized()}},\n                      Vector3d{-3, -1, 2}}\n  };\n  for (const auto& angle_axis_PH : R_PHs) {\n    const RotationMatrixd R_PH{angle_axis_PH};\n    const Vector3d p_HoCmin_P = lowest_corner(R_PH);\n    for (const auto& X_QP : X_QPs) {\n      \/\/ Define the plane in the query frame Q.\n      const Vector3d& Pz_Q = X_QP.rotation().col(2);\n      Plane<double> plane_Q{Pz_Q, X_QP.translation()};\n\n      \/\/ We position Ho such that Cmin lies on the z = 0 plane in Frame P. Given\n      \/\/ we know p_HoCmin_P, we know its current z-value. To put it at zero, we\n      \/\/ must displace it in the negative of that z value. The x- and y-values\n      \/\/ don't matter, so we pick values we know not to be zero.\n      {\n        \/\/ Place the minimum corner just \"above\" the plane.\n        const Vector3d p_PoHo_P{Vector3d{0.5, -0.25, -p_HoCmin_P(2) + kEps}};\n        RigidTransformd X_PH{R_PH, p_PoHo_P};\n        EXPECT_FALSE(Aabb::HasOverlap(aabb_H, plane_Q, X_QP * X_PH));\n      }\n      {\n        \/\/ Place the minimum corner just \"below\" the plane.\n        const Vector3d p_PoHo_P{Vector3d{0.5, -0.25, -p_HoCmin_P(2) - kEps}};\n        RigidTransformd X_PH{R_PH, p_PoHo_P};\n        EXPECT_TRUE(Aabb::HasOverlap(aabb_H, plane_Q, X_QP * X_PH));\n      }\n\n      \/\/ We repeat the same task but with Cmax. Cmax is the reflection of Cmin\n      \/\/ over Bo (the origin of the box). We'll express all vectors in the P\n      \/\/ frame so we can place that corner just above and below the Pz = 0\n      \/\/ plane using the same trick as documented above.\n      const Vector3d p_HoBo_P = R_PH * p_HoBo_H;\n      const Vector3d p_HoCmax_P = p_HoCmin_P + 2 * (p_HoBo_P - p_HoCmin_P);\n      {\n        \/\/ Put the maximum corner *on* the z = 0 plane in Frame P. The bulk of\n        \/\/ the box now extends *below* the plane; so bump it up epsilon to\n        \/\/ guarantee intersection.\n        const Vector3d p_PoHo_P{Vector3d{0.5, -0.25, -p_HoCmax_P(2) + kEps}};\n        RigidTransformd X_PH{R_PH, p_PoHo_P};\n        EXPECT_TRUE(Aabb::HasOverlap(aabb_H, plane_Q, X_QP * X_PH));\n      }\n      {\n        \/\/ Put the maximum corner *on* the z = 0 plane in Frame P. The bulk of\n        \/\/ the box now extends *below* the plane; so bump it down epsilon to\n        \/\/ guarantee _no_ intersection.\n        const Vector3d p_PoHo_P{Vector3d{0.5, -0.25, -p_HoCmax_P(2) - kEps}};\n        RigidTransformd X_PH{R_PH, p_PoHo_P};\n        EXPECT_FALSE(Aabb::HasOverlap(aabb_H, plane_Q, X_QP * X_PH));\n      }\n    }\n  }\n}","docstring":"\/\/ (if expect_overlap is false) or inside (if true).","function_name":"GTEST_TEST"},"id":40,"seed":"GTEST_TEST(AabbTest, PlaneOverlap) {\n  \/\/ The aabb is *not* defined at the origin of the hierarchy frame.\n  const Vector3d p_HoBo_H = Vector3d{0.5, 0.25, -0.75};\n  const Vector3d half_width{1, 2, 3};\n  Aabb aabb_H{p_HoBo_H, half_width};\n\n  \/\/ Use brute force to find the position of the \"lowest\" corner of the box\n  \/\/ measured from Ho and expressed in frame P. \"Lowest\" means the corner with\n  \/\/ the smallest z-component. Note: the \"z-component\" trick only works because\n  \/\/ we expect the plane to be Pz = 0.\n  auto lowest_corner = [&half_width, &p_HoBo_H](const RotationMatrixd& R_PH) {\n    Vector3d p_HoCmin_P =\n        Vector3d::Constant(std::numeric_limits<double>::infinity());\n    for (const double x_sign : {-1.0, 1.0}) {\n      for (const double y_sign : {-1.0, 1.0}) {\n        for (const double z_sign : {-1.0, 1.0}) {\n          const Vector3d signs{x_sign, y_sign, z_sign};\n          const Vector3d p_BoC_H = half_width.cwiseProduct(signs);\n          const Vector3d p_HoC_P = R_PH * (p_HoBo_H + p_BoC_H);\n          if (p_HoC_P(2) < p_HoCmin_P(2)) {\n            p_HoCmin_P = p_HoC_P;\n          }\n        }\n      }\n    }\n    return p_HoCmin_P;\n  };\n\n  \/\/ Test epsilon is the product of three factors:\n  \/\/  - machine epsilon\n  \/\/  - Two orders of magnitude attributed to the various transformations.\n  \/\/  - A scale factor that is the maximum of (box size, p_HoBo, p_PoHo)\n  const double kEps = 300 * std::numeric_limits<double>::epsilon();\n  \/\/ An arbitrary collection of orientations for the box's hierarchy frame H\n  \/\/ in the plane frame P.\n  std::vector<AngleAxisd> R_PHs{\n      AngleAxisd{0, Vector3d::UnitX()},\n      AngleAxisd{M_PI \/ 2, Vector3d::UnitX()},\n      AngleAxisd{M_PI \/ 2, Vector3d::UnitY()},\n      AngleAxisd{M_PI \/ 2, Vector3d::UnitZ()},\n      AngleAxisd{M_PI \/ 4, Vector3d::UnitX()},\n      AngleAxisd{M_PI \/ 4, Vector3d::UnitY()},\n      AngleAxisd{M_PI \/ 7, Vector3d{1, 2, 3}.normalized()},\n      AngleAxisd{7 * M_PI \/ 6, Vector3d{-1, 2, -3}.normalized()},\n      AngleAxisd{12 * M_PI \/ 7, Vector3d{1, -2, 3}.normalized()}\n  };\n  \/\/ An arbitrary collection of poses of the plane in the query frame Q.\n  std::vector<RigidTransformd> X_QPs{\n      RigidTransformd{},  \/\/ Identity matrix.\n      RigidTransformd{\n          RotationMatrixd{AngleAxisd{M_PI \/ 4, Vector3d{1, 2, 3}.normalized()}},\n          Vector3d{1, 2, 3}},\n      RigidTransformd{RotationMatrixd{AngleAxisd{\n                          12 * M_PI \/ 7, Vector3d{-1, -1, 3}.normalized()}},\n                      Vector3d{-3, -1, 2}}\n  };\n  for (const auto& angle_axis_PH : R_PHs) {\n    const RotationMatrixd R_PH{angle_axis_PH};\n    const Vector3d p_HoCmin_P = lowest_corner(R_PH);\n    for (const auto& X_QP : X_QPs) {\n      \/\/ Define the plane in the query frame Q.\n      const Vector3d& Pz_Q = X_QP.rotation().col(2);\n      Plane<double> plane_Q{Pz_Q, X_QP.translation()};\n\n      \/\/ We position Ho such that Cmin lies on the z = 0 plane in Frame P. Given\n      \/\/ we know p_HoCmin_P, we know its current z-value. To put it at zero, we\n      \/\/ must displace it in the negative of that z value. The x- and y-values\n      \/\/ don't matter, so we pick values we know not to be zero.\n      {\n        \/\/ Place the minimum corner just \"above\" the plane.\n        const Vector3d p_PoHo_P{Vector3d{0.5, -0.25, -p_HoCmin_P(2) + kEps}};\n        RigidTransformd X_PH{R_PH, p_PoHo_P};\n        EXPECT_FALSE(Aabb::HasOverlap(aabb_H, plane_Q, X_QP * X_PH));\n      }\n      {\n        \/\/ Place the minimum corner just \"below\" the plane.\n        const Vector3d p_PoHo_P{Vector3d{0.5, -0.25, -p_HoCmin_P(2) - kEps}};\n        RigidTransformd X_PH{R_PH, p_PoHo_P};\n        EXPECT_TRUE(Aabb::HasOverlap(aabb_H, plane_Q, X_QP * X_PH));\n      }\n\n      \/\/ We repeat the same task but with Cmax. Cmax is the reflection of Cmin\n      \/\/ over Bo (the origin of the box). We'll express all vectors in the P\n      \/\/ frame so we can place that corner just above and below the Pz = 0\n      \/\/ plane using the same trick as documented above.\n      const Vector3d p_HoBo_P = R_PH * p_HoBo_H;\n      const Vector3d p_HoCmax_P = p_HoCmin_P + 2 * (p_HoBo_P - p_HoCmin_P);\n      {\n        \/\/ Put the maximum corner *on* the z = 0 plane in Frame P. The bulk of\n        \/\/ the box now extends *below* the plane; so bump it up epsilon to\n        \/\/ guarantee intersection.\n        const Vector3d p_PoHo_P{Vector3d{0.5, -0.25, -p_HoCmax_P(2) + kEps}};\n        RigidTransformd X_PH{R_PH, p_PoHo_P};\n        EXPECT_TRUE(Aabb::HasOverlap(aabb_H, plane_Q, X_QP * X_PH));\n      }\n      {\n        \/\/ Put the maximum corner *on* the z = 0 plane in Frame P. The bulk of\n        \/\/ the box now extends *below* the plane; so bump it down epsilon to\n        \/\/ guarantee _no_ intersection.\n        const Vector3d p_PoHo_P{Vector3d{0.5, -0.25, -p_HoCmax_P(2) - kEps}};\n        RigidTransformd X_PH{R_PH, p_PoHo_P};\n        EXPECT_FALSE(Aabb::HasOverlap(aabb_H, plane_Q, X_QP * X_PH));\n      }\n    }\n  }\n}"}
{"content":{"code":"string cc_smart_shorten(string& s, int limiter){\n    \/\/s = s.substr(0, limiter * 2);\n    int nl_pos = s.find_first_of(\"<\");\n    s = s.substr(0, nl_pos);\n    if(s.size() <= limiter) return s;\n\n    string ret = s.substr(0, limiter);\n    if(nl_pos <= limiter) return ret;\n\n    for(int i = limiter; i < s.size(); ++i){\n        if(i < s.size() - 3){\n            if(s[i] == -17 && s[i+1] == -68 && s[i+2] == -116) break;\n            if(s[i] == -29 && s[i+1] == -128 && s[i+2] == -126) break;\n            if(s[i] == ',' || s[i] == '.') break;\n        }\n        ret += s[i];\n    }\n\n    return ret;\n}","docstring":"\/* Exit immediately *\/","function_name":"database_fatal"},"id":41,"seed":"string cc_smart_shorten(string& s, int limiter){\n    \/\/s = s.substr(0, limiter * 2);\n    int nl_pos = s.find_first_of(\"<\");\n    s = s.substr(0, nl_pos);\n    if(s.size() <= limiter) return s;\n\n    string ret = s.substr(0, limiter);\n    if(nl_pos <= limiter) return ret;\n\n    for(int i = limiter; i < s.size(); ++i){\n        if(i < s.size() - 3){\n            if(s[i] == -17 && s[i+1] == -68 && s[i+2] == -116) break;\n            if(s[i] == -29 && s[i+1] == -128 && s[i+2] == -126) break;\n            if(s[i] == ',' || s[i] == '.') break;\n        }\n        ret += s[i];\n    }\n\n    return ret;\n}"}
{"content":{"code":"static bool js_cc_scene_SubModel_update(se::State& s)\n{\n    \/\/ js_function\n    \n    CC_UNUSED bool ok = true;\n    const auto& args = s.args();\n    size_t argc = args.size();\n    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;\n    \n    if(argc != 0) {\n        SE_REPORT_ERROR(\"wrong number of arguments: %d, was expecting %d\", (int)argc, 0);\n        return false;\n    }\n    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    (arg1)->update();\n    \n    \n    return true;\n}","docstring":"\/\/ js_dtoroverride","function_name":"js_delete_cc_scene_SubModel"},"id":45,"seed":"static bool js_cc_scene_SubModel_update(se::State& s)\n{\n    \/\/ js_function\n    \n    CC_UNUSED bool ok = true;\n    const auto& args = s.args();\n    size_t argc = args.size();\n    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;\n    \n    if(argc != 0) {\n        SE_REPORT_ERROR(\"wrong number of arguments: %d, was expecting %d\", (int)argc, 0);\n        return false;\n    }\n    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    (arg1)->update();\n    \n    \n    return true;\n}"}
{"content":{"code":"GLuint createTFF1DTexture(const char* filename)\n{\n\t\/\/ read in the user defined data of transfer function\n\tifstream inFile(filename, ifstream::in);\n\tif (!inFile)\n\t{\n\t\tcerr << \"Error openning file: \" << filename << endl;\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tconst int MAX_CNT = 10000;\n\tGLubyte *tff = (GLubyte *)calloc(MAX_CNT, sizeof(GLubyte));\n\tinFile.read(reinterpret_cast<char *>(tff), MAX_CNT);\n\tif (inFile.eof())\n\t{\n\t\tsize_t bytecnt = inFile.gcount();\n\t\t*(tff + bytecnt) = '\\0';\n\t\tcout << \"bytecnt \" << bytecnt << endl;\n\t}\n\telse\n\t{\n\t\tcout << filename << \" read failed \" << endl;\n\t}\n\tGLuint tff1DTexture;\n\tglGenTextures(1, &tff1DTexture);\n\tglBindTexture(GL_TEXTURE_1D, tff1DTexture);\n\tglTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n\tglTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\tglTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\tglPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n\tglTexImage1D(GL_TEXTURE_1D, 0, GL_RGBA8, 256, 0, GL_RGBA, GL_UNSIGNED_BYTE, tff);\n\tfree(tff);\n\treturn tff1DTexture;\n}","docstring":"\/\/ Create the shader program","function_name":"createShaderProgram"},"id":46,"seed":"GLuint createTFF1DTexture(const char* filename)\n{\n\t\/\/ read in the user defined data of transfer function\n\tifstream inFile(filename, ifstream::in);\n\tif (!inFile)\n\t{\n\t\tcerr << \"Error openning file: \" << filename << endl;\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tconst int MAX_CNT = 10000;\n\tGLubyte *tff = (GLubyte *)calloc(MAX_CNT, sizeof(GLubyte));\n\tinFile.read(reinterpret_cast<char *>(tff), MAX_CNT);\n\tif (inFile.eof())\n\t{\n\t\tsize_t bytecnt = inFile.gcount();\n\t\t*(tff + bytecnt) = '\\0';\n\t\tcout << \"bytecnt \" << bytecnt << endl;\n\t}\n\telse\n\t{\n\t\tcout << filename << \" read failed \" << endl;\n\t}\n\tGLuint tff1DTexture;\n\tglGenTextures(1, &tff1DTexture);\n\tglBindTexture(GL_TEXTURE_1D, tff1DTexture);\n\tglTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n\tglTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\tglTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\tglPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n\tglTexImage1D(GL_TEXTURE_1D, 0, GL_RGBA8, 256, 0, GL_RGBA, GL_UNSIGNED_BYTE, tff);\n\tfree(tff);\n\treturn tff1DTexture;\n}"}
{"content":{"code":"void setup(void){\n  pinMode(2, OUTPUT);\n  randomSeed(10);\n  strip.begin();\n  strip.show();\n\n  \/\/server.on(\"\/\", handleRoot);\n  \n    server.on(\"\/RainbowCycle\", [](){\n    val = 2;\n    Serial.println(\"RainbowCycle\");\n    rainbowCycle(20);\n  });\n  \n  server.on(\"\/Rainbow\", [](){\n    val = 3;\n    Serial.println(\"Rainbow\");\n    rainbow(20);  \n  });\n    server.on(\"\/ChaseRainbow\", [](){\n    val = 4;\n    Serial.println(\"ChaseRainbow\");\n    theaterChaseRainbow(50);\n  });\n  \n    server.on(\"\/2_Color\", [](){\n     Serial.println(\"2_Color\");\n     doubleColor = 1;\n  });\n\n  server.begin();\n  Serial.println(\"HTTP server started\");\n  \n  Serial.begin(115200);\n  EEPROM.begin(512);\n  delay(10);\n  Serial.println();\n  Serial.println();\n  Serial.println(\"Startup\");\n  \/\/ read eeprom for ssid and pass\n  Serial.println(\"Reading EEPROM ssid\");\n  String esid;\n  for (int i = 0; i < 32; ++i)\n    {\n      esid += char(EEPROM.read(i));\n    }\n  Serial.print(\"SSID: \");\n  Serial.println(esid);\n  Serial.println(\"Reading EEPROM pass\");\n  String epass = \"\";\n  for (int i = 32; i < 96; ++i)\n    {\n      epass += char(EEPROM.read(i));\n    }\n  Serial.print(\"PASS: \");\n  Serial.println(epass);  \n  if ( esid.length() > 1 ) {\n      \/\/ test esid \n      \/\/WiFi.mode(WIFI_AP_STA);\n      \/\/WiFi.disconnect();\n      \/\/delay(100);\n      WiFi.begin(esid.c_str(), epass.c_str());\n      WiFi.config(IPAddress(192,168,8,187), IPAddress(192,168,8,1), IPAddress(255,255,255,0),IPAddress(192,168,8,1));\n      if (testWifi()) {\n        launchWeb(0);\n        return;\n      }\n  }\n  setupAP();\n\/*  \n  WiFi.begin(ssid, password);\n  WiFi.config(IPAddress(192,168,1,187), IPAddress(192,168,1,1), IPAddress(255,255,255,0),IPAddress(192,168,1,1));\n  Serial.println(\"\");\n\n  \/\/ Wait for connection\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n\n  if (MDNS.begin(\"esp8266\")) {\n    Serial.println(\"MDNS responder started\");\n  }\n  *\/\n  #if defined (__AVR_ATtiny85__)\n    if (F_CPU == 16000000) clock_prescale_set(clock_div_1);\n  #endif\n\n  \n\n}","docstring":"\/\/","function_name":"handleRoot"},"id":48,"seed":"void setup(void){\n  pinMode(2, OUTPUT);\n  randomSeed(10);\n  strip.begin();\n  strip.show();\n\n  \/\/server.on(\"\/\", handleRoot);\n  \n    server.on(\"\/RainbowCycle\", [](){\n    val = 2;\n    Serial.println(\"RainbowCycle\");\n    rainbowCycle(20);\n  });\n  \n  server.on(\"\/Rainbow\", [](){\n    val = 3;\n    Serial.println(\"Rainbow\");\n    rainbow(20);  \n  });\n    server.on(\"\/ChaseRainbow\", [](){\n    val = 4;\n    Serial.println(\"ChaseRainbow\");\n    theaterChaseRainbow(50);\n  });\n  \n    server.on(\"\/2_Color\", [](){\n     Serial.println(\"2_Color\");\n     doubleColor = 1;\n  });\n\n  server.begin();\n  Serial.println(\"HTTP server started\");\n  \n  Serial.begin(115200);\n  EEPROM.begin(512);\n  delay(10);\n  Serial.println();\n  Serial.println();\n  Serial.println(\"Startup\");\n  \/\/ read eeprom for ssid and pass\n  Serial.println(\"Reading EEPROM ssid\");\n  String esid;\n  for (int i = 0; i < 32; ++i)\n    {\n      esid += char(EEPROM.read(i));\n    }\n  Serial.print(\"SSID: \");\n  Serial.println(esid);\n  Serial.println(\"Reading EEPROM pass\");\n  String epass = \"\";\n  for (int i = 32; i < 96; ++i)\n    {\n      epass += char(EEPROM.read(i));\n    }\n  Serial.print(\"PASS: \");\n  Serial.println(epass);  \n  if ( esid.length() > 1 ) {\n      \/\/ test esid \n      \/\/WiFi.mode(WIFI_AP_STA);\n      \/\/WiFi.disconnect();\n      \/\/delay(100);\n      WiFi.begin(esid.c_str(), epass.c_str());\n      WiFi.config(IPAddress(192,168,8,187), IPAddress(192,168,8,1), IPAddress(255,255,255,0),IPAddress(192,168,8,1));\n      if (testWifi()) {\n        launchWeb(0);\n        return;\n      }\n  }\n  setupAP();\n\/*  \n  WiFi.begin(ssid, password);\n  WiFi.config(IPAddress(192,168,1,187), IPAddress(192,168,1,1), IPAddress(255,255,255,0),IPAddress(192,168,1,1));\n  Serial.println(\"\");\n\n  \/\/ Wait for connection\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n\n  if (MDNS.begin(\"esp8266\")) {\n    Serial.println(\"MDNS responder started\");\n  }\n  *\/\n  #if defined (__AVR_ATtiny85__)\n    if (F_CPU == 16000000) clock_prescale_set(clock_div_1);\n  #endif\n\n  \n\n}"}
{"content":{"code":"void YY(int i) \/\/ |\n{\n    punto da = strade[i];\n    punto a = strade[i+1];\n    \n    bool swapped = false;\n    \/\/ sempre dal basso verso l'alto\n    if ( a.y < da.y) swap(da, a),swapped = true;;\n    \n    punto *prima = lower_bound(fx, fx+F, da, cmpX);\n    punto *ultima = upper_bound(fx, fx+F, a, cmpX);\n    ultima--;\n    \n    if (prima == fx+F || prima->x != da.x|| ultima < prima)\n    { l_senza += pointDist(strade[i], strade[i+1]); return; }\n    \n    int ind_prima = prima - fx;\n    int ind_ultima = ultima - fx;\n    \n    error(ind_prima);\n    error(ind_ultima);\n    \n    int RMQY = rmq_x(ind_prima,ind_ultima);\n    error(RMQY);\n    smax(max_dist, RMQY);\n    if ( !swapped){\n        smax(max_dist, l_senza+ pointDist(strade[i], (*prima)));\n        l_senza = pointDist((*ultima), a);}\n    else\n    {\n        smax(max_dist, l_senza+ pointDist(strade[i], (*ultima)));\n        l_senza = pointDist((*prima), da);\n    }\n    error(max_dist);\n}","docstring":"\/\/ sempre da sx a dx","function_name":"XX"},"id":50,"seed":"void YY(int i) \/\/ |\n{\n    punto da = strade[i];\n    punto a = strade[i+1];\n    \n    bool swapped = false;\n    \/\/ sempre dal basso verso l'alto\n    if ( a.y < da.y) swap(da, a),swapped = true;;\n    \n    punto *prima = lower_bound(fx, fx+F, da, cmpX);\n    punto *ultima = upper_bound(fx, fx+F, a, cmpX);\n    ultima--;\n    \n    if (prima == fx+F || prima->x != da.x|| ultima < prima)\n    { l_senza += pointDist(strade[i], strade[i+1]); return; }\n    \n    int ind_prima = prima - fx;\n    int ind_ultima = ultima - fx;\n    \n    error(ind_prima);\n    error(ind_ultima);\n    \n    int RMQY = rmq_x(ind_prima,ind_ultima);\n    error(RMQY);\n    smax(max_dist, RMQY);\n    if ( !swapped){\n        smax(max_dist, l_senza+ pointDist(strade[i], (*prima)));\n        l_senza = pointDist((*ultima), a);}\n    else\n    {\n        smax(max_dist, l_senza+ pointDist(strade[i], (*ultima)));\n        l_senza = pointDist((*prima), da);\n    }\n    error(max_dist);\n}"}
{"content":{"code":"SumsOfAllDigit sumAlldigit(string strLimitNum,map<string,SumsOfAllDigit> &memoMap)\n{\t\n\t\/\/Memoization \ud65c\uc6a9\n\tmap<string, SumsOfAllDigit>::iterator iter =memoMap.find(strLimitNum);\n\tif (iter != memoMap.end())\n\t{\t\t\n\t\treturn iter->second;\n\t}\n\tSumsOfAllDigit result;\n\t\/\/\ud55c\uc790\ub9bf\uc218\uc77c \uacbd\uc6b0\n\tif (strLimitNum.length() == 1)\n\t{\n\t\t\/\/int num = strLimitNum.at(0)-'0';\n\t\tint num = atoi(strLimitNum.c_str());\n\t\tfor (int i = 0; i <= num; i++)\n\t\t{\n\t\t\tresult.m_sumsOfDigit[i] += 1;\n\t\t}\n\t\treturn result;\n\t}\n\t\/\/---------------\uc5ec\uae30\uae4c\uc9c0 \uae30\uc800\n\tchar tempBuf[11];\n\n\t\/\/\"\uccab\uc790\ub9bf\uc218\ub9cc\uc788\uace0 \ub098\uba38\uc9c0 0\uc758 \ud569\uacc4\" + \"\uadf8\ub2e4\uc74c \uc790\ub9bf\uc218 \ubd80\ud130 \ub9cc\ub4e0 \uc22b\uc790\uc758 \ud569\uacc4\"\n\t\/\/\uadf8\ub2e4\uc74c \uc790\ub9bf\uc218 \ud569\uacc4\uad6c\ud558\uae30\n\tstring subDigits= strLimitNum.substr(1, strLimitNum.length() - 1);\n\tint subDigitsNum =atoi(subDigits.c_str());\/\/\ub9e8\uc55e\uc790\ub9ac\ub97c \uc81c\uc678\ud55c \uc22b\uc790\n\tint firstDigitNum = strLimitNum.at(0) - '0';\/\/\ub9e8\uc55e\uc790\ub9ac \uc22b\uc790\n\tif (0 == subDigitsNum)\/\/\ub9e8 \uc55e\uc790\ub9ac \ube7c\uace0 \ub2e4 0\uc77c \uacbd\uc6b0\n\t{\n\t\tstring digitsOfNines;\/\/\ud55c \uc790\ub9bf\uc218\uac00 \uc791\uc740 9\ub85c \uc774\ub904\uc9c4 \uc22b\uc790 \ub9cc\ub4e4\uae30\n\t\tfor (int i = 0; i < subDigits.size(); i++)\n\t\t\tdigitsOfNines.push_back('9');\n\t\tSumsOfAllDigit sumsOfNumberWithStartingOne;\/\/\ud55c \uc790\ub9bf\uc218 \uc791\uc740 9\ub85c \uc774\ub904\uc9c4 \uc22b\uc790\uc758 \ud569\uacc4\n\t\tint numberWithStartingOne = atoi(digitsOfNines.c_str()) + 1;\n\t\tsumsOfNumberWithStartingOne = sumAlldigit(digitsOfNines, memoMap);\/\/9...\uc758 \uac83 \uad6c\ud558\uae30\n\t\t\/\/sumsOfNumberWithStartingOne.m_sumsOfDigit[0] += subDigits.length();\/\/0\uac1c\uc218 \ub354\ud558\uae30\t\t\n\t\t\n\t\t\/\/\ub9e8\uc55e\uc790\ub9ac \uc218\ub97c \ub2e4 \ub354\ud558\uae30\n\t\t\/\/for (int i = 1; i < firstDigitNum; i++)\/\/1\ubd80\ud130\uc778 \uc774\uc720\ub294 \ub9e8\uc55e\uc790\ub9ac\ub294 0\uc744 \uc148\ud558\uc9c0 \uc54a\uc544\uc11c\n\t\tfor (int i = 0; i < firstDigitNum; i++)\/\/\n\t\t{\n\t\t\tresult.m_sumsOfDigit[i] += numberWithStartingOne;\/\/\n\t\t}\n\t\tresult.m_sumsOfDigit[firstDigitNum] += 1;\n\t\tresult = result + (sumsOfNumberWithStartingOne * firstDigitNum) ;\/\/\ub9e8\uc55e\uc790\ub9ac\uc218\ub9cc \ubc14\ub00c\uba74\uc11c \ubc18\ubcf5\ub418\uae30 \ub54c\ubb38\n\t\tresult.m_sumsOfDigit[0] += subDigits.length();\/\/0\uac1c\uc218 \ub354\ud558\uae30\t\t\n\t}\n\telse\n\t{\n\t\tstring digitsWithAllZeroExceptFirst;\/\/\ub9e8\uc55e\uc790\ub9ac \uc81c\uc678 0\ub85c \uc774\ub904\uc9c4 \uc22b\uc790 \ub9cc\ub4e4\uae30\n\t\tdigitsWithAllZeroExceptFirst.push_back(strLimitNum.at(0));\n\t\tfor (int i = 0; i < subDigits.size(); i++)\n\t\t\tdigitsWithAllZeroExceptFirst.push_back('0');\n\t\t\/\/subDigits\uc758 \uc55e\uc790\ub9ac\uac00 0\uc77c \uacbd\uc6b0\ub300\ube44\n\t\tsprintf(tempBuf, \"%d\", atoi(subDigits.c_str()));\n\t\t\/\/SumsOfAllDigit subDigitsSum = sumAlldigit(subDigits, memoMap);\n\t\tSumsOfAllDigit subDigitsSum = sumAlldigit(string(tempBuf), memoMap);\n\t\tresult = sumAlldigit(digitsWithAllZeroExceptFirst, memoMap) + subDigitsSum;\n\n\t\tsprintf(tempBuf, \"%d\", subDigitsNum);\n\t\t\n\t\tresult.m_sumsOfDigit[0] += ((subDigitsNum )* ((int)subDigits.length() - (int)string(tempBuf).length()))- (int)string(tempBuf).length();\/\/-1\uc740 0\uc774 \uc911\ubcf5\ub418\uae30 \ub54c\ubb38\n\t\t\n\t\tresult.m_sumsOfDigit[firstDigitNum] += subDigitsNum;\/\/0\uc77c\ub54c\ub294 \ub354\ud574\uc838\uc11c \uc628\ub2e4.\uc148\ud558\uc9c0 \ub9d0\uac83\n\t}\n\n\t\n\t\n\t\/\/Memoization \n\tmemoMap.insert(pair<string, SumsOfAllDigit>(strLimitNum, result));\n\treturn result;\n}","docstring":"\/\/result.printAllSums();","function_name":"main"},"id":52,"seed":"SumsOfAllDigit sumAlldigit(string strLimitNum,map<string,SumsOfAllDigit> &memoMap)\n{\t\n\t\/\/Memoization \ud65c\uc6a9\n\tmap<string, SumsOfAllDigit>::iterator iter =memoMap.find(strLimitNum);\n\tif (iter != memoMap.end())\n\t{\t\t\n\t\treturn iter->second;\n\t}\n\tSumsOfAllDigit result;\n\t\/\/\ud55c\uc790\ub9bf\uc218\uc77c \uacbd\uc6b0\n\tif (strLimitNum.length() == 1)\n\t{\n\t\t\/\/int num = strLimitNum.at(0)-'0';\n\t\tint num = atoi(strLimitNum.c_str());\n\t\tfor (int i = 0; i <= num; i++)\n\t\t{\n\t\t\tresult.m_sumsOfDigit[i] += 1;\n\t\t}\n\t\treturn result;\n\t}\n\t\/\/---------------\uc5ec\uae30\uae4c\uc9c0 \uae30\uc800\n\tchar tempBuf[11];\n\n\t\/\/\"\uccab\uc790\ub9bf\uc218\ub9cc\uc788\uace0 \ub098\uba38\uc9c0 0\uc758 \ud569\uacc4\" + \"\uadf8\ub2e4\uc74c \uc790\ub9bf\uc218 \ubd80\ud130 \ub9cc\ub4e0 \uc22b\uc790\uc758 \ud569\uacc4\"\n\t\/\/\uadf8\ub2e4\uc74c \uc790\ub9bf\uc218 \ud569\uacc4\uad6c\ud558\uae30\n\tstring subDigits= strLimitNum.substr(1, strLimitNum.length() - 1);\n\tint subDigitsNum =atoi(subDigits.c_str());\/\/\ub9e8\uc55e\uc790\ub9ac\ub97c \uc81c\uc678\ud55c \uc22b\uc790\n\tint firstDigitNum = strLimitNum.at(0) - '0';\/\/\ub9e8\uc55e\uc790\ub9ac \uc22b\uc790\n\tif (0 == subDigitsNum)\/\/\ub9e8 \uc55e\uc790\ub9ac \ube7c\uace0 \ub2e4 0\uc77c \uacbd\uc6b0\n\t{\n\t\tstring digitsOfNines;\/\/\ud55c \uc790\ub9bf\uc218\uac00 \uc791\uc740 9\ub85c \uc774\ub904\uc9c4 \uc22b\uc790 \ub9cc\ub4e4\uae30\n\t\tfor (int i = 0; i < subDigits.size(); i++)\n\t\t\tdigitsOfNines.push_back('9');\n\t\tSumsOfAllDigit sumsOfNumberWithStartingOne;\/\/\ud55c \uc790\ub9bf\uc218 \uc791\uc740 9\ub85c \uc774\ub904\uc9c4 \uc22b\uc790\uc758 \ud569\uacc4\n\t\tint numberWithStartingOne = atoi(digitsOfNines.c_str()) + 1;\n\t\tsumsOfNumberWithStartingOne = sumAlldigit(digitsOfNines, memoMap);\/\/9...\uc758 \uac83 \uad6c\ud558\uae30\n\t\t\/\/sumsOfNumberWithStartingOne.m_sumsOfDigit[0] += subDigits.length();\/\/0\uac1c\uc218 \ub354\ud558\uae30\t\t\n\t\t\n\t\t\/\/\ub9e8\uc55e\uc790\ub9ac \uc218\ub97c \ub2e4 \ub354\ud558\uae30\n\t\t\/\/for (int i = 1; i < firstDigitNum; i++)\/\/1\ubd80\ud130\uc778 \uc774\uc720\ub294 \ub9e8\uc55e\uc790\ub9ac\ub294 0\uc744 \uc148\ud558\uc9c0 \uc54a\uc544\uc11c\n\t\tfor (int i = 0; i < firstDigitNum; i++)\/\/\n\t\t{\n\t\t\tresult.m_sumsOfDigit[i] += numberWithStartingOne;\/\/\n\t\t}\n\t\tresult.m_sumsOfDigit[firstDigitNum] += 1;\n\t\tresult = result + (sumsOfNumberWithStartingOne * firstDigitNum) ;\/\/\ub9e8\uc55e\uc790\ub9ac\uc218\ub9cc \ubc14\ub00c\uba74\uc11c \ubc18\ubcf5\ub418\uae30 \ub54c\ubb38\n\t\tresult.m_sumsOfDigit[0] += subDigits.length();\/\/0\uac1c\uc218 \ub354\ud558\uae30\t\t\n\t}\n\telse\n\t{\n\t\tstring digitsWithAllZeroExceptFirst;\/\/\ub9e8\uc55e\uc790\ub9ac \uc81c\uc678 0\ub85c \uc774\ub904\uc9c4 \uc22b\uc790 \ub9cc\ub4e4\uae30\n\t\tdigitsWithAllZeroExceptFirst.push_back(strLimitNum.at(0));\n\t\tfor (int i = 0; i < subDigits.size(); i++)\n\t\t\tdigitsWithAllZeroExceptFirst.push_back('0');\n\t\t\/\/subDigits\uc758 \uc55e\uc790\ub9ac\uac00 0\uc77c \uacbd\uc6b0\ub300\ube44\n\t\tsprintf(tempBuf, \"%d\", atoi(subDigits.c_str()));\n\t\t\/\/SumsOfAllDigit subDigitsSum = sumAlldigit(subDigits, memoMap);\n\t\tSumsOfAllDigit subDigitsSum = sumAlldigit(string(tempBuf), memoMap);\n\t\tresult = sumAlldigit(digitsWithAllZeroExceptFirst, memoMap) + subDigitsSum;\n\n\t\tsprintf(tempBuf, \"%d\", subDigitsNum);\n\t\t\n\t\tresult.m_sumsOfDigit[0] += ((subDigitsNum )* ((int)subDigits.length() - (int)string(tempBuf).length()))- (int)string(tempBuf).length();\/\/-1\uc740 0\uc774 \uc911\ubcf5\ub418\uae30 \ub54c\ubb38\n\t\t\n\t\tresult.m_sumsOfDigit[firstDigitNum] += subDigitsNum;\/\/0\uc77c\ub54c\ub294 \ub354\ud574\uc838\uc11c \uc628\ub2e4.\uc148\ud558\uc9c0 \ub9d0\uac83\n\t}\n\n\t\n\t\n\t\/\/Memoization \n\tmemoMap.insert(pair<string, SumsOfAllDigit>(strLimitNum, result));\n\treturn result;\n}"}
{"content":{"code":"void List_1_AddEnumerable_m1553189708_gshared (List_1_t3612285922 * __this, RuntimeObject* ___enumerable0, const RuntimeMethod* method)\n{\n\tstatic bool s_Il2CppMethodInitialized;\n\tif (!s_Il2CppMethodInitialized)\n\t{\n\t\til2cpp_codegen_initialize_method (List_1_AddEnumerable_m1553189708_MetadataUsageId);\n\t\ts_Il2CppMethodInitialized = true;\n\t}\n\tint32_t V_0 = 0;\n\tRuntimeObject* V_1 = NULL;\n\tException_t2748878030 * __last_unhandled_exception = 0;\n\tNO_UNUSED_WARNING (__last_unhandled_exception);\n\tException_t2748878030 * __exception_local = 0;\n\tNO_UNUSED_WARNING (__exception_local);\n\tint32_t __leave_target = 0;\n\tNO_UNUSED_WARNING (__leave_target);\n\t{\n\t\tRuntimeObject* L_0 = ___enumerable0;\n\t\tNullCheck((RuntimeObject*)L_0);\n\t\tRuntimeObject* L_1 = InterfaceFuncInvoker0< RuntimeObject* >::Invoke(0 \/* System.Collections.Generic.IEnumerator`1<T> System.Collections.Generic.IEnumerable`1<System.Int32>::GetEnumerator() *\/, IL2CPP_RGCTX_DATA(method->declaring_type->rgctx_data, 20), (RuntimeObject*)L_0);\n\t\tV_1 = (RuntimeObject*)L_1;\n\t}\n\nIL_0007:\n\ttry\n\t{ \/\/ begin try (depth: 1)\n\t\t{\n\t\t\tgoto IL_001a;\n\t\t}\n\nIL_000c:\n\t\t{\n\t\t\tRuntimeObject* L_2 = V_1;\n\t\t\tNullCheck((RuntimeObject*)L_2);\n\t\t\tint32_t L_3 = InterfaceFuncInvoker0< int32_t >::Invoke(0 \/* T System.Collections.Generic.IEnumerator`1<System.Int32>::get_Current() *\/, IL2CPP_RGCTX_DATA(method->declaring_type->rgctx_data, 21), (RuntimeObject*)L_2);\n\t\t\tV_0 = (int32_t)L_3;\n\t\t\tint32_t L_4 = V_0;\n\t\t\tNullCheck((List_1_t3612285922 *)__this);\n\t\t\t((  void (*) (List_1_t3612285922 *, int32_t, const RuntimeMethod*))IL2CPP_RGCTX_METHOD_INFO(method->declaring_type->rgctx_data, 9)->methodPointer)((List_1_t3612285922 *)__this, (int32_t)L_4, \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->declaring_type->rgctx_data, 9));\n\t\t}\n\nIL_001a:\n\t\t{\n\t\t\tRuntimeObject* L_5 = V_1;\n\t\t\tNullCheck((RuntimeObject*)L_5);\n\t\t\tbool L_6 = InterfaceFuncInvoker0< bool >::Invoke(1 \/* System.Boolean System.Collections.IEnumerator::MoveNext() *\/, IEnumerator_t3774429009_il2cpp_TypeInfo_var, (RuntimeObject*)L_5);\n\t\t\tif (L_6)\n\t\t\t{\n\t\t\t\tgoto IL_000c;\n\t\t\t}\n\t\t}\n\nIL_0025:\n\t\t{\n\t\t\tIL2CPP_LEAVE(0x35, FINALLY_002a);\n\t\t}\n\t} \/\/ end try (depth: 1)\n\tcatch(Il2CppExceptionWrapper& e)\n\t{\n\t\t__last_unhandled_exception = (Exception_t2748878030 *)e.ex;\n\t\tgoto FINALLY_002a;\n\t}\n\nFINALLY_002a:\n\t{ \/\/ begin finally (depth: 1)\n\t\t{\n\t\t\tRuntimeObject* L_7 = V_1;\n\t\t\tif (L_7)\n\t\t\t{\n\t\t\t\tgoto IL_002e;\n\t\t\t}\n\t\t}\n\nIL_002d:\n\t\t{\n\t\t\tIL2CPP_END_FINALLY(42)\n\t\t}\n\nIL_002e:\n\t\t{\n\t\t\tRuntimeObject* L_8 = V_1;\n\t\t\tNullCheck((RuntimeObject*)L_8);\n\t\t\tInterfaceActionInvoker0::Invoke(0 \/* System.Void System.IDisposable::Dispose() *\/, IDisposable_t4289139908_il2cpp_TypeInfo_var, (RuntimeObject*)L_8);\n\t\t\tIL2CPP_END_FINALLY(42)\n\t\t}\n\t} \/\/ end finally (depth: 1)\n\tIL2CPP_CLEANUP(42)\n\t{\n\t\tIL2CPP_JUMP_TBL(0x35, IL_0035)\n\t\tIL2CPP_RETHROW_IF_UNHANDLED(Exception_t2748878030 *)\n\t}\n\nIL_0035:\n\t{\n\t\treturn;\n\t}\n}","docstring":"\/\/ end catch (depth: 1)","function_name":"List_1_System_Collections_IList_set_Item_m37152599_gshared"},"id":64,"seed":"void List_1_AddEnumerable_m1553189708_gshared (List_1_t3612285922 * __this, RuntimeObject* ___enumerable0, const RuntimeMethod* method)\n{\n\tstatic bool s_Il2CppMethodInitialized;\n\tif (!s_Il2CppMethodInitialized)\n\t{\n\t\til2cpp_codegen_initialize_method (List_1_AddEnumerable_m1553189708_MetadataUsageId);\n\t\ts_Il2CppMethodInitialized = true;\n\t}\n\tint32_t V_0 = 0;\n\tRuntimeObject* V_1 = NULL;\n\tException_t2748878030 * __last_unhandled_exception = 0;\n\tNO_UNUSED_WARNING (__last_unhandled_exception);\n\tException_t2748878030 * __exception_local = 0;\n\tNO_UNUSED_WARNING (__exception_local);\n\tint32_t __leave_target = 0;\n\tNO_UNUSED_WARNING (__leave_target);\n\t{\n\t\tRuntimeObject* L_0 = ___enumerable0;\n\t\tNullCheck((RuntimeObject*)L_0);\n\t\tRuntimeObject* L_1 = InterfaceFuncInvoker0< RuntimeObject* >::Invoke(0 \/* System.Collections.Generic.IEnumerator`1<T> System.Collections.Generic.IEnumerable`1<System.Int32>::GetEnumerator() *\/, IL2CPP_RGCTX_DATA(method->declaring_type->rgctx_data, 20), (RuntimeObject*)L_0);\n\t\tV_1 = (RuntimeObject*)L_1;\n\t}\n\nIL_0007:\n\ttry\n\t{ \/\/ begin try (depth: 1)\n\t\t{\n\t\t\tgoto IL_001a;\n\t\t}\n\nIL_000c:\n\t\t{\n\t\t\tRuntimeObject* L_2 = V_1;\n\t\t\tNullCheck((RuntimeObject*)L_2);\n\t\t\tint32_t L_3 = InterfaceFuncInvoker0< int32_t >::Invoke(0 \/* T System.Collections.Generic.IEnumerator`1<System.Int32>::get_Current() *\/, IL2CPP_RGCTX_DATA(method->declaring_type->rgctx_data, 21), (RuntimeObject*)L_2);\n\t\t\tV_0 = (int32_t)L_3;\n\t\t\tint32_t L_4 = V_0;\n\t\t\tNullCheck((List_1_t3612285922 *)__this);\n\t\t\t((  void (*) (List_1_t3612285922 *, int32_t, const RuntimeMethod*))IL2CPP_RGCTX_METHOD_INFO(method->declaring_type->rgctx_data, 9)->methodPointer)((List_1_t3612285922 *)__this, (int32_t)L_4, \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->declaring_type->rgctx_data, 9));\n\t\t}\n\nIL_001a:\n\t\t{\n\t\t\tRuntimeObject* L_5 = V_1;\n\t\t\tNullCheck((RuntimeObject*)L_5);\n\t\t\tbool L_6 = InterfaceFuncInvoker0< bool >::Invoke(1 \/* System.Boolean System.Collections.IEnumerator::MoveNext() *\/, IEnumerator_t3774429009_il2cpp_TypeInfo_var, (RuntimeObject*)L_5);\n\t\t\tif (L_6)\n\t\t\t{\n\t\t\t\tgoto IL_000c;\n\t\t\t}\n\t\t}\n\nIL_0025:\n\t\t{\n\t\t\tIL2CPP_LEAVE(0x35, FINALLY_002a);\n\t\t}\n\t} \/\/ end try (depth: 1)\n\tcatch(Il2CppExceptionWrapper& e)\n\t{\n\t\t__last_unhandled_exception = (Exception_t2748878030 *)e.ex;\n\t\tgoto FINALLY_002a;\n\t}\n\nFINALLY_002a:\n\t{ \/\/ begin finally (depth: 1)\n\t\t{\n\t\t\tRuntimeObject* L_7 = V_1;\n\t\t\tif (L_7)\n\t\t\t{\n\t\t\t\tgoto IL_002e;\n\t\t\t}\n\t\t}\n\nIL_002d:\n\t\t{\n\t\t\tIL2CPP_END_FINALLY(42)\n\t\t}\n\nIL_002e:\n\t\t{\n\t\t\tRuntimeObject* L_8 = V_1;\n\t\t\tNullCheck((RuntimeObject*)L_8);\n\t\t\tInterfaceActionInvoker0::Invoke(0 \/* System.Void System.IDisposable::Dispose() *\/, IDisposable_t4289139908_il2cpp_TypeInfo_var, (RuntimeObject*)L_8);\n\t\t\tIL2CPP_END_FINALLY(42)\n\t\t}\n\t} \/\/ end finally (depth: 1)\n\tIL2CPP_CLEANUP(42)\n\t{\n\t\tIL2CPP_JUMP_TBL(0x35, IL_0035)\n\t\tIL2CPP_RETHROW_IF_UNHANDLED(Exception_t2748878030 *)\n\t}\n\nIL_0035:\n\t{\n\t\treturn;\n\t}\n}"}
{"content":{"code":"double NeuroSimSubArrayReadLatency(SubArray *subArray) {\t\/\/ For 1 weighted sum task on selected columns\n\tif (!param->NeuroSimDynamicPerformance) { return 0; }\t\/\/ Skip this function if param->NeuroSimDynamicPerformance is false\n\tif (subArray->cell.memCellType == Type::SRAM) {   \/\/ SRAM\n\t\tsubArray->wlDecoder.CalculateLatency(1e20, subArray->capRow1, NULL, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead, 1);\t\/\/ Don't care write\n\t\tsubArray->precharger.CalculateLatency(1e20, subArray->capCol, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead, 1);\t\/\/ Don't care write\n\t\tsubArray->senseAmp.CalculateLatency(subArray->numRow * subArray->numReadPulse * subArray->activityRowRead);\n\t\tsubArray->adder.CalculateLatency(1e20, subArray->dff.capTgDrain, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead);\n\t\tsubArray->dff.CalculateLatency(1e20, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead);\n\t\tsubArray->subtractor.CalculateLatency(1e20, subArray->dff.capTgDrain, subArray->numReadPulse);\n\t\tif (subArray->shiftAddEnable) {\n\t\t\tsubArray->shiftAdd.CalculateLatency(subArray->numReadPulse);\t\/\/ There are numReadPulse times of shift-and-add\n\t\t}\n\t\tdouble resPullDown = CalculateOnResistance(subArray->cell.widthSRAMCellNMOS * subArray->tech.featureSize, NMOS, subArray->inputParameter.temperature, subArray->tech);\n\t\tdouble tau = (subArray->resCellAccess + resPullDown) * (subArray->capCellAccess + subArray->capCol) + subArray->resCol * subArray->capCol \/ 2;\n\t\ttau *= log(subArray->tech.vdd \/ (subArray->tech.vdd - subArray->cell.minSenseVoltage \/ 2));   \/* one signal raises and the other drops, so cell.minSenseVoltage\/2 is enough *\/\n\t\tdouble gm = CalculateTransconductance(subArray->cell.widthAccessCMOS * subArray->tech.featureSize, NMOS, subArray->tech);\n\t\tdouble beta = 1 \/ (resPullDown * gm);\n\t\tdouble colRamp = 0;\n\t\tsubArray->colDelay = horowitz(tau, beta, subArray->wlDecoder.rampOutput, &colRamp) * subArray->numRow * subArray->numReadPulse * subArray->activityRowRead;\n\n\t\treturn \tsubArray->wlDecoder.readLatency +\n\t\t\t\tsubArray->precharger.readLatency +\n\t\t\t\tsubArray->colDelay +\n\t\t\t\tsubArray->senseAmp.readLatency +\n\t\t\t\tsubArray->adder.readLatency +\n\t\t\t\tsubArray->dff.readLatency +\n\t\t\t\tsubArray->subtractor.readLatency +\n\t\t\t\tsubArray->shiftAdd.readLatency;\n\n\t} \n    else {\t\/\/ eNVM\n\t\tif (subArray->digitalModeNeuro) {\t\/\/ Digital eNVM, row by row operation\n\t\t\tif (subArray->cell.accessType == CMOS_access) {   \/\/ 1T1R\n\t\t\t\tif(subArray->parallelRead == true) \n                {   \/\/ for the parallel readout\n                    \/\/void NewSwitchMatrix::CalculateLatency(double _rampInput, double _capLoad, double _resLoad, double numRead, double numWrite) {\t\/\/ For simplicity, assume shift register is ideal\n                    double capToDrive=MAX(subArray->capRow2,subArray->capRow1);\n                    double resToDrive=subArray->resRow;\n                    subArray->wlBlSwitchMatrix.CalculateLatency(1e20, capToDrive, resToDrive, subArray->numReadPulse * subArray->activityRowRead, 1);\n                   \n                    \/\/ only need the wl-bl decoder\n                    double capBL = subArray->lengthCol * 0.2e-15 \/ 1e-6;\n                    \/\/ subArray->colDelay = 2.3 * subArray->resCol * capBL; \/\/column delay\n                    \n                    \/\/ Calculate column latency\n\t\t\t\t\tdouble tau = subArray->capCol*(subArray->cell.resMemCellAvg\/(subArray->numRow\/2));\n\t\t\t\t\tsubArray->colDelay = tau * 0.2 * subArray->numReadPulse * subArray->numColMuxed;  \/\/ assume the 15~20% voltage drop is enough for sensing\n \n                    \/\/ the read circuit\n                    \/\/ The input capacitance of the read circuit\n                    double Cin_ReadCircuit = subArray->capCol + subArray->mux.capTgDrain * (2 + subArray->numColMuxed - 1) + subArray->readCircuit.capTgDrain + subArray->readCircuit.capPmosGate;\n\n                    \/\/ Use the maximum read current to determine the readpulsewidth\n                    double Imax = subArray->numRow * subArray->cell.readVoltage \/ subArray->cell.resMemCellOn;\n                    subArray->cell.readPulseWidth = Cin_ReadCircuit * subArray->readCircuit.voltageIntThreshold \/ Imax * subArray->readCircuit.maxNumIntPerCycle;\n\n                    \/\/ Delay at the Mux the mux is driving the read circuit\n                    double colRamp=0;\n                    subArray->mux.CalculateLatency(colRamp, Cin_ReadCircuit, 1); \/\/ the drive resistance should be the input resistance of the read circuit, the cap is the cap of\n\n                    \/\/ Here numColMuxed can mean how many synapses share 1 adder or how many columns share 1 S\/A\n                    int numAdder = (int)ceil(((double)subArray->numCol \/ subArray->numCellPerSynapse) \/ subArray->numColMuxed);   \/\/ numCol is divisible by numCellPerSynapse\n                    int numInput = numAdder * subArray->numCellPerSynapse; \/\/ number of input of the mux\n                    subArray->muxDecoder.CalculateLatency(1e20, subArray->mux.capTgGateN * numInput, subArray->mux.capTgGateP * numInput, 1, 1);\n                    subArray->readCircuit.CalculateLatency(subArray->numReadPulse);\n                    subArray->subtractor.CalculateLatency(1e20, 0, subArray->numReadPulse);\n                   if (subArray->shiftAddEnable) {\n                       \/\/ two shift adders are needed. one to add\n                       subArray->shiftAdd.CalculateLatency(subArray->numReadPulse);\n                   }\n                                \n                   return  MAX(subArray->wlBlSwitchMatrix.readLatency, subArray->muxDecoder.readLatency + subArray->mux.readLatency)+\n                           subArray->readCircuit.readLatency +\n                           subArray->subtractor.readLatency +\n                           subArray->colDelay+ \/\/ need furthercheck\n                           subArray->shiftAdd.readLatency;                \n                }\n                else {\n                   double capBL = subArray->lengthCol * 0.2e-15 \/ 1e-6;\n\t\t\t\t   subArray->wlDecoder.CalculateLatency(1e20, subArray->capRow2, NULL, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead, 1);\t\/\/ Don't care write\n\t\t\t\t   double colRamp = 0;\n\t\t\t\t   \/\/ double tau = subArray->resCol * capBL \/ 2 * (subArray->cell.resMemCellOff + subArray->resCol \/ 3) \/ (subArray->cell.resMemCellOff + subArray->resCol);\n\t\t\t\t   \/\/ subArray->colDelay = horowitz(tau, 0, 1e20, &colRamp);\n\t\t\t\t   \/\/ subArray->colDelay = 2.3 * subArray->resCol * capBL;\n\t\t\t\t   double tau = subArray->resCol * subArray->capCol \/ 2 * (subArray->cell.resMemCellOff + subArray->resCol \/ 3) \/ (subArray->cell.resMemCellOff + subArray->resCol);\n                   subArray->colDelay = tau * 0.2 * subArray->numColMuxed * subArray->numRow * subArray->numReadPulse;                   \n                   subArray->mux.CalculateLatency(colRamp, 0, 1);\n\t\t\t\t   \/\/ Here numColMuxed can mean how many synapses share 1 adder or how many columns share 1 S\/A\n\t\t\t\t   int numAdder = (int)ceil(((double)subArray->numCol \/ subArray->numCellPerSynapse) \/ subArray->numColMuxed);   \/\/ numCol is divisible by numCellPerSynapse\n\t\t\t\t   int numInput = numAdder * subArray->numCellPerSynapse; \/\/ number of input of the mux\n\t\t\t\t   subArray->muxDecoder.CalculateLatency(1e20, subArray->mux.capTgGateN * numInput, subArray->mux.capTgGateP * numInput, 1, 1);\n\t\t\t\t   double capInputLoad = capBL + subArray->mux.capTgDrain * (2 + subArray->numColMuxed - 1);\n\t\t\t\t   subArray->voltageSenseAmp.CalculateLatency(capInputLoad, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead);\n\t\t\t\t   subArray->adder.CalculateLatency(1e20, subArray->dff.capTgDrain, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead);\n\t\t\t\t   subArray->dff.CalculateLatency(1e20, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead);\n\t\t\t\t   subArray->subtractor.CalculateLatency(1e20, subArray->dff.capTgDrain, subArray->numReadPulse);\n\t\t\t\t   if (subArray->shiftAddEnable) {\n\t\t\t\t\t   subArray->shiftAdd.CalculateLatency(subArray->numReadPulse);    \/\/ There are numReadPulse times of shift-and-add\n\t\t\t\t}\n\n\t\t\t\treturn  MAX(subArray->wlDecoder.readLatency, subArray->muxDecoder.readLatency + subArray->mux.readLatency)+\n\t\t\t\t\t\tsubArray->voltageSenseAmp.readLatency +\n\t\t\t\t\t\tsubArray->adder.readLatency +\n\t\t\t\t\t\tsubArray->dff.readLatency +\n\t\t\t\t\t\tsubArray->subtractor.readLatency +\n                        subArray->colDelay+\n\t\t\t\t\t\tsubArray->shiftAdd.readLatency;\n                }\n                        \n\t\t\t} else {        \/\/ Cross-point\n\t\t\t\tdouble wlDecoderLoad = subArray->colDecoderDriver.capInvInput + subArray->colDecoderDriver.capTgGateN + subArray->colDecoderDriver.capTgGateP;\n\t\t\t\tsubArray->wlDecoder.CalculateLatency(1e20, wlDecoderLoad, NULL, subArray->numRow * subArray->activityRowRead * subArray->numReadPulse, 1);\t\/\/ Don't care write\n\t\t\t\tsubArray->wlDecoderDriver.CalculateLatency(subArray->wlDecoder.rampOutput, subArray->capRow1, subArray->capRow1, subArray->resRow, subArray->numRow * subArray->activityRowRead * subArray->numReadPulse, 1);\t\/\/ Don't care write\n\t\t\t\tdouble colRamp = 0;\n\t\t\t\t\/\/ double tau = subArray->resCol * subArray->capCol \/ 2 * (subArray->cell.resMemCellOff + subArray->resCol \/ 3) \/ (subArray->cell.resMemCellOff + subArray->resCol);\n\t\t\t\t\/\/ subArray->colDelay = horowitz(tau, 0, 1e20, &colRamp);\n\t\t\t\t\/\/ subArray->colDelay = 2.3 * subArray->resCol * subArray->capCol;\n\t\t\t\tdouble tau = subArray->capCol*(subArray->cell.resMemCellAvg\/(subArray->numRow\/2));\n\t\t\t\tsubArray->colDelay = tau * 0.2 * subArray->numReadPulse * subArray->numColMuxed;\n                subArray->mux.CalculateLatency(colRamp, 0, 1);\n\t\t\t\t\/\/ Here numColMuxed can mean how many synapses share 1 adder or how many columns share 1 S\/A\n\t\t\t\tint numAdder = (int)ceil(((double)subArray->numCol \/ subArray->numCellPerSynapse) \/ subArray->numColMuxed);   \/\/ numCol is divisible by numCellPerSynapse\n\t\t\t\tint numInput = numAdder * subArray->numCellPerSynapse;\n\t\t\t\tsubArray->muxDecoder.CalculateLatency(1e20, subArray->mux.capTgGateN * numInput, subArray->mux.capTgGateP*numInput, 1, 1);\n\t\t\t\tdouble capInputLoad = subArray->capCol + subArray->mux.capTgDrain * (2 + subArray->numColMuxed - 1);\n\t\t\t\tsubArray->voltageSenseAmp.CalculateLatency(capInputLoad, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead);\n\t\t\t\tsubArray->adder.CalculateLatency(1e20, subArray->dff.capTgDrain, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead);\n\t\t\t\tsubArray->dff.CalculateLatency(1e20, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead);\n\t\t\t\tsubArray->subtractor.CalculateLatency(1e20, subArray->dff.capTgDrain, subArray->numReadPulse);\n\t\t\t\tif (subArray->shiftAddEnable) {\n\t\t\t\t\tsubArray->shiftAdd.CalculateLatency(subArray->numReadPulse);    \/\/ There are numReadPulse times of shift-and-add\n\t\t\t\t}\n\t\t\t\treturn  MAX(subArray->wlDecoder.readLatency + subArray->wlDecoderDriver.readLatency, subArray->muxDecoder.readLatency + subArray->mux.readLatency);\n\t\t\t\t\t\tsubArray->voltageSenseAmp.readLatency +\n\t\t\t\t\t\tsubArray->adder.readLatency +\n\t\t\t\t\t\tsubArray->dff.readLatency +\n\t\t\t\t\t\tsubArray->subtractor.readLatency +\n\t\t\t\t\t\tsubArray->shiftAdd.readLatency;\n\t\t\t}\n\t\t} else {\t\/\/ Analog eNVM\n\t\t\tif (subArray->cell.accessType == CMOS_access) {   \/\/ 1T1R\n\t\t\t\tsubArray->wlDecoder.CalculateLatency(1e20, subArray->wlDecoderOutput.capNorInput, NULL, 1, 1);\t\/\/ Don't care write\n\t\t\t\tsubArray->wlDecoderOutput.CalculateLatency(subArray->wlDecoder.rampOutput, subArray->capRow2, subArray->resRow, 1, 1);\t\/\/ Don't care write\n\t\t\t\tsubArray->blSwitchMatrix.CalculateLatency(1e20, subArray->capRow1, subArray->resRow, subArray->numReadPulse, 1);    \/\/ Don't care write\n\t\t\t\tdouble tau = subArray->capCol*(subArray->cell.resMemCellAvg\/(subArray->numRow\/2));\n\t\t\t\tsubArray->colDelay = tau * 0.2 * subArray->numReadPulse * subArray->numColMuxed;\n\t\t\t\tif (subArray->readCircuit.mode == CMOS) {\n                    \/\/ Cin is the capacitance to collect the charge\n\t\t\t\t\tdouble Cin = subArray->capCol + subArray->mux.capTgDrain * (2 + subArray->numColMuxed - 1) + subArray->readCircuit.capTgDrain + subArray->readCircuit.capPmosGate;\n\t\t\t\t\t\/\/ the maximum read current\n                    double Imax = subArray->numRow * subArray->cell.readVoltage \/ subArray->cell.resMemCellOn;\n\t\t\t\t\tsubArray->cell.readPulseWidth = Cin * subArray->readCircuit.voltageIntThreshold \/ Imax * subArray->readCircuit.maxNumIntPerCycle;\n\t\t\t\t} else {    \/\/ mode==OSCILLATION\n\t\t\t\t\tdouble Cin = subArray->capCol + subArray->mux.capTgDrain * (2 + subArray->numColMuxed - 1) + subArray->readCircuit.capInvInput;\n\t\t\t\t\tdouble Rmin = subArray->cell.resMemCellOn \/ subArray->numRow;\n\t\t\t\t\tdouble Rp = 1 \/ (1\/Rmin + 1\/subArray->readCircuit.R_OSC_OFF);\n\t\t\t\t\tdouble t_rise = -Rp * Cin * log((subArray->readCircuit.Vth - subArray->readCircuit.Vrow * Rp \/ Rmin) \/ (subArray->readCircuit.Vhold - subArray->readCircuit.Vrow * Rp \/ Rmin));\n\t\t\t\t\tsubArray->cell.readPulseWidth = t_rise * subArray->readCircuit.maxNumIntPerCycle;\n\t\t\t\t}\n\t\t\t\tsubArray->readCircuit.CalculateLatency(subArray->numReadPulse);\n\t\t\t\tsubArray->subtractor.CalculateLatency(1e20, 0, subArray->numReadPulse);\n\t\t\t\tif (subArray->shiftAddEnable) {\n\t\t\t\t\tsubArray->shiftAdd.CalculateLatency(subArray->numReadPulse);\n\t\t\t\t}\n\t\t\t\treturn \tsubArray->wlDecoderOutput.readLatency +\n\t\t\t\t\t\tsubArray->blSwitchMatrix.readLatency +\n\t\t\t\t\t\tsubArray->readCircuit.readLatency +\n\t\t\t\t\t\tsubArray->subtractor.readLatency +\n\t\t\t\t\t\tsubArray->shiftAdd.readLatency + \n                        subArray->colDelay;\n\n\t\t\t} else {\t\t\/\/ Cross-point\n\t\t\t\tsubArray->wlSwitchMatrix.CalculateLatency(1e20, subArray->capRow1, subArray->resRow, subArray->numReadPulse, 1);\t\/\/ Don't care write\n\t\t\t\tif (subArray->readCircuit.mode == CMOS) {\n\t\t\t\t\tdouble Cin = subArray->capCol + subArray->mux.capTgDrain * (2 + subArray->numColMuxed - 1) + subArray->readCircuit.capTgDrain + subArray->readCircuit.capPmosGate;\n\t\t\t\t\tdouble Imax = subArray->numRow * subArray->cell.readVoltage \/ subArray->cell.resMemCellOn;\n\t\t\t\t\tsubArray->cell.readPulseWidth = Cin * subArray->readCircuit.voltageIntThreshold \/ Imax * subArray->readCircuit.maxNumIntPerCycle;\n\t\t\t\t} else {    \/\/ mode==OSCILLATION\n\t\t\t\t\tdouble Cin = subArray->capCol + subArray->mux.capTgDrain * (2 + subArray->numColMuxed - 1) + subArray->readCircuit.capInvInput;\n\t\t\t\t\tdouble Rmin = subArray->cell.resMemCellOn \/ subArray->numRow;\n\t\t\t\t\tdouble Rp = 1 \/ (1\/Rmin + 1\/subArray->readCircuit.R_OSC_OFF);\n\t\t\t\t\tdouble t_rise = -Rp * Cin * log((subArray->readCircuit.Vth - subArray->readCircuit.Vrow * Rp \/ Rmin) \/ (subArray->readCircuit.Vhold - subArray->readCircuit.Vrow * Rp \/ Rmin));\n\t\t\t\t\tsubArray->cell.readPulseWidth = t_rise * subArray->readCircuit.maxNumIntPerCycle;\n\t\t\t\t}\n                \/\/ the column delay\n\t\t\t\tdouble tau = subArray->capCol*(subArray->cell.resMemCellAvg\/(subArray->numRow\/2));\n\t\t\t\tsubArray->colDelay = tau * 0.2 * subArray->numReadPulse * subArray->numColMuxed;\n\t\t\t\tsubArray->readCircuit.CalculateLatency(subArray->numReadPulse);\n\t\t\t\tsubArray->subtractor.CalculateLatency(1e20, 0, subArray->numReadPulse);\n\t\t\t\tif (subArray->shiftAddEnable) {\n\t\t\t\t\tsubArray->shiftAdd.CalculateLatency(subArray->numReadPulse);\n\t\t\t\t}\n\t\t\t\treturn \tsubArray->wlSwitchMatrix.readLatency +\n\t\t\t\t\t\tsubArray->readCircuit.readLatency +\n\t\t\t\t\t\tsubArray->subtractor.readLatency +\n\t\t\t\t\t\tsubArray->shiftAdd.readLatency;\n\t\t\t}\n\t\t}\n\t}\n}","docstring":"\/\/ calculate the area from Subarray class","function_name":"NeuroSimSubArrayArea"},"id":65,"seed":"double NeuroSimSubArrayReadLatency(SubArray *subArray) {\t\/\/ For 1 weighted sum task on selected columns\n\tif (!param->NeuroSimDynamicPerformance) { return 0; }\t\/\/ Skip this function if param->NeuroSimDynamicPerformance is false\n\tif (subArray->cell.memCellType == Type::SRAM) {   \/\/ SRAM\n\t\tsubArray->wlDecoder.CalculateLatency(1e20, subArray->capRow1, NULL, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead, 1);\t\/\/ Don't care write\n\t\tsubArray->precharger.CalculateLatency(1e20, subArray->capCol, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead, 1);\t\/\/ Don't care write\n\t\tsubArray->senseAmp.CalculateLatency(subArray->numRow * subArray->numReadPulse * subArray->activityRowRead);\n\t\tsubArray->adder.CalculateLatency(1e20, subArray->dff.capTgDrain, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead);\n\t\tsubArray->dff.CalculateLatency(1e20, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead);\n\t\tsubArray->subtractor.CalculateLatency(1e20, subArray->dff.capTgDrain, subArray->numReadPulse);\n\t\tif (subArray->shiftAddEnable) {\n\t\t\tsubArray->shiftAdd.CalculateLatency(subArray->numReadPulse);\t\/\/ There are numReadPulse times of shift-and-add\n\t\t}\n\t\tdouble resPullDown = CalculateOnResistance(subArray->cell.widthSRAMCellNMOS * subArray->tech.featureSize, NMOS, subArray->inputParameter.temperature, subArray->tech);\n\t\tdouble tau = (subArray->resCellAccess + resPullDown) * (subArray->capCellAccess + subArray->capCol) + subArray->resCol * subArray->capCol \/ 2;\n\t\ttau *= log(subArray->tech.vdd \/ (subArray->tech.vdd - subArray->cell.minSenseVoltage \/ 2));   \/* one signal raises and the other drops, so cell.minSenseVoltage\/2 is enough *\/\n\t\tdouble gm = CalculateTransconductance(subArray->cell.widthAccessCMOS * subArray->tech.featureSize, NMOS, subArray->tech);\n\t\tdouble beta = 1 \/ (resPullDown * gm);\n\t\tdouble colRamp = 0;\n\t\tsubArray->colDelay = horowitz(tau, beta, subArray->wlDecoder.rampOutput, &colRamp) * subArray->numRow * subArray->numReadPulse * subArray->activityRowRead;\n\n\t\treturn \tsubArray->wlDecoder.readLatency +\n\t\t\t\tsubArray->precharger.readLatency +\n\t\t\t\tsubArray->colDelay +\n\t\t\t\tsubArray->senseAmp.readLatency +\n\t\t\t\tsubArray->adder.readLatency +\n\t\t\t\tsubArray->dff.readLatency +\n\t\t\t\tsubArray->subtractor.readLatency +\n\t\t\t\tsubArray->shiftAdd.readLatency;\n\n\t} \n    else {\t\/\/ eNVM\n\t\tif (subArray->digitalModeNeuro) {\t\/\/ Digital eNVM, row by row operation\n\t\t\tif (subArray->cell.accessType == CMOS_access) {   \/\/ 1T1R\n\t\t\t\tif(subArray->parallelRead == true) \n                {   \/\/ for the parallel readout\n                    \/\/void NewSwitchMatrix::CalculateLatency(double _rampInput, double _capLoad, double _resLoad, double numRead, double numWrite) {\t\/\/ For simplicity, assume shift register is ideal\n                    double capToDrive=MAX(subArray->capRow2,subArray->capRow1);\n                    double resToDrive=subArray->resRow;\n                    subArray->wlBlSwitchMatrix.CalculateLatency(1e20, capToDrive, resToDrive, subArray->numReadPulse * subArray->activityRowRead, 1);\n                   \n                    \/\/ only need the wl-bl decoder\n                    double capBL = subArray->lengthCol * 0.2e-15 \/ 1e-6;\n                    \/\/ subArray->colDelay = 2.3 * subArray->resCol * capBL; \/\/column delay\n                    \n                    \/\/ Calculate column latency\n\t\t\t\t\tdouble tau = subArray->capCol*(subArray->cell.resMemCellAvg\/(subArray->numRow\/2));\n\t\t\t\t\tsubArray->colDelay = tau * 0.2 * subArray->numReadPulse * subArray->numColMuxed;  \/\/ assume the 15~20% voltage drop is enough for sensing\n \n                    \/\/ the read circuit\n                    \/\/ The input capacitance of the read circuit\n                    double Cin_ReadCircuit = subArray->capCol + subArray->mux.capTgDrain * (2 + subArray->numColMuxed - 1) + subArray->readCircuit.capTgDrain + subArray->readCircuit.capPmosGate;\n\n                    \/\/ Use the maximum read current to determine the readpulsewidth\n                    double Imax = subArray->numRow * subArray->cell.readVoltage \/ subArray->cell.resMemCellOn;\n                    subArray->cell.readPulseWidth = Cin_ReadCircuit * subArray->readCircuit.voltageIntThreshold \/ Imax * subArray->readCircuit.maxNumIntPerCycle;\n\n                    \/\/ Delay at the Mux the mux is driving the read circuit\n                    double colRamp=0;\n                    subArray->mux.CalculateLatency(colRamp, Cin_ReadCircuit, 1); \/\/ the drive resistance should be the input resistance of the read circuit, the cap is the cap of\n\n                    \/\/ Here numColMuxed can mean how many synapses share 1 adder or how many columns share 1 S\/A\n                    int numAdder = (int)ceil(((double)subArray->numCol \/ subArray->numCellPerSynapse) \/ subArray->numColMuxed);   \/\/ numCol is divisible by numCellPerSynapse\n                    int numInput = numAdder * subArray->numCellPerSynapse; \/\/ number of input of the mux\n                    subArray->muxDecoder.CalculateLatency(1e20, subArray->mux.capTgGateN * numInput, subArray->mux.capTgGateP * numInput, 1, 1);\n                    subArray->readCircuit.CalculateLatency(subArray->numReadPulse);\n                    subArray->subtractor.CalculateLatency(1e20, 0, subArray->numReadPulse);\n                   if (subArray->shiftAddEnable) {\n                       \/\/ two shift adders are needed. one to add\n                       subArray->shiftAdd.CalculateLatency(subArray->numReadPulse);\n                   }\n                                \n                   return  MAX(subArray->wlBlSwitchMatrix.readLatency, subArray->muxDecoder.readLatency + subArray->mux.readLatency)+\n                           subArray->readCircuit.readLatency +\n                           subArray->subtractor.readLatency +\n                           subArray->colDelay+ \/\/ need furthercheck\n                           subArray->shiftAdd.readLatency;                \n                }\n                else {\n                   double capBL = subArray->lengthCol * 0.2e-15 \/ 1e-6;\n\t\t\t\t   subArray->wlDecoder.CalculateLatency(1e20, subArray->capRow2, NULL, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead, 1);\t\/\/ Don't care write\n\t\t\t\t   double colRamp = 0;\n\t\t\t\t   \/\/ double tau = subArray->resCol * capBL \/ 2 * (subArray->cell.resMemCellOff + subArray->resCol \/ 3) \/ (subArray->cell.resMemCellOff + subArray->resCol);\n\t\t\t\t   \/\/ subArray->colDelay = horowitz(tau, 0, 1e20, &colRamp);\n\t\t\t\t   \/\/ subArray->colDelay = 2.3 * subArray->resCol * capBL;\n\t\t\t\t   double tau = subArray->resCol * subArray->capCol \/ 2 * (subArray->cell.resMemCellOff + subArray->resCol \/ 3) \/ (subArray->cell.resMemCellOff + subArray->resCol);\n                   subArray->colDelay = tau * 0.2 * subArray->numColMuxed * subArray->numRow * subArray->numReadPulse;                   \n                   subArray->mux.CalculateLatency(colRamp, 0, 1);\n\t\t\t\t   \/\/ Here numColMuxed can mean how many synapses share 1 adder or how many columns share 1 S\/A\n\t\t\t\t   int numAdder = (int)ceil(((double)subArray->numCol \/ subArray->numCellPerSynapse) \/ subArray->numColMuxed);   \/\/ numCol is divisible by numCellPerSynapse\n\t\t\t\t   int numInput = numAdder * subArray->numCellPerSynapse; \/\/ number of input of the mux\n\t\t\t\t   subArray->muxDecoder.CalculateLatency(1e20, subArray->mux.capTgGateN * numInput, subArray->mux.capTgGateP * numInput, 1, 1);\n\t\t\t\t   double capInputLoad = capBL + subArray->mux.capTgDrain * (2 + subArray->numColMuxed - 1);\n\t\t\t\t   subArray->voltageSenseAmp.CalculateLatency(capInputLoad, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead);\n\t\t\t\t   subArray->adder.CalculateLatency(1e20, subArray->dff.capTgDrain, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead);\n\t\t\t\t   subArray->dff.CalculateLatency(1e20, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead);\n\t\t\t\t   subArray->subtractor.CalculateLatency(1e20, subArray->dff.capTgDrain, subArray->numReadPulse);\n\t\t\t\t   if (subArray->shiftAddEnable) {\n\t\t\t\t\t   subArray->shiftAdd.CalculateLatency(subArray->numReadPulse);    \/\/ There are numReadPulse times of shift-and-add\n\t\t\t\t}\n\n\t\t\t\treturn  MAX(subArray->wlDecoder.readLatency, subArray->muxDecoder.readLatency + subArray->mux.readLatency)+\n\t\t\t\t\t\tsubArray->voltageSenseAmp.readLatency +\n\t\t\t\t\t\tsubArray->adder.readLatency +\n\t\t\t\t\t\tsubArray->dff.readLatency +\n\t\t\t\t\t\tsubArray->subtractor.readLatency +\n                        subArray->colDelay+\n\t\t\t\t\t\tsubArray->shiftAdd.readLatency;\n                }\n                        \n\t\t\t} else {        \/\/ Cross-point\n\t\t\t\tdouble wlDecoderLoad = subArray->colDecoderDriver.capInvInput + subArray->colDecoderDriver.capTgGateN + subArray->colDecoderDriver.capTgGateP;\n\t\t\t\tsubArray->wlDecoder.CalculateLatency(1e20, wlDecoderLoad, NULL, subArray->numRow * subArray->activityRowRead * subArray->numReadPulse, 1);\t\/\/ Don't care write\n\t\t\t\tsubArray->wlDecoderDriver.CalculateLatency(subArray->wlDecoder.rampOutput, subArray->capRow1, subArray->capRow1, subArray->resRow, subArray->numRow * subArray->activityRowRead * subArray->numReadPulse, 1);\t\/\/ Don't care write\n\t\t\t\tdouble colRamp = 0;\n\t\t\t\t\/\/ double tau = subArray->resCol * subArray->capCol \/ 2 * (subArray->cell.resMemCellOff + subArray->resCol \/ 3) \/ (subArray->cell.resMemCellOff + subArray->resCol);\n\t\t\t\t\/\/ subArray->colDelay = horowitz(tau, 0, 1e20, &colRamp);\n\t\t\t\t\/\/ subArray->colDelay = 2.3 * subArray->resCol * subArray->capCol;\n\t\t\t\tdouble tau = subArray->capCol*(subArray->cell.resMemCellAvg\/(subArray->numRow\/2));\n\t\t\t\tsubArray->colDelay = tau * 0.2 * subArray->numReadPulse * subArray->numColMuxed;\n                subArray->mux.CalculateLatency(colRamp, 0, 1);\n\t\t\t\t\/\/ Here numColMuxed can mean how many synapses share 1 adder or how many columns share 1 S\/A\n\t\t\t\tint numAdder = (int)ceil(((double)subArray->numCol \/ subArray->numCellPerSynapse) \/ subArray->numColMuxed);   \/\/ numCol is divisible by numCellPerSynapse\n\t\t\t\tint numInput = numAdder * subArray->numCellPerSynapse;\n\t\t\t\tsubArray->muxDecoder.CalculateLatency(1e20, subArray->mux.capTgGateN * numInput, subArray->mux.capTgGateP*numInput, 1, 1);\n\t\t\t\tdouble capInputLoad = subArray->capCol + subArray->mux.capTgDrain * (2 + subArray->numColMuxed - 1);\n\t\t\t\tsubArray->voltageSenseAmp.CalculateLatency(capInputLoad, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead);\n\t\t\t\tsubArray->adder.CalculateLatency(1e20, subArray->dff.capTgDrain, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead);\n\t\t\t\tsubArray->dff.CalculateLatency(1e20, subArray->numRow * subArray->numReadPulse * subArray->activityRowRead);\n\t\t\t\tsubArray->subtractor.CalculateLatency(1e20, subArray->dff.capTgDrain, subArray->numReadPulse);\n\t\t\t\tif (subArray->shiftAddEnable) {\n\t\t\t\t\tsubArray->shiftAdd.CalculateLatency(subArray->numReadPulse);    \/\/ There are numReadPulse times of shift-and-add\n\t\t\t\t}\n\t\t\t\treturn  MAX(subArray->wlDecoder.readLatency + subArray->wlDecoderDriver.readLatency, subArray->muxDecoder.readLatency + subArray->mux.readLatency);\n\t\t\t\t\t\tsubArray->voltageSenseAmp.readLatency +\n\t\t\t\t\t\tsubArray->adder.readLatency +\n\t\t\t\t\t\tsubArray->dff.readLatency +\n\t\t\t\t\t\tsubArray->subtractor.readLatency +\n\t\t\t\t\t\tsubArray->shiftAdd.readLatency;\n\t\t\t}\n\t\t} else {\t\/\/ Analog eNVM\n\t\t\tif (subArray->cell.accessType == CMOS_access) {   \/\/ 1T1R\n\t\t\t\tsubArray->wlDecoder.CalculateLatency(1e20, subArray->wlDecoderOutput.capNorInput, NULL, 1, 1);\t\/\/ Don't care write\n\t\t\t\tsubArray->wlDecoderOutput.CalculateLatency(subArray->wlDecoder.rampOutput, subArray->capRow2, subArray->resRow, 1, 1);\t\/\/ Don't care write\n\t\t\t\tsubArray->blSwitchMatrix.CalculateLatency(1e20, subArray->capRow1, subArray->resRow, subArray->numReadPulse, 1);    \/\/ Don't care write\n\t\t\t\tdouble tau = subArray->capCol*(subArray->cell.resMemCellAvg\/(subArray->numRow\/2));\n\t\t\t\tsubArray->colDelay = tau * 0.2 * subArray->numReadPulse * subArray->numColMuxed;\n\t\t\t\tif (subArray->readCircuit.mode == CMOS) {\n                    \/\/ Cin is the capacitance to collect the charge\n\t\t\t\t\tdouble Cin = subArray->capCol + subArray->mux.capTgDrain * (2 + subArray->numColMuxed - 1) + subArray->readCircuit.capTgDrain + subArray->readCircuit.capPmosGate;\n\t\t\t\t\t\/\/ the maximum read current\n                    double Imax = subArray->numRow * subArray->cell.readVoltage \/ subArray->cell.resMemCellOn;\n\t\t\t\t\tsubArray->cell.readPulseWidth = Cin * subArray->readCircuit.voltageIntThreshold \/ Imax * subArray->readCircuit.maxNumIntPerCycle;\n\t\t\t\t} else {    \/\/ mode==OSCILLATION\n\t\t\t\t\tdouble Cin = subArray->capCol + subArray->mux.capTgDrain * (2 + subArray->numColMuxed - 1) + subArray->readCircuit.capInvInput;\n\t\t\t\t\tdouble Rmin = subArray->cell.resMemCellOn \/ subArray->numRow;\n\t\t\t\t\tdouble Rp = 1 \/ (1\/Rmin + 1\/subArray->readCircuit.R_OSC_OFF);\n\t\t\t\t\tdouble t_rise = -Rp * Cin * log((subArray->readCircuit.Vth - subArray->readCircuit.Vrow * Rp \/ Rmin) \/ (subArray->readCircuit.Vhold - subArray->readCircuit.Vrow * Rp \/ Rmin));\n\t\t\t\t\tsubArray->cell.readPulseWidth = t_rise * subArray->readCircuit.maxNumIntPerCycle;\n\t\t\t\t}\n\t\t\t\tsubArray->readCircuit.CalculateLatency(subArray->numReadPulse);\n\t\t\t\tsubArray->subtractor.CalculateLatency(1e20, 0, subArray->numReadPulse);\n\t\t\t\tif (subArray->shiftAddEnable) {\n\t\t\t\t\tsubArray->shiftAdd.CalculateLatency(subArray->numReadPulse);\n\t\t\t\t}\n\t\t\t\treturn \tsubArray->wlDecoderOutput.readLatency +\n\t\t\t\t\t\tsubArray->blSwitchMatrix.readLatency +\n\t\t\t\t\t\tsubArray->readCircuit.readLatency +\n\t\t\t\t\t\tsubArray->subtractor.readLatency +\n\t\t\t\t\t\tsubArray->shiftAdd.readLatency + \n                        subArray->colDelay;\n\n\t\t\t} else {\t\t\/\/ Cross-point\n\t\t\t\tsubArray->wlSwitchMatrix.CalculateLatency(1e20, subArray->capRow1, subArray->resRow, subArray->numReadPulse, 1);\t\/\/ Don't care write\n\t\t\t\tif (subArray->readCircuit.mode == CMOS) {\n\t\t\t\t\tdouble Cin = subArray->capCol + subArray->mux.capTgDrain * (2 + subArray->numColMuxed - 1) + subArray->readCircuit.capTgDrain + subArray->readCircuit.capPmosGate;\n\t\t\t\t\tdouble Imax = subArray->numRow * subArray->cell.readVoltage \/ subArray->cell.resMemCellOn;\n\t\t\t\t\tsubArray->cell.readPulseWidth = Cin * subArray->readCircuit.voltageIntThreshold \/ Imax * subArray->readCircuit.maxNumIntPerCycle;\n\t\t\t\t} else {    \/\/ mode==OSCILLATION\n\t\t\t\t\tdouble Cin = subArray->capCol + subArray->mux.capTgDrain * (2 + subArray->numColMuxed - 1) + subArray->readCircuit.capInvInput;\n\t\t\t\t\tdouble Rmin = subArray->cell.resMemCellOn \/ subArray->numRow;\n\t\t\t\t\tdouble Rp = 1 \/ (1\/Rmin + 1\/subArray->readCircuit.R_OSC_OFF);\n\t\t\t\t\tdouble t_rise = -Rp * Cin * log((subArray->readCircuit.Vth - subArray->readCircuit.Vrow * Rp \/ Rmin) \/ (subArray->readCircuit.Vhold - subArray->readCircuit.Vrow * Rp \/ Rmin));\n\t\t\t\t\tsubArray->cell.readPulseWidth = t_rise * subArray->readCircuit.maxNumIntPerCycle;\n\t\t\t\t}\n                \/\/ the column delay\n\t\t\t\tdouble tau = subArray->capCol*(subArray->cell.resMemCellAvg\/(subArray->numRow\/2));\n\t\t\t\tsubArray->colDelay = tau * 0.2 * subArray->numReadPulse * subArray->numColMuxed;\n\t\t\t\tsubArray->readCircuit.CalculateLatency(subArray->numReadPulse);\n\t\t\t\tsubArray->subtractor.CalculateLatency(1e20, 0, subArray->numReadPulse);\n\t\t\t\tif (subArray->shiftAddEnable) {\n\t\t\t\t\tsubArray->shiftAdd.CalculateLatency(subArray->numReadPulse);\n\t\t\t\t}\n\t\t\t\treturn \tsubArray->wlSwitchMatrix.readLatency +\n\t\t\t\t\t\tsubArray->readCircuit.readLatency +\n\t\t\t\t\t\tsubArray->subtractor.readLatency +\n\t\t\t\t\t\tsubArray->shiftAdd.readLatency;\n\t\t\t}\n\t\t}\n\t}\n}"}
{"content":{"code":"static bool js_cc_Scene_autoReleaseAssets_set(se::State& s)\n{\n    CC_UNUSED bool ok = true;\n    const auto& args = s.args();\n    size_t argc = args.size();\n    cc::Scene *arg1 = (cc::Scene *) NULL ;\n    bool arg2 ;\n    \n    arg1 = SE_THIS_OBJECT<cc::Scene>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    \/\/ %typemap(in) bool\n    ok &= sevalue_to_native(args[0], &arg2);\n    SE_PRECONDITION2(ok, false, \"Scene_autoReleaseAssets_set,2,SWIGTYPE_bool\"); \n    cc_Scene_autoReleaseAssets_set(arg1,arg2);\n    \n    \n    return true;\n}","docstring":"\/\/ %typemap(in) bool","function_name":"js_cc_Scene_onBatchCreated"},"id":66,"seed":"static bool js_cc_Scene_autoReleaseAssets_set(se::State& s)\n{\n    CC_UNUSED bool ok = true;\n    const auto& args = s.args();\n    size_t argc = args.size();\n    cc::Scene *arg1 = (cc::Scene *) NULL ;\n    bool arg2 ;\n    \n    arg1 = SE_THIS_OBJECT<cc::Scene>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    \/\/ %typemap(in) bool\n    ok &= sevalue_to_native(args[0], &arg2);\n    SE_PRECONDITION2(ok, false, \"Scene_autoReleaseAssets_set,2,SWIGTYPE_bool\"); \n    cc_Scene_autoReleaseAssets_set(arg1,arg2);\n    \n    \n    return true;\n}"}
{"content":{"code":"int client() {\n\t\/*\n\tSimple udp client\n\t*\/\n\tstruct sockaddr_in si_other;\n\tint s, slen = sizeof(si_other);\n\tchar buf[1500];\n\tchar message[BUFLEN];\n\tWSADATA wsa;\n\tchar ip_address[20];\n\n\tprintf(\"input the IP address, for default press d\\n\");\n\tscanf(\"%s\", ip_address);\n\tif (strcmp(ip_address, \"d\") == 0)\n\t\tstrcpy(ip_address, SERVER);\n\n\t\/\/Initialise winsock\n\tprintf(\"\\nInitialising Winsock...\");\n\tif (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)\n\t{\n\t\tprintf(\"Failed. Error Code : %d\\n\", WSAGetLastError());\n\t\texit(EXIT_FAILURE);\n\t}\n\tprintf(\"Initialised.\\n\");\n\n\t\/\/create socket\n\tif ((s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == SOCKET_ERROR)\n\t{\n\t\tprintf(\"socket() failed with error code : %d\\n\", WSAGetLastError());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t\/\/setup address structure\n\tmemset((char *)&si_other, 0, sizeof(si_other));\n\tsi_other.sin_family = AF_INET;\n\tsi_other.sin_port = htons(PORT);\n\tsi_other.sin_addr.S_un.S_addr = inet_addr(ip_address);\n\n\tAS_FIELDS* asfieldo = (AS_FIELDS*)malloc(sizeof(AS_FIELDS));\n\tasfieldo->a = s;\n\tasfieldo->b = slen;\n\tasfieldo->si_other = si_other;\n\tDWORD myThreadID, dwExit= 0;\n\tHANDLE myHandle = CreateThread(0, 0, sendingThread, (void*)asfieldo, 0, &myThreadID);\n\n\tchar c;\n\tgetchar();\n\n\tdo {\n\t\t\/\/ menu\n\t\tprintf(\"CLIENT MENU:\\n\");\n\t\tprintf(\"t - text message:\\n\");\n\t\tprintf(\"c - change connection:\\n\");\n\t\tprintf(\"f - send faulty packet:\\n\");\n\t\tprintf(\"d - doimplementacia:\\n\");\n\t\tprintf(\"e - exit program:\\n\");\n\t\tc = getchar();\n\t\tgetchar();\n\t\tswitch (c) {\n\t\tcase 't':\n\t\t\tTerminateThread(myHandle, dwExit);\n\t\t\tsend_text(s, si_other, slen);\n\t\t\tmyHandle = CreateThread(0, 0, sendingThread, (void*)asfieldo, 0, &myThreadID);\n\t\t\tcontinue;\n\t\tcase 'c':\n\t\t\tTerminateThread(myHandle, dwExit);\n\t\t\tchange_conn(s, si_other, slen);\n\t\t\tc = 'e';\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tTerminateThread(myHandle, dwExit);\n\t\t\tsend_faulty_packet(s, si_other, slen);\n\t\t\tmyHandle = CreateThread(0, 0, sendingThread, (void*)asfieldo, 0, &myThreadID);\n\t\t\tcontinue;\n\t\tcase 'd':\n\t\t\tTerminateThread(myHandle, dwExit);\n\t\t\tdoimplementacia(s, si_other, slen);\n\t\t\tmyHandle = CreateThread(0, 0, sendingThread, (void*)asfieldo, 0, &myThreadID);\n\t\t\tcontinue;\n\t\tcase 'e':\n\t\t\treturn 1;\n\t\t}\n\t} while (c != 'e');\n\t\n\tclosesocket(s);\n\tWSACleanup();\n\treturn 0;\n}","docstring":"\/\/try to receive some data, this is a blocking call","function_name":"send_text"},"id":69,"seed":"int client() {\n\t\/*\n\tSimple udp client\n\t*\/\n\tstruct sockaddr_in si_other;\n\tint s, slen = sizeof(si_other);\n\tchar buf[1500];\n\tchar message[BUFLEN];\n\tWSADATA wsa;\n\tchar ip_address[20];\n\n\tprintf(\"input the IP address, for default press d\\n\");\n\tscanf(\"%s\", ip_address);\n\tif (strcmp(ip_address, \"d\") == 0)\n\t\tstrcpy(ip_address, SERVER);\n\n\t\/\/Initialise winsock\n\tprintf(\"\\nInitialising Winsock...\");\n\tif (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)\n\t{\n\t\tprintf(\"Failed. Error Code : %d\\n\", WSAGetLastError());\n\t\texit(EXIT_FAILURE);\n\t}\n\tprintf(\"Initialised.\\n\");\n\n\t\/\/create socket\n\tif ((s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == SOCKET_ERROR)\n\t{\n\t\tprintf(\"socket() failed with error code : %d\\n\", WSAGetLastError());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t\/\/setup address structure\n\tmemset((char *)&si_other, 0, sizeof(si_other));\n\tsi_other.sin_family = AF_INET;\n\tsi_other.sin_port = htons(PORT);\n\tsi_other.sin_addr.S_un.S_addr = inet_addr(ip_address);\n\n\tAS_FIELDS* asfieldo = (AS_FIELDS*)malloc(sizeof(AS_FIELDS));\n\tasfieldo->a = s;\n\tasfieldo->b = slen;\n\tasfieldo->si_other = si_other;\n\tDWORD myThreadID, dwExit= 0;\n\tHANDLE myHandle = CreateThread(0, 0, sendingThread, (void*)asfieldo, 0, &myThreadID);\n\n\tchar c;\n\tgetchar();\n\n\tdo {\n\t\t\/\/ menu\n\t\tprintf(\"CLIENT MENU:\\n\");\n\t\tprintf(\"t - text message:\\n\");\n\t\tprintf(\"c - change connection:\\n\");\n\t\tprintf(\"f - send faulty packet:\\n\");\n\t\tprintf(\"d - doimplementacia:\\n\");\n\t\tprintf(\"e - exit program:\\n\");\n\t\tc = getchar();\n\t\tgetchar();\n\t\tswitch (c) {\n\t\tcase 't':\n\t\t\tTerminateThread(myHandle, dwExit);\n\t\t\tsend_text(s, si_other, slen);\n\t\t\tmyHandle = CreateThread(0, 0, sendingThread, (void*)asfieldo, 0, &myThreadID);\n\t\t\tcontinue;\n\t\tcase 'c':\n\t\t\tTerminateThread(myHandle, dwExit);\n\t\t\tchange_conn(s, si_other, slen);\n\t\t\tc = 'e';\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tTerminateThread(myHandle, dwExit);\n\t\t\tsend_faulty_packet(s, si_other, slen);\n\t\t\tmyHandle = CreateThread(0, 0, sendingThread, (void*)asfieldo, 0, &myThreadID);\n\t\t\tcontinue;\n\t\tcase 'd':\n\t\t\tTerminateThread(myHandle, dwExit);\n\t\t\tdoimplementacia(s, si_other, slen);\n\t\t\tmyHandle = CreateThread(0, 0, sendingThread, (void*)asfieldo, 0, &myThreadID);\n\t\t\tcontinue;\n\t\tcase 'e':\n\t\t\treturn 1;\n\t\t}\n\t} while (c != 'e');\n\t\n\tclosesocket(s);\n\tWSACleanup();\n\treturn 0;\n}"}
{"content":{"code":"soap_in__ns1__loginCmsResponse(struct soap *soap, const char *tag, _ns1__loginCmsResponse *a, const char *type)\n{\n\t(void)type; \/* appease -Wall -Werror *\/\n\tif (soap_element_begin_in(soap, tag, 0, NULL))\n\t\treturn NULL;\n\ta = (_ns1__loginCmsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns1__loginCmsResponse, sizeof(_ns1__loginCmsResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);\n\tif (!a)\n\t\treturn NULL;\n\tif (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns1__loginCmsResponse)\n\t{\tsoap_revert(soap);\n\t\t*soap->id = '\\0';\n\t\treturn (_ns1__loginCmsResponse *)a->soap_in(soap, tag, type);\n\t}\n\tif (soap->alloced)\n\t\ta->soap_default(soap);\n\tsize_t soap_flag_loginCmsReturn1 = 1;\n\tif (soap->body && *soap->href != '#')\n\t{\n\t\tfor (;;)\n\t\t{\tsoap->error = SOAP_TAG_MISMATCH;\n\t\t\tif (soap_flag_loginCmsReturn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))\n\t\t\t{\tif (soap_in_std__string(soap, \"ns1:loginCmsReturn\", &a->_ns1__loginCmsResponse::loginCmsReturn, \"xsd:string\"))\n\t\t\t\t{\tsoap_flag_loginCmsReturn1--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsoap_check_result(soap, \"ns1:loginCmsReturn\");\n\t\t\tif (soap->error == SOAP_TAG_MISMATCH)\n\t\t\t\tsoap->error = soap_ignore_element(soap);\n\t\t\tif (soap->error == SOAP_NO_TAG)\n\t\t\t\tbreak;\n\t\t\tif (soap->error)\n\t\t\t\treturn NULL;\n\t\t}\n\t\tif (soap_element_end_in(soap, tag))\n\t\t\treturn NULL;\n\t\tif ((soap->mode & SOAP_XML_STRICT) && (soap_flag_loginCmsReturn1 > 0))\n\t\t{\tsoap->error = SOAP_OCCURS;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')\n\t{\tsoap->error = SOAP_OCCURS;\n\t\treturn NULL;\n\t}\n\telse\n\t{\ta = (_ns1__loginCmsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns1__loginCmsResponse, SOAP_TYPE_afip__ns1__loginCmsResponse, sizeof(_ns1__loginCmsResponse), 0, afip_finsert, afip_fbase);\n\t\tif (soap->body && soap_element_end_in(soap, tag))\n\t\t\treturn NULL;\n\t}\n\treturn a;\n}","docstring":"\/* appease -Wall -Werror *\/","function_name":"soap_out__ns1__loginCmsResponse"},"id":73,"seed":"soap_in__ns1__loginCmsResponse(struct soap *soap, const char *tag, _ns1__loginCmsResponse *a, const char *type)\n{\n\t(void)type; \/* appease -Wall -Werror *\/\n\tif (soap_element_begin_in(soap, tag, 0, NULL))\n\t\treturn NULL;\n\ta = (_ns1__loginCmsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns1__loginCmsResponse, sizeof(_ns1__loginCmsResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);\n\tif (!a)\n\t\treturn NULL;\n\tif (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns1__loginCmsResponse)\n\t{\tsoap_revert(soap);\n\t\t*soap->id = '\\0';\n\t\treturn (_ns1__loginCmsResponse *)a->soap_in(soap, tag, type);\n\t}\n\tif (soap->alloced)\n\t\ta->soap_default(soap);\n\tsize_t soap_flag_loginCmsReturn1 = 1;\n\tif (soap->body && *soap->href != '#')\n\t{\n\t\tfor (;;)\n\t\t{\tsoap->error = SOAP_TAG_MISMATCH;\n\t\t\tif (soap_flag_loginCmsReturn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))\n\t\t\t{\tif (soap_in_std__string(soap, \"ns1:loginCmsReturn\", &a->_ns1__loginCmsResponse::loginCmsReturn, \"xsd:string\"))\n\t\t\t\t{\tsoap_flag_loginCmsReturn1--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsoap_check_result(soap, \"ns1:loginCmsReturn\");\n\t\t\tif (soap->error == SOAP_TAG_MISMATCH)\n\t\t\t\tsoap->error = soap_ignore_element(soap);\n\t\t\tif (soap->error == SOAP_NO_TAG)\n\t\t\t\tbreak;\n\t\t\tif (soap->error)\n\t\t\t\treturn NULL;\n\t\t}\n\t\tif (soap_element_end_in(soap, tag))\n\t\t\treturn NULL;\n\t\tif ((soap->mode & SOAP_XML_STRICT) && (soap_flag_loginCmsReturn1 > 0))\n\t\t{\tsoap->error = SOAP_OCCURS;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')\n\t{\tsoap->error = SOAP_OCCURS;\n\t\treturn NULL;\n\t}\n\telse\n\t{\ta = (_ns1__loginCmsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns1__loginCmsResponse, SOAP_TYPE_afip__ns1__loginCmsResponse, sizeof(_ns1__loginCmsResponse), 0, afip_finsert, afip_fbase);\n\t\tif (soap->body && soap_element_end_in(soap, tag))\n\t\t\treturn NULL;\n\t}\n\treturn a;\n}"}
{"content":{"code":"cv::Mat matRotateClockWise180(cv::Mat src) { \/\/\u987a\u65f6\u9488180\n    \/\/0: \u6cbfX\u8f74\u7ffb\u8f6c\uff1b >0: \u6cbfY\u8f74\u7ffb\u8f6c\uff1b <0: \u6cbfX\u8f74\u548cY\u8f74\u7ffb\u8f6c\n    flip(src, src, 0);\/\/ \u7ffb\u8f6c\u6a21\u5f0f\uff0cflipCode == 0\u5782\u76f4\u7ffb\u8f6c\uff08\u6cbfX\u8f74\u7ffb\u8f6c\uff09\uff0cflipCode>0\u6c34\u5e73\u7ffb\u8f6c\uff08\u6cbfY\u8f74\u7ffb\u8f6c\uff09\uff0cflipCode<0\u6c34\u5e73\u5782\u76f4\u7ffb\u8f6c\uff08\u5148\u6cbfX\u8f74\u7ffb\u8f6c\uff0c\u518d\u6cbfY\u8f74\u7ffb\u8f6c\uff0c\u7b49\u4ef7\u4e8e\u65cb\u8f6c180\u00b0\uff09\n    flip(src, src, 1);\n    return src;\n    \/\/transpose(src, src);\/\/ \u77e9\u9635\u8f6c\u7f6e\n}","docstring":"\/\/ std::cout<<\"\u7f29\u653e\u5c3a\u5bf8 (\" << w << \", \"<<h<<\")\"<<std::endl;","function_name":"resize_img"},"id":81,"seed":"cv::Mat matRotateClockWise180(cv::Mat src) { \/\/\u987a\u65f6\u9488180\n    \/\/0: \u6cbfX\u8f74\u7ffb\u8f6c\uff1b >0: \u6cbfY\u8f74\u7ffb\u8f6c\uff1b <0: \u6cbfX\u8f74\u548cY\u8f74\u7ffb\u8f6c\n    flip(src, src, 0);\/\/ \u7ffb\u8f6c\u6a21\u5f0f\uff0cflipCode == 0\u5782\u76f4\u7ffb\u8f6c\uff08\u6cbfX\u8f74\u7ffb\u8f6c\uff09\uff0cflipCode>0\u6c34\u5e73\u7ffb\u8f6c\uff08\u6cbfY\u8f74\u7ffb\u8f6c\uff09\uff0cflipCode<0\u6c34\u5e73\u5782\u76f4\u7ffb\u8f6c\uff08\u5148\u6cbfX\u8f74\u7ffb\u8f6c\uff0c\u518d\u6cbfY\u8f74\u7ffb\u8f6c\uff0c\u7b49\u4ef7\u4e8e\u65cb\u8f6c180\u00b0\uff09\n    flip(src, src, 1);\n    return src;\n    \/\/transpose(src, src);\/\/ \u77e9\u9635\u8f6c\u7f6e\n}"}
{"content":{"code":"void ReadDS3231()\n{\n\tsecondNoDst = Clock.getSecond();\n\tminuteNoDst = Clock.getMinute();\n\thourNoDst   = Clock.getHour(h12, PM);\n\tdayNoDst    = Clock.getDate();\n\tmonthNoDst  = Clock.getMonth(Century);\n\tyearNoDst   = Clock.getYear();\n\/\/  temperature = Clock.getTemperature();\n\tsecond = secondNoDst;\n\tminute = minuteNoDst;\n\tday    = dayNoDst;\n\tmonth  = monthNoDst;\n\tyear   = yearNoDst;\n\tif (NowInDST())\n\t{\n\t\thour = hourNoDst + 1;\n\t\tif (hour >= 24)\n\t\t{\n\t\t\thour = 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\thour = hourNoDst;\n\t}\n\n\tif (mode == LED_TEST_MODE)\n\t{\n\t\treturn;\n\t}\n\tif (bWriteOnSerial)\n\t{\n\t\tShowDateTimeOnSerial();\n\t}\n}","docstring":"\/\/Set the year (Last two digits of the year)","function_name":"SetDS3231"},"id":82,"seed":"void ReadDS3231()\n{\n\tsecondNoDst = Clock.getSecond();\n\tminuteNoDst = Clock.getMinute();\n\thourNoDst   = Clock.getHour(h12, PM);\n\tdayNoDst    = Clock.getDate();\n\tmonthNoDst  = Clock.getMonth(Century);\n\tyearNoDst   = Clock.getYear();\n\/\/  temperature = Clock.getTemperature();\n\tsecond = secondNoDst;\n\tminute = minuteNoDst;\n\tday    = dayNoDst;\n\tmonth  = monthNoDst;\n\tyear   = yearNoDst;\n\tif (NowInDST())\n\t{\n\t\thour = hourNoDst + 1;\n\t\tif (hour >= 24)\n\t\t{\n\t\t\thour = 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\thour = hourNoDst;\n\t}\n\n\tif (mode == LED_TEST_MODE)\n\t{\n\t\treturn;\n\t}\n\tif (bWriteOnSerial)\n\t{\n\t\tShowDateTimeOnSerial();\n\t}\n}"}
{"content":{"code":"soap_in_ns3__ArrayOfMoneda(struct soap *soap, const char *tag, ns3__ArrayOfMoneda *a, const char *type)\n{\n\t(void)type; \/* appease -Wall -Werror *\/\n\tif (soap_element_begin_in(soap, tag, 0, NULL))\n\t\treturn NULL;\n\ta = (ns3__ArrayOfMoneda*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfMoneda, sizeof(ns3__ArrayOfMoneda), soap->type, soap->arrayType, afip_instantiate, afip_fbase);\n\tif (!a)\n\t\treturn NULL;\n\tif (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfMoneda)\n\t{\tsoap_revert(soap);\n\t\t*soap->id = '\\0';\n\t\treturn (ns3__ArrayOfMoneda *)a->soap_in(soap, tag, type);\n\t}\n\tif (soap->alloced)\n\t\ta->soap_default(soap);\n\tif (soap->body && *soap->href != '#')\n\t{\n\t\tfor (;;)\n\t\t{\tsoap->error = SOAP_TAG_MISMATCH;\n\t\t\tif (soap->error == SOAP_TAG_MISMATCH)\n\t\t\t{\tif (soap_in_std__vectorTemplateOfPointerTons3__Moneda(soap, \"ns3:Moneda\", &a->ns3__ArrayOfMoneda::Moneda, \"ns3:Moneda\"))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (soap->error == SOAP_TAG_MISMATCH)\n\t\t\t\tsoap->error = soap_ignore_element(soap);\n\t\t\tif (soap->error == SOAP_NO_TAG)\n\t\t\t\tbreak;\n\t\t\tif (soap->error)\n\t\t\t\treturn NULL;\n\t\t}\n\t\tif (soap_element_end_in(soap, tag))\n\t\t\treturn NULL;\n\t}\n\telse\n\t{\ta = (ns3__ArrayOfMoneda *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfMoneda, SOAP_TYPE_afip_ns3__ArrayOfMoneda, sizeof(ns3__ArrayOfMoneda), 0, afip_finsert, afip_fbase);\n\t\tif (soap->body && soap_element_end_in(soap, tag))\n\t\t\treturn NULL;\n\t}\n\treturn a;\n}","docstring":"\/* appease -Wall -Werror *\/","function_name":"soap_out_ns3__ArrayOfMoneda"},"id":87,"seed":"soap_in_ns3__ArrayOfMoneda(struct soap *soap, const char *tag, ns3__ArrayOfMoneda *a, const char *type)\n{\n\t(void)type; \/* appease -Wall -Werror *\/\n\tif (soap_element_begin_in(soap, tag, 0, NULL))\n\t\treturn NULL;\n\ta = (ns3__ArrayOfMoneda*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfMoneda, sizeof(ns3__ArrayOfMoneda), soap->type, soap->arrayType, afip_instantiate, afip_fbase);\n\tif (!a)\n\t\treturn NULL;\n\tif (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfMoneda)\n\t{\tsoap_revert(soap);\n\t\t*soap->id = '\\0';\n\t\treturn (ns3__ArrayOfMoneda *)a->soap_in(soap, tag, type);\n\t}\n\tif (soap->alloced)\n\t\ta->soap_default(soap);\n\tif (soap->body && *soap->href != '#')\n\t{\n\t\tfor (;;)\n\t\t{\tsoap->error = SOAP_TAG_MISMATCH;\n\t\t\tif (soap->error == SOAP_TAG_MISMATCH)\n\t\t\t{\tif (soap_in_std__vectorTemplateOfPointerTons3__Moneda(soap, \"ns3:Moneda\", &a->ns3__ArrayOfMoneda::Moneda, \"ns3:Moneda\"))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (soap->error == SOAP_TAG_MISMATCH)\n\t\t\t\tsoap->error = soap_ignore_element(soap);\n\t\t\tif (soap->error == SOAP_NO_TAG)\n\t\t\t\tbreak;\n\t\t\tif (soap->error)\n\t\t\t\treturn NULL;\n\t\t}\n\t\tif (soap_element_end_in(soap, tag))\n\t\t\treturn NULL;\n\t}\n\telse\n\t{\ta = (ns3__ArrayOfMoneda *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfMoneda, SOAP_TYPE_afip_ns3__ArrayOfMoneda, sizeof(ns3__ArrayOfMoneda), 0, afip_finsert, afip_fbase);\n\t\tif (soap->body && soap_element_end_in(soap, tag))\n\t\t\treturn NULL;\n\t}\n\treturn a;\n}"}
{"content":{"code":"SharedPtr<T> dynamic_pointer_cast(const SharedPtr<U> &sp){\n    \/\/SharedPtr<T> tmpPtr(sp);\n    \/\/couldn't use sp.objPtr because it is private\n    \/\/T* tempPtr = dynamic_cast<T*>(sp.get());\n\n    SharedPtr<T> tempPtr(sp);\n    tempPtr.set(dynamic_cast<T*>(sp.get()));\n    return tempPtr;\n}","docstring":"\/\/couldn't use sp.objPtr because it is private","function_name":"static_pointer_cast"},"id":89,"seed":"SharedPtr<T> dynamic_pointer_cast(const SharedPtr<U> &sp){\n    \/\/SharedPtr<T> tmpPtr(sp);\n    \/\/couldn't use sp.objPtr because it is private\n    \/\/T* tempPtr = dynamic_cast<T*>(sp.get());\n\n    SharedPtr<T> tempPtr(sp);\n    tempPtr.set(dynamic_cast<T*>(sp.get()));\n    return tempPtr;\n}"}
{"content":{"code":"int keyboard() {\n\n  int touche = 5555;\n  \/* Principe on balaye les colonne et on tcheck si une ligne est appuy\u00e9e\n     = 14 ; # = 15 ; A = 19 ; B = 18 ; C = 17 ;  D = 16 *\/\n  \/\/ colonne des 1 4 7 *\n  digitalWrite(13, LOW);\n  digitalWrite(12, HIGH);\n  digitalWrite(14, HIGH);\n  digitalWrite(16, HIGH);\n\n  if (!digitalRead(3)) touche = 14; \/\/ *\n  if (!digitalRead(10)) touche = 7;\n  if (!digitalRead(2)) touche = 4;\n  if (!digitalRead(0)) touche = 1;\n\n  \/\/ colonne des 2 5 8 0\n  digitalWrite(13, HIGH);\n  digitalWrite(12, LOW);\n  digitalWrite(14, HIGH);\n  digitalWrite(16, HIGH);\n\n  if (!digitalRead(3)) touche = 0;\n  if (!digitalRead(10)) touche = 8;\n  if (!digitalRead(2)) touche = 5;\n  if (!digitalRead(0)) touche = 2;\n\n  \/\/ colonne des 3 6 9 #\n  digitalWrite(13, HIGH);\n  digitalWrite(12, HIGH);\n  digitalWrite(14, LOW);\n  digitalWrite(16, HIGH);\n\n  if (!digitalRead(3)) touche = 15; \/\/ #HTTPClient\n  if (!digitalRead(10)) touche = 9;\n  if (!digitalRead(2)) touche = 6;\n  if (!digitalRead(0)) touche = 3;\n\n  \/\/ colonne des A B C D\n  digitalWrite(13, HIGH);\n  digitalWrite(12, HIGH);\n  digitalWrite(14, HIGH);\n  digitalWrite(16, LOW);\n\n  if (!digitalRead(3)) touche = 16; \/\/D\n  if (!digitalRead(10)) touche = 17; \/\/ C\n  if (!digitalRead(2)) touche = 18; \/\/ B\n  if (!digitalRead(0)) touche = 19; \/\/ A\n  return touche;\n\n}","docstring":"\/\/ Initialisation du WIFI","function_name":"setup"},"id":91,"seed":"int keyboard() {\n\n  int touche = 5555;\n  \/* Principe on balaye les colonne et on tcheck si une ligne est appuy\u00e9e\n     = 14 ; # = 15 ; A = 19 ; B = 18 ; C = 17 ;  D = 16 *\/\n  \/\/ colonne des 1 4 7 *\n  digitalWrite(13, LOW);\n  digitalWrite(12, HIGH);\n  digitalWrite(14, HIGH);\n  digitalWrite(16, HIGH);\n\n  if (!digitalRead(3)) touche = 14; \/\/ *\n  if (!digitalRead(10)) touche = 7;\n  if (!digitalRead(2)) touche = 4;\n  if (!digitalRead(0)) touche = 1;\n\n  \/\/ colonne des 2 5 8 0\n  digitalWrite(13, HIGH);\n  digitalWrite(12, LOW);\n  digitalWrite(14, HIGH);\n  digitalWrite(16, HIGH);\n\n  if (!digitalRead(3)) touche = 0;\n  if (!digitalRead(10)) touche = 8;\n  if (!digitalRead(2)) touche = 5;\n  if (!digitalRead(0)) touche = 2;\n\n  \/\/ colonne des 3 6 9 #\n  digitalWrite(13, HIGH);\n  digitalWrite(12, HIGH);\n  digitalWrite(14, LOW);\n  digitalWrite(16, HIGH);\n\n  if (!digitalRead(3)) touche = 15; \/\/ #HTTPClient\n  if (!digitalRead(10)) touche = 9;\n  if (!digitalRead(2)) touche = 6;\n  if (!digitalRead(0)) touche = 3;\n\n  \/\/ colonne des A B C D\n  digitalWrite(13, HIGH);\n  digitalWrite(12, HIGH);\n  digitalWrite(14, HIGH);\n  digitalWrite(16, LOW);\n\n  if (!digitalRead(3)) touche = 16; \/\/D\n  if (!digitalRead(10)) touche = 17; \/\/ C\n  if (!digitalRead(2)) touche = 18; \/\/ B\n  if (!digitalRead(0)) touche = 19; \/\/ A\n  return touche;\n\n}"}
{"content":{"code":"float MX_HAND_GetScalarGyro(void)\r\n{\r\n    float gyro[ 3 ];\r\n    float ans = 0;\r\n\r\n    \/*\r\n    while (!MX_HAND_HW_getData(acc, gyro)) {\r\n\r\n    }\r\n    *\/\r\n    memcpy(gyro, stashed_gyro, sizeof(gyro));\r\n\r\n    for (int i = 0; i < 3; i++) {\r\n        if (i != 0) {\r\n            ans += gyro[ i ] * gyro[ i ];\r\n        }\r\n    }\r\n\r\n    return sqrtf(ans);\r\n}","docstring":"\/*\r\n    bool isSwing = false;\r\n\r\n    if (isSwing && !p->bActive[ HAND_ID_Clash ]) {\r\n        p->bActive[ HAND_ID_Clash ]      = true;\r\n        p->u32TimeStamp[ HAND_ID_Clash ] = time;\r\n    }\r\n\r\n    if (!isSwing && p->bActive[ HAND_ID_Clash ]) {\r\n        p->bActive[ HAND_ID_Clash ] = false;\r\n    }\r\n    return p->bActive[ HAND_ID_Clash ];\r\n    *\/","function_name":"MX_HAND_isClash"},"id":92,"seed":"float MX_HAND_GetScalarGyro(void)\r\n{\r\n    float gyro[ 3 ];\r\n    float ans = 0;\r\n\r\n    \/*\r\n    while (!MX_HAND_HW_getData(acc, gyro)) {\r\n\r\n    }\r\n    *\/\r\n    memcpy(gyro, stashed_gyro, sizeof(gyro));\r\n\r\n    for (int i = 0; i < 3; i++) {\r\n        if (i != 0) {\r\n            ans += gyro[ i ] * gyro[ i ];\r\n        }\r\n    }\r\n\r\n    return sqrtf(ans);\r\n}"}
{"content":{"code":"std::string safe_number_to_string(const SafeNumber& a) {\n\tconst auto& val = compress_number(a);\n\tif (!safe_number_is_valid(val))\n\t\treturn NaN_str;\n\tif (safe_number_is_zero(val))\n\t\treturn \"0\";\n\tstd::stringstream ss;\n\tif (!val.sign) {\n\t\tss << \"-\";\n\t}\n\t\/\/ x = p.q\n\tauto e10 = uint64_pow(10, val.e);\n\tconst auto& e10_uint = simple_uint128_create(0, e10);\n\tconst auto& pq = simple_uint128_divmod(val.x, e10_uint);\n\tconst auto& p = pq.div_result;\n\tconst auto& q = pq.mod_result;\n\tss << simple_uint128_to_string(p, 10, 0);\n\n\tauto decimal_len = val.e;\n\tif (!simple_uint128_is_zero(q)) {\n\t\tauto decimal = simple_uint128_to_string(q, 10, decimal_len);\n\t\tss << \".\" << decimal;\n\t}\n\treturn ss.str();\n}","docstring":"\/\/ r.x = r.x* 10 + big_a\/big_b, big_a = (big_a % big_b) * 10, r.e += 1, Repeat this step until r.e >= 16 or big_a == 0 or rx > largest_x","function_name":"safe_number_div"},"id":97,"seed":"std::string safe_number_to_string(const SafeNumber& a) {\n\tconst auto& val = compress_number(a);\n\tif (!safe_number_is_valid(val))\n\t\treturn NaN_str;\n\tif (safe_number_is_zero(val))\n\t\treturn \"0\";\n\tstd::stringstream ss;\n\tif (!val.sign) {\n\t\tss << \"-\";\n\t}\n\t\/\/ x = p.q\n\tauto e10 = uint64_pow(10, val.e);\n\tconst auto& e10_uint = simple_uint128_create(0, e10);\n\tconst auto& pq = simple_uint128_divmod(val.x, e10_uint);\n\tconst auto& p = pq.div_result;\n\tconst auto& q = pq.mod_result;\n\tss << simple_uint128_to_string(p, 10, 0);\n\n\tauto decimal_len = val.e;\n\tif (!simple_uint128_is_zero(q)) {\n\t\tauto decimal = simple_uint128_to_string(q, 10, decimal_len);\n\t\tss << \".\" << decimal;\n\t}\n\treturn ss.str();\n}"}
{"content":{"code":"Vector2f eval_time_spline(double t)\n{\n\tassert(t >= 0. && t <= t_max);\n\t\n\t\/\/Do a binary search to find t coordinate for time value\n\tfloat lo = 0., hi = 1.;\n\tVector3f pt;\n\twhile(abs(lo - hi) > 1e-6)\n\t{\n\t\tfloat m = lo + (hi - lo) * .5;\n\t\tpt = eval_spline(m);\n\t\t\n\t\tif(pt.z() > t)\n\t\t\thi = m;\n\t\telse\n\t\t\tlo = m;\n\t}\n\t\n\t\/\/Return the value of the spline at this time\n\treturn Vector2f(pt.x(), pt.y());\n}","docstring":"\/\/Validate data (assert that path is monotonic)","function_name":"read_control_points"},"id":101,"seed":"Vector2f eval_time_spline(double t)\n{\n\tassert(t >= 0. && t <= t_max);\n\t\n\t\/\/Do a binary search to find t coordinate for time value\n\tfloat lo = 0., hi = 1.;\n\tVector3f pt;\n\twhile(abs(lo - hi) > 1e-6)\n\t{\n\t\tfloat m = lo + (hi - lo) * .5;\n\t\tpt = eval_spline(m);\n\t\t\n\t\tif(pt.z() > t)\n\t\t\thi = m;\n\t\telse\n\t\t\tlo = m;\n\t}\n\t\n\t\/\/Return the value of the spline at this time\n\treturn Vector2f(pt.x(), pt.y());\n}"}
{"content":{"code":"static inline bool create_directory(string &path)\n{\n    assert(path.length() > 0);\n    \/\/\u76f8\u5bf9\u8def\u5f84\n    if ('\/' != path[0])\n    {\n        char abs_path[MAX_PATH_LEN];\n        getcwd(abs_path, MAX_PATH_LEN);\n        string cur_dir(abs_path);\n        path = cur_dir + \"\/\" + path;\n    }\n    \/\/\u521b\u5efa\u6587\u4ef6\u5939\n    try\n    {\n        mkdir(path.c_str(), S_IRWXU);\n        LOG(DEBUG) << \"CREATE DIR=\" << path << \" SUCCEED\";\n        return true;\n    }\n    catch (exception &err_msg)\n    {\n        LOG(ERROR) << \"CREATE DIR=\" << path << \" FAILED\"\n                   << \"error msg:\" << err_msg.what();\n    }\n    return false;\n}","docstring":"\/\/LOG(DEBUG)<<\"HEX STRING OF BYTES_BUF:\"<<buf.str();","function_name":"trans_bytes_to_string"},"id":113,"seed":"static inline bool create_directory(string &path)\n{\n    assert(path.length() > 0);\n    \/\/\u76f8\u5bf9\u8def\u5f84\n    if ('\/' != path[0])\n    {\n        char abs_path[MAX_PATH_LEN];\n        getcwd(abs_path, MAX_PATH_LEN);\n        string cur_dir(abs_path);\n        path = cur_dir + \"\/\" + path;\n    }\n    \/\/\u521b\u5efa\u6587\u4ef6\u5939\n    try\n    {\n        mkdir(path.c_str(), S_IRWXU);\n        LOG(DEBUG) << \"CREATE DIR=\" << path << \" SUCCEED\";\n        return true;\n    }\n    catch (exception &err_msg)\n    {\n        LOG(ERROR) << \"CREATE DIR=\" << path << \" FAILED\"\n                   << \"error msg:\" << err_msg.what();\n    }\n    return false;\n}"}
{"content":{"code":"QString formatDurationStr(std::chrono::seconds dur)\n{\n    using days = std::chrono::duration<int, std::ratio<86400>>; \/\/ can remove this line after C++20\n    const auto d{std::chrono::duration_cast<days>(dur)};\n    const auto h{std::chrono::duration_cast<std::chrono::hours>(dur - d)};\n    const auto m{std::chrono::duration_cast<std::chrono::minutes>(dur - d - h)};\n    const auto s{std::chrono::duration_cast<std::chrono::seconds>(dur - d - h - m)};\n    QStringList str_list;\n    if (auto d2{d.count()}) str_list.append(QObject::tr(\"%1 d\").arg(d2));\n    if (auto h2{h.count()}) str_list.append(QObject::tr(\"%1 h\").arg(h2));\n    if (auto m2{m.count()}) str_list.append(QObject::tr(\"%1 m\").arg(m2));\n    const auto s2{s.count()};\n    if (s2 || str_list.empty()) str_list.append(QObject::tr(\"%1 s\").arg(s2));\n    return str_list.join(\" \");\n}","docstring":"\/\/ no default case, so the compiler can warn about missing cases","function_name":"ConnectionTypeToQString"},"id":114,"seed":"QString formatDurationStr(std::chrono::seconds dur)\n{\n    using days = std::chrono::duration<int, std::ratio<86400>>; \/\/ can remove this line after C++20\n    const auto d{std::chrono::duration_cast<days>(dur)};\n    const auto h{std::chrono::duration_cast<std::chrono::hours>(dur - d)};\n    const auto m{std::chrono::duration_cast<std::chrono::minutes>(dur - d - h)};\n    const auto s{std::chrono::duration_cast<std::chrono::seconds>(dur - d - h - m)};\n    QStringList str_list;\n    if (auto d2{d.count()}) str_list.append(QObject::tr(\"%1 d\").arg(d2));\n    if (auto h2{h.count()}) str_list.append(QObject::tr(\"%1 h\").arg(h2));\n    if (auto m2{m.count()}) str_list.append(QObject::tr(\"%1 m\").arg(m2));\n    const auto s2{s.count()};\n    if (s2 || str_list.empty()) str_list.append(QObject::tr(\"%1 s\").arg(s2));\n    return str_list.join(\" \");\n}"}
{"content":{"code":"static bool updateInstallationHelper(char * accessToken,\n\tstd::string id, UpdateInstallationObject body, std::string xEmbarcaderoApplicationId, std::string xEmbarcaderoAppSecret, std::string xEmbarcaderoMasterSecret, \n\tvoid(* handler)(UpdatedInstallationObject, Error, void* )\n\t, void* userData, bool isAsync)\n{\n\n\t\/\/TODO: maybe delete headerList after its used to free up space?\n\tstruct curl_slist *headerList = NULL;\n\n\t\n\t{\n\t\tstring headerString(\"X-Embarcadero-Application-Id: \");\n\t\theaderString.append(stringify(&xEmbarcaderoApplicationId, \"std::string\"));\n\t\theaderList = curl_slist_append(headerList, headerString.c_str());\n\t}\n\n\t{\n\t\tstring headerString(\"X-Embarcadero-App-Secret: \");\n\t\theaderString.append(stringify(&xEmbarcaderoAppSecret, \"std::string\"));\n\t\theaderList = curl_slist_append(headerList, headerString.c_str());\n\t}\n\n\t{\n\t\tstring headerString(\"X-Embarcadero-Master-Secret: \");\n\t\theaderString.append(stringify(&xEmbarcaderoMasterSecret, \"std::string\"));\n\t\theaderList = curl_slist_append(headerList, headerString.c_str());\n\t}\n\n\tstring accessHeader = \"Authorization: Bearer \";\n\taccessHeader.append(accessToken);\n\theaderList = curl_slist_append(headerList, accessHeader.c_str());\n\theaderList = curl_slist_append(headerList, \"Content-Type: application\/json\");\n\n\tmap <string, string> queryParams;\n\tstring itemAtq;\n\t\n\tstring mBody = \"\";\n\tJsonNode* node;\n\tJsonArray* json_array;\n\n\tif (isprimitive(\"UpdateInstallationObject\")) {\n\t\tnode = converttoJson(&body, \"UpdateInstallationObject\", \"\");\n\t}\n\t\n\tchar *jsonStr =  body.toJson();\n\tnode = json_from_string(jsonStr, NULL);\n\tg_free(static_cast<gpointer>(jsonStr));\n\t\n\n\tchar *jsonStr1 =  json_to_string(node, false);\n\tmBody.append(jsonStr1);\n\tg_free(static_cast<gpointer>(jsonStr1));\n\n\tstring url(\"\/installations\/{id}\");\n\tint pos;\n\n\tstring s_id(\"{\");\n\ts_id.append(\"id\");\n\ts_id.append(\"}\");\n\tpos = url.find(s_id);\n\turl.erase(pos, s_id.length());\n\turl.insert(pos, stringify(&id, \"std::string\"));\n\n\t\/\/TODO: free memory of errormsg, memorystruct\n\tMemoryStruct_s* p_chunk = new MemoryStruct_s();\n\tlong code;\n\tchar* errormsg = NULL;\n\tstring myhttpmethod(\"PUT\");\n\n\tif(strcmp(\"PUT\", \"PUT\") == 0){\n\t\tif(strcmp(\"\", mBody.c_str()) == 0){\n\t\t\tmBody.append(\"{}\");\n\t\t}\n\t}\n\n\tif(!isAsync){\n\t\tNetClient::easycurl(InstallationsManager::getBasePath(), url, myhttpmethod, queryParams,\n\t\t\tmBody, headerList, p_chunk, &code, errormsg);\n\t\tbool retval = updateInstallationProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));\n\n\t\tcurl_slist_free_all(headerList);\n\t\tif (p_chunk) {\n\t\t\tif(p_chunk->memory) {\n\t\t\t\tfree(p_chunk->memory);\n\t\t\t}\n\t\t\tdelete (p_chunk);\n\t\t}\n\t\tif (errormsg) {\n\t\t\tfree(errormsg);\n\t\t}\n\t\treturn retval;\n\t} else{\n\t\tGThread *thread = NULL;\n\t\tRequestInfo *requestInfo = NULL;\n\n\t\trequestInfo = new(nothrow) RequestInfo (InstallationsManager::getBasePath(), url, myhttpmethod, queryParams,\n\t\t\tmBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), updateInstallationProcessor);;\n\t\tif(requestInfo == NULL)\n\t\t\treturn false;\n\n\t\tthread = g_thread_new(NULL, __InstallationsManagerthreadFunc, static_cast<gpointer>(requestInfo));\n\t\treturn true;\n\t}\n}","docstring":"\/\/TODO: free memory of errormsg, memorystruct","function_name":"getInstallationsHelper"},"id":119,"seed":"static bool updateInstallationHelper(char * accessToken,\n\tstd::string id, UpdateInstallationObject body, std::string xEmbarcaderoApplicationId, std::string xEmbarcaderoAppSecret, std::string xEmbarcaderoMasterSecret, \n\tvoid(* handler)(UpdatedInstallationObject, Error, void* )\n\t, void* userData, bool isAsync)\n{\n\n\t\/\/TODO: maybe delete headerList after its used to free up space?\n\tstruct curl_slist *headerList = NULL;\n\n\t\n\t{\n\t\tstring headerString(\"X-Embarcadero-Application-Id: \");\n\t\theaderString.append(stringify(&xEmbarcaderoApplicationId, \"std::string\"));\n\t\theaderList = curl_slist_append(headerList, headerString.c_str());\n\t}\n\n\t{\n\t\tstring headerString(\"X-Embarcadero-App-Secret: \");\n\t\theaderString.append(stringify(&xEmbarcaderoAppSecret, \"std::string\"));\n\t\theaderList = curl_slist_append(headerList, headerString.c_str());\n\t}\n\n\t{\n\t\tstring headerString(\"X-Embarcadero-Master-Secret: \");\n\t\theaderString.append(stringify(&xEmbarcaderoMasterSecret, \"std::string\"));\n\t\theaderList = curl_slist_append(headerList, headerString.c_str());\n\t}\n\n\tstring accessHeader = \"Authorization: Bearer \";\n\taccessHeader.append(accessToken);\n\theaderList = curl_slist_append(headerList, accessHeader.c_str());\n\theaderList = curl_slist_append(headerList, \"Content-Type: application\/json\");\n\n\tmap <string, string> queryParams;\n\tstring itemAtq;\n\t\n\tstring mBody = \"\";\n\tJsonNode* node;\n\tJsonArray* json_array;\n\n\tif (isprimitive(\"UpdateInstallationObject\")) {\n\t\tnode = converttoJson(&body, \"UpdateInstallationObject\", \"\");\n\t}\n\t\n\tchar *jsonStr =  body.toJson();\n\tnode = json_from_string(jsonStr, NULL);\n\tg_free(static_cast<gpointer>(jsonStr));\n\t\n\n\tchar *jsonStr1 =  json_to_string(node, false);\n\tmBody.append(jsonStr1);\n\tg_free(static_cast<gpointer>(jsonStr1));\n\n\tstring url(\"\/installations\/{id}\");\n\tint pos;\n\n\tstring s_id(\"{\");\n\ts_id.append(\"id\");\n\ts_id.append(\"}\");\n\tpos = url.find(s_id);\n\turl.erase(pos, s_id.length());\n\turl.insert(pos, stringify(&id, \"std::string\"));\n\n\t\/\/TODO: free memory of errormsg, memorystruct\n\tMemoryStruct_s* p_chunk = new MemoryStruct_s();\n\tlong code;\n\tchar* errormsg = NULL;\n\tstring myhttpmethod(\"PUT\");\n\n\tif(strcmp(\"PUT\", \"PUT\") == 0){\n\t\tif(strcmp(\"\", mBody.c_str()) == 0){\n\t\t\tmBody.append(\"{}\");\n\t\t}\n\t}\n\n\tif(!isAsync){\n\t\tNetClient::easycurl(InstallationsManager::getBasePath(), url, myhttpmethod, queryParams,\n\t\t\tmBody, headerList, p_chunk, &code, errormsg);\n\t\tbool retval = updateInstallationProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));\n\n\t\tcurl_slist_free_all(headerList);\n\t\tif (p_chunk) {\n\t\t\tif(p_chunk->memory) {\n\t\t\t\tfree(p_chunk->memory);\n\t\t\t}\n\t\t\tdelete (p_chunk);\n\t\t}\n\t\tif (errormsg) {\n\t\t\tfree(errormsg);\n\t\t}\n\t\treturn retval;\n\t} else{\n\t\tGThread *thread = NULL;\n\t\tRequestInfo *requestInfo = NULL;\n\n\t\trequestInfo = new(nothrow) RequestInfo (InstallationsManager::getBasePath(), url, myhttpmethod, queryParams,\n\t\t\tmBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), updateInstallationProcessor);;\n\t\tif(requestInfo == NULL)\n\t\t\treturn false;\n\n\t\tthread = g_thread_new(NULL, __InstallationsManagerthreadFunc, static_cast<gpointer>(requestInfo));\n\t\treturn true;\n\t}\n}"}
{"content":{"code":"BNPosi<T> InPost(T* inOrder, T* postOrder, int size, BNPosi<T> parent) {\n\tif (size < 1)\treturn nullptr;\n\tBNPosi<T> x = new BinNode<T>(*(postOrder + size - 1), parent);\n\tif (size == 1)\treturn x;\n\n\t\/*\u5bf9\u4e24\u4e2a\u5e8f\u5217\u8fdb\u884c\u5207\u5206\uff1a\n\t\u5bfb\u627epostOrder[size-1]\u5728inOrder\u4e2d\u7684\u4f4d\u7f6einBound\n\tinOrder[0, inBound)\u4e3a\u5de6\u5b50\u5e8f\u5217\t\tinOrder[inBound+1, size)\u4e3a\u53f3\u5b50\u5e8f\u5217\n\tpostOrder[0, inBound)\u4e3a\u5de6\u5b50\u5e8f\u5217\t\tpostOrder[inBound, size-1)\u4e3a\u53f3\u5b50\u5e8f\u5217*\/\n\tint inBound = 0;\n\tfor (T* t = inOrder; *t != postOrder + size - 1; t++, inBound++);\n\n\tx->lchild = InPost(inOrder, postOrder, inBound, x);\t\t\/\/\u9012\u5f52\u91cd\u6784\u5de6\u5b50\u6811\n\tx->rchild = InPost(inOrder + inBound + 1, postOrder + inBound, size - inBound - 1, x);\t\t\/\/\u9012\u5f52\u91cd\u6784\u53f3\u5b50\u6811\n\treturn x;\n}","docstring":"\/\/\u9012\u5f52\u91cd\u6784\u53f3\u5b50\u6811","function_name":"PreIn"},"id":122,"seed":"BNPosi<T> InPost(T* inOrder, T* postOrder, int size, BNPosi<T> parent) {\n\tif (size < 1)\treturn nullptr;\n\tBNPosi<T> x = new BinNode<T>(*(postOrder + size - 1), parent);\n\tif (size == 1)\treturn x;\n\n\t\/*\u5bf9\u4e24\u4e2a\u5e8f\u5217\u8fdb\u884c\u5207\u5206\uff1a\n\t\u5bfb\u627epostOrder[size-1]\u5728inOrder\u4e2d\u7684\u4f4d\u7f6einBound\n\tinOrder[0, inBound)\u4e3a\u5de6\u5b50\u5e8f\u5217\t\tinOrder[inBound+1, size)\u4e3a\u53f3\u5b50\u5e8f\u5217\n\tpostOrder[0, inBound)\u4e3a\u5de6\u5b50\u5e8f\u5217\t\tpostOrder[inBound, size-1)\u4e3a\u53f3\u5b50\u5e8f\u5217*\/\n\tint inBound = 0;\n\tfor (T* t = inOrder; *t != postOrder + size - 1; t++, inBound++);\n\n\tx->lchild = InPost(inOrder, postOrder, inBound, x);\t\t\/\/\u9012\u5f52\u91cd\u6784\u5de6\u5b50\u6811\n\tx->rchild = InPost(inOrder + inBound + 1, postOrder + inBound, size - inBound - 1, x);\t\t\/\/\u9012\u5f52\u91cd\u6784\u53f3\u5b50\u6811\n\treturn x;\n}"}
{"content":{"code":"static int _cocos2d_PhysicsBody_setVelocity(lua_State *L)\n{\n    olua_startinvoke(L);\n\n    cocos2d::PhysicsBody *self = nullptr;\n    cocos2d::Vec2 arg1;       \/** velocity *\/\n\n    olua_to_cppobj(L, 1, (void **)&self, \"cc.PhysicsBody\");\n    olua_check_cocos2d_Vec2(L, 2, &arg1);\n\n    \/\/ void setVelocity(const cocos2d::Vec2 &velocity)\n    self->setVelocity(arg1);\n\n    olua_endinvoke(L);\n\n    return 0;\n}","docstring":"\/\/ void setTag(int tag)","function_name":"_cocos2d_PhysicsBody_setTag"},"id":128,"seed":"static int _cocos2d_PhysicsBody_setVelocity(lua_State *L)\n{\n    olua_startinvoke(L);\n\n    cocos2d::PhysicsBody *self = nullptr;\n    cocos2d::Vec2 arg1;       \/** velocity *\/\n\n    olua_to_cppobj(L, 1, (void **)&self, \"cc.PhysicsBody\");\n    olua_check_cocos2d_Vec2(L, 2, &arg1);\n\n    \/\/ void setVelocity(const cocos2d::Vec2 &velocity)\n    self->setVelocity(arg1);\n\n    olua_endinvoke(L);\n\n    return 0;\n}"}
{"content":{"code":"call777a()\n{\n        push(af);\n        push(bc);\n        push(de);\n        get16(bc,0x73df);\n        e=a;\n        get8(l,0x73e1); \/\/get16(hl,0x73e1);\n        h=00;\n        c=h;\n        a=b;\nl7789:  cp(e);\n        if(!fc) goto l77b1;\n        if(!getByte(a)) goto l77d9;\n        push(de);\n        ex_de_hl();\n        l=a;\n        h=00;\n        a=b;\nl7797:  or(a);\n        if(fz) goto l77a3;\n        rl(l);\n        rl(h);\n        rl(c);\n        a--;\n        goto l7797;\nl77a3:  a=l;\n        or(e);\n        e=a;\n        a=h;\n        or(d);\n        d=a;\n        ex_de_hl();\n        pop(de);\n        a=0x08;\n        a+=b;\n        b=a;\n        goto l7789;\nl77b1:  push(hl);\n        a=e;\nl77b3:  or(a);\n        rr(c);\n        rr(h);\n        rr(l);\n        b--;\n        a--; fz=(a==0)?1:0;\n        if(!fz) goto l77b3;\n        a=b;\n        put8(0x73e0,a);\n        a=l;\n        put8(0x73e1,a);\n        a=0x0f;\n        pop(hl);\n        and(h);\n        h=a;\n        a=e;\n        cp(07);\n        if(!fz) goto l77d4;\n        h=00;\n        l=l&0x7f; \/\/res     7,l\nl77d4:  pop(de);\n        pop(bc);\n        pop(af);\n        and(a);\n        return 0;\n\nl77d9:  pop(de);\n        pop(bc);\n        pop(af);\n        fc=1;\/\/scf\n        return 0;\n}","docstring":"\/\/goto l785a;","function_name":"call76d2"},"id":132,"seed":"call777a()\n{\n        push(af);\n        push(bc);\n        push(de);\n        get16(bc,0x73df);\n        e=a;\n        get8(l,0x73e1); \/\/get16(hl,0x73e1);\n        h=00;\n        c=h;\n        a=b;\nl7789:  cp(e);\n        if(!fc) goto l77b1;\n        if(!getByte(a)) goto l77d9;\n        push(de);\n        ex_de_hl();\n        l=a;\n        h=00;\n        a=b;\nl7797:  or(a);\n        if(fz) goto l77a3;\n        rl(l);\n        rl(h);\n        rl(c);\n        a--;\n        goto l7797;\nl77a3:  a=l;\n        or(e);\n        e=a;\n        a=h;\n        or(d);\n        d=a;\n        ex_de_hl();\n        pop(de);\n        a=0x08;\n        a+=b;\n        b=a;\n        goto l7789;\nl77b1:  push(hl);\n        a=e;\nl77b3:  or(a);\n        rr(c);\n        rr(h);\n        rr(l);\n        b--;\n        a--; fz=(a==0)?1:0;\n        if(!fz) goto l77b3;\n        a=b;\n        put8(0x73e0,a);\n        a=l;\n        put8(0x73e1,a);\n        a=0x0f;\n        pop(hl);\n        and(h);\n        h=a;\n        a=e;\n        cp(07);\n        if(!fz) goto l77d4;\n        h=00;\n        l=l&0x7f; \/\/res     7,l\nl77d4:  pop(de);\n        pop(bc);\n        pop(af);\n        and(a);\n        return 0;\n\nl77d9:  pop(de);\n        pop(bc);\n        pop(af);\n        fc=1;\/\/scf\n        return 0;\n}"}
{"content":{"code":"inline double torque_calc(double r,   \/\/wheel radius\n                          double L,   \/\/wheel load\n                          double wn,  \/\/wheel numeric\n                          double sr){ \/\/slip ratio\n  \n  return r*L*0.75*(1-exp(-0.3*wn*sr));\n}","docstring":"\/\/wheel numeric","function_name":"towed_force_calc"},"id":136,"seed":"inline double torque_calc(double r,   \/\/wheel radius\n                          double L,   \/\/wheel load\n                          double wn,  \/\/wheel numeric\n                          double sr){ \/\/slip ratio\n  \n  return r*L*0.75*(1-exp(-0.3*wn*sr));\n}"}
{"content":{"code":"int main() {\n    scanf(\"%d%d\", &N, &K);\n    queue<point> q;\/\/\u521b\u5efa\u961f\u4f0d\n    q.push(point(N, 0));\/\/\u519c\u592b\u521d\u59cb\u4f4d\u7f6e\u5165\u961f\n    int end_step = -1;\/\/\u521d\u59cb\u5316\u6700\u7ec8\u6b65\u6570\n    while(!q.empty()) {\n        point this_pos = q.front();\/\/\u8bfb\u53d6\u961f\u5934\n        q.pop();\/\/\u5f39\u51fa\u961f\u5934\n        int x=this_pos.pos, step=this_pos.step;\n        if(x == K) { \/\/\u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u7b49\u4e8e\u725b\u7684\u4f4d\u7f6e\n            end_step = step;\n            break;\n        }\n        if(x-1>=0 && x-1<=100000 && vis[x-1]==0) { \/\/\u5411\u540e\u4e00\u6b65\u7684\u70b9\u5728\u8303\u56f4\u5185\u4e14\u6ca1\u6709\u8d70\u8fc7\n            q.push(point(x-1, step+1));\n            vis[x-1] = 1;\n        }\n        if(x+1>=0 && x+1<=100000 && vis[x+1]==0) { \/\/\u5411\u524d\u4e00\u6b65\u7684\u70b9\u5728\u8303\u56f4\u5185\u4e14\u6ca1\u6709\u8d70\u8fc7\n            q.push(point(x+1, step+1));\n            vis[x+1] = 1;\n        }\n        if(x*2<=100000 && x*2>=0 && vis[x*2]==0) { \/\/2\u500d\u4f4d\u7f6e\u7684\u70b9\u5728\u8303\u56f4\u5185\u4e14\u6ca1\u6709\u8d70\u8fc7\n            q.push(point(x*2, step+1));\n            vis[x*2] = 1;\n        }\n    }\n    printf(\"%d\\n\", end_step);\n    return 0;\n}","docstring":"\/\/\u6784\u9020\u51fd\u6570....","function_name":"point"},"id":145,"seed":"int main() {\n    scanf(\"%d%d\", &N, &K);\n    queue<point> q;\/\/\u521b\u5efa\u961f\u4f0d\n    q.push(point(N, 0));\/\/\u519c\u592b\u521d\u59cb\u4f4d\u7f6e\u5165\u961f\n    int end_step = -1;\/\/\u521d\u59cb\u5316\u6700\u7ec8\u6b65\u6570\n    while(!q.empty()) {\n        point this_pos = q.front();\/\/\u8bfb\u53d6\u961f\u5934\n        q.pop();\/\/\u5f39\u51fa\u961f\u5934\n        int x=this_pos.pos, step=this_pos.step;\n        if(x == K) { \/\/\u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u7b49\u4e8e\u725b\u7684\u4f4d\u7f6e\n            end_step = step;\n            break;\n        }\n        if(x-1>=0 && x-1<=100000 && vis[x-1]==0) { \/\/\u5411\u540e\u4e00\u6b65\u7684\u70b9\u5728\u8303\u56f4\u5185\u4e14\u6ca1\u6709\u8d70\u8fc7\n            q.push(point(x-1, step+1));\n            vis[x-1] = 1;\n        }\n        if(x+1>=0 && x+1<=100000 && vis[x+1]==0) { \/\/\u5411\u524d\u4e00\u6b65\u7684\u70b9\u5728\u8303\u56f4\u5185\u4e14\u6ca1\u6709\u8d70\u8fc7\n            q.push(point(x+1, step+1));\n            vis[x+1] = 1;\n        }\n        if(x*2<=100000 && x*2>=0 && vis[x*2]==0) { \/\/2\u500d\u4f4d\u7f6e\u7684\u70b9\u5728\u8303\u56f4\u5185\u4e14\u6ca1\u6709\u8d70\u8fc7\n            q.push(point(x*2, step+1));\n            vis[x*2] = 1;\n        }\n    }\n    printf(\"%d\\n\", end_step);\n    return 0;\n}"}
{"content":{"code":"IL2CPP_METHOD_ATTR bool IVector_1_IndexOf_m672898A842984D0C417D15E67F519A98DF24BF4E (RuntimeObject* __this, RuntimeObject* ___value0, uint32_t* ___index1, const RuntimeMethod* method)\n{\n\tIVector_1_t89733F40378DF9CE0D71A3AE18DE1A01B9A86464* ____ivector_1_t89733F40378DF9CE0D71A3AE18DE1A01B9A86464 = NULL;\n\til2cpp_hresult_t hr = static_cast<Il2CppComObject *>(__this)->identity->QueryInterface(IVector_1_t89733F40378DF9CE0D71A3AE18DE1A01B9A86464::IID, reinterpret_cast<void**>(&____ivector_1_t89733F40378DF9CE0D71A3AE18DE1A01B9A86464));\n\til2cpp_codegen_com_raise_exception_if_failed(hr, false);\n\n\t\/\/ Marshaling of parameter U27___value0U27 to native representation\n\tIVector_1_t23729E0EC4680A8E87F007D46D312A7C15F7317B* ____value0_marshaled = NULL;\n\tif (___value0 != NULL)\n\t{\n\t\tif (il2cpp_codegen_is_import_or_windows_runtime(___value0))\n\t\t{\n\t\t\til2cpp_hresult_t hr = ((Il2CppComObject *)___value0)->identity->QueryInterface(IVector_1_t23729E0EC4680A8E87F007D46D312A7C15F7317B::IID, reinterpret_cast<void**>(&____value0_marshaled));\n\t\t\til2cpp_codegen_com_raise_exception_if_failed(hr, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t____value0_marshaled = il2cpp_codegen_com_get_or_create_ccw<IVector_1_t23729E0EC4680A8E87F007D46D312A7C15F7317B>(___value0);\n\t\t}\n\t}\n\telse\n\t{\n\t\t____value0_marshaled = NULL;\n\t}\n\n\t\/\/ Native function invocation\n\tbool returnValue = 0;\n\thr = ____ivector_1_t89733F40378DF9CE0D71A3AE18DE1A01B9A86464->IVector_1_IndexOf_m672898A842984D0C417D15E67F519A98DF24BF4E(____value0_marshaled, ___index1, &returnValue);\n\t____ivector_1_t89733F40378DF9CE0D71A3AE18DE1A01B9A86464->Release();\n\n\til2cpp_codegen_com_raise_exception_if_failed(hr, false);\n\n\t\/\/ Marshaling cleanup of parameter U27___value0U27 native representation\n\tif (____value0_marshaled != NULL)\n\t{\n\t\t(____value0_marshaled)->Release();\n\t\t____value0_marshaled = NULL;\n\t}\n\n\treturn returnValue;\n}","docstring":"\/\/ Native function invocation","function_name":"IVector_1_get_Size_m13AF259177E8200E07E482976E26D8E59C27BB64"},"id":146,"seed":"IL2CPP_METHOD_ATTR bool IVector_1_IndexOf_m672898A842984D0C417D15E67F519A98DF24BF4E (RuntimeObject* __this, RuntimeObject* ___value0, uint32_t* ___index1, const RuntimeMethod* method)\n{\n\tIVector_1_t89733F40378DF9CE0D71A3AE18DE1A01B9A86464* ____ivector_1_t89733F40378DF9CE0D71A3AE18DE1A01B9A86464 = NULL;\n\til2cpp_hresult_t hr = static_cast<Il2CppComObject *>(__this)->identity->QueryInterface(IVector_1_t89733F40378DF9CE0D71A3AE18DE1A01B9A86464::IID, reinterpret_cast<void**>(&____ivector_1_t89733F40378DF9CE0D71A3AE18DE1A01B9A86464));\n\til2cpp_codegen_com_raise_exception_if_failed(hr, false);\n\n\t\/\/ Marshaling of parameter U27___value0U27 to native representation\n\tIVector_1_t23729E0EC4680A8E87F007D46D312A7C15F7317B* ____value0_marshaled = NULL;\n\tif (___value0 != NULL)\n\t{\n\t\tif (il2cpp_codegen_is_import_or_windows_runtime(___value0))\n\t\t{\n\t\t\til2cpp_hresult_t hr = ((Il2CppComObject *)___value0)->identity->QueryInterface(IVector_1_t23729E0EC4680A8E87F007D46D312A7C15F7317B::IID, reinterpret_cast<void**>(&____value0_marshaled));\n\t\t\til2cpp_codegen_com_raise_exception_if_failed(hr, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t____value0_marshaled = il2cpp_codegen_com_get_or_create_ccw<IVector_1_t23729E0EC4680A8E87F007D46D312A7C15F7317B>(___value0);\n\t\t}\n\t}\n\telse\n\t{\n\t\t____value0_marshaled = NULL;\n\t}\n\n\t\/\/ Native function invocation\n\tbool returnValue = 0;\n\thr = ____ivector_1_t89733F40378DF9CE0D71A3AE18DE1A01B9A86464->IVector_1_IndexOf_m672898A842984D0C417D15E67F519A98DF24BF4E(____value0_marshaled, ___index1, &returnValue);\n\t____ivector_1_t89733F40378DF9CE0D71A3AE18DE1A01B9A86464->Release();\n\n\til2cpp_codegen_com_raise_exception_if_failed(hr, false);\n\n\t\/\/ Marshaling cleanup of parameter U27___value0U27 native representation\n\tif (____value0_marshaled != NULL)\n\t{\n\t\t(____value0_marshaled)->Release();\n\t\t____value0_marshaled = NULL;\n\t}\n\n\treturn returnValue;\n}"}
{"content":{"code":"int main()\r\n{\r\n\r\n    \/\/add code here\r\n    int ans;\r\n\r\n    Menu();\r\n\r\n    cin >> ans;\r\n\r\n    choiceMenu(ans);\r\n\r\n    tryAgain();\r\n    cout<<endl;\r\n\r\n    return 0; \/\/ Remove this\r\n}","docstring":"\/\/ Remove\r","function_name":"pauseScreen"},"id":148,"seed":"int main()\r\n{\r\n\r\n    \/\/add code here\r\n    int ans;\r\n\r\n    Menu();\r\n\r\n    cin >> ans;\r\n\r\n    choiceMenu(ans);\r\n\r\n    tryAgain();\r\n    cout<<endl;\r\n\r\n    return 0; \/\/ Remove this\r\n}"}
{"content":{"code":"static bool js_cc_scene_Camera_height_get(se::State& s)\n{\n    CC_UNUSED bool ok = true;\n    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;\n    uint32_t result;\n    \n    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    result = cc_scene_Camera_height_get(arg1);\n    \/\/ %typemap(out) SWIGTYPE\n    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() \/*ctx*\/);\n    SE_PRECONDITION2(ok, false, \"Camera_height_get, Error processing arguments\");\n    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());\n    \n    \n    \n    return true;\n}","docstring":"\/\/ %typemap(out) SWIGTYPE","function_name":"js_cc_scene_Camera_width_get"},"id":154,"seed":"static bool js_cc_scene_Camera_height_get(se::State& s)\n{\n    CC_UNUSED bool ok = true;\n    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;\n    uint32_t result;\n    \n    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    result = cc_scene_Camera_height_get(arg1);\n    \/\/ %typemap(out) SWIGTYPE\n    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() \/*ctx*\/);\n    SE_PRECONDITION2(ok, false, \"Camera_height_get, Error processing arguments\");\n    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());\n    \n    \n    \n    return true;\n}"}
{"content":{"code":"JDK_SCHEME_NATIVE(trace)\n  {\n    jdk_scheme_sexp_dec_ref( interp, list ); \/* throw away any input parameters *\/\n    jdk_scheme_sexp_inc_ref( interp, interp->empty_value );\n    return interp->empty_value;\n  }","docstring":"\/* throw away any input parameters *\/","function_name":"JDK_SCHEME_NATIVE"},"id":156,"seed":"JDK_SCHEME_NATIVE(trace)\n  {\n    jdk_scheme_sexp_dec_ref( interp, list ); \/* throw away any input parameters *\/\n    jdk_scheme_sexp_inc_ref( interp, interp->empty_value );\n    return interp->empty_value;\n  }"}
{"content":{"code":"static bool js_cc_scene_Light_attachToScene(se::State& s)\n{\n    \/\/ js_function\n    \n    CC_UNUSED bool ok = true;\n    const auto& args = s.args();\n    size_t argc = args.size();\n    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;\n    cc::scene::RenderScene *arg2 = (cc::scene::RenderScene *) NULL ;\n    \n    if(argc != 1) {\n        SE_REPORT_ERROR(\"wrong number of arguments: %d, was expecting %d\", (int)argc, 1);\n        return false;\n    }\n    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    \/\/ %typemap(in) SWIGTYPE*\n    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());\n    SE_PRECONDITION2(ok, false, \"Light_attachToScene,2,SWIGTYPE_p_cc__scene__RenderScene\"); \n    (arg1)->attachToScene(arg2);\n    \n    \n    return true;\n}","docstring":"\/\/ js_dtoroverride","function_name":"js_delete_cc_scene_Light"},"id":157,"seed":"static bool js_cc_scene_Light_attachToScene(se::State& s)\n{\n    \/\/ js_function\n    \n    CC_UNUSED bool ok = true;\n    const auto& args = s.args();\n    size_t argc = args.size();\n    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;\n    cc::scene::RenderScene *arg2 = (cc::scene::RenderScene *) NULL ;\n    \n    if(argc != 1) {\n        SE_REPORT_ERROR(\"wrong number of arguments: %d, was expecting %d\", (int)argc, 1);\n        return false;\n    }\n    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    \/\/ %typemap(in) SWIGTYPE*\n    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());\n    SE_PRECONDITION2(ok, false, \"Light_attachToScene,2,SWIGTYPE_p_cc__scene__RenderScene\"); \n    (arg1)->attachToScene(arg2);\n    \n    \n    return true;\n}"}
{"content":{"code":"int memorize(int begin)\n{\n\tif (begin == N.size())return 0;\/\/\uae30\uc800 \uc0ac\ub840\uc758 \ub05d\uc5d0 \ub3c4\ub2ec\ud588\uc744 \uacbd\uc6b0\n\tint& ret = cache[begin];\n\tif (ret != -1) return ret;\/\/\uc774\ubbf8 \uc800\uc7a5\ub418\uc5b4 \uc788\ub2e4\uba74 \uadf8 \uac12\uc744 \ub9ac\ud134\ud55c\ub2e4. \n\tret = INF;\n\tfor (int L = 3; L <= 5; ++L)\/\/3~5\uc790\ub9ac\ub85c \ub098\ub208\ub2e4.\n\t\tif (begin + L <= N.size())\n\t\t{\n\t\t\tret = min(ret, memorize(begin + L) + classify(begin, begin + L - 1));\/\/\ub098\ub208 \uac12\uc911\uc5d0\uc11c \uc81c\uc77c \uc791\uc740 \ucd5c\uc18c \ub09c\uc774\ub3c4\ub97c \ub9ac\ud134\ud55c\ub2e4. \n\t\t}\n\treturn ret;\n}","docstring":"\/\/ \uadf8\uc678\uc5d0\ub294 \ub09c\uc774\ub3c4 10","function_name":"classify"},"id":161,"seed":"int memorize(int begin)\n{\n\tif (begin == N.size())return 0;\/\/\uae30\uc800 \uc0ac\ub840\uc758 \ub05d\uc5d0 \ub3c4\ub2ec\ud588\uc744 \uacbd\uc6b0\n\tint& ret = cache[begin];\n\tif (ret != -1) return ret;\/\/\uc774\ubbf8 \uc800\uc7a5\ub418\uc5b4 \uc788\ub2e4\uba74 \uadf8 \uac12\uc744 \ub9ac\ud134\ud55c\ub2e4. \n\tret = INF;\n\tfor (int L = 3; L <= 5; ++L)\/\/3~5\uc790\ub9ac\ub85c \ub098\ub208\ub2e4.\n\t\tif (begin + L <= N.size())\n\t\t{\n\t\t\tret = min(ret, memorize(begin + L) + classify(begin, begin + L - 1));\/\/\ub098\ub208 \uac12\uc911\uc5d0\uc11c \uc81c\uc77c \uc791\uc740 \ucd5c\uc18c \ub09c\uc774\ub3c4\ub97c \ub9ac\ud134\ud55c\ub2e4. \n\t\t}\n\treturn ret;\n}"}
{"content":{"code":"static bool js_cc_scene_SpotLight_shadowEnabled_set(se::State& s)\n{\n    CC_UNUSED bool ok = true;\n    const auto& args = s.args();\n    size_t argc = args.size();\n    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;\n    bool arg2 ;\n    \n    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    \/\/ %typemap(in) bool\n    ok &= sevalue_to_native(args[0], &arg2);\n    SE_PRECONDITION2(ok, false, \"SpotLight_shadowEnabled_set,2,SWIGTYPE_bool\"); \n    cc_scene_SpotLight_shadowEnabled_set(arg1,arg2);\n    \n    \n    return true;\n}","docstring":"\/\/ %typemap(out) SWIGTYPE&","function_name":"js_cc_scene_SpotLight_frustum_get"},"id":165,"seed":"static bool js_cc_scene_SpotLight_shadowEnabled_set(se::State& s)\n{\n    CC_UNUSED bool ok = true;\n    const auto& args = s.args();\n    size_t argc = args.size();\n    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;\n    bool arg2 ;\n    \n    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    \/\/ %typemap(in) bool\n    ok &= sevalue_to_native(args[0], &arg2);\n    SE_PRECONDITION2(ok, false, \"SpotLight_shadowEnabled_set,2,SWIGTYPE_bool\"); \n    cc_scene_SpotLight_shadowEnabled_set(arg1,arg2);\n    \n    \n    return true;\n}"}
{"content":{"code":"static bool js_cc_scene_DirectionalLight_csmLayerLambda_set(se::State& s)\n{\n    CC_UNUSED bool ok = true;\n    const auto& args = s.args();\n    size_t argc = args.size();\n    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;\n    float arg2 ;\n    \n    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    \/\/ %typemap(in) int, short, long, signed char, float, double\n    ok &= sevalue_to_native(args[0], &arg2, nullptr);\n    SE_PRECONDITION2(ok, false, \"DirectionalLight_csmLayerLambda_set,2,SWIGTYPE_float\"); \n    cc_scene_DirectionalLight_csmLayerLambda_set(arg1,arg2);\n    \n    \n    return true;\n}","docstring":"\/\/ out 5","function_name":"js_cc_scene_DirectionalLight_csmNeedUpdate_get"},"id":167,"seed":"static bool js_cc_scene_DirectionalLight_csmLayerLambda_set(se::State& s)\n{\n    CC_UNUSED bool ok = true;\n    const auto& args = s.args();\n    size_t argc = args.size();\n    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;\n    float arg2 ;\n    \n    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    \/\/ %typemap(in) int, short, long, signed char, float, double\n    ok &= sevalue_to_native(args[0], &arg2, nullptr);\n    SE_PRECONDITION2(ok, false, \"DirectionalLight_csmLayerLambda_set,2,SWIGTYPE_float\"); \n    cc_scene_DirectionalLight_csmLayerLambda_set(arg1,arg2);\n    \n    \n    return true;\n}"}
{"content":{"code":"BOOL MY_KEY_DOWN_PRECEDENCE(int key,int cnt)\n{\n\t\/\/\u5148\u884c\u5165\u529b\u53ef\u80fd\u306b\u306a\u3063\u305f\u3089\u30ab\u30a6\u30f3\u30c8\u3092\u59cb\u3081\u308b\n\tif (IsPrecedence[key] == TRUE)\n\t{\n\t\tprecdence[key].CntMax = cnt;\n\t\tprecdence[key].cnt = CNT_CHECK(precdence[key].cnt, precdence[key].CntMax);\n\t\tif (precdence[key].cnt != 0)\n\t\t{\n\t\t\treturn TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tIsPrecedence[key] = FALSE;\/\/\u5148\u884c\u5165\u529b\u306e\u6642\u9593\u3092\u7d42\u3048\u308b\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn FALSE;\n}","docstring":"\/\/\u62bc\u3057\u59cb\u3081\u3066\u3044\u306a\u3044","function_name":"MY_KEY_DOWN_MOMENT"},"id":170,"seed":"BOOL MY_KEY_DOWN_PRECEDENCE(int key,int cnt)\n{\n\t\/\/\u5148\u884c\u5165\u529b\u53ef\u80fd\u306b\u306a\u3063\u305f\u3089\u30ab\u30a6\u30f3\u30c8\u3092\u59cb\u3081\u308b\n\tif (IsPrecedence[key] == TRUE)\n\t{\n\t\tprecdence[key].CntMax = cnt;\n\t\tprecdence[key].cnt = CNT_CHECK(precdence[key].cnt, precdence[key].CntMax);\n\t\tif (precdence[key].cnt != 0)\n\t\t{\n\t\t\treturn TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tIsPrecedence[key] = FALSE;\/\/\u5148\u884c\u5165\u529b\u306e\u6642\u9593\u3092\u7d42\u3048\u308b\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn FALSE;\n}"}
{"content":{"code":"int32_t List_1_System_Collections_IList_Add_m858760638_gshared (List_1_t3093144868 * __this, RuntimeObject * ___item0, const RuntimeMethod* method)\n{\n\tstatic bool s_Il2CppMethodInitialized;\n\tif (!s_Il2CppMethodInitialized)\n\t{\n\t\til2cpp_codegen_initialize_method (List_1_System_Collections_IList_Add_m858760638_MetadataUsageId);\n\t\ts_Il2CppMethodInitialized = true;\n\t}\n\tint32_t V_0 = 0;\n\tException_t2748878030 * __last_unhandled_exception = 0;\n\tNO_UNUSED_WARNING (__last_unhandled_exception);\n\tException_t2748878030 * __exception_local = 0;\n\tNO_UNUSED_WARNING (__exception_local);\n\tint32_t __leave_target = 0;\n\tNO_UNUSED_WARNING (__leave_target);\n\nIL_0000:\n\ttry\n\t{ \/\/ begin try (depth: 1)\n\t\t{\n\t\t\tRuntimeObject * L_0 = ___item0;\n\t\t\tNullCheck((List_1_t3093144868 *)__this);\n\t\t\t((  void (*) (List_1_t3093144868 *, UICharInfo_t3151594060 , const RuntimeMethod*))IL2CPP_RGCTX_METHOD_INFO(method->declaring_type->rgctx_data, 9)->methodPointer)((List_1_t3093144868 *)__this, (UICharInfo_t3151594060 )((*(UICharInfo_t3151594060 *)((UICharInfo_t3151594060 *)UnBox(L_0, IL2CPP_RGCTX_DATA(method->declaring_type->rgctx_data, 8))))), \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->declaring_type->rgctx_data, 9));\n\t\t\tint32_t L_1 = (int32_t)__this->get__size_2();\n\t\t\tV_0 = (int32_t)((int32_t)((int32_t)L_1-(int32_t)1));\n\t\t\tgoto IL_0036;\n\t\t}\n\nIL_001a:\n\t\t{\n\t\t\t; \/\/ IL_001a: leave IL_002b\n\t\t}\n\t} \/\/ end try (depth: 1)\n\tcatch(Il2CppExceptionWrapper& e)\n\t{\n\t\t__exception_local = (Exception_t2748878030 *)e.ex;\n\t\tif(il2cpp_codegen_class_is_assignable_from (NullReferenceException_t2898655055_il2cpp_TypeInfo_var, il2cpp_codegen_object_class(e.ex)))\n\t\t\tgoto CATCH_001f;\n\t\tif(il2cpp_codegen_class_is_assignable_from (InvalidCastException_t330901945_il2cpp_TypeInfo_var, il2cpp_codegen_object_class(e.ex)))\n\t\t\tgoto CATCH_0025;\n\t\tthrow e;\n\t}\n\nCATCH_001f:\n\t{ \/\/ begin catch(System.NullReferenceException)\n\t\tgoto IL_002b;\n\t} \/\/ end catch (depth: 1)\n\nCATCH_0025:\n\t{ \/\/ begin catch(System.InvalidCastException)\n\t\tgoto IL_002b;\n\t} \/\/ end catch (depth: 1)\n\nIL_002b:\n\t{\n\t\tArgumentException_t3261393077 * L_2 = (ArgumentException_t3261393077 *)il2cpp_codegen_object_new(ArgumentException_t3261393077_il2cpp_TypeInfo_var);\n\t\tArgumentException__ctor_m4106072998(L_2, (String_t*)_stringLiteral927986437, \/*hidden argument*\/NULL);\n\t\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_2);\n\t}\n\nIL_0036:\n\t{\n\t\tint32_t L_3 = V_0;\n\t\treturn L_3;\n\t}\n}","docstring":"\/\/ end finally (depth: 1)","function_name":"List_1_AddEnumerable_m250401200_gshared"},"id":172,"seed":"int32_t List_1_System_Collections_IList_Add_m858760638_gshared (List_1_t3093144868 * __this, RuntimeObject * ___item0, const RuntimeMethod* method)\n{\n\tstatic bool s_Il2CppMethodInitialized;\n\tif (!s_Il2CppMethodInitialized)\n\t{\n\t\til2cpp_codegen_initialize_method (List_1_System_Collections_IList_Add_m858760638_MetadataUsageId);\n\t\ts_Il2CppMethodInitialized = true;\n\t}\n\tint32_t V_0 = 0;\n\tException_t2748878030 * __last_unhandled_exception = 0;\n\tNO_UNUSED_WARNING (__last_unhandled_exception);\n\tException_t2748878030 * __exception_local = 0;\n\tNO_UNUSED_WARNING (__exception_local);\n\tint32_t __leave_target = 0;\n\tNO_UNUSED_WARNING (__leave_target);\n\nIL_0000:\n\ttry\n\t{ \/\/ begin try (depth: 1)\n\t\t{\n\t\t\tRuntimeObject * L_0 = ___item0;\n\t\t\tNullCheck((List_1_t3093144868 *)__this);\n\t\t\t((  void (*) (List_1_t3093144868 *, UICharInfo_t3151594060 , const RuntimeMethod*))IL2CPP_RGCTX_METHOD_INFO(method->declaring_type->rgctx_data, 9)->methodPointer)((List_1_t3093144868 *)__this, (UICharInfo_t3151594060 )((*(UICharInfo_t3151594060 *)((UICharInfo_t3151594060 *)UnBox(L_0, IL2CPP_RGCTX_DATA(method->declaring_type->rgctx_data, 8))))), \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->declaring_type->rgctx_data, 9));\n\t\t\tint32_t L_1 = (int32_t)__this->get__size_2();\n\t\t\tV_0 = (int32_t)((int32_t)((int32_t)L_1-(int32_t)1));\n\t\t\tgoto IL_0036;\n\t\t}\n\nIL_001a:\n\t\t{\n\t\t\t; \/\/ IL_001a: leave IL_002b\n\t\t}\n\t} \/\/ end try (depth: 1)\n\tcatch(Il2CppExceptionWrapper& e)\n\t{\n\t\t__exception_local = (Exception_t2748878030 *)e.ex;\n\t\tif(il2cpp_codegen_class_is_assignable_from (NullReferenceException_t2898655055_il2cpp_TypeInfo_var, il2cpp_codegen_object_class(e.ex)))\n\t\t\tgoto CATCH_001f;\n\t\tif(il2cpp_codegen_class_is_assignable_from (InvalidCastException_t330901945_il2cpp_TypeInfo_var, il2cpp_codegen_object_class(e.ex)))\n\t\t\tgoto CATCH_0025;\n\t\tthrow e;\n\t}\n\nCATCH_001f:\n\t{ \/\/ begin catch(System.NullReferenceException)\n\t\tgoto IL_002b;\n\t} \/\/ end catch (depth: 1)\n\nCATCH_0025:\n\t{ \/\/ begin catch(System.InvalidCastException)\n\t\tgoto IL_002b;\n\t} \/\/ end catch (depth: 1)\n\nIL_002b:\n\t{\n\t\tArgumentException_t3261393077 * L_2 = (ArgumentException_t3261393077 *)il2cpp_codegen_object_new(ArgumentException_t3261393077_il2cpp_TypeInfo_var);\n\t\tArgumentException__ctor_m4106072998(L_2, (String_t*)_stringLiteral927986437, \/*hidden argument*\/NULL);\n\t\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_2);\n\t}\n\nIL_0036:\n\t{\n\t\tint32_t L_3 = V_0;\n\t\treturn L_3;\n\t}\n}"}
{"content":{"code":"static bool js_cc_SceneGlobals_getSkyboxInfo(se::State& s)\n{\n    \/\/ js_function\n    \n    CC_UNUSED bool ok = true;\n    const auto& args = s.args();\n    size_t argc = args.size();\n    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;\n    cc::scene::SkyboxInfo *result = 0 ;\n    \n    if(argc != 0) {\n        SE_REPORT_ERROR(\"wrong number of arguments: %d, was expecting %d\", (int)argc, 0);\n        return false;\n    }\n    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    result = (cc::scene::SkyboxInfo *)((cc::SceneGlobals const *)arg1)->getSkyboxInfo();\n    \/\/ %typemap(out) SWIGTYPE*\n    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() \/*ctx*\/);\n    SE_PRECONDITION2(ok, false, \"SceneGlobals_getSkyboxInfo, Error processing arguments\");\n    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); \n    \n    \n    return true;\n}","docstring":"\/\/ %typemap(out) SWIGTYPE*","function_name":"js_cc_SceneGlobals_getShadowsInfo"},"id":178,"seed":"static bool js_cc_SceneGlobals_getSkyboxInfo(se::State& s)\n{\n    \/\/ js_function\n    \n    CC_UNUSED bool ok = true;\n    const auto& args = s.args();\n    size_t argc = args.size();\n    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;\n    cc::scene::SkyboxInfo *result = 0 ;\n    \n    if(argc != 0) {\n        SE_REPORT_ERROR(\"wrong number of arguments: %d, was expecting %d\", (int)argc, 0);\n        return false;\n    }\n    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    result = (cc::scene::SkyboxInfo *)((cc::SceneGlobals const *)arg1)->getSkyboxInfo();\n    \/\/ %typemap(out) SWIGTYPE*\n    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() \/*ctx*\/);\n    SE_PRECONDITION2(ok, false, \"SceneGlobals_getSkyboxInfo, Error processing arguments\");\n    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); \n    \n    \n    return true;\n}"}
{"content":{"code":"soap_instantiate__ns3__FECAESolicitarResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)\n{\n\tDBGLOG(TEST, SOAP_MESSAGE(fdebug, \"soap_instantiate__ns3__FECAESolicitarResponse(%p, %d, %s, %s)\\n\", (void*)soap, n, type?type:\"\", arrayType?arrayType:\"\"));\n\t(void)type; (void)arrayType; \/* appease -Wall -Werror *\/\n\t_ns3__FECAESolicitarResponse *p;\n\tsize_t k = sizeof(_ns3__FECAESolicitarResponse);\n\tstruct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FECAESolicitarResponse, n, afip_fdelete);\n\tif (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)\n\t\treturn NULL;\n\tif (n < 0)\n\t{\tp = SOAP_NEW(soap, _ns3__FECAESolicitarResponse);\n\t\tif (p)\n\t\t\tp->soap = soap;\n\t}\n\telse\n\t{\tp = SOAP_NEW_ARRAY(soap, _ns3__FECAESolicitarResponse, n);\n\t\tk *= n;\n\t\tif (p)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tp[i].soap = soap;\n\t}\n\tDBGLOG(TEST, SOAP_MESSAGE(fdebug, \"Instantiated _ns3__FECAESolicitarResponse location=%p n=%d\\n\", (void*)p, n));\n\tif (size)\n\t\t*size = k;\n\tif (!p)\n\t\tsoap->error = SOAP_EOM;\n\telse if (cp)\n\t\tcp->ptr = (void*)p;\n\treturn p;\n}","docstring":"\/* appease -Wall -Werror *\/","function_name":"soap_in__ns3__FECAESolicitarResponse"},"id":181,"seed":"soap_instantiate__ns3__FECAESolicitarResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)\n{\n\tDBGLOG(TEST, SOAP_MESSAGE(fdebug, \"soap_instantiate__ns3__FECAESolicitarResponse(%p, %d, %s, %s)\\n\", (void*)soap, n, type?type:\"\", arrayType?arrayType:\"\"));\n\t(void)type; (void)arrayType; \/* appease -Wall -Werror *\/\n\t_ns3__FECAESolicitarResponse *p;\n\tsize_t k = sizeof(_ns3__FECAESolicitarResponse);\n\tstruct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FECAESolicitarResponse, n, afip_fdelete);\n\tif (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)\n\t\treturn NULL;\n\tif (n < 0)\n\t{\tp = SOAP_NEW(soap, _ns3__FECAESolicitarResponse);\n\t\tif (p)\n\t\t\tp->soap = soap;\n\t}\n\telse\n\t{\tp = SOAP_NEW_ARRAY(soap, _ns3__FECAESolicitarResponse, n);\n\t\tk *= n;\n\t\tif (p)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tp[i].soap = soap;\n\t}\n\tDBGLOG(TEST, SOAP_MESSAGE(fdebug, \"Instantiated _ns3__FECAESolicitarResponse location=%p n=%d\\n\", (void*)p, n));\n\tif (size)\n\t\t*size = k;\n\tif (!p)\n\t\tsoap->error = SOAP_EOM;\n\telse if (cp)\n\t\tcp->ptr = (void*)p;\n\treturn p;\n}"}
{"content":{"code":"TYPED_TEST(RocprimBlockReduceInputArrayTests, Reduce)\n{\n    using T = typename TestFixture::type;\n    using binary_op_type = typename TestFixture::binary_op_type;\n    constexpr auto algorithm = TestFixture::algorithm;\n    constexpr size_t block_size = TestFixture::block_size;\n    constexpr size_t items_per_thread = TestFixture::items_per_thread;\n\n    \/\/ Given block size not supported\n    if(block_size > test_utils::get_max_block_size())\n    {\n        return;\n    }\n\n    const size_t items_per_block = block_size * items_per_thread;\n    const size_t size = items_per_block * 37;\n    const size_t grid_size = size \/ items_per_block;\n    \/\/ Generate data\n    std::vector<T> output = test_utils::get_random_data<T>(size, 2, 50);\n\n    \/\/ Output reduce results\n    std::vector<T> output_reductions(size \/ block_size, 0);\n\n    \/\/ Calculate expected results on host\n    std::vector<T> expected_reductions(output_reductions.size(), 0);\n    binary_op_type binary_op;\n    for(size_t i = 0; i < output.size() \/ items_per_block; i++)\n    {\n        T value = 0;\n        for(size_t j = 0; j < items_per_block; j++)\n        {\n            auto idx = i * items_per_block + j;\n            value = apply(binary_op, value, output[idx]);\n        }\n        expected_reductions[i] = value;\n    }\n\n    \/\/ Preparing device\n    T* device_output;\n    HIP_CHECK(hipMalloc(&device_output, output.size() * sizeof(T)));\n    T* device_output_reductions;\n    HIP_CHECK(hipMalloc(&device_output_reductions, output_reductions.size() * sizeof(T)));\n\n    HIP_CHECK(\n        hipMemcpy(\n            device_output, output.data(),\n            output.size() * sizeof(T),\n            hipMemcpyHostToDevice\n        )\n    );\n\n    HIP_CHECK(\n        hipMemcpy(\n            device_output_reductions, output_reductions.data(),\n            output_reductions.size() * sizeof(T),\n            hipMemcpyHostToDevice\n        )\n    );\n\n    \/\/ Running kernel\n    hipLaunchKernelGGL(\n        HIP_KERNEL_NAME(reduce_array_kernel<block_size, items_per_thread, algorithm, T, binary_op_type>),\n        dim3(grid_size), dim3(block_size), 0, 0,\n        device_output, device_output_reductions\n    );\n\n    \/\/ Reading results back\n    HIP_CHECK(\n        hipMemcpy(\n            output_reductions.data(), device_output_reductions,\n            output_reductions.size() * sizeof(T),\n            hipMemcpyDeviceToHost\n        )\n    );\n\n    \/\/ Verifying results\n    test_utils::assert_near(output_reductions, expected_reductions, 0.05);\n\n    HIP_CHECK(hipFree(device_output));\n    HIP_CHECK(hipFree(device_output_reductions));\n}","docstring":"\/\/ load","function_name":"reduce_array_kernel"},"id":186,"seed":"TYPED_TEST(RocprimBlockReduceInputArrayTests, Reduce)\n{\n    using T = typename TestFixture::type;\n    using binary_op_type = typename TestFixture::binary_op_type;\n    constexpr auto algorithm = TestFixture::algorithm;\n    constexpr size_t block_size = TestFixture::block_size;\n    constexpr size_t items_per_thread = TestFixture::items_per_thread;\n\n    \/\/ Given block size not supported\n    if(block_size > test_utils::get_max_block_size())\n    {\n        return;\n    }\n\n    const size_t items_per_block = block_size * items_per_thread;\n    const size_t size = items_per_block * 37;\n    const size_t grid_size = size \/ items_per_block;\n    \/\/ Generate data\n    std::vector<T> output = test_utils::get_random_data<T>(size, 2, 50);\n\n    \/\/ Output reduce results\n    std::vector<T> output_reductions(size \/ block_size, 0);\n\n    \/\/ Calculate expected results on host\n    std::vector<T> expected_reductions(output_reductions.size(), 0);\n    binary_op_type binary_op;\n    for(size_t i = 0; i < output.size() \/ items_per_block; i++)\n    {\n        T value = 0;\n        for(size_t j = 0; j < items_per_block; j++)\n        {\n            auto idx = i * items_per_block + j;\n            value = apply(binary_op, value, output[idx]);\n        }\n        expected_reductions[i] = value;\n    }\n\n    \/\/ Preparing device\n    T* device_output;\n    HIP_CHECK(hipMalloc(&device_output, output.size() * sizeof(T)));\n    T* device_output_reductions;\n    HIP_CHECK(hipMalloc(&device_output_reductions, output_reductions.size() * sizeof(T)));\n\n    HIP_CHECK(\n        hipMemcpy(\n            device_output, output.data(),\n            output.size() * sizeof(T),\n            hipMemcpyHostToDevice\n        )\n    );\n\n    HIP_CHECK(\n        hipMemcpy(\n            device_output_reductions, output_reductions.data(),\n            output_reductions.size() * sizeof(T),\n            hipMemcpyHostToDevice\n        )\n    );\n\n    \/\/ Running kernel\n    hipLaunchKernelGGL(\n        HIP_KERNEL_NAME(reduce_array_kernel<block_size, items_per_thread, algorithm, T, binary_op_type>),\n        dim3(grid_size), dim3(block_size), 0, 0,\n        device_output, device_output_reductions\n    );\n\n    \/\/ Reading results back\n    HIP_CHECK(\n        hipMemcpy(\n            output_reductions.data(), device_output_reductions,\n            output_reductions.size() * sizeof(T),\n            hipMemcpyDeviceToHost\n        )\n    );\n\n    \/\/ Verifying results\n    test_utils::assert_near(output_reductions, expected_reductions, 0.05);\n\n    HIP_CHECK(hipFree(device_output));\n    HIP_CHECK(hipFree(device_output_reductions));\n}"}
{"content":{"code":"int main_loop_file_kmeans(string filepath,int kcluster = 5)\n{\n    \/\/\u8bf7\u6c42\u722c\u53bbhtml\u7f51\u9875\n    getWebPageClass gwp;\n    string utf_8_content = gwp.get_web_page_by_read_XML_file(filepath);\n    \/\/string utf_8_content = gwp.get_web_page_by_read_XML_file(\"\/Users\/pc\/sohufile.html\");\n    string web_page_title = gwp.get_web_page_title();\n    \n    if(utf_8_content.size() <= 0)\n    {\n        cout<<\"get url content error\\n\";\n        return 0;\n    }\n    \n    \/\/\u7f51\u9875html\u9884\u5904\u7406\n    contentProcess cp;\n    cp.parse_content_avoid_over_delete(utf_8_content);\n    \n    cout<<\"content size after process : \"<<utf_8_content.size()<<endl;\n    \n    int ret = save_content2file(\"\/Users\/pc\/get_clear_page.html\", utf_8_content);\n    if(ret == 1)\n        cout<< \"save clear  file ok\"<<endl;\n    else\n        cout<< \"save clear  file error\"<<endl;\n    \n    \/\/vector<struct lableFeature> lable_feature = get_content_lable_feature(utf_8_content);\n    vector<struct lableFeature> lable_feature = get_content_lable_feature_1124(utf_8_content);\n    for(int i=0;i<lable_feature.size();i++)\n        print_lable_feature(lable_feature[i]);\n    \n    vector<Feature> feature_vector = get_feature_vector(lable_feature);\n    \n    int max_kc =kcluster;\n    try\n    {\n        kmeansCluster kmeans(feature_vector);\n        \/\/kmeans.kmeans_function();\n        kmeans.kmeans_with_select_k_function(max_kc);\n        int KC = kmeans.get_K();\n        for(int i=1;i<=KC;i++)\n            kmeans.print_kmeans_cluster(i);\n        \n        vector< vector<int> > lableId_cluster = kmeans.get_lableId_from_cluster();\n        vector<Feature> kCenter = kmeans.get_kCenter();\n        vector< vector<Feature> > cluster = kmeans.get_cluster();\n        \n        for(int i=1;i<=KC; i++)\n        {\n            print_content_by_kmeansCluster(lable_feature, lableId_cluster, kCenter,i);\n        }\n        \n        int page_text_cluster_k = kmeans.get_page_text_cluster_k();\n        \n        \/\/vector<int> page_text_id_vector =  get_page_text_cluster_id_after_produce(lable_feature, lableId_cluster, page_text_cluster_k);\n        string selectLableName;\n        vector<int> page_text_id_vector =  get_page_text_cluster_id_after_produce(lable_feature, lableId_cluster, page_text_cluster_k,selectLableName);\n        \n        if(page_text_id_vector.size() == 0)\n        {\n            cout<<\" \u8fd9\u4e2a\u7f51\u9875\u975e\u65b0\u95fb\u6587\u672c\"<<endl;\n        }\n        else\n        {\n            for(int i=0;i<page_text_id_vector.size();i++)\n            {\n                cout<<page_text_id_vector[i]<<\" \";\n            }\n            cout<<endl;\n            cout<<\"\\n\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\u6b63\u6587\u6807\u7b7e\u4fe1\u606f\u5f00\u59cb\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\\n\";\n            cout<<\"\u6807\u9898\uff1a\"<<web_page_title<<endl;\n            string page_text = print_page_content_by_id(lable_feature, page_text_id_vector,selectLableName);\n            cout<<\"\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\u6b63\u6587\u6807\u7b7e\u4fe1\u606f\u7ed3\u675f\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\\n\";\n            \n            cout<<\"\\n\\n\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\u7f51\u9875\u6b63\u6587\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\\n\";\n            cout<<\"              \u65b0\u95fb\u6807\u9898\uff1a \"<<web_page_title<<endl;\n            cout<<\"\\n\" << page_text<<endl;\n            cout<<\"\\n\\n\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\u7f51\u9875\u6b63\u6587\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\\n\\n\";\n            \n            string tmp(\"              \u65b0\u95fb\u6807\u9898\uff1a \");\n            page_text = tmp + web_page_title +\"\\n\\n\" + page_text;\n            ret = save_content2file(\"\/Users\/pc\/get_page_text.html\", page_text);\n            if(ret == 1)\n                cout<< \"save page text  file ok\"<<endl;\n            else\n                cout<< \"save page text  file error\"<<endl;\n        }\n    }\n    catch(int e)\n    {\n        if(e == 1)\n            cout<<\"K must big than 0  or  featureVector  is empty\"<<endl;\n        else if(e==2)\n        {\n            cout<<\"No need to cluter,because K is small than featureCluster number \"<<endl;\n            \n        }\n        else if(e == 3)\n            cout << \"this page only has less two lables,maybe it's not a new page\\n\"<<endl;\n    }\n    return 1;\n}","docstring":"\/\/vector<struct lableFeature> lable_feature = get_content_lable_feature(utf_8_content);","function_name":"main_loop_url_kmeans"},"id":189,"seed":"int main_loop_file_kmeans(string filepath,int kcluster = 5)\n{\n    \/\/\u8bf7\u6c42\u722c\u53bbhtml\u7f51\u9875\n    getWebPageClass gwp;\n    string utf_8_content = gwp.get_web_page_by_read_XML_file(filepath);\n    \/\/string utf_8_content = gwp.get_web_page_by_read_XML_file(\"\/Users\/pc\/sohufile.html\");\n    string web_page_title = gwp.get_web_page_title();\n    \n    if(utf_8_content.size() <= 0)\n    {\n        cout<<\"get url content error\\n\";\n        return 0;\n    }\n    \n    \/\/\u7f51\u9875html\u9884\u5904\u7406\n    contentProcess cp;\n    cp.parse_content_avoid_over_delete(utf_8_content);\n    \n    cout<<\"content size after process : \"<<utf_8_content.size()<<endl;\n    \n    int ret = save_content2file(\"\/Users\/pc\/get_clear_page.html\", utf_8_content);\n    if(ret == 1)\n        cout<< \"save clear  file ok\"<<endl;\n    else\n        cout<< \"save clear  file error\"<<endl;\n    \n    \/\/vector<struct lableFeature> lable_feature = get_content_lable_feature(utf_8_content);\n    vector<struct lableFeature> lable_feature = get_content_lable_feature_1124(utf_8_content);\n    for(int i=0;i<lable_feature.size();i++)\n        print_lable_feature(lable_feature[i]);\n    \n    vector<Feature> feature_vector = get_feature_vector(lable_feature);\n    \n    int max_kc =kcluster;\n    try\n    {\n        kmeansCluster kmeans(feature_vector);\n        \/\/kmeans.kmeans_function();\n        kmeans.kmeans_with_select_k_function(max_kc);\n        int KC = kmeans.get_K();\n        for(int i=1;i<=KC;i++)\n            kmeans.print_kmeans_cluster(i);\n        \n        vector< vector<int> > lableId_cluster = kmeans.get_lableId_from_cluster();\n        vector<Feature> kCenter = kmeans.get_kCenter();\n        vector< vector<Feature> > cluster = kmeans.get_cluster();\n        \n        for(int i=1;i<=KC; i++)\n        {\n            print_content_by_kmeansCluster(lable_feature, lableId_cluster, kCenter,i);\n        }\n        \n        int page_text_cluster_k = kmeans.get_page_text_cluster_k();\n        \n        \/\/vector<int> page_text_id_vector =  get_page_text_cluster_id_after_produce(lable_feature, lableId_cluster, page_text_cluster_k);\n        string selectLableName;\n        vector<int> page_text_id_vector =  get_page_text_cluster_id_after_produce(lable_feature, lableId_cluster, page_text_cluster_k,selectLableName);\n        \n        if(page_text_id_vector.size() == 0)\n        {\n            cout<<\" \u8fd9\u4e2a\u7f51\u9875\u975e\u65b0\u95fb\u6587\u672c\"<<endl;\n        }\n        else\n        {\n            for(int i=0;i<page_text_id_vector.size();i++)\n            {\n                cout<<page_text_id_vector[i]<<\" \";\n            }\n            cout<<endl;\n            cout<<\"\\n\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\u6b63\u6587\u6807\u7b7e\u4fe1\u606f\u5f00\u59cb\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\\n\";\n            cout<<\"\u6807\u9898\uff1a\"<<web_page_title<<endl;\n            string page_text = print_page_content_by_id(lable_feature, page_text_id_vector,selectLableName);\n            cout<<\"\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\u6b63\u6587\u6807\u7b7e\u4fe1\u606f\u7ed3\u675f\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\\n\";\n            \n            cout<<\"\\n\\n\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\u7f51\u9875\u6b63\u6587\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\\n\";\n            cout<<\"              \u65b0\u95fb\u6807\u9898\uff1a \"<<web_page_title<<endl;\n            cout<<\"\\n\" << page_text<<endl;\n            cout<<\"\\n\\n\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\u7f51\u9875\u6b63\u6587\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\uff0d\\n\\n\";\n            \n            string tmp(\"              \u65b0\u95fb\u6807\u9898\uff1a \");\n            page_text = tmp + web_page_title +\"\\n\\n\" + page_text;\n            ret = save_content2file(\"\/Users\/pc\/get_page_text.html\", page_text);\n            if(ret == 1)\n                cout<< \"save page text  file ok\"<<endl;\n            else\n                cout<< \"save page text  file error\"<<endl;\n        }\n    }\n    catch(int e)\n    {\n        if(e == 1)\n            cout<<\"K must big than 0  or  featureVector  is empty\"<<endl;\n        else if(e==2)\n        {\n            cout<<\"No need to cluter,because K is small than featureCluster number \"<<endl;\n            \n        }\n        else if(e == 3)\n            cout << \"this page only has less two lables,maybe it's not a new page\\n\"<<endl;\n    }\n    return 1;\n}"}
{"content":{"code":"sl_result_t stocklib_wait_all()\n{\n    MLOCK;\n    init_guard();\n\n    \/\/ Wait for all tasks to complete\n    for ( auto h : g_taskset )\n    {\n\t\/\/ Wait for entry into the finish state\n\tif (!h->ready())\n\t    h->wait();\n\n\t\/\/ Wait for state entry actions to complete\n\tauto l = h->obtain_lock();\n\tl.unlock();\n\tl.release();\n\n    }\n\n    return SL_OK;\n\n}","docstring":"\/\/ Is this a known task?","function_name":"stocklib_asynch_result"},"id":191,"seed":"sl_result_t stocklib_wait_all()\n{\n    MLOCK;\n    init_guard();\n\n    \/\/ Wait for all tasks to complete\n    for ( auto h : g_taskset )\n    {\n\t\/\/ Wait for entry into the finish state\n\tif (!h->ready())\n\t    h->wait();\n\n\t\/\/ Wait for state entry actions to complete\n\tauto l = h->obtain_lock();\n\tl.unlock();\n\tl.release();\n\n    }\n\n    return SL_OK;\n\n}"}
{"content":{"code":"static int\r\nTypedObject_gettype(lua_State* L)\r\n{\r\n\tDbgScriptHostContext* hostCtxt = GetLuaProvGlobals()->HostCtxt;\r\n\tCHECK_ABORT(hostCtxt);\r\n\t\r\n\t\/\/ Validate that the first param was 'self'. I.e. a Userdatum of the right\r\n\t\/\/ type. (Having the right metatable).\r\n\t\/\/\r\n\tDbgScriptTypedObject* typObj = (DbgScriptTypedObject*)\r\n\t\tluaL_checkudata(L, 1, TYPED_OBJECT_METATABLE);\r\n\r\n\tlua_pushstring(L, typObj->TypeName);\r\n\t\r\n\treturn 1;\r\n}","docstring":"\/\/\r","function_name":"TypedObject_getsize"},"id":198,"seed":"static int\r\nTypedObject_gettype(lua_State* L)\r\n{\r\n\tDbgScriptHostContext* hostCtxt = GetLuaProvGlobals()->HostCtxt;\r\n\tCHECK_ABORT(hostCtxt);\r\n\t\r\n\t\/\/ Validate that the first param was 'self'. I.e. a Userdatum of the right\r\n\t\/\/ type. (Having the right metatable).\r\n\t\/\/\r\n\tDbgScriptTypedObject* typObj = (DbgScriptTypedObject*)\r\n\t\tluaL_checkudata(L, 1, TYPED_OBJECT_METATABLE);\r\n\r\n\tlua_pushstring(L, typObj->TypeName);\r\n\t\r\n\treturn 1;\r\n}"}
{"content":{"code":"int prim(int u)     \/\/ prim \u6c42\u8fde\u901a\u5757 u \u4e2d\u7684\u6700\u5c0f\u751f\u6210\u6811\n{\n\tint res = 0;    \/\/ res \u8bb0\u5f55\u751f\u6210\u6811\u7684\u5927\u5c0f\n\tmemset(dist, 0x3f, sizeof dist); \/\/ \u5c06 dist \u5236\u4e3a\u6b63\u65e0\u7a77\n\tmemset(st, false, sizeof st);    \/\/ \u7531\u4e8e\u8981\u591a\u6b21\u4f7f\u7528 st\uff0c\u6240\u4ee5\u6bcf\u6b21\u8981\u5148\u5c06 st \u5236\u6210 false\n\tfor (int i = 0; i < dcc[u].size(); i++) \/\/ \u6269\u5c55 dcc[u].size() \u6b21\n\t{\n\t\tint t = -1;\n\t\tfor (int j = 0; j < dcc[u].size(); j++) \/\/ \u679a\u4e3e\u4e00\u4e0b\u5f53\u524d\u8fde\u901a\u5757 u \u4e2d\u6240\u6709\u70b9\n\t\t{\n\t\t\tint ver = dcc[u][j];                  \/\/ \u5c06\u8be5\u70b9\u53d6\u51fa\n\t\t\tif (!st[ver] && (t == -1 || dist[t] > dist[ver])) \/\/ \u5982\u679c\u8be5\u70b9\u4e0d\u5728\u751f\u6210\u6811\u4e2d\u4e14\u5230\u8be5\u70b9\u7684\u8ddd\u79bb\u5927\u4e8e\u5230\u70b9 t \u7684\u8ddd\u79bb\n\t\t\t\tt = ver;                          \/\/ \u90a3\u4e48\u8ba9\u5c06 t \u6539\u4e3a\u8be5\u70b9\n\t\t}\n\t\tif (i) res += dist[t];                    \/\/ res \u52a0\u4e0a\u5230\u5df2\u6709\u751f\u6210\u6811\u4e2d\u8ddd\u79bb\u6700\u8fd1\u7684\u70b9\u5230\u5df2\u6709\u751f\u6210\u6811\u7684\u8ddd\u79bb\n\t\tst[t] = true;                             \/\/ \u5c06\u8be5\u70b9 t \u52a0\u5165\u5df2\u6709\u751f\u6210\u6811\n\t\tfor (int j = 0; j < dcc[u].size(); j++) \/\/ \u66f4\u65b0\u5f53\u524d\u8fde\u901a\u5757\u4e2d\u6240\u6709\u70b9\n\t\t{\n\t\t\tint ver = dcc[u][j];                  \/\/ \u5c06\u8be5\u70b9\u53d6\u51fa\n\t\t\tdist[ver] = min(dist[ver], g[t][ver]);\/\/ \u66f4\u65b0\u8be5\u70b9\u8ddd\u79bb\n\t\t}\n\t}\n\treturn res;     \/\/ \u8fd4\u56de\u8be5\u751f\u6210\u6811\u7684\u5927\u5c0f\n}","docstring":"\/\/ \u90a3\u4e48\u641c\u7d22\u70b9 i","function_name":"dfs"},"id":202,"seed":"int prim(int u)     \/\/ prim \u6c42\u8fde\u901a\u5757 u \u4e2d\u7684\u6700\u5c0f\u751f\u6210\u6811\n{\n\tint res = 0;    \/\/ res \u8bb0\u5f55\u751f\u6210\u6811\u7684\u5927\u5c0f\n\tmemset(dist, 0x3f, sizeof dist); \/\/ \u5c06 dist \u5236\u4e3a\u6b63\u65e0\u7a77\n\tmemset(st, false, sizeof st);    \/\/ \u7531\u4e8e\u8981\u591a\u6b21\u4f7f\u7528 st\uff0c\u6240\u4ee5\u6bcf\u6b21\u8981\u5148\u5c06 st \u5236\u6210 false\n\tfor (int i = 0; i < dcc[u].size(); i++) \/\/ \u6269\u5c55 dcc[u].size() \u6b21\n\t{\n\t\tint t = -1;\n\t\tfor (int j = 0; j < dcc[u].size(); j++) \/\/ \u679a\u4e3e\u4e00\u4e0b\u5f53\u524d\u8fde\u901a\u5757 u \u4e2d\u6240\u6709\u70b9\n\t\t{\n\t\t\tint ver = dcc[u][j];                  \/\/ \u5c06\u8be5\u70b9\u53d6\u51fa\n\t\t\tif (!st[ver] && (t == -1 || dist[t] > dist[ver])) \/\/ \u5982\u679c\u8be5\u70b9\u4e0d\u5728\u751f\u6210\u6811\u4e2d\u4e14\u5230\u8be5\u70b9\u7684\u8ddd\u79bb\u5927\u4e8e\u5230\u70b9 t \u7684\u8ddd\u79bb\n\t\t\t\tt = ver;                          \/\/ \u90a3\u4e48\u8ba9\u5c06 t \u6539\u4e3a\u8be5\u70b9\n\t\t}\n\t\tif (i) res += dist[t];                    \/\/ res \u52a0\u4e0a\u5230\u5df2\u6709\u751f\u6210\u6811\u4e2d\u8ddd\u79bb\u6700\u8fd1\u7684\u70b9\u5230\u5df2\u6709\u751f\u6210\u6811\u7684\u8ddd\u79bb\n\t\tst[t] = true;                             \/\/ \u5c06\u8be5\u70b9 t \u52a0\u5165\u5df2\u6709\u751f\u6210\u6811\n\t\tfor (int j = 0; j < dcc[u].size(); j++) \/\/ \u66f4\u65b0\u5f53\u524d\u8fde\u901a\u5757\u4e2d\u6240\u6709\u70b9\n\t\t{\n\t\t\tint ver = dcc[u][j];                  \/\/ \u5c06\u8be5\u70b9\u53d6\u51fa\n\t\t\tdist[ver] = min(dist[ver], g[t][ver]);\/\/ \u66f4\u65b0\u8be5\u70b9\u8ddd\u79bb\n\t\t}\n\t}\n\treturn res;     \/\/ \u8fd4\u56de\u8be5\u751f\u6210\u6811\u7684\u5927\u5c0f\n}"}
{"content":{"code":"int GetNumOfConnectionATM()\n{\n\t\/\/std::lock_guard<std::mutex> gaurd(mu);\n\treturn NumOfConnectionsATM;\n}","docstring":"\/\/std::lock_guard<std::mutex> gaurd(mu);","function_name":"Inc_Dec_ClientCount"},"id":207,"seed":"int GetNumOfConnectionATM()\n{\n\t\/\/std::lock_guard<std::mutex> gaurd(mu);\n\treturn NumOfConnectionsATM;\n}"}
{"content":{"code":"void sub_188E1()\n{\n    if (_ds != 0xa000)\/\/??\n    {\n        if (memory(_ds, 0x6471) == 0x01)            \/\/jz short locret_188E0\n            goto locret_188F4;\n    } else {\n        if (memoryVideoGet(_ds, 0x6471) == 0x01)            \/\/jz short locret_188E0\n            goto locret_188F4;\n    }\n    _push(_dx);                                 \/\/push dx\n    _push(_ax);                                 \/\/push ax\n    _dx = 0x03ce;                               \/\/mov dx, 3CEh\n    _al = 0x08;                                 \/\/mov al, 8\n    _out(_dx, _al);                             \/\/out dx, al\n    _dx += 1;                                   \/\/inc dx\n    _ax = _pop();                               \/\/pop ax\n    _out(_dx, _al);                             \/\/out dx, al\n    _dx = _pop();                               \/\/pop dx\nlocret_188F4:                                   \/\/locret_188F4:\n    return;\n}","docstring":"\/\/pop dx","function_name":"sub_188CD"},"id":210,"seed":"void sub_188E1()\n{\n    if (_ds != 0xa000)\/\/??\n    {\n        if (memory(_ds, 0x6471) == 0x01)            \/\/jz short locret_188E0\n            goto locret_188F4;\n    } else {\n        if (memoryVideoGet(_ds, 0x6471) == 0x01)            \/\/jz short locret_188E0\n            goto locret_188F4;\n    }\n    _push(_dx);                                 \/\/push dx\n    _push(_ax);                                 \/\/push ax\n    _dx = 0x03ce;                               \/\/mov dx, 3CEh\n    _al = 0x08;                                 \/\/mov al, 8\n    _out(_dx, _al);                             \/\/out dx, al\n    _dx += 1;                                   \/\/inc dx\n    _ax = _pop();                               \/\/pop ax\n    _out(_dx, _al);                             \/\/out dx, al\n    _dx = _pop();                               \/\/pop dx\nlocret_188F4:                                   \/\/locret_188F4:\n    return;\n}"}
{"content":{"code":"NTSTATUS TestDeviceAdd(IN WDFDRIVER Driver, IN PWDFDEVICE_INIT DeviceInit)\r\n\/*++\r\n\r\nRoutine Description:\r\n\r\nCalled by the DriverEntry to create a control-device. This call is\r\nresponsible for freeing the memory for DeviceInit.\r\n\r\nArguments:\r\n\r\nDriverObject - a pointer to the object that represents this device\r\ndriver.\r\n\r\nDeviceInit - Pointer to a driver-allocated WDFDEVICE_INIT structure.\r\n\r\nReturn Value:\r\n\r\nSTATUS_SUCCESS if initialized; an error otherwise.\r\n\r\n--*\/\r\n{\r\n\tNTSTATUS status;\r\n\tWDF_OBJECT_ATTRIBUTES attributes;\r\n\tWDF_IO_QUEUE_CONFIG ioQueueConfig;\r\n\tWDFQUEUE queue;\r\n\tWDFDEVICE controlDevice;\r\n\tDECLARE_CONST_UNICODE_STRING(ntDeviceName, NTDEVICE_NAME_STRING);\r\n\tDECLARE_CONST_UNICODE_STRING(symbolicLinkName, SYMBOLIC_NAME_STRING);\r\n\r\n\tUNREFERENCED_PARAMETER(Driver);\r\n\r\n\tPAGED_CODE();\r\n\r\n\t\/\/\r\n\t\/\/ Set exclusive to TRUE so that no more than one app can talk to the\r\n\t\/\/ control device at any time.\r\n\t\/\/\r\n\tWdfDeviceInitSetExclusive(DeviceInit, TRUE);\r\n\r\n\tWdfDeviceInitSetIoType(DeviceInit, WdfDeviceIoBuffered);\r\n\r\n\r\n\tstatus = WdfDeviceInitAssignName(DeviceInit, &ntDeviceName);\r\n\r\n\tif (!NT_SUCCESS(status)) {\r\n\t\tgoto End;\r\n\t}\r\n\r\n\tWdfControlDeviceInitSetShutdownNotification(DeviceInit,\r\n\t\tTestShutdown,\r\n\t\tWdfDeviceShutdown);\r\n\r\n\tstatus = WdfDeviceCreate(&DeviceInit,\r\n\t\tWDF_NO_OBJECT_ATTRIBUTES,\r\n\t\t&controlDevice);\r\n\tif (!NT_SUCCESS(status)) {\r\n\t\tgoto End;\r\n\t}\r\n\r\n\t\/\/\r\n\t\/\/ Create a symbolic link for the control object so that usermode can open\r\n\t\/\/ the device.\r\n\t\/\/\r\n\r\n\r\n\tstatus = WdfDeviceCreateSymbolicLink(controlDevice,\r\n\t\t&symbolicLinkName);\r\n\r\n\tif (!NT_SUCCESS(status)) {\r\n\t\t\/\/\r\n\t\t\/\/ Control device will be deleted automatically by the framework.\r\n\t\t\/\/\r\n\t\tgoto End;\r\n\t}\r\n\r\n\t\/\/\r\n\t\/\/ Configure a default queue so that requests that are not\r\n\t\/\/ configure-fowarded using WdfDeviceConfigureRequestDispatching to goto\r\n\t\/\/ other queues get dispatched here.\r\n\t\/\/\r\n\tWDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(&ioQueueConfig,\r\n\t\tWdfIoQueueDispatchSequential);\r\n\r\n\tioQueueConfig.EvtIoDeviceControl = DrvEvtIoDeviceControl;\r\n\r\n\tWDF_OBJECT_ATTRIBUTES_INIT(&attributes);\r\n\t\/\/\r\n\t\/\/ Since we are using Zw function set execution level to passive so that\r\n\t\/\/ framework ensures that our Io callbacks called at only passive-level\r\n\t\/\/ even if the request came in at DISPATCH_LEVEL from another driver.\r\n\t\/\/\r\n\t\/\/attributes.ExecutionLevel = WdfExecutionLevelPassive;\r\n\r\n\t\/\/\r\n\t\/\/ By default, Static Driver Verifier (SDV) displays a warning if it \r\n\t\/\/ doesn't find the EvtIoStop callback on a power-managed queue. \r\n\t\/\/ The 'assume' below causes SDV to suppress this warning. If the driver \r\n\t\/\/ has not explicitly set PowerManaged to WdfFalse, the framework creates\r\n\t\/\/ power-managed queues when the device is not a filter driver.  Normally \r\n\t\/\/ the EvtIoStop is required for power-managed queues, but for this driver\r\n\t\/\/ it is not needed b\/c the driver doesn't hold on to the requests or \r\n\t\/\/ forward them to other drivers. This driver completes the requests \r\n\t\/\/ directly in the queue's handlers. If the EvtIoStop callback is not \r\n\t\/\/ implemented, the framework waits for all driver-owned requests to be\r\n\t\/\/ done before moving in the Dx\/sleep states or before removing the \r\n\t\/\/ device, which is the correct behavior for this type of driver.\r\n\t\/\/ If the requests were taking an indeterminate amount of time to complete,\r\n\t\/\/ or if the driver forwarded the requests to a lower driver\/another stack,\r\n\t\/\/ the queue should have an EvtIoStop\/EvtIoResume.\r\n\t\/\/\r\n\t__analysis_assume(ioQueueConfig.EvtIoStop != 0);\r\n\tstatus = WdfIoQueueCreate(controlDevice,\r\n\t\t&ioQueueConfig,\r\n\t\t&attributes,\r\n\t\t&queue \/\/ pointer to default queue\r\n\t);\r\n\t__analysis_assume(ioQueueConfig.EvtIoStop == 0);\r\n\tif (!NT_SUCCESS(status)) {\r\n\t\tgoto End;\r\n\t}\r\n\r\n\t\/\/\r\n\t\/\/ Control devices must notify WDF when they are done initializing.   I\/O is\r\n\t\/\/ rejected until this call is made.\r\n\t\/\/\r\n\tWdfControlFinishInitializing(controlDevice);\r\n\r\nEnd:\r\n\t\/\/\r\n\t\/\/ If the device is created successfully, framework would clear the\r\n\t\/\/ DeviceInit value. Otherwise device create must have failed so we\r\n\t\/\/ should free the memory ourself.\r\n\t\/\/\r\n\tif (DeviceInit != nullptr) {\r\n\t\tWdfDeviceInitFree(DeviceInit);\r\n\t}\r\n\r\n\treturn status;\r\n\r\n}","docstring":"\/\/\r","function_name":"DriverEntry"},"id":214,"seed":"NTSTATUS TestDeviceAdd(IN WDFDRIVER Driver, IN PWDFDEVICE_INIT DeviceInit)\r\n\/*++\r\n\r\nRoutine Description:\r\n\r\nCalled by the DriverEntry to create a control-device. This call is\r\nresponsible for freeing the memory for DeviceInit.\r\n\r\nArguments:\r\n\r\nDriverObject - a pointer to the object that represents this device\r\ndriver.\r\n\r\nDeviceInit - Pointer to a driver-allocated WDFDEVICE_INIT structure.\r\n\r\nReturn Value:\r\n\r\nSTATUS_SUCCESS if initialized; an error otherwise.\r\n\r\n--*\/\r\n{\r\n\tNTSTATUS status;\r\n\tWDF_OBJECT_ATTRIBUTES attributes;\r\n\tWDF_IO_QUEUE_CONFIG ioQueueConfig;\r\n\tWDFQUEUE queue;\r\n\tWDFDEVICE controlDevice;\r\n\tDECLARE_CONST_UNICODE_STRING(ntDeviceName, NTDEVICE_NAME_STRING);\r\n\tDECLARE_CONST_UNICODE_STRING(symbolicLinkName, SYMBOLIC_NAME_STRING);\r\n\r\n\tUNREFERENCED_PARAMETER(Driver);\r\n\r\n\tPAGED_CODE();\r\n\r\n\t\/\/\r\n\t\/\/ Set exclusive to TRUE so that no more than one app can talk to the\r\n\t\/\/ control device at any time.\r\n\t\/\/\r\n\tWdfDeviceInitSetExclusive(DeviceInit, TRUE);\r\n\r\n\tWdfDeviceInitSetIoType(DeviceInit, WdfDeviceIoBuffered);\r\n\r\n\r\n\tstatus = WdfDeviceInitAssignName(DeviceInit, &ntDeviceName);\r\n\r\n\tif (!NT_SUCCESS(status)) {\r\n\t\tgoto End;\r\n\t}\r\n\r\n\tWdfControlDeviceInitSetShutdownNotification(DeviceInit,\r\n\t\tTestShutdown,\r\n\t\tWdfDeviceShutdown);\r\n\r\n\tstatus = WdfDeviceCreate(&DeviceInit,\r\n\t\tWDF_NO_OBJECT_ATTRIBUTES,\r\n\t\t&controlDevice);\r\n\tif (!NT_SUCCESS(status)) {\r\n\t\tgoto End;\r\n\t}\r\n\r\n\t\/\/\r\n\t\/\/ Create a symbolic link for the control object so that usermode can open\r\n\t\/\/ the device.\r\n\t\/\/\r\n\r\n\r\n\tstatus = WdfDeviceCreateSymbolicLink(controlDevice,\r\n\t\t&symbolicLinkName);\r\n\r\n\tif (!NT_SUCCESS(status)) {\r\n\t\t\/\/\r\n\t\t\/\/ Control device will be deleted automatically by the framework.\r\n\t\t\/\/\r\n\t\tgoto End;\r\n\t}\r\n\r\n\t\/\/\r\n\t\/\/ Configure a default queue so that requests that are not\r\n\t\/\/ configure-fowarded using WdfDeviceConfigureRequestDispatching to goto\r\n\t\/\/ other queues get dispatched here.\r\n\t\/\/\r\n\tWDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(&ioQueueConfig,\r\n\t\tWdfIoQueueDispatchSequential);\r\n\r\n\tioQueueConfig.EvtIoDeviceControl = DrvEvtIoDeviceControl;\r\n\r\n\tWDF_OBJECT_ATTRIBUTES_INIT(&attributes);\r\n\t\/\/\r\n\t\/\/ Since we are using Zw function set execution level to passive so that\r\n\t\/\/ framework ensures that our Io callbacks called at only passive-level\r\n\t\/\/ even if the request came in at DISPATCH_LEVEL from another driver.\r\n\t\/\/\r\n\t\/\/attributes.ExecutionLevel = WdfExecutionLevelPassive;\r\n\r\n\t\/\/\r\n\t\/\/ By default, Static Driver Verifier (SDV) displays a warning if it \r\n\t\/\/ doesn't find the EvtIoStop callback on a power-managed queue. \r\n\t\/\/ The 'assume' below causes SDV to suppress this warning. If the driver \r\n\t\/\/ has not explicitly set PowerManaged to WdfFalse, the framework creates\r\n\t\/\/ power-managed queues when the device is not a filter driver.  Normally \r\n\t\/\/ the EvtIoStop is required for power-managed queues, but for this driver\r\n\t\/\/ it is not needed b\/c the driver doesn't hold on to the requests or \r\n\t\/\/ forward them to other drivers. This driver completes the requests \r\n\t\/\/ directly in the queue's handlers. If the EvtIoStop callback is not \r\n\t\/\/ implemented, the framework waits for all driver-owned requests to be\r\n\t\/\/ done before moving in the Dx\/sleep states or before removing the \r\n\t\/\/ device, which is the correct behavior for this type of driver.\r\n\t\/\/ If the requests were taking an indeterminate amount of time to complete,\r\n\t\/\/ or if the driver forwarded the requests to a lower driver\/another stack,\r\n\t\/\/ the queue should have an EvtIoStop\/EvtIoResume.\r\n\t\/\/\r\n\t__analysis_assume(ioQueueConfig.EvtIoStop != 0);\r\n\tstatus = WdfIoQueueCreate(controlDevice,\r\n\t\t&ioQueueConfig,\r\n\t\t&attributes,\r\n\t\t&queue \/\/ pointer to default queue\r\n\t);\r\n\t__analysis_assume(ioQueueConfig.EvtIoStop == 0);\r\n\tif (!NT_SUCCESS(status)) {\r\n\t\tgoto End;\r\n\t}\r\n\r\n\t\/\/\r\n\t\/\/ Control devices must notify WDF when they are done initializing.   I\/O is\r\n\t\/\/ rejected until this call is made.\r\n\t\/\/\r\n\tWdfControlFinishInitializing(controlDevice);\r\n\r\nEnd:\r\n\t\/\/\r\n\t\/\/ If the device is created successfully, framework would clear the\r\n\t\/\/ DeviceInit value. Otherwise device create must have failed so we\r\n\t\/\/ should free the memory ourself.\r\n\t\/\/\r\n\tif (DeviceInit != nullptr) {\r\n\t\tWdfDeviceInitFree(DeviceInit);\r\n\t}\r\n\r\n\treturn status;\r\n\r\n}"}
{"content":{"code":"absl::optional<media_router::MediaRoute> GetSessionRoute(\n    const std::string& item_id,\n    base::WeakPtr<media_message_center::MediaNotificationItem> item,\n    content::BrowserContext* context) {\n  if (!media_router::MediaRouterEnabled(context)) {\n    return absl::nullopt;\n  }\n\n  \/\/ Return absl::nullopt if the item is not a local media session.\n  if (!item || item->SourceType() !=\n                   media_message_center::SourceType::kLocalMediaSession) {\n    return absl::nullopt;\n  }\n\n  \/\/ Return absl::nullopt if fallback to tab mirroring is disabled, and\n  \/\/ media session doesn't have an associated Remote Playback route.\n  if (!base::FeatureList::IsEnabled(\n          media_router::kFallbackToAudioTabMirroring) &&\n      !HasRemotePlaybackRoute(item)) {\n    return absl::nullopt;\n  }\n\n  auto* web_contents =\n      content::MediaSession::GetWebContentsFromRequestId(item_id);\n  if (!web_contents) {\n    return absl::nullopt;\n  }\n\n  const int item_tab_id =\n      sessions::SessionTabHelper::IdForTab(web_contents).id();\n  for (const auto& route :\n       media_router::MediaRouterFactory::GetApiForBrowserContext(context)\n           ->GetCurrentRoutes()) {\n    media_router::MediaSource media_source = route.media_source();\n    absl::optional<int> tab_id_from_route_id;\n    if (media_source.IsRemotePlaybackSource()) {\n      tab_id_from_route_id = media_source.TabIdFromRemotePlaybackSource();\n    } else if (media_source.IsTabMirroringSource()) {\n      tab_id_from_route_id = media_source.TabId();\n    }\n\n    if (tab_id_from_route_id.has_value() &&\n        tab_id_from_route_id.value() == item_tab_id) {\n      return route;\n    }\n  }\n\n  return absl::nullopt;\n}","docstring":"\/\/ Playback or Tab Mirroring.","function_name":"ShouldShowDeviceSelectorView"},"id":215,"seed":"absl::optional<media_router::MediaRoute> GetSessionRoute(\n    const std::string& item_id,\n    base::WeakPtr<media_message_center::MediaNotificationItem> item,\n    content::BrowserContext* context) {\n  if (!media_router::MediaRouterEnabled(context)) {\n    return absl::nullopt;\n  }\n\n  \/\/ Return absl::nullopt if the item is not a local media session.\n  if (!item || item->SourceType() !=\n                   media_message_center::SourceType::kLocalMediaSession) {\n    return absl::nullopt;\n  }\n\n  \/\/ Return absl::nullopt if fallback to tab mirroring is disabled, and\n  \/\/ media session doesn't have an associated Remote Playback route.\n  if (!base::FeatureList::IsEnabled(\n          media_router::kFallbackToAudioTabMirroring) &&\n      !HasRemotePlaybackRoute(item)) {\n    return absl::nullopt;\n  }\n\n  auto* web_contents =\n      content::MediaSession::GetWebContentsFromRequestId(item_id);\n  if (!web_contents) {\n    return absl::nullopt;\n  }\n\n  const int item_tab_id =\n      sessions::SessionTabHelper::IdForTab(web_contents).id();\n  for (const auto& route :\n       media_router::MediaRouterFactory::GetApiForBrowserContext(context)\n           ->GetCurrentRoutes()) {\n    media_router::MediaSource media_source = route.media_source();\n    absl::optional<int> tab_id_from_route_id;\n    if (media_source.IsRemotePlaybackSource()) {\n      tab_id_from_route_id = media_source.TabIdFromRemotePlaybackSource();\n    } else if (media_source.IsTabMirroringSource()) {\n      tab_id_from_route_id = media_source.TabId();\n    }\n\n    if (tab_id_from_route_id.has_value() &&\n        tab_id_from_route_id.value() == item_tab_id) {\n      return route;\n    }\n  }\n\n  return absl::nullopt;\n}"}
{"content":{"code":"PRESTypePluginParticipantData \n    setRight_replyPlugin_on_participant_attached(\n        void *registration_data,\n        const struct PRESTypePluginParticipantInfo *participant_info,\n        RTIBool top_level_registration,\n        void *container_plugin_context,\n        RTICdrTypeCode *type_code)\n    {\n        struct RTIXCdrInterpreterPrograms *programs = NULL;\n        struct PRESTypePluginDefaultParticipantData *pd = NULL;\n        struct RTIXCdrInterpreterProgramsGenProperty programProperty =\n        RTIXCdrInterpreterProgramsGenProperty_INITIALIZER;\n        if (registration_data) {} \/* To avoid warnings *\/\n        if (participant_info) {} \/* To avoid warnings *\/\n        if (top_level_registration) {} \/* To avoid warnings *\/\n        if (container_plugin_context) {} \/* To avoid warnings *\/\n        if (type_code) {} \/* To avoid warnings *\/\n        pd = (struct PRESTypePluginDefaultParticipantData *)\n        PRESTypePluginDefaultParticipantData_new(participant_info);\n\n        programProperty.generateV1Encapsulation = RTI_XCDR_TRUE;\n        programProperty.generateV2Encapsulation = RTI_XCDR_TRUE;\n        programProperty.resolveAlias = RTI_XCDR_TRUE;\n        programProperty.inlineStruct = RTI_XCDR_TRUE;\n        programProperty.optimizeEnum = RTI_XCDR_TRUE;\n\n        programProperty.externalReferenceSize = \n        (RTIXCdrUnsignedShort) sizeof(::dds::core::external<char>);\n        programProperty.getExternalRefPointerFcn = \n        ::rti::topic::interpreter::get_external_value_pointer;\n\n        programs = DDS_TypeCodeFactory_assert_programs_in_global_list(\n            DDS_TypeCodeFactory_get_instance(),\n            (DDS_TypeCode *) (RTIXCdrTypeCode *)&::rti::topic::dynamic_type< setRight_reply >::get().native()\n            ,\n            &programProperty,\n            RTI_XCDR_PROGRAM_MASK_TYPEPLUGIN);\n\n        if (programs == NULL) {\n            PRESTypePluginDefaultParticipantData_delete(\n                (PRESTypePluginParticipantData)pd);\n            return NULL;\n        }\n\n        pd->programs = programs;\n        return (PRESTypePluginParticipantData)pd;\n    }","docstring":"\/* To avoid warnings *\/","function_name":"setRight_reqPlugin_on_participant_attached"},"id":219,"seed":"PRESTypePluginParticipantData \n    setRight_replyPlugin_on_participant_attached(\n        void *registration_data,\n        const struct PRESTypePluginParticipantInfo *participant_info,\n        RTIBool top_level_registration,\n        void *container_plugin_context,\n        RTICdrTypeCode *type_code)\n    {\n        struct RTIXCdrInterpreterPrograms *programs = NULL;\n        struct PRESTypePluginDefaultParticipantData *pd = NULL;\n        struct RTIXCdrInterpreterProgramsGenProperty programProperty =\n        RTIXCdrInterpreterProgramsGenProperty_INITIALIZER;\n        if (registration_data) {} \/* To avoid warnings *\/\n        if (participant_info) {} \/* To avoid warnings *\/\n        if (top_level_registration) {} \/* To avoid warnings *\/\n        if (container_plugin_context) {} \/* To avoid warnings *\/\n        if (type_code) {} \/* To avoid warnings *\/\n        pd = (struct PRESTypePluginDefaultParticipantData *)\n        PRESTypePluginDefaultParticipantData_new(participant_info);\n\n        programProperty.generateV1Encapsulation = RTI_XCDR_TRUE;\n        programProperty.generateV2Encapsulation = RTI_XCDR_TRUE;\n        programProperty.resolveAlias = RTI_XCDR_TRUE;\n        programProperty.inlineStruct = RTI_XCDR_TRUE;\n        programProperty.optimizeEnum = RTI_XCDR_TRUE;\n\n        programProperty.externalReferenceSize = \n        (RTIXCdrUnsignedShort) sizeof(::dds::core::external<char>);\n        programProperty.getExternalRefPointerFcn = \n        ::rti::topic::interpreter::get_external_value_pointer;\n\n        programs = DDS_TypeCodeFactory_assert_programs_in_global_list(\n            DDS_TypeCodeFactory_get_instance(),\n            (DDS_TypeCode *) (RTIXCdrTypeCode *)&::rti::topic::dynamic_type< setRight_reply >::get().native()\n            ,\n            &programProperty,\n            RTI_XCDR_PROGRAM_MASK_TYPEPLUGIN);\n\n        if (programs == NULL) {\n            PRESTypePluginDefaultParticipantData_delete(\n                (PRESTypePluginParticipantData)pd);\n            return NULL;\n        }\n\n        pd->programs = programs;\n        return (PRESTypePluginParticipantData)pd;\n    }"}
{"content":{"code":"static bool js_cc_scene_AmbientInfo__skyColorLDR_get(se::State& s)\n{\n    CC_UNUSED bool ok = true;\n    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;\n    \n    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    \/\/ %typemap(out) SWIGTYPE\n    ok &= nativevalue_to_se(arg1->_skyColorLDR, s.rval(), s.thisObject() \/*ctx*\/);\n    SE_PRECONDITION2(ok, false, \"AmbientInfo__skyColorLDR_get, Error processing arguments\");\n    SE_HOLD_RETURN_VALUE(arg1->_skyColorLDR, s.thisObject(), s.rval());\n    \n    \n    \n    return true;\n}","docstring":"\/\/ %typemap(in) SWIGTYPE value in","function_name":"js_cc_scene_AmbientInfo__skyColorLDR_set"},"id":220,"seed":"static bool js_cc_scene_AmbientInfo__skyColorLDR_get(se::State& s)\n{\n    CC_UNUSED bool ok = true;\n    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;\n    \n    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    \/\/ %typemap(out) SWIGTYPE\n    ok &= nativevalue_to_se(arg1->_skyColorLDR, s.rval(), s.thisObject() \/*ctx*\/);\n    SE_PRECONDITION2(ok, false, \"AmbientInfo__skyColorLDR_get, Error processing arguments\");\n    SE_HOLD_RETURN_VALUE(arg1->_skyColorLDR, s.thisObject(), s.rval());\n    \n    \n    \n    return true;\n}"}
{"content":{"code":"PRESTypePluginParticipantData \n    setLevel_replyPlugin_on_participant_attached(\n        void *registration_data,\n        const struct PRESTypePluginParticipantInfo *participant_info,\n        RTIBool top_level_registration,\n        void *container_plugin_context,\n        RTICdrTypeCode *type_code)\n    {\n        struct RTIXCdrInterpreterPrograms *programs = NULL;\n        struct PRESTypePluginDefaultParticipantData *pd = NULL;\n        struct RTIXCdrInterpreterProgramsGenProperty programProperty =\n        RTIXCdrInterpreterProgramsGenProperty_INITIALIZER;\n        if (registration_data) {} \/* To avoid warnings *\/\n        if (participant_info) {} \/* To avoid warnings *\/\n        if (top_level_registration) {} \/* To avoid warnings *\/\n        if (container_plugin_context) {} \/* To avoid warnings *\/\n        if (type_code) {} \/* To avoid warnings *\/\n        pd = (struct PRESTypePluginDefaultParticipantData *)\n        PRESTypePluginDefaultParticipantData_new(participant_info);\n\n        programProperty.generateV1Encapsulation = RTI_XCDR_TRUE;\n        programProperty.generateV2Encapsulation = RTI_XCDR_TRUE;\n        programProperty.resolveAlias = RTI_XCDR_TRUE;\n        programProperty.inlineStruct = RTI_XCDR_TRUE;\n        programProperty.optimizeEnum = RTI_XCDR_TRUE;\n\n        programProperty.externalReferenceSize = \n        (RTIXCdrUnsignedShort) sizeof(::dds::core::external<char>);\n        programProperty.getExternalRefPointerFcn = \n        ::rti::topic::interpreter::get_external_value_pointer;\n\n        programs = DDS_TypeCodeFactory_assert_programs_in_global_list(\n            DDS_TypeCodeFactory_get_instance(),\n            (DDS_TypeCode *) (RTIXCdrTypeCode *)&::rti::topic::dynamic_type< setLevel_reply >::get().native()\n            ,\n            &programProperty,\n            RTI_XCDR_PROGRAM_MASK_TYPEPLUGIN);\n\n        if (programs == NULL) {\n            PRESTypePluginDefaultParticipantData_delete(\n                (PRESTypePluginParticipantData)pd);\n            return NULL;\n        }\n\n        pd->programs = programs;\n        return (PRESTypePluginParticipantData)pd;\n    }","docstring":"\/* To avoid warnings *\/","function_name":"setLevel_reqPlugin_on_participant_attached"},"id":222,"seed":"PRESTypePluginParticipantData \n    setLevel_replyPlugin_on_participant_attached(\n        void *registration_data,\n        const struct PRESTypePluginParticipantInfo *participant_info,\n        RTIBool top_level_registration,\n        void *container_plugin_context,\n        RTICdrTypeCode *type_code)\n    {\n        struct RTIXCdrInterpreterPrograms *programs = NULL;\n        struct PRESTypePluginDefaultParticipantData *pd = NULL;\n        struct RTIXCdrInterpreterProgramsGenProperty programProperty =\n        RTIXCdrInterpreterProgramsGenProperty_INITIALIZER;\n        if (registration_data) {} \/* To avoid warnings *\/\n        if (participant_info) {} \/* To avoid warnings *\/\n        if (top_level_registration) {} \/* To avoid warnings *\/\n        if (container_plugin_context) {} \/* To avoid warnings *\/\n        if (type_code) {} \/* To avoid warnings *\/\n        pd = (struct PRESTypePluginDefaultParticipantData *)\n        PRESTypePluginDefaultParticipantData_new(participant_info);\n\n        programProperty.generateV1Encapsulation = RTI_XCDR_TRUE;\n        programProperty.generateV2Encapsulation = RTI_XCDR_TRUE;\n        programProperty.resolveAlias = RTI_XCDR_TRUE;\n        programProperty.inlineStruct = RTI_XCDR_TRUE;\n        programProperty.optimizeEnum = RTI_XCDR_TRUE;\n\n        programProperty.externalReferenceSize = \n        (RTIXCdrUnsignedShort) sizeof(::dds::core::external<char>);\n        programProperty.getExternalRefPointerFcn = \n        ::rti::topic::interpreter::get_external_value_pointer;\n\n        programs = DDS_TypeCodeFactory_assert_programs_in_global_list(\n            DDS_TypeCodeFactory_get_instance(),\n            (DDS_TypeCode *) (RTIXCdrTypeCode *)&::rti::topic::dynamic_type< setLevel_reply >::get().native()\n            ,\n            &programProperty,\n            RTI_XCDR_PROGRAM_MASK_TYPEPLUGIN);\n\n        if (programs == NULL) {\n            PRESTypePluginDefaultParticipantData_delete(\n                (PRESTypePluginParticipantData)pd);\n            return NULL;\n        }\n\n        pd->programs = programs;\n        return (PRESTypePluginParticipantData)pd;\n    }"}
{"content":{"code":"DAG ComputeDAG2(const Graph &graph, int src_v) {\n  DAG dag(graph.size());\n  multimap<Bignum, Edge> que;\n\/\/ stack<Edge> que;\n  que.insert(make_pair(1, Edge{src_v, 0}));\n\n  rep (iter, FLAGS_search_limit) {\n    if (que.empty()) break;\n    Edge crr = que.begin()->second;\n    que.erase(que.begin());\n\n    if (crr.second == 1) {\n      printf(\"%d -> %d\\n\", src_v, crr.first);\n      EnumeratePaths(dag, crr);\n    }\n\/\/ if (iter % 1000 == 0) cerr << src_v << \" \" << iter << \": \" << static_cast<double>(crr.second) << endl;\n\n    for (const auto &e : graph[crr.first]) {\n      Edge nxt(e.first, crr.second + e.second);\n      if (nxt.second > 1) continue;\n\n      auto &v = dag[nxt.first][nxt.second];\n      if (v.empty()) que.insert(make_pair(denominator(nxt.second), nxt));\n      v.emplace_back(crr);\n    }\n  }\n\n  return dag;\n}","docstring":"\/\/ if (iter % 1000 == 0) cerr << src_v << \" \" << iter << \": \" << static_cast<double>(crr.second) << endl;","function_name":"rep"},"id":224,"seed":"DAG ComputeDAG2(const Graph &graph, int src_v) {\n  DAG dag(graph.size());\n  multimap<Bignum, Edge> que;\n\/\/ stack<Edge> que;\n  que.insert(make_pair(1, Edge{src_v, 0}));\n\n  rep (iter, FLAGS_search_limit) {\n    if (que.empty()) break;\n    Edge crr = que.begin()->second;\n    que.erase(que.begin());\n\n    if (crr.second == 1) {\n      printf(\"%d -> %d\\n\", src_v, crr.first);\n      EnumeratePaths(dag, crr);\n    }\n\/\/ if (iter % 1000 == 0) cerr << src_v << \" \" << iter << \": \" << static_cast<double>(crr.second) << endl;\n\n    for (const auto &e : graph[crr.first]) {\n      Edge nxt(e.first, crr.second + e.second);\n      if (nxt.second > 1) continue;\n\n      auto &v = dag[nxt.first][nxt.second];\n      if (v.empty()) que.insert(make_pair(denominator(nxt.second), nxt));\n      v.emplace_back(crr);\n    }\n  }\n\n  return dag;\n}"}
{"content":{"code":"inline int DFS(int x,int flw){\/\/flw\uff1a\u5f53\u524d\u6d41\u91cf\uff08flow\uff09 \r\n\tif (x==n) return flw;\r\n\tfor (int i=cur[x];i!=-1;i=cur[x]=nxt[i]){\r\n\t\tif ((deep[son[i]]==deep[x]+1)&&w[i]){\r\n\t\t\tint nxtflw=DFS(son[i],min(flw,w[i]));\r\n\t\t\tif (nxtflw){\/\/nxtflw>0\u8bf4\u660e\u589e\u5e7f\u6210\u529f \r\n\t\t\t\tw[i]-=nxtflw;\r\n\t\t\t\tw[i^1]+=nxtflw;\/\/\u53cd\u5411\u8fb9\u52a0\u4e0a\u672c\u6b21\u589e\u5e7f\u6d41\u91cf\uff0c\u7531\u4e8e\u6b63\u53cd\u8fb9\u4e24\u4e24\u76f8\u90bb\u5b58\u50a8\uff0c\u6240\u4ee5i^1\u5373\u4e3ai\u7684\u53cd\u5411\u8fb9 \r\n\t\t\t\treturn nxtflw;\/\/\u5411\u4e0a\u4f20\u9012 \r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn 0;\/\/\u6ca1\u6709return\u8bf4\u660e\u6ca1\u6709\u589e\u5e7f\u8def \r\n}","docstring":"\/\/\u6784\u9020\u5206\u5c42\u56fe\uff0c\u8fd4\u56de\u662f\u5426\u5b58\u5728\u589e\u5e7f\u8def \r","function_name":"BFS"},"id":228,"seed":"inline int DFS(int x,int flw){\/\/flw\uff1a\u5f53\u524d\u6d41\u91cf\uff08flow\uff09 \r\n\tif (x==n) return flw;\r\n\tfor (int i=cur[x];i!=-1;i=cur[x]=nxt[i]){\r\n\t\tif ((deep[son[i]]==deep[x]+1)&&w[i]){\r\n\t\t\tint nxtflw=DFS(son[i],min(flw,w[i]));\r\n\t\t\tif (nxtflw){\/\/nxtflw>0\u8bf4\u660e\u589e\u5e7f\u6210\u529f \r\n\t\t\t\tw[i]-=nxtflw;\r\n\t\t\t\tw[i^1]+=nxtflw;\/\/\u53cd\u5411\u8fb9\u52a0\u4e0a\u672c\u6b21\u589e\u5e7f\u6d41\u91cf\uff0c\u7531\u4e8e\u6b63\u53cd\u8fb9\u4e24\u4e24\u76f8\u90bb\u5b58\u50a8\uff0c\u6240\u4ee5i^1\u5373\u4e3ai\u7684\u53cd\u5411\u8fb9 \r\n\t\t\t\treturn nxtflw;\/\/\u5411\u4e0a\u4f20\u9012 \r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn 0;\/\/\u6ca1\u6709return\u8bf4\u660e\u6ca1\u6709\u589e\u5e7f\u8def \r\n}"}
{"content":{"code":"SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__Obs(struct soap *soap, const char *tag, int id, const ns3__Obs *a, const char *type)\n{\n\t(void)soap; (void)tag; (void)id; (void)a; (void)type; \/* appease -Wall -Werror *\/\n\tif (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__Obs), type))\n\t\treturn soap->error;\n\tif (soap_out_int(soap, \"ns3:Code\", -1, &a->ns3__Obs::Code, \"\"))\n\t\treturn soap->error;\n\tif (soap_out_PointerTostd__string(soap, \"ns3:Msg\", -1, &a->ns3__Obs::Msg, \"\"))\n\t\treturn soap->error;\n\treturn soap_element_end_out(soap, tag);\n}","docstring":"\/* appease -Wall -Werror *\/","function_name":"soap_instantiate_ns3__ArrayOfEvt"},"id":236,"seed":"SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__Obs(struct soap *soap, const char *tag, int id, const ns3__Obs *a, const char *type)\n{\n\t(void)soap; (void)tag; (void)id; (void)a; (void)type; \/* appease -Wall -Werror *\/\n\tif (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__Obs), type))\n\t\treturn soap->error;\n\tif (soap_out_int(soap, \"ns3:Code\", -1, &a->ns3__Obs::Code, \"\"))\n\t\treturn soap->error;\n\tif (soap_out_PointerTostd__string(soap, \"ns3:Msg\", -1, &a->ns3__Obs::Msg, \"\"))\n\t\treturn soap->error;\n\treturn soap_element_end_out(soap, tag);\n}"}
{"content":{"code":"int readVoltages(byte * ltc_addr){\n Serial.println(\"Reading voltages on 0x\"+String(ltc_addr[0],HEX));\n\n int err_count = 0;\n byte res[6];\n unsigned int total_vRead = 0;\n \n\n  int j = 0;\n  if (readBytes(ltc_addr,RDCVA,res,6)) {\n    for (int i = 0 ; i < 2 ; i++ ) {\n      double va = (((res[3*i+1]&0x0f)*0xff + res[3*i])-512)*VLSB;\n      Serial.println(\"Cell \"+String(i*2+4*j)+\": \"+String(va)+\" [V]\");\n      total_vRead += (((res[3*i+1]&0x0f)*0xff + res[3*i])-512);\n      double vb = (((res[3*i+2]>>4)*0xff + ((res[3*i+2]&0x0f)<<4 | (res[3*i+1]&0xf0)>>4))-512)*VLSB;\n      Serial.println(\"Cell \"+String(1+i*2+4*j)+\": \"+String(vb)+\" [V]\");\n      total_vRead += (((res[3*i+2]>>4)*0xff + ((res[3*i+2]&0x0f)<<4 | (res[3*i+1]&0xf0)>>4))-512);\n    }\n  } else { err_count += 1; }\n\n  j++;\n  if (readBytes(ltc_addr,RDCVB,res,6)) {\n    for (int i = 0 ; i < 2 ; i++ ) {\n      double va = (((res[3*i+1]&0x0f)*0xff + res[3*i])-512)*VLSB;\n      Serial.println(\"Cell \"+String(i*2+4*j)+\": \"+String(va)+\" [V]\");\n      total_vRead += (((res[3*i+1]&0x0f)*0xff + res[3*i])-512);\n      double vb = (((res[3*i+2]>>4)*0xff + ((res[3*i+2]&0x0f)<<4 | (res[3*i+1]&0xf0)>>4))-512)*VLSB;\n      Serial.println(\"Cell \"+String(1+i*2+4*j)+\": \"+String(vb)+\" [V]\");\n      total_vRead += (((res[3*i+2]>>4)*0xff + ((res[3*i+2]&0x0f)<<4 | (res[3*i+1]&0xf0)>>4))-512);\n    }\n  } else { err_count += 1; }\n\n  \/*j++;\n  if (readBytes(ltc_addr,RDCVC,res,6)) {\n    for (int i = 0 ; i < 2 ; i++ ) {\n      double va = (((res[3*i+1]&0x0f)*0xff + res[3*i])-512)*VLSB;\n      Serial.println(\"Cell \"+String(i*2+4*j)+\": \"+String(va)+\" [V]\");\n      total_vRead += (((res[3*i+1]&0x0f)*0xff + res[3*i])-512);\n      double vb = (((res[3*i+2]>>4)*0xff + ((res[3*i+2]&0x0f)<<4 | (res[3*i+1]&0xf0)>>4))-512)*VLSB;\n      Serial.println(\"Cell \"+String(1+i*2+4*j)+\": \"+String(vb)+\" [V]\");\n      total_vRead += (((res[3*i+2]>>4)*0xff + ((res[3*i+2]&0x0f)<<4 | (res[3*i+1]&0xf0)>>4))-512);\n    }\n  } else { err_count += 1; }*\/\n  Serial.println(\"Total: \"+String(total_vRead*VLSB)+\" [V]\");\n \n  return err_count;\n }","docstring":"\/\/ so far this has always failed ; see page 16","function_name":"doSelfTest"},"id":242,"seed":"int readVoltages(byte * ltc_addr){\n Serial.println(\"Reading voltages on 0x\"+String(ltc_addr[0],HEX));\n\n int err_count = 0;\n byte res[6];\n unsigned int total_vRead = 0;\n \n\n  int j = 0;\n  if (readBytes(ltc_addr,RDCVA,res,6)) {\n    for (int i = 0 ; i < 2 ; i++ ) {\n      double va = (((res[3*i+1]&0x0f)*0xff + res[3*i])-512)*VLSB;\n      Serial.println(\"Cell \"+String(i*2+4*j)+\": \"+String(va)+\" [V]\");\n      total_vRead += (((res[3*i+1]&0x0f)*0xff + res[3*i])-512);\n      double vb = (((res[3*i+2]>>4)*0xff + ((res[3*i+2]&0x0f)<<4 | (res[3*i+1]&0xf0)>>4))-512)*VLSB;\n      Serial.println(\"Cell \"+String(1+i*2+4*j)+\": \"+String(vb)+\" [V]\");\n      total_vRead += (((res[3*i+2]>>4)*0xff + ((res[3*i+2]&0x0f)<<4 | (res[3*i+1]&0xf0)>>4))-512);\n    }\n  } else { err_count += 1; }\n\n  j++;\n  if (readBytes(ltc_addr,RDCVB,res,6)) {\n    for (int i = 0 ; i < 2 ; i++ ) {\n      double va = (((res[3*i+1]&0x0f)*0xff + res[3*i])-512)*VLSB;\n      Serial.println(\"Cell \"+String(i*2+4*j)+\": \"+String(va)+\" [V]\");\n      total_vRead += (((res[3*i+1]&0x0f)*0xff + res[3*i])-512);\n      double vb = (((res[3*i+2]>>4)*0xff + ((res[3*i+2]&0x0f)<<4 | (res[3*i+1]&0xf0)>>4))-512)*VLSB;\n      Serial.println(\"Cell \"+String(1+i*2+4*j)+\": \"+String(vb)+\" [V]\");\n      total_vRead += (((res[3*i+2]>>4)*0xff + ((res[3*i+2]&0x0f)<<4 | (res[3*i+1]&0xf0)>>4))-512);\n    }\n  } else { err_count += 1; }\n\n  \/*j++;\n  if (readBytes(ltc_addr,RDCVC,res,6)) {\n    for (int i = 0 ; i < 2 ; i++ ) {\n      double va = (((res[3*i+1]&0x0f)*0xff + res[3*i])-512)*VLSB;\n      Serial.println(\"Cell \"+String(i*2+4*j)+\": \"+String(va)+\" [V]\");\n      total_vRead += (((res[3*i+1]&0x0f)*0xff + res[3*i])-512);\n      double vb = (((res[3*i+2]>>4)*0xff + ((res[3*i+2]&0x0f)<<4 | (res[3*i+1]&0xf0)>>4))-512)*VLSB;\n      Serial.println(\"Cell \"+String(1+i*2+4*j)+\": \"+String(vb)+\" [V]\");\n      total_vRead += (((res[3*i+2]>>4)*0xff + ((res[3*i+2]&0x0f)<<4 | (res[3*i+1]&0xf0)>>4))-512);\n    }\n  } else { err_count += 1; }*\/\n  Serial.println(\"Total: \"+String(total_vRead*VLSB)+\" [V]\");\n \n  return err_count;\n }"}
{"content":{"code":"int main(){\n\t\/\/ #ifndef ONLINE_JUDGE\n\t\/\/ freopen(\"\/home\/naman\/CP\/input.txt\", \"r\", stdin);\n\t\/\/ freopen(\"\/home\/naman\/CP\/output.txt\", \"w\", stdout);\n\t\/\/ #endif\n\tint n;\n    int S[] = { 1, 3, 1 };\n\tn = sizeof(S) \/ sizeof(S[0]);\n\n\t\/\/ sort the set\n\tsort(S, S + n);\n\n\t\/\/ create an empty vector to store elements of a subset\n\tvector<int> out;\n\tfindPowerSet(S, out, 0);\n\n\treturn 0;\n\n}","docstring":"\/\/ exclude current element in the current subset and recur","function_name":"findPowerSet"},"id":246,"seed":"int main(){\n\t\/\/ #ifndef ONLINE_JUDGE\n\t\/\/ freopen(\"\/home\/naman\/CP\/input.txt\", \"r\", stdin);\n\t\/\/ freopen(\"\/home\/naman\/CP\/output.txt\", \"w\", stdout);\n\t\/\/ #endif\n\tint n;\n    int S[] = { 1, 3, 1 };\n\tn = sizeof(S) \/ sizeof(S[0]);\n\n\t\/\/ sort the set\n\tsort(S, S + n);\n\n\t\/\/ create an empty vector to store elements of a subset\n\tvector<int> out;\n\tfindPowerSet(S, out, 0);\n\n\treturn 0;\n\n}"}
{"content":{"code":"static void ExtractOne(ZipArchiveHandle zah, ZipEntry& entry, const std::string& name) {\r\n  \/\/ Bad filename?\r\n  if (android::base::StartsWith(name, \"\/\") || android::base::StartsWith(name, \"..\/\") ||\r\n      name.find(\"\/..\/\") != std::string::npos) {\r\n  }\r\n\r\n  \/\/ Where are we actually extracting to (for human-readable output)?\r\n  std::string dst;\r\n  if (flag_d) {\r\n    dst = flag_d;\r\n    if (!android::base::EndsWith(dst, \"\/\")) dst += '\/';\r\n  }\r\n  dst += name;\r\n\r\n  \/\/ Ensure the directory hierarchy exists.\r\n  if (!MakeDirectoryHierarchy(android::base::Dirname(name))) {\r\n  }\r\n\r\n  \/\/ An entry in a zip file can just be a directory itself.\r\n  if (android::base::EndsWith(name, \"\/\")) {\r\n\t  if (android::base::utf8::mkdir(name.c_str(), entry.unix_mode) == -1) {\r\n      \/\/ If the directory already exists, that's fine.\r\n      if (errno == EEXIST) {\r\n        struct stat sb;\r\n        if (stat(name.c_str(), &sb) != -1 && S_ISDIR(sb.st_mode)) return;\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  \/\/ Create the file.\r\n  int fd = open(name.c_str(), O_CREAT | O_WRONLY | O_CLOEXEC | O_EXCL, entry.unix_mode);\r\n  if (fd == -1 && errno == EEXIST) {\r\n    if (overwrite_mode == kNever) return;\r\n    if (overwrite_mode == kPrompt && !PromptOverwrite(dst)) return;\r\n    \/\/ Either overwrite_mode is kAlways or the user consented to this specific case.\r\n    fd = open(name.c_str(), O_WRONLY | O_CREAT | O_CLOEXEC | O_TRUNC, entry.unix_mode);\r\n  }\r\n  if (fd == -1) {\r\n  }\r\n\r\n  \/\/ Actually extract into the file.\r\n  if (!flag_q) printf(\"  inflating: %s\\n\", dst.c_str());\r\n  int err = ExtractEntryToFile(zah, &entry, fd);\r\n  if (err < 0) {\r\n  }\r\n  close(fd);\r\n}","docstring":"\/\/ being able to seek and truncate, and you can't do that with stdout.\r","function_name":"ExtractToPipe"},"id":251,"seed":"static void ExtractOne(ZipArchiveHandle zah, ZipEntry& entry, const std::string& name) {\r\n  \/\/ Bad filename?\r\n  if (android::base::StartsWith(name, \"\/\") || android::base::StartsWith(name, \"..\/\") ||\r\n      name.find(\"\/..\/\") != std::string::npos) {\r\n  }\r\n\r\n  \/\/ Where are we actually extracting to (for human-readable output)?\r\n  std::string dst;\r\n  if (flag_d) {\r\n    dst = flag_d;\r\n    if (!android::base::EndsWith(dst, \"\/\")) dst += '\/';\r\n  }\r\n  dst += name;\r\n\r\n  \/\/ Ensure the directory hierarchy exists.\r\n  if (!MakeDirectoryHierarchy(android::base::Dirname(name))) {\r\n  }\r\n\r\n  \/\/ An entry in a zip file can just be a directory itself.\r\n  if (android::base::EndsWith(name, \"\/\")) {\r\n\t  if (android::base::utf8::mkdir(name.c_str(), entry.unix_mode) == -1) {\r\n      \/\/ If the directory already exists, that's fine.\r\n      if (errno == EEXIST) {\r\n        struct stat sb;\r\n        if (stat(name.c_str(), &sb) != -1 && S_ISDIR(sb.st_mode)) return;\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  \/\/ Create the file.\r\n  int fd = open(name.c_str(), O_CREAT | O_WRONLY | O_CLOEXEC | O_EXCL, entry.unix_mode);\r\n  if (fd == -1 && errno == EEXIST) {\r\n    if (overwrite_mode == kNever) return;\r\n    if (overwrite_mode == kPrompt && !PromptOverwrite(dst)) return;\r\n    \/\/ Either overwrite_mode is kAlways or the user consented to this specific case.\r\n    fd = open(name.c_str(), O_WRONLY | O_CREAT | O_CLOEXEC | O_TRUNC, entry.unix_mode);\r\n  }\r\n  if (fd == -1) {\r\n  }\r\n\r\n  \/\/ Actually extract into the file.\r\n  if (!flag_q) printf(\"  inflating: %s\\n\", dst.c_str());\r\n  int err = ExtractEntryToFile(zah, &entry, fd);\r\n  if (err < 0) {\r\n  }\r\n  close(fd);\r\n}"}
{"content":{"code":"int main (int argc, char * argv[]) {\n\n  \/\/If the number of command-line arguments is incorrect, the program should print line\n  \/\/Usage: executable-path <storage-duration-name> <count>\n  \/\/and quit.\n  if (argc != 3) {\n    std::cout << \"Usage: executable-path <storage-duration-name> <count> \\n\";\n    return 1;\n  }\n\n \/\/ If the <count> is not a valid unsigned short integer, the program should print line \"Invalid count\" and quit.\n  try {\n    unsigned short count = std::stoi(argv[2]);\n    \/\/ If the <count> is greater than 100, the program should print line \"Too many requested\" and quit.\n    if (count > 100 || count < 0 ) {\n      std::cout << \"Too many requested \\n\";\n      return 1;\n    }\n  }\n  catch (...){\n    std::cout << \"Invalid count \\n\";\n    return 1;\n  }\n\n    unsigned short count = std::stoi(argv[2]);\n    createObjects (argv[1], count);\n    \n    return 0;\n}","docstring":"\/\/ the program should print line Invalid storage duration and quit.","function_name":"createObjects"},"id":256,"seed":"int main (int argc, char * argv[]) {\n\n  \/\/If the number of command-line arguments is incorrect, the program should print line\n  \/\/Usage: executable-path <storage-duration-name> <count>\n  \/\/and quit.\n  if (argc != 3) {\n    std::cout << \"Usage: executable-path <storage-duration-name> <count> \\n\";\n    return 1;\n  }\n\n \/\/ If the <count> is not a valid unsigned short integer, the program should print line \"Invalid count\" and quit.\n  try {\n    unsigned short count = std::stoi(argv[2]);\n    \/\/ If the <count> is greater than 100, the program should print line \"Too many requested\" and quit.\n    if (count > 100 || count < 0 ) {\n      std::cout << \"Too many requested \\n\";\n      return 1;\n    }\n  }\n  catch (...){\n    std::cout << \"Invalid count \\n\";\n    return 1;\n  }\n\n    unsigned short count = std::stoi(argv[2]);\n    createObjects (argv[1], count);\n    \n    return 0;\n}"}
{"content":{"code":"static int _cocos2d_PhysicsWorld_removeBody2(lua_State *L)\n{\n    olua_startinvoke(L);\n\n    cocos2d::PhysicsWorld *self = nullptr;\n    lua_Integer arg1 = 0;       \/** tag *\/\n\n    olua_to_cppobj(L, 1, (void **)&self, \"cc.PhysicsWorld\");\n    olua_check_int(L, 2, &arg1);\n\n    \/\/ void removeBody(int tag)\n    self->removeBody((int)arg1);\n\n    olua_endinvoke(L);\n\n    return 0;\n}","docstring":"\/\/ void removeBody(cocos2d::PhysicsBody *body)","function_name":"_cocos2d_PhysicsWorld_removeBody1"},"id":258,"seed":"static int _cocos2d_PhysicsWorld_removeBody2(lua_State *L)\n{\n    olua_startinvoke(L);\n\n    cocos2d::PhysicsWorld *self = nullptr;\n    lua_Integer arg1 = 0;       \/** tag *\/\n\n    olua_to_cppobj(L, 1, (void **)&self, \"cc.PhysicsWorld\");\n    olua_check_int(L, 2, &arg1);\n\n    \/\/ void removeBody(int tag)\n    self->removeBody((int)arg1);\n\n    olua_endinvoke(L);\n\n    return 0;\n}"}
{"content":{"code":"static int scifs_rmdir(const char *path)\n{\n  int res;\n  string rpath;\n \/\/ std::cout << \"\\n REMOVE INVOKED ::\" << path << std::endl;\n \n  for (int i=0; i<RPCALL->get_locations_size(); i++) \n  {\n    rpath = RPCALL->MakePath(path,i);\n   \/\/ std::cout << \" AFTER MAKEPATH \" <<std::endl;\n    res = rmdir(rpath.c_str());\n   \/\/ std::cout << \" AFTER RMDIR \" <<std::endl;\n    if (res == -1)\n      return -errno;\n  }\n  return 0;\n}","docstring":"\/* On Linux this could just be 'mknod(path, mode, rdev)' but this\n     is more portable *\/","function_name":"scifs_mknod"},"id":259,"seed":"static int scifs_rmdir(const char *path)\n{\n  int res;\n  string rpath;\n \/\/ std::cout << \"\\n REMOVE INVOKED ::\" << path << std::endl;\n \n  for (int i=0; i<RPCALL->get_locations_size(); i++) \n  {\n    rpath = RPCALL->MakePath(path,i);\n   \/\/ std::cout << \" AFTER MAKEPATH \" <<std::endl;\n    res = rmdir(rpath.c_str());\n   \/\/ std::cout << \" AFTER RMDIR \" <<std::endl;\n    if (res == -1)\n      return -errno;\n  }\n  return 0;\n}"}
{"content":{"code":"int sdconf(sd_t *sd)\n{\n\tint err;\n\t\n\t\/\/get the current options\n\terr = tcgetattr(sd->fd, &sd->saved);\n\tif(err) return err;\n\t\n\tmemcpy(&sd->saved, &sd->settings, sizeof(struct termios));\n\t\n\tsd->settings.c_cflag |= (CLOCAL | CREAD);\n\tsd->settings.c_cflag |= B115200;\n\tsd->settings.c_cflag |= CS8;\n\tsd->settings.c_cflag |= PARENB;\n\t\n\t\/\/input flags\n\t\/\/termios_p.c_iflag = IGNPAR | IGNBRK;\n\t\n\t\/\/local options\n\tsd->settings.c_lflag     &= ~(ICANON | ECHO | ECHOE | ISIG);\t\/\/sets up raw input, NON-canonical\n\t\n\t\/\/output options\n\tsd->settings.c_oflag     &= ~OPOST;\t\t\/\/disable post-processing, to use raw output\n\t\n\tsd->settings.c_cc[VMIN]  = 1;\n\tsd->settings.c_cc[VTIME] = 0;\n\t\n\t\/\/set the options\n\terr = tcsetattr(sd->fd, TCSANOW, &sd->settings);\n\tif(err) return err;\n\t\n\t\/\/flush the buffers\n\ttcflush(sd->fd, TCOFLUSH);\n\ttcflush(sd->fd, TCIFLUSH);\n\t\n\treturn 0;\n}","docstring":"\/*\n\tReading data from a port is a little trickier.\n\tWhen you operate the port in raw data mode, each read(2) system call will return\n\tthe number of characters that are actually available in the serial input buffers.\n\tIf no characters are available, the call will block (wait) until characters come in,\n\tan interval timer expires, or an error occurs.\n\tThe read function can be made to return immediately by doing the following:\n\n\tfcntl(fd, F_SETFL, FNDELAY);\n\n\tThe FNDELAY option causes the read function to return 0 if no characters are available on the port.\n\tTo restore normal (blocking) behavior, call fcntl() without the FNDELAY option:\n\n    fcntl(fd, F_SETFL, 0);\n\n\tThis is also used after opening a serial port with the O_NDELAY option.\n*\/","function_name":"sdopen"},"id":260,"seed":"int sdconf(sd_t *sd)\n{\n\tint err;\n\t\n\t\/\/get the current options\n\terr = tcgetattr(sd->fd, &sd->saved);\n\tif(err) return err;\n\t\n\tmemcpy(&sd->saved, &sd->settings, sizeof(struct termios));\n\t\n\tsd->settings.c_cflag |= (CLOCAL | CREAD);\n\tsd->settings.c_cflag |= B115200;\n\tsd->settings.c_cflag |= CS8;\n\tsd->settings.c_cflag |= PARENB;\n\t\n\t\/\/input flags\n\t\/\/termios_p.c_iflag = IGNPAR | IGNBRK;\n\t\n\t\/\/local options\n\tsd->settings.c_lflag     &= ~(ICANON | ECHO | ECHOE | ISIG);\t\/\/sets up raw input, NON-canonical\n\t\n\t\/\/output options\n\tsd->settings.c_oflag     &= ~OPOST;\t\t\/\/disable post-processing, to use raw output\n\t\n\tsd->settings.c_cc[VMIN]  = 1;\n\tsd->settings.c_cc[VTIME] = 0;\n\t\n\t\/\/set the options\n\terr = tcsetattr(sd->fd, TCSANOW, &sd->settings);\n\tif(err) return err;\n\t\n\t\/\/flush the buffers\n\ttcflush(sd->fd, TCOFLUSH);\n\ttcflush(sd->fd, TCIFLUSH);\n\t\n\treturn 0;\n}"}
{"content":{"code":"void gridedit_updatezoomviewvalues ( void )\n{\n\t\/\/  accepts gridentityinzoomview\n\tif (  t.gridentityinzoomview>0 ) \n\t{\n\t\tt.zoomviewcameraangle_f=0.0;\n\t\tt.zoomviewcameraheight_f=50.0;\n\t\tt.zoomviewcamerarange_f=75.0;\n\t\tif (  t.entityelement[t.gridentityinzoomview].obj>0 ) \n\t\t{\n\t\t\tif (  ObjectExist(t.entityelement[t.gridentityinzoomview].obj) == 1 ) \n\t\t\t{\n\t\t\t\tt.zoomviewcamerarange_f=ObjectSize(t.entityelement[t.gridentityinzoomview].obj,1)*2.0;\n\t\t\t\tt.zoomviewcameraheight_f=(ObjectSize(t.entityelement[t.gridentityinzoomview].obj,1)\/2.0)-100.0;\n\t\t\t\tif (  t.zoomviewcameraheight_f<5  )  t.zoomviewcameraheight_f = 5;\n\t\t\t}\n\t\t}\n\t}\nreturn;\n\n}","docstring":"\/\/  Only if within map","function_name":"gridedit_mapediting"},"id":269,"seed":"void gridedit_updatezoomviewvalues ( void )\n{\n\t\/\/  accepts gridentityinzoomview\n\tif (  t.gridentityinzoomview>0 ) \n\t{\n\t\tt.zoomviewcameraangle_f=0.0;\n\t\tt.zoomviewcameraheight_f=50.0;\n\t\tt.zoomviewcamerarange_f=75.0;\n\t\tif (  t.entityelement[t.gridentityinzoomview].obj>0 ) \n\t\t{\n\t\t\tif (  ObjectExist(t.entityelement[t.gridentityinzoomview].obj) == 1 ) \n\t\t\t{\n\t\t\t\tt.zoomviewcamerarange_f=ObjectSize(t.entityelement[t.gridentityinzoomview].obj,1)*2.0;\n\t\t\t\tt.zoomviewcameraheight_f=(ObjectSize(t.entityelement[t.gridentityinzoomview].obj,1)\/2.0)-100.0;\n\t\t\t\tif (  t.zoomviewcameraheight_f<5  )  t.zoomviewcameraheight_f = 5;\n\t\t\t}\n\t\t}\n\t}\nreturn;\n\n}"}
{"content":{"code":"fpfhFeature::Ptr compute_fpfh_feature(PointCloud<PointXYZRGB>::Ptr incloud, int ksearchnum, int openmpcores)\n{\n\t\/\/\u5efa\u7acbkdtree\n\tpcl::search::KdTree<pcl::PointXYZRGB>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZRGB>);\n\t\/\/\u6cd5\u5411\u91cf\n\tpointnormal::Ptr point_normal(new pointnormal);\n\tpcl::NormalEstimation<pcl::PointXYZRGB, pcl::Normal> est_normal;\n\test_normal.setInputCloud(incloud);\n\test_normal.setSearchMethod(tree);\n\test_normal.setKSearch(ksearchnum);\n\test_normal.compute(*point_normal);\n\t\/\/fpfh \u4f30\u8ba1\n\tfpfhFeature::Ptr fpfh(new fpfhFeature);\n\t\/\/pcl::FPFHEstimation<pcl::PointXYZ,pcl::Normal,pcl::FPFHSignature33> est_target_fpfh;\n\tpcl::FPFHEstimationOMP<pcl::PointXYZRGB, pcl::Normal, pcl::FPFHSignature33> est_fpfh;\n\test_fpfh.setNumberOfThreads(openmpcores); \/\/\u6307\u5b9a4\u6838\u8ba1\u7b97\n\t\/\/ pcl::search::KdTree<pcl::PointXYZ>::Ptr tree4 (new pcl::search::KdTree<pcl::PointXYZ> ());\n\test_fpfh.setInputCloud(incloud);\n\test_fpfh.setInputNormals(point_normal);\n\test_fpfh.setSearchMethod(tree);\n\test_fpfh.setKSearch(ksearchnum);\n\test_fpfh.compute(*fpfh);\n\treturn fpfh;\n}","docstring":"\/\/open3d::FastGlobalRegistrationOption(fastpara));","function_name":"FPFHRegister_open3d"},"id":271,"seed":"fpfhFeature::Ptr compute_fpfh_feature(PointCloud<PointXYZRGB>::Ptr incloud, int ksearchnum, int openmpcores)\n{\n\t\/\/\u5efa\u7acbkdtree\n\tpcl::search::KdTree<pcl::PointXYZRGB>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZRGB>);\n\t\/\/\u6cd5\u5411\u91cf\n\tpointnormal::Ptr point_normal(new pointnormal);\n\tpcl::NormalEstimation<pcl::PointXYZRGB, pcl::Normal> est_normal;\n\test_normal.setInputCloud(incloud);\n\test_normal.setSearchMethod(tree);\n\test_normal.setKSearch(ksearchnum);\n\test_normal.compute(*point_normal);\n\t\/\/fpfh \u4f30\u8ba1\n\tfpfhFeature::Ptr fpfh(new fpfhFeature);\n\t\/\/pcl::FPFHEstimation<pcl::PointXYZ,pcl::Normal,pcl::FPFHSignature33> est_target_fpfh;\n\tpcl::FPFHEstimationOMP<pcl::PointXYZRGB, pcl::Normal, pcl::FPFHSignature33> est_fpfh;\n\test_fpfh.setNumberOfThreads(openmpcores); \/\/\u6307\u5b9a4\u6838\u8ba1\u7b97\n\t\/\/ pcl::search::KdTree<pcl::PointXYZ>::Ptr tree4 (new pcl::search::KdTree<pcl::PointXYZ> ());\n\test_fpfh.setInputCloud(incloud);\n\test_fpfh.setInputNormals(point_normal);\n\test_fpfh.setSearchMethod(tree);\n\test_fpfh.setKSearch(ksearchnum);\n\test_fpfh.compute(*fpfh);\n\treturn fpfh;\n}"}
{"content":{"code":"static bool js_cc_scene_Camera_initGeometryRenderer(se::State& s)\n{\n    \/\/ js_function\n    \n    CC_UNUSED bool ok = true;\n    const auto& args = s.args();\n    size_t argc = args.size();\n    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;\n    \n    if(argc != 0) {\n        SE_REPORT_ERROR(\"wrong number of arguments: %d, was expecting %d\", (int)argc, 0);\n        return false;\n    }\n    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    (arg1)->initGeometryRenderer();\n    \n    \n    return true;\n}","docstring":"\/\/ %typemap(in) SWIGTYPE&","function_name":"js_cc_scene_Camera_setViewportInOrientedSpace"},"id":273,"seed":"static bool js_cc_scene_Camera_initGeometryRenderer(se::State& s)\n{\n    \/\/ js_function\n    \n    CC_UNUSED bool ok = true;\n    const auto& args = s.args();\n    size_t argc = args.size();\n    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;\n    \n    if(argc != 0) {\n        SE_REPORT_ERROR(\"wrong number of arguments: %d, was expecting %d\", (int)argc, 0);\n        return false;\n    }\n    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    (arg1)->initGeometryRenderer();\n    \n    \n    return true;\n}"}
{"content":{"code":"int main()\n{IN;\/\/OUT;\n    ios::sync_with_stdio(0);\n    cin.tie(NULL);\n    int n,c;\n    cin>>n>>c;\n    ll res=0;\n    FOR (i,0,1){\n    \tFOR (j,0,1){\n    \t\tres=(res+calc(n,i,j,c))%K;\n    \t}\n    }\n    cout<<res<<endl;\n    \n\t\n         return 0;\n}","docstring":"\/\/cout<<n<<\" \"<<a1<<\" \"<<a2<<\" \"<<c<<\" \"<<d[n][a1][a2][c]<<endl;","function_name":"calc"},"id":282,"seed":"int main()\n{IN;\/\/OUT;\n    ios::sync_with_stdio(0);\n    cin.tie(NULL);\n    int n,c;\n    cin>>n>>c;\n    ll res=0;\n    FOR (i,0,1){\n    \tFOR (j,0,1){\n    \t\tres=(res+calc(n,i,j,c))%K;\n    \t}\n    }\n    cout<<res<<endl;\n    \n\t\n         return 0;\n}"}
{"content":{"code":"IplImage CreationImageFTMP_3(IplImage *src,IplImage *templ_3)\/\/src=image camera ,templ=image de reference (une des fleches)\n{\n\/\/d\u00e9finition de la taille(largeur, hauteur) de l'image ftmp\n    int iwidth = src->width - templ_3->width + 1;\n    int iheight = src->height - templ_3->height + 1;\n\n\t\/\/Creer un pointeur d'image ftmp de type IplImage et de taille iwidth et iheight\n    IplImage *ftmp_3 = cvCreateImage(cvSize(iwidth,iheight),IPL_DEPTH_32F,1);\n\treturn *ftmp_3;\n}","docstring":"\/\/Creer un pointeur d'image ftmp de type IplImage et de taille iwidth et iheight","function_name":"CreationImageFTMP_2"},"id":285,"seed":"IplImage CreationImageFTMP_3(IplImage *src,IplImage *templ_3)\/\/src=image camera ,templ=image de reference (une des fleches)\n{\n\/\/d\u00e9finition de la taille(largeur, hauteur) de l'image ftmp\n    int iwidth = src->width - templ_3->width + 1;\n    int iheight = src->height - templ_3->height + 1;\n\n\t\/\/Creer un pointeur d'image ftmp de type IplImage et de taille iwidth et iheight\n    IplImage *ftmp_3 = cvCreateImage(cvSize(iwidth,iheight),IPL_DEPTH_32F,1);\n\treturn *ftmp_3;\n}"}
{"content":{"code":"IL2CPP_METHOD_ATTR uint32_t IVectorView_1_GetAt_m401DCF98BCB09DE624254EC85C6D723CE6492CAC (RuntimeObject* __this, uint32_t ___index0, const RuntimeMethod* method)\n{\n\tIVectorView_1_tCF0B931F5248DBD90A72F83BA70262CF7422BCB5* ____ivectorView_1_tCF0B931F5248DBD90A72F83BA70262CF7422BCB5 = NULL;\n\til2cpp_hresult_t hr = static_cast<Il2CppComObject *>(__this)->identity->QueryInterface(IVectorView_1_tCF0B931F5248DBD90A72F83BA70262CF7422BCB5::IID, reinterpret_cast<void**>(&____ivectorView_1_tCF0B931F5248DBD90A72F83BA70262CF7422BCB5));\n\til2cpp_codegen_com_raise_exception_if_failed(hr, false);\n\n\t\/\/ Native function invocation\n\tuint32_t returnValue = 0;\n\thr = ____ivectorView_1_tCF0B931F5248DBD90A72F83BA70262CF7422BCB5->IVectorView_1_GetAt_m401DCF98BCB09DE624254EC85C6D723CE6492CAC(___index0, &returnValue);\n\t____ivectorView_1_tCF0B931F5248DBD90A72F83BA70262CF7422BCB5->Release();\n\n\til2cpp_codegen_com_raise_exception_if_failed(hr, false);\n\n\treturn returnValue;\n}","docstring":"\/\/ Marshaling cleanup of parameter U27___items1U27 native representation","function_name":"IVectorView_1_GetMany_mEBDD2A781BF98D9450B52E34F2265FA193840186"},"id":294,"seed":"IL2CPP_METHOD_ATTR uint32_t IVectorView_1_GetAt_m401DCF98BCB09DE624254EC85C6D723CE6492CAC (RuntimeObject* __this, uint32_t ___index0, const RuntimeMethod* method)\n{\n\tIVectorView_1_tCF0B931F5248DBD90A72F83BA70262CF7422BCB5* ____ivectorView_1_tCF0B931F5248DBD90A72F83BA70262CF7422BCB5 = NULL;\n\til2cpp_hresult_t hr = static_cast<Il2CppComObject *>(__this)->identity->QueryInterface(IVectorView_1_tCF0B931F5248DBD90A72F83BA70262CF7422BCB5::IID, reinterpret_cast<void**>(&____ivectorView_1_tCF0B931F5248DBD90A72F83BA70262CF7422BCB5));\n\til2cpp_codegen_com_raise_exception_if_failed(hr, false);\n\n\t\/\/ Native function invocation\n\tuint32_t returnValue = 0;\n\thr = ____ivectorView_1_tCF0B931F5248DBD90A72F83BA70262CF7422BCB5->IVectorView_1_GetAt_m401DCF98BCB09DE624254EC85C6D723CE6492CAC(___index0, &returnValue);\n\t____ivectorView_1_tCF0B931F5248DBD90A72F83BA70262CF7422BCB5->Release();\n\n\til2cpp_codegen_com_raise_exception_if_failed(hr, false);\n\n\treturn returnValue;\n}"}
{"content":{"code":"int getButtton(int pinNumber){\n  int lastState;\n  int reading;\n  lastState = digitalRead(pinNumber);\n  do  {\n    reading = digitalRead(pinNumber);\n    if (reading != lastState) {\n      lastDebounceTime = millis();\n      lastState = reading;\n    } \n  } \n  while ((millis() - lastDebounceTime) < debounceDelay);\n  \/\/  lastDebounceTime = millis();\n  return reading;\n}","docstring":"\/\/ only send if a button is pushed!","function_name":"loop"},"id":299,"seed":"int getButtton(int pinNumber){\n  int lastState;\n  int reading;\n  lastState = digitalRead(pinNumber);\n  do  {\n    reading = digitalRead(pinNumber);\n    if (reading != lastState) {\n      lastDebounceTime = millis();\n      lastState = reading;\n    } \n  } \n  while ((millis() - lastDebounceTime) < debounceDelay);\n  \/\/  lastDebounceTime = millis();\n  return reading;\n}"}
{"content":{"code":"int main(int argc, char* argv[]) {\n\tif (argc <= 1) {\n\t\treturn 0;\n\t}\n\n\tcxxopts::Options options(\"Model Converter\", \"Converts model format with Assimp\");\n\toptions.add_options()\n\t\t\/\/General\n\t\t(\"i,inputFilepath\", \"Input filepath\", cxxopts::value<std::string>())\n\t\t(\"o,outputFilepath\", \"Output filepath (must contain extension)\", cxxopts::value<std::string>())\n\t\t(\"h,help\", \"Displays help\")\n\t\t(\"v,version\", \"Displays version\")\n\t\t\/\/Assimp options\n\t\t(\"aiProcess_CalcTangentSpace\", \"Calculates the tangents and bitangents for the imported meshes\")\n\t\t(\"aiProcess_JoinIdenticalVertices\", \"Identifies and joins identical vertex data sets within all imported meshes\")\n\t\t(\"aiProcess_MakeLeftHanded\", \"Converts all the imported data to a left-handed coordinate space\")\n\t\t(\"aiProcess_Triangulate\", \"Triangulates all faces of all meshes\")\n\t\t(\"aiProcess_RemoveComponent\", \"Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components)\")\n\t\t(\"aiProcess_GenNormals\", \"Generates normals for all faces of all meshes\")\n\t\t(\"aiProcess_GenSmoothNormals\", \"Generates smooth normals for all vertices in the mesh\")\n\t\t(\"aiProcess_SplitLargeMeshes\", \"Splits large meshes into smaller sub-meshes\")\n\t\t(\"aiProcess_PreTransformVertices\", \"Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes\")\n\t\t(\"aiProcess_LimitBoneWeights\", \"Limits the number of bones simultaneously affecting a single vertex to a maximum value\")\n\t\t(\"aiProcess_ValidateDataStructure\", \"Validates the imported scene data structure\")\n\t\t(\"aiProcess_ImproveCacheLocality\", \"Reorders triangles for better vertex cache locality\")\n\t\t(\"aiProcess_RemoveRedundantMaterials\", \"Searches for redundant\/unreferenced materials and removes them\")\n\t\t(\"aiProcess_FixInfacingNormals\", \"This step tries to determine which meshes have normal vectors that are facing inwards and inverts them\")\n\t\t(\"aiProcess_SortByPType\", \"This step splits meshes with more than one primitive type in homogeneous sub-meshes\")\n\t\t(\"aiProcess_FindDegenerates\", \"This step searches all meshes for degenerate primitives and converts them to proper lines or points\")\n\t\t(\"aiProcess_FindInvalidData\", \"This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes\/fixes them\")\n\t\t(\"aiProcess_GenUVCoords\", \"This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels\")\n\t\t(\"aiProcess_TransformUVCoords\", \"This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels\")\n\t\t(\"aiProcess_FindInstances\", \"This step searches for duplicate meshes and replaces them with references to the first mesh\")\n\t\t(\"aiProcess_OptimizeMeshes\", \"A postprocessing step to reduce the number of meshes\")\n\t\t(\"aiProcess_OptimizeGraph\", \"A postprocessing step to optimize the scene hierarchy\")\n\t\t(\"aiProcess_FlipUVs\", \"This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly\")\n\t\t(\"aiProcess_FlipWindingOrder\", \"This step adjusts the output face winding order to be CW\")\n\t\t(\"aiProcess_SplitByBoneCount\", \"This step splits meshes with many bones into sub-meshes so that each su-bmesh has fewer or as many bones as a given limit\")\n\t\t(\"aiProcess_Debone\", \"This step removes bones losslessly or according to some threshold\")\n\t\t\/\/Assimp macros\n\t\t(\"aiProcessPreset_TargetRealtime_Fast\", \"\")\n\t\t(\"aiProcessPreset_TargetRealtime_MaxQuality\", \"\")\n\t\t(\"aiProcessPreset_TargetRealtime_Quality\", \"\")\n\t\t;\n\tauto result = options.parse(argc, argv);\n\n\tif (result.count(\"help\") != 0) {\n\t\tstd::cout << options.help() << std::endl;\n\t\treturn 0;\n\t}\n\tif (result.count(\"version\") != 0) {\n\t\t\/\/Version of Model Converter\n\t\tstd::cout << VERSION_STR << std::endl;\n\t\tstd::cout << std::endl;\n\t\t\/\/Version of Assimp\n\t\tstd::cout << \"Assimp v\" << aiGetVersionMajor() << \".\" << aiGetVersionMinor() << \".\" << aiGetVersionRevision() << std::endl;\n\t\tstd::cout << std::endl;\n\t\t\/\/Legal string of Assimp\n\t\tstd::cout << aiGetLegalString() << std::endl;\n\n\t\treturn 0;\n\t}\n\n\tif (result.count(\"inputFilepath\") == 0) {\n\t\tstd::cerr << \"Error: You must specify input filepath\" << std::endl;\n\t\treturn -1;\n\t}\n\tif (result.count(\"outputFilepath\") == 0) {\n\t\tstd::cerr << \"Error: You must specify output filepath\" << std::endl;\n\t\treturn -1;\n\t}\n\n\tauto inputFilepath = result[\"inputFilepath\"].as<std::string>();\n\tauto outputFilepath = result[\"outputFilepath\"].as<std::string>();\n\n\tunsigned int readFileOptions = 0;\n\t\/\/Assimp options\n\tif (result.count(\"aiProcess_CalcTangentSpace\") != 0) {\n\t\treadFileOptions |= aiProcess_CalcTangentSpace;\n\t}\n\tif (result.count(\"aiProcess_JoinIdenticalVertices\") != 0) {\n\t\treadFileOptions |= aiProcess_JoinIdenticalVertices;\n\t}\n\tif (result.count(\"aiProcess_MakeLeftHanded\") != 0) {\n\t\treadFileOptions |= aiProcess_MakeLeftHanded;\n\t}\n\tif (result.count(\"aiProcess_Triangulate\") != 0) {\n\t\treadFileOptions |= aiProcess_Triangulate;\n\t}\n\tif (result.count(\"aiProcess_RemoveComponent\") != 0) {\n\t\treadFileOptions |= aiProcess_RemoveComponent;\n\t}\n\tif (result.count(\"aiProcess_GenNormals\") != 0) {\n\t\treadFileOptions |= aiProcess_GenNormals;\n\t}\n\tif (result.count(\"aiProcess_GenSmoothNormals\") != 0) {\n\t\treadFileOptions |= aiProcess_GenSmoothNormals;\n\t}\n\tif (result.count(\"aiProcess_SplitLargeMeshes\") != 0) {\n\t\treadFileOptions |= aiProcess_SplitLargeMeshes;\n\t}\n\tif (result.count(\"aiProcess_PreTransformVertices\") != 0) {\n\t\treadFileOptions |= aiProcess_PreTransformVertices;\n\t}\n\tif (result.count(\"aiProcess_LimitBoneWeights\") != 0) {\n\t\treadFileOptions |= aiProcess_LimitBoneWeights;\n\t}\n\tif (result.count(\"aiProcess_ValidateDataStructure\") != 0) {\n\t\treadFileOptions |= aiProcess_ValidateDataStructure;\n\t}\n\tif (result.count(\"aiProcess_ImproveCacheLocality\") != 0) {\n\t\treadFileOptions |= aiProcess_ImproveCacheLocality;\n\t}\n\tif (result.count(\"aiProcess_RemoveRedundantMaterials\") != 0) {\n\t\treadFileOptions |= aiProcess_RemoveRedundantMaterials;\n\t}\n\tif (result.count(\"aiProcess_FixInfacingNormals\") != 0) {\n\t\treadFileOptions |= aiProcess_FixInfacingNormals;\n\t}\n\tif (result.count(\"aiProcess_SortByPType\") != 0) {\n\t\treadFileOptions |= aiProcess_SortByPType;\n\t}\n\tif (result.count(\"aiProcess_FindDegenerates\") != 0) {\n\t\treadFileOptions |= aiProcess_FindDegenerates;\n\t}\n\tif (result.count(\"aiProcess_FindInvalidData\") != 0) {\n\t\treadFileOptions |= aiProcess_FindInvalidData;\n\t}\n\tif (result.count(\"aiProcess_GenUVCoords\") != 0) {\n\t\treadFileOptions |= aiProcess_GenUVCoords;\n\t}\n\tif (result.count(\"aiProcess_TransformUVCoords\") != 0) {\n\t\treadFileOptions |= aiProcess_TransformUVCoords;\n\t}\n\tif (result.count(\"aiProcess_FindInstances\") != 0) {\n\t\treadFileOptions |= aiProcess_FindInstances;\n\t}\n\tif (result.count(\"aiProcess_OptimizeMeshes\") != 0) {\n\t\treadFileOptions |= aiProcess_OptimizeMeshes;\n\t}\n\tif (result.count(\"aiProcess_OptimizeGraph\") != 0) {\n\t\treadFileOptions |= aiProcess_OptimizeGraph;\n\t}\n\tif (result.count(\"aiProcess_FlipUVs\") != 0) {\n\t\treadFileOptions |= aiProcess_FlipUVs;\n\t}\n\tif (result.count(\"aiProcess_FlipWindingOrder\") != 0) {\n\t\treadFileOptions |= aiProcess_FlipWindingOrder;\n\t}\n\tif (result.count(\"aiProcess_SplitByBoneCount\") != 0) {\n\t\treadFileOptions |= aiProcess_SplitByBoneCount;\n\t}\n\tif (result.count(\"aiProcess_Debone\") != 0) {\n\t\treadFileOptions |= aiProcess_Debone;\n\t}\n\t\/\/Assimp macros\n\tif (result.count(\"aiProcessPreset_TargetRealtime_Fast\") != 0) {\n\t\treadFileOptions |= aiProcessPreset_TargetRealtime_Fast;\n\t}\n\tif (result.count(\"aiProcessPreset_TargetRealtime_MaxQuality\") != 0) {\n\t\treadFileOptions |= aiProcessPreset_TargetRealtime_MaxQuality;\n\t}\n\tif (result.count(\"aiProcessPreset_TargetRealtime_Quality\") != 0) {\n\t\treadFileOptions |= aiProcessPreset_TargetRealtime_Quality;\n\t}\n\n\t\/\/Set aiProcessPreset_TargetRealtime_Quality as a default option if no options are set\n\tif (readFileOptions == 0) {\n\t\treadFileOptions = aiProcessPreset_TargetRealtime_Quality;\n\t}\n\n\tConvertModelFormat(inputFilepath, outputFilepath, readFileOptions);\n\n\treturn 0;\n}","docstring":"\/\/Get the file extension and determine the output format","function_name":"ConvertModelFormat"},"id":301,"seed":"int main(int argc, char* argv[]) {\n\tif (argc <= 1) {\n\t\treturn 0;\n\t}\n\n\tcxxopts::Options options(\"Model Converter\", \"Converts model format with Assimp\");\n\toptions.add_options()\n\t\t\/\/General\n\t\t(\"i,inputFilepath\", \"Input filepath\", cxxopts::value<std::string>())\n\t\t(\"o,outputFilepath\", \"Output filepath (must contain extension)\", cxxopts::value<std::string>())\n\t\t(\"h,help\", \"Displays help\")\n\t\t(\"v,version\", \"Displays version\")\n\t\t\/\/Assimp options\n\t\t(\"aiProcess_CalcTangentSpace\", \"Calculates the tangents and bitangents for the imported meshes\")\n\t\t(\"aiProcess_JoinIdenticalVertices\", \"Identifies and joins identical vertex data sets within all imported meshes\")\n\t\t(\"aiProcess_MakeLeftHanded\", \"Converts all the imported data to a left-handed coordinate space\")\n\t\t(\"aiProcess_Triangulate\", \"Triangulates all faces of all meshes\")\n\t\t(\"aiProcess_RemoveComponent\", \"Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components)\")\n\t\t(\"aiProcess_GenNormals\", \"Generates normals for all faces of all meshes\")\n\t\t(\"aiProcess_GenSmoothNormals\", \"Generates smooth normals for all vertices in the mesh\")\n\t\t(\"aiProcess_SplitLargeMeshes\", \"Splits large meshes into smaller sub-meshes\")\n\t\t(\"aiProcess_PreTransformVertices\", \"Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes\")\n\t\t(\"aiProcess_LimitBoneWeights\", \"Limits the number of bones simultaneously affecting a single vertex to a maximum value\")\n\t\t(\"aiProcess_ValidateDataStructure\", \"Validates the imported scene data structure\")\n\t\t(\"aiProcess_ImproveCacheLocality\", \"Reorders triangles for better vertex cache locality\")\n\t\t(\"aiProcess_RemoveRedundantMaterials\", \"Searches for redundant\/unreferenced materials and removes them\")\n\t\t(\"aiProcess_FixInfacingNormals\", \"This step tries to determine which meshes have normal vectors that are facing inwards and inverts them\")\n\t\t(\"aiProcess_SortByPType\", \"This step splits meshes with more than one primitive type in homogeneous sub-meshes\")\n\t\t(\"aiProcess_FindDegenerates\", \"This step searches all meshes for degenerate primitives and converts them to proper lines or points\")\n\t\t(\"aiProcess_FindInvalidData\", \"This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes\/fixes them\")\n\t\t(\"aiProcess_GenUVCoords\", \"This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels\")\n\t\t(\"aiProcess_TransformUVCoords\", \"This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels\")\n\t\t(\"aiProcess_FindInstances\", \"This step searches for duplicate meshes and replaces them with references to the first mesh\")\n\t\t(\"aiProcess_OptimizeMeshes\", \"A postprocessing step to reduce the number of meshes\")\n\t\t(\"aiProcess_OptimizeGraph\", \"A postprocessing step to optimize the scene hierarchy\")\n\t\t(\"aiProcess_FlipUVs\", \"This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly\")\n\t\t(\"aiProcess_FlipWindingOrder\", \"This step adjusts the output face winding order to be CW\")\n\t\t(\"aiProcess_SplitByBoneCount\", \"This step splits meshes with many bones into sub-meshes so that each su-bmesh has fewer or as many bones as a given limit\")\n\t\t(\"aiProcess_Debone\", \"This step removes bones losslessly or according to some threshold\")\n\t\t\/\/Assimp macros\n\t\t(\"aiProcessPreset_TargetRealtime_Fast\", \"\")\n\t\t(\"aiProcessPreset_TargetRealtime_MaxQuality\", \"\")\n\t\t(\"aiProcessPreset_TargetRealtime_Quality\", \"\")\n\t\t;\n\tauto result = options.parse(argc, argv);\n\n\tif (result.count(\"help\") != 0) {\n\t\tstd::cout << options.help() << std::endl;\n\t\treturn 0;\n\t}\n\tif (result.count(\"version\") != 0) {\n\t\t\/\/Version of Model Converter\n\t\tstd::cout << VERSION_STR << std::endl;\n\t\tstd::cout << std::endl;\n\t\t\/\/Version of Assimp\n\t\tstd::cout << \"Assimp v\" << aiGetVersionMajor() << \".\" << aiGetVersionMinor() << \".\" << aiGetVersionRevision() << std::endl;\n\t\tstd::cout << std::endl;\n\t\t\/\/Legal string of Assimp\n\t\tstd::cout << aiGetLegalString() << std::endl;\n\n\t\treturn 0;\n\t}\n\n\tif (result.count(\"inputFilepath\") == 0) {\n\t\tstd::cerr << \"Error: You must specify input filepath\" << std::endl;\n\t\treturn -1;\n\t}\n\tif (result.count(\"outputFilepath\") == 0) {\n\t\tstd::cerr << \"Error: You must specify output filepath\" << std::endl;\n\t\treturn -1;\n\t}\n\n\tauto inputFilepath = result[\"inputFilepath\"].as<std::string>();\n\tauto outputFilepath = result[\"outputFilepath\"].as<std::string>();\n\n\tunsigned int readFileOptions = 0;\n\t\/\/Assimp options\n\tif (result.count(\"aiProcess_CalcTangentSpace\") != 0) {\n\t\treadFileOptions |= aiProcess_CalcTangentSpace;\n\t}\n\tif (result.count(\"aiProcess_JoinIdenticalVertices\") != 0) {\n\t\treadFileOptions |= aiProcess_JoinIdenticalVertices;\n\t}\n\tif (result.count(\"aiProcess_MakeLeftHanded\") != 0) {\n\t\treadFileOptions |= aiProcess_MakeLeftHanded;\n\t}\n\tif (result.count(\"aiProcess_Triangulate\") != 0) {\n\t\treadFileOptions |= aiProcess_Triangulate;\n\t}\n\tif (result.count(\"aiProcess_RemoveComponent\") != 0) {\n\t\treadFileOptions |= aiProcess_RemoveComponent;\n\t}\n\tif (result.count(\"aiProcess_GenNormals\") != 0) {\n\t\treadFileOptions |= aiProcess_GenNormals;\n\t}\n\tif (result.count(\"aiProcess_GenSmoothNormals\") != 0) {\n\t\treadFileOptions |= aiProcess_GenSmoothNormals;\n\t}\n\tif (result.count(\"aiProcess_SplitLargeMeshes\") != 0) {\n\t\treadFileOptions |= aiProcess_SplitLargeMeshes;\n\t}\n\tif (result.count(\"aiProcess_PreTransformVertices\") != 0) {\n\t\treadFileOptions |= aiProcess_PreTransformVertices;\n\t}\n\tif (result.count(\"aiProcess_LimitBoneWeights\") != 0) {\n\t\treadFileOptions |= aiProcess_LimitBoneWeights;\n\t}\n\tif (result.count(\"aiProcess_ValidateDataStructure\") != 0) {\n\t\treadFileOptions |= aiProcess_ValidateDataStructure;\n\t}\n\tif (result.count(\"aiProcess_ImproveCacheLocality\") != 0) {\n\t\treadFileOptions |= aiProcess_ImproveCacheLocality;\n\t}\n\tif (result.count(\"aiProcess_RemoveRedundantMaterials\") != 0) {\n\t\treadFileOptions |= aiProcess_RemoveRedundantMaterials;\n\t}\n\tif (result.count(\"aiProcess_FixInfacingNormals\") != 0) {\n\t\treadFileOptions |= aiProcess_FixInfacingNormals;\n\t}\n\tif (result.count(\"aiProcess_SortByPType\") != 0) {\n\t\treadFileOptions |= aiProcess_SortByPType;\n\t}\n\tif (result.count(\"aiProcess_FindDegenerates\") != 0) {\n\t\treadFileOptions |= aiProcess_FindDegenerates;\n\t}\n\tif (result.count(\"aiProcess_FindInvalidData\") != 0) {\n\t\treadFileOptions |= aiProcess_FindInvalidData;\n\t}\n\tif (result.count(\"aiProcess_GenUVCoords\") != 0) {\n\t\treadFileOptions |= aiProcess_GenUVCoords;\n\t}\n\tif (result.count(\"aiProcess_TransformUVCoords\") != 0) {\n\t\treadFileOptions |= aiProcess_TransformUVCoords;\n\t}\n\tif (result.count(\"aiProcess_FindInstances\") != 0) {\n\t\treadFileOptions |= aiProcess_FindInstances;\n\t}\n\tif (result.count(\"aiProcess_OptimizeMeshes\") != 0) {\n\t\treadFileOptions |= aiProcess_OptimizeMeshes;\n\t}\n\tif (result.count(\"aiProcess_OptimizeGraph\") != 0) {\n\t\treadFileOptions |= aiProcess_OptimizeGraph;\n\t}\n\tif (result.count(\"aiProcess_FlipUVs\") != 0) {\n\t\treadFileOptions |= aiProcess_FlipUVs;\n\t}\n\tif (result.count(\"aiProcess_FlipWindingOrder\") != 0) {\n\t\treadFileOptions |= aiProcess_FlipWindingOrder;\n\t}\n\tif (result.count(\"aiProcess_SplitByBoneCount\") != 0) {\n\t\treadFileOptions |= aiProcess_SplitByBoneCount;\n\t}\n\tif (result.count(\"aiProcess_Debone\") != 0) {\n\t\treadFileOptions |= aiProcess_Debone;\n\t}\n\t\/\/Assimp macros\n\tif (result.count(\"aiProcessPreset_TargetRealtime_Fast\") != 0) {\n\t\treadFileOptions |= aiProcessPreset_TargetRealtime_Fast;\n\t}\n\tif (result.count(\"aiProcessPreset_TargetRealtime_MaxQuality\") != 0) {\n\t\treadFileOptions |= aiProcessPreset_TargetRealtime_MaxQuality;\n\t}\n\tif (result.count(\"aiProcessPreset_TargetRealtime_Quality\") != 0) {\n\t\treadFileOptions |= aiProcessPreset_TargetRealtime_Quality;\n\t}\n\n\t\/\/Set aiProcessPreset_TargetRealtime_Quality as a default option if no options are set\n\tif (readFileOptions == 0) {\n\t\treadFileOptions = aiProcessPreset_TargetRealtime_Quality;\n\t}\n\n\tConvertModelFormat(inputFilepath, outputFilepath, readFileOptions);\n\n\treturn 0;\n}"}
{"content":{"code":"int main()\n{\n    struct Sparse s1,s2,*s3;\n    cout <<\"Creating the Matrix1\\n\";\n    Create(&s1);\n    cout <<\"Creating the Matrix2\\n\";\n    Create(&s2);\n    s3 = add(&s1, &s2);\n    cout <<\"Displaying the First Matrix\\n\";\n    Display(s1);\n    cout <<\"\\nDisplaying the Second Matrix\\n\";\n    Display(s2);\n    cout <<\"\\nDisplaying the Sum of the Matrix1 and Matrix2\\n\";\n    Display(*s3);\/\/ As this was a pointer so derefrencing it.\n    return 0;\n}","docstring":"\/\/ Array of type element and size num.","function_name":"Create"},"id":305,"seed":"int main()\n{\n    struct Sparse s1,s2,*s3;\n    cout <<\"Creating the Matrix1\\n\";\n    Create(&s1);\n    cout <<\"Creating the Matrix2\\n\";\n    Create(&s2);\n    s3 = add(&s1, &s2);\n    cout <<\"Displaying the First Matrix\\n\";\n    Display(s1);\n    cout <<\"\\nDisplaying the Second Matrix\\n\";\n    Display(s2);\n    cout <<\"\\nDisplaying the Sum of the Matrix1 and Matrix2\\n\";\n    Display(*s3);\/\/ As this was a pointer so derefrencing it.\n    return 0;\n}"}
{"content":{"code":"soap_instantiate_ns3__FECAEARequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)\n{\n\tDBGLOG(TEST, SOAP_MESSAGE(fdebug, \"soap_instantiate_ns3__FECAEARequest(%p, %d, %s, %s)\\n\", (void*)soap, n, type?type:\"\", arrayType?arrayType:\"\"));\n\t(void)type; (void)arrayType; \/* appease -Wall -Werror *\/\n\tns3__FECAEARequest *p;\n\tsize_t k = sizeof(ns3__FECAEARequest);\n\tstruct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECAEARequest, n, afip_fdelete);\n\tif (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)\n\t\treturn NULL;\n\tif (n < 0)\n\t{\tp = SOAP_NEW(soap, ns3__FECAEARequest);\n\t\tif (p)\n\t\t\tp->soap = soap;\n\t}\n\telse\n\t{\tp = SOAP_NEW_ARRAY(soap, ns3__FECAEARequest, n);\n\t\tk *= n;\n\t\tif (p)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tp[i].soap = soap;\n\t}\n\tDBGLOG(TEST, SOAP_MESSAGE(fdebug, \"Instantiated ns3__FECAEARequest location=%p n=%d\\n\", (void*)p, n));\n\tif (size)\n\t\t*size = k;\n\tif (!p)\n\t\tsoap->error = SOAP_EOM;\n\telse if (cp)\n\t\tcp->ptr = (void*)p;\n\treturn p;\n}","docstring":"\/* appease -Wall -Werror *\/","function_name":"soap_in_ns3__FECAEARequest"},"id":321,"seed":"soap_instantiate_ns3__FECAEARequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)\n{\n\tDBGLOG(TEST, SOAP_MESSAGE(fdebug, \"soap_instantiate_ns3__FECAEARequest(%p, %d, %s, %s)\\n\", (void*)soap, n, type?type:\"\", arrayType?arrayType:\"\"));\n\t(void)type; (void)arrayType; \/* appease -Wall -Werror *\/\n\tns3__FECAEARequest *p;\n\tsize_t k = sizeof(ns3__FECAEARequest);\n\tstruct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECAEARequest, n, afip_fdelete);\n\tif (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)\n\t\treturn NULL;\n\tif (n < 0)\n\t{\tp = SOAP_NEW(soap, ns3__FECAEARequest);\n\t\tif (p)\n\t\t\tp->soap = soap;\n\t}\n\telse\n\t{\tp = SOAP_NEW_ARRAY(soap, ns3__FECAEARequest, n);\n\t\tk *= n;\n\t\tif (p)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tp[i].soap = soap;\n\t}\n\tDBGLOG(TEST, SOAP_MESSAGE(fdebug, \"Instantiated ns3__FECAEARequest location=%p n=%d\\n\", (void*)p, n));\n\tif (size)\n\t\t*size = k;\n\tif (!p)\n\t\tsoap->error = SOAP_EOM;\n\telse if (cp)\n\t\tcp->ptr = (void*)p;\n\treturn p;\n}"}
{"content":{"code":"IL2CPP_METHOD_ATTR uint32_t IVector_1_get_Size_mE153CC42F19B88AD5568B2251C4AFC600A431C50 (RuntimeObject* __this, const RuntimeMethod* method)\n{\n\tIVector_1_t309AEF845C8CD32F6804A23AF18B95404DAE449D* ____ivector_1_t309AEF845C8CD32F6804A23AF18B95404DAE449D = NULL;\n\til2cpp_hresult_t hr = static_cast<Il2CppComObject *>(__this)->identity->QueryInterface(IVector_1_t309AEF845C8CD32F6804A23AF18B95404DAE449D::IID, reinterpret_cast<void**>(&____ivector_1_t309AEF845C8CD32F6804A23AF18B95404DAE449D));\n\til2cpp_codegen_com_raise_exception_if_failed(hr, false);\n\n\t\/\/ Native function invocation\n\tuint32_t returnValue = 0;\n\thr = ____ivector_1_t309AEF845C8CD32F6804A23AF18B95404DAE449D->IVector_1_get_Size_mE153CC42F19B88AD5568B2251C4AFC600A431C50(&returnValue);\n\t____ivector_1_t309AEF845C8CD32F6804A23AF18B95404DAE449D->Release();\n\n\til2cpp_codegen_com_raise_exception_if_failed(hr, false);\n\n\treturn returnValue;\n}","docstring":"\/\/ Marshaling cleanup of parameter U27___items0U27 native representation","function_name":"IVector_1_ReplaceAll_m2AEA0484E455AA62B3AD0802FBC213043247FDDA"},"id":327,"seed":"IL2CPP_METHOD_ATTR uint32_t IVector_1_get_Size_mE153CC42F19B88AD5568B2251C4AFC600A431C50 (RuntimeObject* __this, const RuntimeMethod* method)\n{\n\tIVector_1_t309AEF845C8CD32F6804A23AF18B95404DAE449D* ____ivector_1_t309AEF845C8CD32F6804A23AF18B95404DAE449D = NULL;\n\til2cpp_hresult_t hr = static_cast<Il2CppComObject *>(__this)->identity->QueryInterface(IVector_1_t309AEF845C8CD32F6804A23AF18B95404DAE449D::IID, reinterpret_cast<void**>(&____ivector_1_t309AEF845C8CD32F6804A23AF18B95404DAE449D));\n\til2cpp_codegen_com_raise_exception_if_failed(hr, false);\n\n\t\/\/ Native function invocation\n\tuint32_t returnValue = 0;\n\thr = ____ivector_1_t309AEF845C8CD32F6804A23AF18B95404DAE449D->IVector_1_get_Size_mE153CC42F19B88AD5568B2251C4AFC600A431C50(&returnValue);\n\t____ivector_1_t309AEF845C8CD32F6804A23AF18B95404DAE449D->Release();\n\n\til2cpp_codegen_com_raise_exception_if_failed(hr, false);\n\n\treturn returnValue;\n}"}
{"content":{"code":"bool  registerElements( IOKitController& controller )\n{\n   DBG_BLOCK( os_hid, \"registerElements\" );\n\n   \/\/ Retrieve properties dictionary.\n   CFMutableDictionaryRef  properties;\n   kern_return_t kr = IORegistryEntryCreateCFProperties(\n      controller.hidDevice,\n      &properties,\n      kCFAllocatorDefault,\n      kNilOptions\n   );\n   if( kr != KERN_SUCCESS )\n   {\n      DBG_MSG( os_hid, \"ERROR - IORegistryEntryCreateCFProperties failed.\" );\n      return false;\n   }\n   CHECK( properties != NULL );\n\n   bool ok = registerElementsFromDict( (CFDictionaryRef)properties, controller );\n\n   return ok;\n}","docstring":"\/\/ switch( usagePage )","function_name":"registerElementsFromDict"},"id":329,"seed":"bool  registerElements( IOKitController& controller )\n{\n   DBG_BLOCK( os_hid, \"registerElements\" );\n\n   \/\/ Retrieve properties dictionary.\n   CFMutableDictionaryRef  properties;\n   kern_return_t kr = IORegistryEntryCreateCFProperties(\n      controller.hidDevice,\n      &properties,\n      kCFAllocatorDefault,\n      kNilOptions\n   );\n   if( kr != KERN_SUCCESS )\n   {\n      DBG_MSG( os_hid, \"ERROR - IORegistryEntryCreateCFProperties failed.\" );\n      return false;\n   }\n   CHECK( properties != NULL );\n\n   bool ok = registerElementsFromDict( (CFDictionaryRef)properties, controller );\n\n   return ok;\n}"}
{"content":{"code":"static bool js_cc_scene_DirectionalLight_illuminanceHDR_set(se::State& s)\n{\n    CC_UNUSED bool ok = true;\n    const auto& args = s.args();\n    size_t argc = args.size();\n    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;\n    float arg2 ;\n    \n    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    \/\/ %typemap(in) int, short, long, signed char, float, double\n    ok &= sevalue_to_native(args[0], &arg2, nullptr);\n    SE_PRECONDITION2(ok, false, \"DirectionalLight_illuminanceHDR_set,2,SWIGTYPE_float\"); \n    cc_scene_DirectionalLight_illuminanceHDR_set(arg1,arg2);\n    \n    \n    return true;\n}","docstring":"\/\/ out 1","function_name":"js_cc_scene_DirectionalLight_illuminance_get"},"id":333,"seed":"static bool js_cc_scene_DirectionalLight_illuminanceHDR_set(se::State& s)\n{\n    CC_UNUSED bool ok = true;\n    const auto& args = s.args();\n    size_t argc = args.size();\n    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;\n    float arg2 ;\n    \n    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);\n    SE_PRECONDITION2(arg1, false, \"%s: Invalid Native Object\", __FUNCTION__); \n    \/\/ %typemap(in) int, short, long, signed char, float, double\n    ok &= sevalue_to_native(args[0], &arg2, nullptr);\n    SE_PRECONDITION2(ok, false, \"DirectionalLight_illuminanceHDR_set,2,SWIGTYPE_float\"); \n    cc_scene_DirectionalLight_illuminanceHDR_set(arg1,arg2);\n    \n    \n    return true;\n}"}
{"content":{"code":"cv::Mat getDenseOpticFlowRobustLeft(cv::Mat frame1_1C,cv::Mat frame2_1C,cv::Mat imageToDrawOn){\n    Mat flow, frame;\n    \/\/ some faster than mat image container\n    UMat  flowUmat, prevgray;\n    vector<Vec4f> interestingPoints;\n    vector<Vec4f> nonInterestingPoints;\n    vector<Vec4f> allPoints;\n    vector<float> angles;\n    vector<float> absoluteSize;\n    \n    \/\/ For all optical flow you need a sequence of images.. Or at least 2 of them. Previous and current frame\n    \n    \/\/ calculate optical flow\n    calcOpticalFlowFarneback(frame1_1C, frame2_1C, flowUmat, 0.5, 2, 50, 3, 5, 1.1, 0);\n    \/\/ copy Umat container to standard Mat\n    flowUmat.copyTo(flow);\n    \n    \/\/ By y += 5, x += 5 you can specify the grid\n    for (int y = 0; y < imageToDrawOn.rows; y += 20){\n        for (int x = 0; x < imageToDrawOn.cols; x += 20)\n        {\n            \/\/ get the flow from y, x position * 10 for better visibility\n            const Point2f flowatxy = flow.at<Point2f>(y, x) * 10;\n            line(imageToDrawOn, Point(x, y), Point(cvRound(x + flowatxy.x), cvRound(y + flowatxy.y)), Scalar(0,0,255));\n            allPoints.push_back(Vec4f(x,y,x + flowatxy.x,y + flowatxy.y));\n            \n            \/\/ draw line at flow direction\n            int minimumDistance = 10;\n            \/\/Minimum Parameters for angle and resultant distance\n            double resultantDistance = sqrt((flowatxy.x*flowatxy.x)+(flowatxy.y*flowatxy.y));\n            float angletemp = atanf((abs(flowatxy.y))\/(abs(flowatxy.x)));\n            \/\/                            cout<< \"angletemp= \"<<angletemp*180\/M_PI<<endl;\n            float calculatedAngle;\n            if(flowatxy.x<0 && flowatxy.y<0 ){\n                calculatedAngle = M_PI-angletemp;\n            }else if (flowatxy.x<0 && flowatxy.y>0){\n                calculatedAngle =M_PI + angletemp;\n            }else if(flowatxy.x>0&&flowatxy.y>0 ){\n                calculatedAngle = 2*M_PI - angletemp;\n            }else{\n                calculatedAngle = angletemp;\n            }\n            \/\/Filter Lines\n            if (resultantDistance>minimumDistance){\n                if(calculatedAngle <20*M_PI\/180 || calculatedAngle>270*M_PI\/180){\n                    angles.push_back(calculatedAngle);\n                    absoluteSize.push_back(resultantDistance);\n                    interestingPoints.push_back(Vec4f(x,y,x + flowatxy.x,y + flowatxy.y));\n                    line(imageToDrawOn, Point(x, y), Point(cvRound(x + flowatxy.x), cvRound(y + flowatxy.y)), Scalar(255,255,0));\n                    \/\/                    line(imageToDrawOn, Point(x, y), Point(cvRound(x + flowatxy.x), cvRound(y + flowatxy.y)), Scalar(255,255,0));\n                    \/\/                                    cout<<\"calculatedAngle= \"<<calculatedAngle*180\/M_PI<<endl;\n                    \/\/                                    imshow(\"imageDebug\", imageToDrawOn);\n                    \/\/\n                    \/\/                                    waitKey();\n                }else{\n                    nonInterestingPoints.push_back(Vec4f(x,y,x + flowatxy.x,y + flowatxy.y));\n                }\n            }\n            circle(imageToDrawOn, Point(x, y), 1, Scalar(0, 0, 0), -1);\n        }\n    }\n    \n    bool isCarCuttingIn;\n    int sizeOfInterestingPoints = interestingPoints.size();\n    int sizeOfNonInterestingPoints = nonInterestingPoints.size();\n    \n    float sumAngles;\n    float sumDistances;\n    \n    \/\/    cout<<\"Interesting Points\"<<interestingPoints.size()<<endl;\n    \/\/    cout<<\"Non-Interesting Points\"<<nonInterestingPoints.size()<<endl;\n    \n    if(interestingPoints.size()>nonInterestingPoints.size()){\n        \/\/average the angles and the magnitude\n        for (int k=0; k<angles.size(); k++) {\n            sumAngles += angles[k];\n            sumDistances += absoluteSize[k];\n        }\n        float averageAngle =sumAngles\/angles.size();\n        float averageDistances = sumDistances\/absoluteSize.size();\n        \n        float width  = imageToDrawOn.cols;\n        float height = imageToDrawOn.rows;\n        \n        float averageY;\n        float averageX;\n        \n        if(averageAngle>90*M_PI\/180 && averageAngle<180*M_PI\/180){\n            \/\/ x -ve y +ve\n            averageAngle = averageAngle-(90*M_PI\/180);\n            \n            averageY = averageDistances * -sin(averageAngle);\n            averageX = averageDistances * -(cos(averageAngle));\n        }else if(averageAngle>180*M_PI\/180 && averageAngle<270*M_PI\/180){\n            \/\/ x -ve y -ve\n            averageAngle = averageAngle-(180*M_PI\/180);\n            \n            averageY = averageDistances * (sin(averageAngle));\n            averageX = averageDistances * -(cos(averageAngle));\n        }else if(averageAngle>270*M_PI\/180 && averageAngle<360*M_PI\/180){\n            \/\/ x +ve y -ve\n            averageAngle = averageAngle-(270*M_PI\/180);\n            \n            averageY = averageDistances * (sin(averageAngle));\n            averageX = averageDistances * (cos(averageAngle));\n        }else{\n            averageX = averageDistances*cos(averageAngle);\n            averageY = averageDistances*sin(averageAngle);\n        }\n        \n        \n        \/\/        float y = averageDistances*sin(averageAngle);\n        \/\/        float x = averageDistances*cos(averageAngle);\n        \n        \/\/Draw Large arrows\n        arrowedLine(imageToDrawOn, Point(width\/2,height\/2), Point(averageX+width\/2,averageY+height\/2), Scalar(255,0,0));\n        \/\/ turn bool on cutting lane\n        isCarCuttingIn = true;\n        \/\/        cout<<\"Car cutting in\"<<endl;\n    }else{\n        \/\/turn Bool on cutting lane\n        \/\/        cout<<\"Car NOT cutting in\"<<endl;\n        isCarCuttingIn = false;\n    }\n    \n    if (isCarCuttingIn) {\n        circle(imageToDrawOn, Point(100,50), 10, Scalar(0,0,255),-1, 8, 0);\n\/\/        objectCuttingIn=true;\n    }else{\n        circle(imageToDrawOn, Point(100,50), 10, Scalar(255,255,255),-1, 8, 0);\n\/\/        objectCuttingIn=false;\n    }\n    \n    return imageToDrawOn;\n}","docstring":"\/\/    cout<<\"Non-Interesting Points\"<<nonInterestingPoints.size()<<endl;","function_name":"getDenseOpticFlowRobustRight"},"id":334,"seed":"cv::Mat getDenseOpticFlowRobustLeft(cv::Mat frame1_1C,cv::Mat frame2_1C,cv::Mat imageToDrawOn){\n    Mat flow, frame;\n    \/\/ some faster than mat image container\n    UMat  flowUmat, prevgray;\n    vector<Vec4f> interestingPoints;\n    vector<Vec4f> nonInterestingPoints;\n    vector<Vec4f> allPoints;\n    vector<float> angles;\n    vector<float> absoluteSize;\n    \n    \/\/ For all optical flow you need a sequence of images.. Or at least 2 of them. Previous and current frame\n    \n    \/\/ calculate optical flow\n    calcOpticalFlowFarneback(frame1_1C, frame2_1C, flowUmat, 0.5, 2, 50, 3, 5, 1.1, 0);\n    \/\/ copy Umat container to standard Mat\n    flowUmat.copyTo(flow);\n    \n    \/\/ By y += 5, x += 5 you can specify the grid\n    for (int y = 0; y < imageToDrawOn.rows; y += 20){\n        for (int x = 0; x < imageToDrawOn.cols; x += 20)\n        {\n            \/\/ get the flow from y, x position * 10 for better visibility\n            const Point2f flowatxy = flow.at<Point2f>(y, x) * 10;\n            line(imageToDrawOn, Point(x, y), Point(cvRound(x + flowatxy.x), cvRound(y + flowatxy.y)), Scalar(0,0,255));\n            allPoints.push_back(Vec4f(x,y,x + flowatxy.x,y + flowatxy.y));\n            \n            \/\/ draw line at flow direction\n            int minimumDistance = 10;\n            \/\/Minimum Parameters for angle and resultant distance\n            double resultantDistance = sqrt((flowatxy.x*flowatxy.x)+(flowatxy.y*flowatxy.y));\n            float angletemp = atanf((abs(flowatxy.y))\/(abs(flowatxy.x)));\n            \/\/                            cout<< \"angletemp= \"<<angletemp*180\/M_PI<<endl;\n            float calculatedAngle;\n            if(flowatxy.x<0 && flowatxy.y<0 ){\n                calculatedAngle = M_PI-angletemp;\n            }else if (flowatxy.x<0 && flowatxy.y>0){\n                calculatedAngle =M_PI + angletemp;\n            }else if(flowatxy.x>0&&flowatxy.y>0 ){\n                calculatedAngle = 2*M_PI - angletemp;\n            }else{\n                calculatedAngle = angletemp;\n            }\n            \/\/Filter Lines\n            if (resultantDistance>minimumDistance){\n                if(calculatedAngle <20*M_PI\/180 || calculatedAngle>270*M_PI\/180){\n                    angles.push_back(calculatedAngle);\n                    absoluteSize.push_back(resultantDistance);\n                    interestingPoints.push_back(Vec4f(x,y,x + flowatxy.x,y + flowatxy.y));\n                    line(imageToDrawOn, Point(x, y), Point(cvRound(x + flowatxy.x), cvRound(y + flowatxy.y)), Scalar(255,255,0));\n                    \/\/                    line(imageToDrawOn, Point(x, y), Point(cvRound(x + flowatxy.x), cvRound(y + flowatxy.y)), Scalar(255,255,0));\n                    \/\/                                    cout<<\"calculatedAngle= \"<<calculatedAngle*180\/M_PI<<endl;\n                    \/\/                                    imshow(\"imageDebug\", imageToDrawOn);\n                    \/\/\n                    \/\/                                    waitKey();\n                }else{\n                    nonInterestingPoints.push_back(Vec4f(x,y,x + flowatxy.x,y + flowatxy.y));\n                }\n            }\n            circle(imageToDrawOn, Point(x, y), 1, Scalar(0, 0, 0), -1);\n        }\n    }\n    \n    bool isCarCuttingIn;\n    int sizeOfInterestingPoints = interestingPoints.size();\n    int sizeOfNonInterestingPoints = nonInterestingPoints.size();\n    \n    float sumAngles;\n    float sumDistances;\n    \n    \/\/    cout<<\"Interesting Points\"<<interestingPoints.size()<<endl;\n    \/\/    cout<<\"Non-Interesting Points\"<<nonInterestingPoints.size()<<endl;\n    \n    if(interestingPoints.size()>nonInterestingPoints.size()){\n        \/\/average the angles and the magnitude\n        for (int k=0; k<angles.size(); k++) {\n            sumAngles += angles[k];\n            sumDistances += absoluteSize[k];\n        }\n        float averageAngle =sumAngles\/angles.size();\n        float averageDistances = sumDistances\/absoluteSize.size();\n        \n        float width  = imageToDrawOn.cols;\n        float height = imageToDrawOn.rows;\n        \n        float averageY;\n        float averageX;\n        \n        if(averageAngle>90*M_PI\/180 && averageAngle<180*M_PI\/180){\n            \/\/ x -ve y +ve\n            averageAngle = averageAngle-(90*M_PI\/180);\n            \n            averageY = averageDistances * -sin(averageAngle);\n            averageX = averageDistances * -(cos(averageAngle));\n        }else if(averageAngle>180*M_PI\/180 && averageAngle<270*M_PI\/180){\n            \/\/ x -ve y -ve\n            averageAngle = averageAngle-(180*M_PI\/180);\n            \n            averageY = averageDistances * (sin(averageAngle));\n            averageX = averageDistances * -(cos(averageAngle));\n        }else if(averageAngle>270*M_PI\/180 && averageAngle<360*M_PI\/180){\n            \/\/ x +ve y -ve\n            averageAngle = averageAngle-(270*M_PI\/180);\n            \n            averageY = averageDistances * (sin(averageAngle));\n            averageX = averageDistances * (cos(averageAngle));\n        }else{\n            averageX = averageDistances*cos(averageAngle);\n            averageY = averageDistances*sin(averageAngle);\n        }\n        \n        \n        \/\/        float y = averageDistances*sin(averageAngle);\n        \/\/        float x = averageDistances*cos(averageAngle);\n        \n        \/\/Draw Large arrows\n        arrowedLine(imageToDrawOn, Point(width\/2,height\/2), Point(averageX+width\/2,averageY+height\/2), Scalar(255,0,0));\n        \/\/ turn bool on cutting lane\n        isCarCuttingIn = true;\n        \/\/        cout<<\"Car cutting in\"<<endl;\n    }else{\n        \/\/turn Bool on cutting lane\n        \/\/        cout<<\"Car NOT cutting in\"<<endl;\n        isCarCuttingIn = false;\n    }\n    \n    if (isCarCuttingIn) {\n        circle(imageToDrawOn, Point(100,50), 10, Scalar(0,0,255),-1, 8, 0);\n\/\/        objectCuttingIn=true;\n    }else{\n        circle(imageToDrawOn, Point(100,50), 10, Scalar(255,255,255),-1, 8, 0);\n\/\/        objectCuttingIn=false;\n    }\n    \n    return imageToDrawOn;\n}"}
{"content":{"code":"float16 uint32_to_float16(uint32_t x) {\n    \/\/ float16 is formatted as follows: sign(1 bit) exponent(5 bits) mantissa(10 bits). The value is interpreted\n    \/\/ The value is interpreted using following formula:\n    \/\/ (-1)^sign * 1, mantissa * 2 ^ (exponent - 15)\n    \/\/ Here we set the following values:\n    \/\/ sign = 0\n    \/\/ exponent = 15, for obtaining a zero exponent.\n    \/\/ mantissa = 10 right bits from generated uint32 random value.\n\n    uint16_t x_uint16 = static_cast<uint16_t>(x);\n    convert_types out_val = {(static_cast<uint16_t>(15) << 10) | (x_uint16 & 0x3ffu)};\n    return out_val.f16 - static_cast<float16>(1);\n}","docstring":"\/\/ mantissa = 23 right bits from generated uint32 random value.","function_name":"uint32_to_float"},"id":341,"seed":"float16 uint32_to_float16(uint32_t x) {\n    \/\/ float16 is formatted as follows: sign(1 bit) exponent(5 bits) mantissa(10 bits). The value is interpreted\n    \/\/ The value is interpreted using following formula:\n    \/\/ (-1)^sign * 1, mantissa * 2 ^ (exponent - 15)\n    \/\/ Here we set the following values:\n    \/\/ sign = 0\n    \/\/ exponent = 15, for obtaining a zero exponent.\n    \/\/ mantissa = 10 right bits from generated uint32 random value.\n\n    uint16_t x_uint16 = static_cast<uint16_t>(x);\n    convert_types out_val = {(static_cast<uint16_t>(15) << 10) | (x_uint16 & 0x3ffu)};\n    return out_val.f16 - static_cast<float16>(1);\n}"}
{"content":{"code":"static bool js_delete_cc_scene_PassDynamicsValue(se::State& s)\n{\n    \/\/ js_dtoroverride\n    return true;\n}","docstring":"\/\/ out 1","function_name":"js_cc_scene_PassDynamicsValue_value_get"},"id":342,"seed":"static bool js_delete_cc_scene_PassDynamicsValue(se::State& s)\n{\n    \/\/ js_dtoroverride\n    return true;\n}"}
{"content":{"code":"static int _cocos2d_PhysicsJointRotarySpring_createConstraints(lua_State *L)\n{\n    olua_startinvoke(L);\n\n    cocos2d::PhysicsJointRotarySpring *self = nullptr;\n\n    olua_to_cppobj(L, 1, (void **)&self, \"cc.PhysicsJointRotarySpring\");\n\n    \/\/ bool createConstraints()\n    bool ret = self->createConstraints();\n    int num_ret = olua_push_bool(L, ret);\n\n    olua_endinvoke(L);\n\n    return num_ret;\n}","docstring":"\/\/ static cocos2d::PhysicsJointRotarySpring *construct(cocos2d::PhysicsBody *a, cocos2d::PhysicsBody *b, float stiffness, float damping)","function_name":"_cocos2d_PhysicsJointRotarySpring_construct"},"id":343,"seed":"static int _cocos2d_PhysicsJointRotarySpring_createConstraints(lua_State *L)\n{\n    olua_startinvoke(L);\n\n    cocos2d::PhysicsJointRotarySpring *self = nullptr;\n\n    olua_to_cppobj(L, 1, (void **)&self, \"cc.PhysicsJointRotarySpring\");\n\n    \/\/ bool createConstraints()\n    bool ret = self->createConstraints();\n    int num_ret = olua_push_bool(L, ret);\n\n    olua_endinvoke(L);\n\n    return num_ret;\n}"}
{"content":{"code":"int main() {\n    \/**1st part of the task*\/\n    start_first_task();\n\n    \/**\n     * 2st part of the task\n     * \u0414\u0430\u043d \u043c\u0430\u0441\u0441\u0438\u0432 \u0438\u0437 N \u0432\u0435\u0449\u0435\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0445 \u0447\u0438\u0441\u0435\u043b. \u041d\u0430\u0439\u0442\u0438 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432, \u0440\u0430\u0441\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u043d\u044b\u0445 \u0434\u043e \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430,\n        \u043a\u0440\u0430\u0442\u043d\u043e\u0433\u043e 5. \u0423\u0434\u0432\u043e\u0438\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u043c\u0430\u0441\u0441\u0438\u0432\u0430, \u0440\u0430\u0432\u043d\u044b\u0435 k. \u0415\u0441\u043b\u0438 \u0440\u0430\u0437\u043c\u0435\u0440 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0431\u043e\u043b\u044c\u0448\u0435 4, \u0442\u043e \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u043f\u0435\u0440\u0432\u044b\u0435 5\n        \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0432 \u043e\u0431\u0440\u0430\u0442\u043d\u043e\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435. \u041f\u0435\u0440\u0435\u043d\u0435\u0441\u0442\u0438 \u0432\u0441\u0435 \u043d\u0443\u043b\u0435\u0432\u044b\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0432 \u043a\u043e\u043d\u0435\u0446 \u043c\u0430\u0441\u0441\u0438\u0432\u0430, \u043d\u0435 \u043c\u0435\u043d\u044f\u044f \u043f\u043e\u0440\u044f\u0434\u043e\u043a\n        \u0441\u043b\u0435\u0434\u043e\u0432\u0430\u043d\u0438\u044f \u043e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0445 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432. \u041e\u0442\u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e \u0447\u0430\u0441\u0442\u044c \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0434\u043e \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e\n        \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\n     *\n     * *\/\n\n    start_second_task();\n\n    return 0;\n}","docstring":"\/\/ push to zeros array indices of elements equal to zero","function_name":"second_part_fourth_task"},"id":344,"seed":"int main() {\n    \/**1st part of the task*\/\n    start_first_task();\n\n    \/**\n     * 2st part of the task\n     * \u0414\u0430\u043d \u043c\u0430\u0441\u0441\u0438\u0432 \u0438\u0437 N \u0432\u0435\u0449\u0435\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0445 \u0447\u0438\u0441\u0435\u043b. \u041d\u0430\u0439\u0442\u0438 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432, \u0440\u0430\u0441\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u043d\u044b\u0445 \u0434\u043e \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430,\n        \u043a\u0440\u0430\u0442\u043d\u043e\u0433\u043e 5. \u0423\u0434\u0432\u043e\u0438\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u043c\u0430\u0441\u0441\u0438\u0432\u0430, \u0440\u0430\u0432\u043d\u044b\u0435 k. \u0415\u0441\u043b\u0438 \u0440\u0430\u0437\u043c\u0435\u0440 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0431\u043e\u043b\u044c\u0448\u0435 4, \u0442\u043e \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u043f\u0435\u0440\u0432\u044b\u0435 5\n        \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0432 \u043e\u0431\u0440\u0430\u0442\u043d\u043e\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435. \u041f\u0435\u0440\u0435\u043d\u0435\u0441\u0442\u0438 \u0432\u0441\u0435 \u043d\u0443\u043b\u0435\u0432\u044b\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0432 \u043a\u043e\u043d\u0435\u0446 \u043c\u0430\u0441\u0441\u0438\u0432\u0430, \u043d\u0435 \u043c\u0435\u043d\u044f\u044f \u043f\u043e\u0440\u044f\u0434\u043e\u043a\n        \u0441\u043b\u0435\u0434\u043e\u0432\u0430\u043d\u0438\u044f \u043e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0445 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432. \u041e\u0442\u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e \u0447\u0430\u0441\u0442\u044c \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0434\u043e \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e\n        \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\n     *\n     * *\/\n\n    start_second_task();\n\n    return 0;\n}"}
{"content":{"code":"GLuint BindCubeTexture(const string path)\n{\n    int width, height;\n    unsigned char* image = NULL;\n    vector<string> faces;\n\n    \/* \u83b7\u53d6\u7acb\u65b9\u4f53\u5404\u9762\u8def\u5f84 *\/\n    faces.push_back(path + \"right.jpg\");\n    faces.push_back(path + \"left.jpg\");\n    faces.push_back(path + \"top.jpg\");\n    faces.push_back(path + \"bottom.jpg\");\n    faces.push_back(path + \"back.jpg\");\n    faces.push_back(path + \"front.jpg\");\n\n    GLuint textureID;\n    glGenTextures(1, &textureID);\n    glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);\n    for(GLuint i = 0;i < faces.size(); ++i)\n    {\n        image = SOIL_load_image(faces[i].c_str(), &width, &height, 0, SOIL_LOAD_RGB);\n        if(image == NULL)\n            cout << \"ERROR:: path:\" << faces[i] << \"\\n\" << endl;\n        \/\/ \u4e3a\u5404\u4e2a\u9762\u5199\u5165\u7eb9\u7406\n        glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, width, height,\n                     0, GL_RGB, GL_UNSIGNED_BYTE, image);\n        SOIL_free_image_data(image);\n    }\n    \/\/glGenerateMipmap(GL_TEXTURE_CUBE_MAP);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);\n    glBindTexture(GL_TEXTURE_CUBE_MAP, 0);\n\n    return textureID;\n}","docstring":"\/\/ \u8bbe\u7f6e\u7eb9\u7406\u5c5e\u6027","function_name":"BindTexture"},"id":346,"seed":"GLuint BindCubeTexture(const string path)\n{\n    int width, height;\n    unsigned char* image = NULL;\n    vector<string> faces;\n\n    \/* \u83b7\u53d6\u7acb\u65b9\u4f53\u5404\u9762\u8def\u5f84 *\/\n    faces.push_back(path + \"right.jpg\");\n    faces.push_back(path + \"left.jpg\");\n    faces.push_back(path + \"top.jpg\");\n    faces.push_back(path + \"bottom.jpg\");\n    faces.push_back(path + \"back.jpg\");\n    faces.push_back(path + \"front.jpg\");\n\n    GLuint textureID;\n    glGenTextures(1, &textureID);\n    glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);\n    for(GLuint i = 0;i < faces.size(); ++i)\n    {\n        image = SOIL_load_image(faces[i].c_str(), &width, &height, 0, SOIL_LOAD_RGB);\n        if(image == NULL)\n            cout << \"ERROR:: path:\" << faces[i] << \"\\n\" << endl;\n        \/\/ \u4e3a\u5404\u4e2a\u9762\u5199\u5165\u7eb9\u7406\n        glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, width, height,\n                     0, GL_RGB, GL_UNSIGNED_BYTE, image);\n        SOIL_free_image_data(image);\n    }\n    \/\/glGenerateMipmap(GL_TEXTURE_CUBE_MAP);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);\n    glBindTexture(GL_TEXTURE_CUBE_MAP, 0);\n\n    return textureID;\n}"}
{"content":{"code":"static int _cocos2d_PhysicsJointRatchet_setRatchet(lua_State *L)\n{\n    olua_startinvoke(L);\n\n    cocos2d::PhysicsJointRatchet *self = nullptr;\n    lua_Number arg1 = 0;       \/** ratchet *\/\n\n    olua_to_cppobj(L, 1, (void **)&self, \"cc.PhysicsJointRatchet\");\n    olua_check_number(L, 2, &arg1);\n\n    \/\/ void setRatchet(float ratchet)\n    self->setRatchet((float)arg1);\n\n    olua_endinvoke(L);\n\n    return 0;\n}","docstring":"\/\/ void setPhase(float phase)","function_name":"_cocos2d_PhysicsJointRatchet_setPhase"},"id":355,"seed":"static int _cocos2d_PhysicsJointRatchet_setRatchet(lua_State *L)\n{\n    olua_startinvoke(L);\n\n    cocos2d::PhysicsJointRatchet *self = nullptr;\n    lua_Number arg1 = 0;       \/** ratchet *\/\n\n    olua_to_cppobj(L, 1, (void **)&self, \"cc.PhysicsJointRatchet\");\n    olua_check_number(L, 2, &arg1);\n\n    \/\/ void setRatchet(float ratchet)\n    self->setRatchet((float)arg1);\n\n    olua_endinvoke(L);\n\n    return 0;\n}"}
{"content":{"code":"SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)\n{\n\tconst char *soap_tmp_faultcode;\n\tsoap_tmp_faultcode = soap_QName2s(soap, a->faultcode);\n\t(void)soap; (void)tag; (void)id; (void)a; (void)type; \/* appease -Wall -Werror *\/\n\tif (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_SOAP_ENV__Fault), type))\n\t\treturn soap->error;\n\tif (soap_out__QName(soap, \"faultcode\", -1, (char*const*)(void*)&soap_tmp_faultcode, \"\"))\n\t\treturn soap->error;\n\tif (soap_out_string(soap, \"faultstring\", -1, (char*const*)&a->faultstring, \"\"))\n\t\treturn soap->error;\n\tif (soap_out_string(soap, \"faultactor\", -1, (char*const*)&a->faultactor, \"\"))\n\t\treturn soap->error;\n\tif (soap_out_PointerToSOAP_ENV__Detail(soap, \"detail\", -1, &a->detail, \"\"))\n\t\treturn soap->error;\n\tif (soap_out_PointerToSOAP_ENV__Code(soap, \"SOAP-ENV:Code\", -1, &a->SOAP_ENV__Code, \"\"))\n\t\treturn soap->error;\n\tif (soap_out_PointerToSOAP_ENV__Reason(soap, \"SOAP-ENV:Reason\", -1, &a->SOAP_ENV__Reason, \"\"))\n\t\treturn soap->error;\n\tif (soap_out_string(soap, \"SOAP-ENV:Node\", -1, (char*const*)&a->SOAP_ENV__Node, \"\"))\n\t\treturn soap->error;\n\tif (soap_out_string(soap, \"SOAP-ENV:Role\", -1, (char*const*)&a->SOAP_ENV__Role, \"\"))\n\t\treturn soap->error;\n\tif (soap_out_PointerToSOAP_ENV__Detail(soap, \"SOAP-ENV:Detail\", -1, &a->SOAP_ENV__Detail, \"\"))\n\t\treturn soap->error;\n\treturn soap_element_end_out(soap, tag);\n}","docstring":"\/* appease -Wall -Werror *\/","function_name":"soap_serialize_SOAP_ENV__Fault"},"id":358,"seed":"SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)\n{\n\tconst char *soap_tmp_faultcode;\n\tsoap_tmp_faultcode = soap_QName2s(soap, a->faultcode);\n\t(void)soap; (void)tag; (void)id; (void)a; (void)type; \/* appease -Wall -Werror *\/\n\tif (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_SOAP_ENV__Fault), type))\n\t\treturn soap->error;\n\tif (soap_out__QName(soap, \"faultcode\", -1, (char*const*)(void*)&soap_tmp_faultcode, \"\"))\n\t\treturn soap->error;\n\tif (soap_out_string(soap, \"faultstring\", -1, (char*const*)&a->faultstring, \"\"))\n\t\treturn soap->error;\n\tif (soap_out_string(soap, \"faultactor\", -1, (char*const*)&a->faultactor, \"\"))\n\t\treturn soap->error;\n\tif (soap_out_PointerToSOAP_ENV__Detail(soap, \"detail\", -1, &a->detail, \"\"))\n\t\treturn soap->error;\n\tif (soap_out_PointerToSOAP_ENV__Code(soap, \"SOAP-ENV:Code\", -1, &a->SOAP_ENV__Code, \"\"))\n\t\treturn soap->error;\n\tif (soap_out_PointerToSOAP_ENV__Reason(soap, \"SOAP-ENV:Reason\", -1, &a->SOAP_ENV__Reason, \"\"))\n\t\treturn soap->error;\n\tif (soap_out_string(soap, \"SOAP-ENV:Node\", -1, (char*const*)&a->SOAP_ENV__Node, \"\"))\n\t\treturn soap->error;\n\tif (soap_out_string(soap, \"SOAP-ENV:Role\", -1, (char*const*)&a->SOAP_ENV__Role, \"\"))\n\t\treturn soap->error;\n\tif (soap_out_PointerToSOAP_ENV__Detail(soap, \"SOAP-ENV:Detail\", -1, &a->SOAP_ENV__Detail, \"\"))\n\t\treturn soap->error;\n\treturn soap_element_end_out(soap, tag);\n}"}
{"content":{"code":"inline hw_uint<16> mpr16b_32_8_rd15_select(in_cache& in, int d0, int d1, int d2, int dynamic_address) {\n#ifdef __VIVADO_SYNTH__\n#endif \/\/__VIVADO_SYNTH__\n  \/\/ mpr16b_32_8_rd15 read pattern: { mpr16b_32_8_update_0[d0, d1, d2] -> in[7 + 8d0, 1 + 2d1, d2] : 0 <= d0 <= 15 and 0 <= d1 <= 63 and 0 <= d2 <= 63 }\n  \/\/ Read schedule : { mpr16b_32_8_update_0[d0, d1, d2] -> [d2, 1 + 2d1, d0, 2] : 0 <= d0 <= 15 and 0 <= d1 <= 63 and 0 <= d2 <= 63 }\n  \/\/ Write schedule: { in_update_0[d0, d1, d2] -> [d2, d1, d0, 1] : 0 <= d0 <= 15 and 0 <= d1 <= 127 and 0 <= d2 <= 63 }\n  auto value_in_in_update_0_write7 = in.in_in_update_0_write7_merged_banks_2.peek_0();\n  return value_in_in_update_0_write7;\n  return 0;\n}","docstring":"\/\/ Write schedule: { in_update_0[d0, d1, d2] -> [d2, d1, d0, 1] : 0 <= d0 <= 15 and 0 <= d1 <= 127 and 0 <= d2 <= 63 }","function_name":"mpr16b_32_8_rd14_select"},"id":359,"seed":"inline hw_uint<16> mpr16b_32_8_rd15_select(in_cache& in, int d0, int d1, int d2, int dynamic_address) {\n#ifdef __VIVADO_SYNTH__\n#endif \/\/__VIVADO_SYNTH__\n  \/\/ mpr16b_32_8_rd15 read pattern: { mpr16b_32_8_update_0[d0, d1, d2] -> in[7 + 8d0, 1 + 2d1, d2] : 0 <= d0 <= 15 and 0 <= d1 <= 63 and 0 <= d2 <= 63 }\n  \/\/ Read schedule : { mpr16b_32_8_update_0[d0, d1, d2] -> [d2, 1 + 2d1, d0, 2] : 0 <= d0 <= 15 and 0 <= d1 <= 63 and 0 <= d2 <= 63 }\n  \/\/ Write schedule: { in_update_0[d0, d1, d2] -> [d2, d1, d0, 1] : 0 <= d0 <= 15 and 0 <= d1 <= 127 and 0 <= d2 <= 63 }\n  auto value_in_in_update_0_write7 = in.in_in_update_0_write7_merged_banks_2.peek_0();\n  return value_in_in_update_0_write7;\n  return 0;\n}"}
{"content":{"code":"cv::RotatedRect rmvTheDot( cv::Mat& labeledObjs){\n\n    \/\/\/ Find contours\n    cv::Mat hierarchy;\n    std::vector< std::vector<cv::Point> > contours;\n    cv::Mat threshold_output = labeledObjs.clone(); \/\/only reference, I guess\n    findContours( threshold_output, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, cv::Point(0, 0) );\n\n    \/\/\/ Find the rotated rectangles and ellipses for each contour\n    std::vector<cv::RotatedRect> minRect( contours.size() );\n    std::vector<cv::RotatedRect> minEllipse( contours.size() );\n    std::vector<double> dotRat( contours.size(), 0.0 );\n    std::vector<int> dotDet( contours.size(), 0 );\n\n    int cntDet=0;\n    for( int i = 0; i < contours.size(); i++ ){\n        minRect[i] = minAreaRect( cv::Mat(contours[i]) );\n        if( contours[i].size() > 5 ){\n            minEllipse[i] = fitEllipse( cv::Mat(contours[i]) );\n\n            cv::Size s(minEllipse[i].size);\n            float sratio = (s.width\/(float)s.height);\n            dotRat[i] = sratio;\n            int mxs = (s.width>s.height) ? s.width : s.height;\n\n            dotDet[i] = ( (sratio>=DOT_SIZE_RATIO) && (sratio<=1\/DOT_SIZE_RATIO ) &&\\\n                          ((mxs)>DOT_SIZE_MINOMAX) && ((mxs)<DOT_SIZE_MAXPMAX)  );\n            cntDet += dotDet[i];\n            std::cerr << \"s[\"<<i<<\"]: \" << s << \" | ratio: \" << sratio << \" | det: \" << (int)dotDet[i] << \"\\n\";\n        }\n     }\n\n\n    \/\/\/\/In case not found\n    if(cntDet==0){\n        cv::RotatedRect empt;\n        \/\/(cv::Point(0,0), cv:Size(0,0), 0);\n\n        return empt;\n    }\n\n    \/\/\/\/Selecting the dot\n    int idet=-1;\n    double mn=99999;\n    if(cntDet>1){ \/\/multiple\n\n        std::cerr << \"dotRat.size=\" << dotRat.size() <<\"\\n\";\n\n        for(int i=0; i<dotRat.size(); i++ ){\n            if(dotDet[i]){\n                dotRat[i] = fabs(1.0-dotRat[i]);\n                std::cerr << \"new[\" << i<<\"]=\" << dotRat[i] << \" \";\n                if( mn > dotRat[i] ){\n                    mn = dotRat[i];\n                    idet = i;\n                    std::cerr << \"new idet\";\n                }\n                std::cerr << \"\\n\";\n            }\n        }\n    }else{\n        for(int i=0; i<dotDet.size(); i++ ){\n            if(dotDet[i]){\n                idet = i;\n                break;\n            }\n        }\n\n    }\n\n    \/\/\/Removing the dot from objects mask\n    labeledObjs(minRect[idet].boundingRect()) = 0;\n\n    return minRect[idet];\n\n    \/*\n            \/\/\/ Draw contours + rotated rects + ellipses\n            RNG rng;\n            cv::Mat drawing = cv::Mat::zeros( threshold_output.size(), CV_8UC3 );\n            for( int i = 0; i< contours.size(); i++ )\n               {\n                 \/\/Scalar color = Scalar( 100, 000, 220 );\n                 Scalar color = Scalar( rng.uniform(0,255), rng.uniform(0,255), rng.uniform(0,255) );\n\n                 \/\/ contour\n                 drawContours( drawing, contours, i, color, 1, 8, std::vector<Vec4i>(), 0, Point() );\n                 \/\/ ellipse\n                 ellipse( drawing, minEllipse[i], color, 2, 8 );\n                 \/\/ rotated rectangle\n                 Point2f rect_points[4]; minRect[i].points( rect_points );\n                 for( int j = 0; j < 4; j++ )\n                    line( drawing, rect_points[j], rect_points[(j+1)%4], color, 1, 8 );\n               }\n\n            imshow(\"drawcircs\", drawing);\n            moveWindow(\"drawcircs\", 800, 1500 );\n            cv::waitKey(0);\n    *\/\n}","docstring":"\/\/(int)hasObj[0];","function_name":"filterObjs4Dial"},"id":363,"seed":"cv::RotatedRect rmvTheDot( cv::Mat& labeledObjs){\n\n    \/\/\/ Find contours\n    cv::Mat hierarchy;\n    std::vector< std::vector<cv::Point> > contours;\n    cv::Mat threshold_output = labeledObjs.clone(); \/\/only reference, I guess\n    findContours( threshold_output, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, cv::Point(0, 0) );\n\n    \/\/\/ Find the rotated rectangles and ellipses for each contour\n    std::vector<cv::RotatedRect> minRect( contours.size() );\n    std::vector<cv::RotatedRect> minEllipse( contours.size() );\n    std::vector<double> dotRat( contours.size(), 0.0 );\n    std::vector<int> dotDet( contours.size(), 0 );\n\n    int cntDet=0;\n    for( int i = 0; i < contours.size(); i++ ){\n        minRect[i] = minAreaRect( cv::Mat(contours[i]) );\n        if( contours[i].size() > 5 ){\n            minEllipse[i] = fitEllipse( cv::Mat(contours[i]) );\n\n            cv::Size s(minEllipse[i].size);\n            float sratio = (s.width\/(float)s.height);\n            dotRat[i] = sratio;\n            int mxs = (s.width>s.height) ? s.width : s.height;\n\n            dotDet[i] = ( (sratio>=DOT_SIZE_RATIO) && (sratio<=1\/DOT_SIZE_RATIO ) &&\\\n                          ((mxs)>DOT_SIZE_MINOMAX) && ((mxs)<DOT_SIZE_MAXPMAX)  );\n            cntDet += dotDet[i];\n            std::cerr << \"s[\"<<i<<\"]: \" << s << \" | ratio: \" << sratio << \" | det: \" << (int)dotDet[i] << \"\\n\";\n        }\n     }\n\n\n    \/\/\/\/In case not found\n    if(cntDet==0){\n        cv::RotatedRect empt;\n        \/\/(cv::Point(0,0), cv:Size(0,0), 0);\n\n        return empt;\n    }\n\n    \/\/\/\/Selecting the dot\n    int idet=-1;\n    double mn=99999;\n    if(cntDet>1){ \/\/multiple\n\n        std::cerr << \"dotRat.size=\" << dotRat.size() <<\"\\n\";\n\n        for(int i=0; i<dotRat.size(); i++ ){\n            if(dotDet[i]){\n                dotRat[i] = fabs(1.0-dotRat[i]);\n                std::cerr << \"new[\" << i<<\"]=\" << dotRat[i] << \" \";\n                if( mn > dotRat[i] ){\n                    mn = dotRat[i];\n                    idet = i;\n                    std::cerr << \"new idet\";\n                }\n                std::cerr << \"\\n\";\n            }\n        }\n    }else{\n        for(int i=0; i<dotDet.size(); i++ ){\n            if(dotDet[i]){\n                idet = i;\n                break;\n            }\n        }\n\n    }\n\n    \/\/\/Removing the dot from objects mask\n    labeledObjs(minRect[idet].boundingRect()) = 0;\n\n    return minRect[idet];\n\n    \/*\n            \/\/\/ Draw contours + rotated rects + ellipses\n            RNG rng;\n            cv::Mat drawing = cv::Mat::zeros( threshold_output.size(), CV_8UC3 );\n            for( int i = 0; i< contours.size(); i++ )\n               {\n                 \/\/Scalar color = Scalar( 100, 000, 220 );\n                 Scalar color = Scalar( rng.uniform(0,255), rng.uniform(0,255), rng.uniform(0,255) );\n\n                 \/\/ contour\n                 drawContours( drawing, contours, i, color, 1, 8, std::vector<Vec4i>(), 0, Point() );\n                 \/\/ ellipse\n                 ellipse( drawing, minEllipse[i], color, 2, 8 );\n                 \/\/ rotated rectangle\n                 Point2f rect_points[4]; minRect[i].points( rect_points );\n                 for( int j = 0; j < 4; j++ )\n                    line( drawing, rect_points[j], rect_points[(j+1)%4], color, 1, 8 );\n               }\n\n            imshow(\"drawcircs\", drawing);\n            moveWindow(\"drawcircs\", 800, 1500 );\n            cv::waitKey(0);\n    *\/\n}"}
{"content":{"code":"fastfloat_really_inline uint32_t  parse_eight_digits_unrolled(uint64_t val) {\n  const uint64_t mask = 0x000000FF000000FF;\n  const uint64_t mul1 = 0x000F424000000064; \/\/ 100 + (1000000ULL << 32)\n  const uint64_t mul2 = 0x0000271000000001; \/\/ 1 + (10000ULL << 32)\n  val -= 0x3030303030303030;\n  val = (val * 10) + (val >> 8); \/\/ val = (val * 2561) >> 8;\n  val = (((val & mask) * mul1) + (((val >> 16) & mask) * mul2)) >> 32;\n  return uint32_t(val);\n}","docstring":"\/\/ handle overflow","function_name":"large_add_from"},"id":365,"seed":"fastfloat_really_inline uint32_t  parse_eight_digits_unrolled(uint64_t val) {\n  const uint64_t mask = 0x000000FF000000FF;\n  const uint64_t mul1 = 0x000F424000000064; \/\/ 100 + (1000000ULL << 32)\n  const uint64_t mul2 = 0x0000271000000001; \/\/ 1 + (10000ULL << 32)\n  val -= 0x3030303030303030;\n  val = (val * 10) + (val >> 8); \/\/ val = (val * 2561) >> 8;\n  val = (((val & mask) * mul1) + (((val >> 16) & mask) * mul2)) >> 32;\n  return uint32_t(val);\n}"}
{"content":{"code":"IL2CPP_EXTERN_C IL2CPP_METHOD_ATTR void List_1_System_Collections_IList_Insert_mA598B2B5AAC3779A06B3CF9243AD90C7451D6667_gshared (List_1_tC12B69E9430500C9BFF5B4B3D9F51DEE87A9D4C6 * __this, int32_t ___index0, RuntimeObject * ___item1, const RuntimeMethod* method)\n{\n\til2cpp::utils::ExceptionSupportStack<RuntimeObject*, 1> __active_exceptions;\n\til2cpp::utils::ExceptionSupportStack<int32_t, 2> __leave_targets;\n\t{\n\t\tRuntimeObject * L_0 = ___item1;\n\t\t((  void (*) (RuntimeObject *, int32_t, const RuntimeMethod*))IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 9)->methodPointer)((RuntimeObject *)L_0, (int32_t)((int32_t)20), \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 9));\n\t}\n\nIL_0008:\n\ttry\n\t{ \/\/ begin try (depth: 1)\n\t\tint32_t L_1 = ___index0;\n\t\tRuntimeObject * L_2 = ___item1;\n\t\tNullCheck((List_1_tC12B69E9430500C9BFF5B4B3D9F51DEE87A9D4C6 *)__this);\n\t\t((  void (*) (List_1_tC12B69E9430500C9BFF5B4B3D9F51DEE87A9D4C6 *, int32_t, X509ChainStatus_tB6C3677955C287CF97042F208630AA0F5ABF77FB , const RuntimeMethod*))IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 31)->methodPointer)((List_1_tC12B69E9430500C9BFF5B4B3D9F51DEE87A9D4C6 *)__this, (int32_t)L_1, (X509ChainStatus_tB6C3677955C287CF97042F208630AA0F5ABF77FB )((*(X509ChainStatus_tB6C3677955C287CF97042F208630AA0F5ABF77FB *)((X509ChainStatus_tB6C3677955C287CF97042F208630AA0F5ABF77FB *)UnBox(L_2, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 7))))), \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 31));\n\t\tgoto IL_002a;\n\t} \/\/ end try (depth: 1)\n\tcatch(Il2CppExceptionWrapper& e)\n\t{\n\t\tif(il2cpp_codegen_class_is_assignable_from (((RuntimeClass*)il2cpp_codegen_initialize_runtime_metadata_inline((uintptr_t*)&InvalidCastException_tD99F9FF94C3859C78E90F68C2F77A1558BCAF463_il2cpp_TypeInfo_var)), il2cpp_codegen_object_class(e.ex)))\n\t\t{\n\t\t\tIL2CPP_PUSH_ACTIVE_EXCEPTION(e.ex);\n\t\t\tgoto CATCH_0017;\n\t\t}\n\t\tthrow e;\n\t}\n\nCATCH_0017:\n\t{ \/\/ begin catch(System.InvalidCastException)\n\t\tRuntimeObject * L_3 = ___item1;\n\t\tRuntimeTypeHandle_tC33965ADA3E041E0C94AF05E5CB527B56482CEF9  L_4 = { reinterpret_cast<intptr_t> (IL2CPP_RGCTX_TYPE(method->klass->rgctx_data, 11)) };\n\t\tIL2CPP_RUNTIME_CLASS_INIT(((RuntimeClass*)il2cpp_codegen_initialize_runtime_metadata_inline((uintptr_t*)&Type_t_il2cpp_TypeInfo_var)));\n\t\tType_t * L_5;\n\t\tL_5 = Type_GetTypeFromHandle_m8BB57524FF7F9DB1803BC561D2B3A4DBACEB385E((RuntimeTypeHandle_tC33965ADA3E041E0C94AF05E5CB527B56482CEF9 )L_4, \/*hidden argument*\/NULL);\n\t\tThrowHelper_ThrowWrongValueTypeArgumentException_m4E9CD2C01D79997EE1808CF75715BB6BB3738F0C((RuntimeObject *)L_3, (Type_t *)L_5, \/*hidden argument*\/NULL);\n\t\tIL2CPP_POP_ACTIVE_EXCEPTION();\n\t\tgoto IL_002a;\n\t} \/\/ end catch (depth: 1)\n\nIL_002a:\n\t{\n\t\treturn;\n\t}\n}","docstring":"\/\/ end catch (depth: 1)","function_name":"List_1_System_Collections_ICollection_CopyTo_m979A262A55A01E0E4355C141CE7F5A3EA37C916C_gshared"},"id":367,"seed":"IL2CPP_EXTERN_C IL2CPP_METHOD_ATTR void List_1_System_Collections_IList_Insert_mA598B2B5AAC3779A06B3CF9243AD90C7451D6667_gshared (List_1_tC12B69E9430500C9BFF5B4B3D9F51DEE87A9D4C6 * __this, int32_t ___index0, RuntimeObject * ___item1, const RuntimeMethod* method)\n{\n\til2cpp::utils::ExceptionSupportStack<RuntimeObject*, 1> __active_exceptions;\n\til2cpp::utils::ExceptionSupportStack<int32_t, 2> __leave_targets;\n\t{\n\t\tRuntimeObject * L_0 = ___item1;\n\t\t((  void (*) (RuntimeObject *, int32_t, const RuntimeMethod*))IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 9)->methodPointer)((RuntimeObject *)L_0, (int32_t)((int32_t)20), \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 9));\n\t}\n\nIL_0008:\n\ttry\n\t{ \/\/ begin try (depth: 1)\n\t\tint32_t L_1 = ___index0;\n\t\tRuntimeObject * L_2 = ___item1;\n\t\tNullCheck((List_1_tC12B69E9430500C9BFF5B4B3D9F51DEE87A9D4C6 *)__this);\n\t\t((  void (*) (List_1_tC12B69E9430500C9BFF5B4B3D9F51DEE87A9D4C6 *, int32_t, X509ChainStatus_tB6C3677955C287CF97042F208630AA0F5ABF77FB , const RuntimeMethod*))IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 31)->methodPointer)((List_1_tC12B69E9430500C9BFF5B4B3D9F51DEE87A9D4C6 *)__this, (int32_t)L_1, (X509ChainStatus_tB6C3677955C287CF97042F208630AA0F5ABF77FB )((*(X509ChainStatus_tB6C3677955C287CF97042F208630AA0F5ABF77FB *)((X509ChainStatus_tB6C3677955C287CF97042F208630AA0F5ABF77FB *)UnBox(L_2, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 7))))), \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 31));\n\t\tgoto IL_002a;\n\t} \/\/ end try (depth: 1)\n\tcatch(Il2CppExceptionWrapper& e)\n\t{\n\t\tif(il2cpp_codegen_class_is_assignable_from (((RuntimeClass*)il2cpp_codegen_initialize_runtime_metadata_inline((uintptr_t*)&InvalidCastException_tD99F9FF94C3859C78E90F68C2F77A1558BCAF463_il2cpp_TypeInfo_var)), il2cpp_codegen_object_class(e.ex)))\n\t\t{\n\t\t\tIL2CPP_PUSH_ACTIVE_EXCEPTION(e.ex);\n\t\t\tgoto CATCH_0017;\n\t\t}\n\t\tthrow e;\n\t}\n\nCATCH_0017:\n\t{ \/\/ begin catch(System.InvalidCastException)\n\t\tRuntimeObject * L_3 = ___item1;\n\t\tRuntimeTypeHandle_tC33965ADA3E041E0C94AF05E5CB527B56482CEF9  L_4 = { reinterpret_cast<intptr_t> (IL2CPP_RGCTX_TYPE(method->klass->rgctx_data, 11)) };\n\t\tIL2CPP_RUNTIME_CLASS_INIT(((RuntimeClass*)il2cpp_codegen_initialize_runtime_metadata_inline((uintptr_t*)&Type_t_il2cpp_TypeInfo_var)));\n\t\tType_t * L_5;\n\t\tL_5 = Type_GetTypeFromHandle_m8BB57524FF7F9DB1803BC561D2B3A4DBACEB385E((RuntimeTypeHandle_tC33965ADA3E041E0C94AF05E5CB527B56482CEF9 )L_4, \/*hidden argument*\/NULL);\n\t\tThrowHelper_ThrowWrongValueTypeArgumentException_m4E9CD2C01D79997EE1808CF75715BB6BB3738F0C((RuntimeObject *)L_3, (Type_t *)L_5, \/*hidden argument*\/NULL);\n\t\tIL2CPP_POP_ACTIVE_EXCEPTION();\n\t\tgoto IL_002a;\n\t} \/\/ end catch (depth: 1)\n\nIL_002a:\n\t{\n\t\treturn;\n\t}\n}"}
{"content":{"code":"HRESULT VectorToString(DBVECTOR* pVector, DBTYPE wType, WCHAR* pwszBuffer, DBLENGTH ulMaxSize)\n{\n    ASSERT(pVector);\n    ASSERT(pwszBuffer);\n    HRESULT hr = S_OK;\n\n    \/\/No-op\n    if(!ulMaxSize)\n        return S_OK;\n\n    VARIANT Variant;\n    VARIANT* pVariant = NULL;\n    WCHAR* pwsz = pwszBuffer;\n    WCHAR* pwszEnd = pwsz + ulMaxSize;\n    pwsz[0] = L'\\0';\n\n    \/\/Make sure we are dealing with the base type...\n    wType &= ~DBTYPE_VECTOR;\n\n    \/\/Loop over the vector...\n    for(ULONG iEle=0; iEle<pVector->size; iEle++)\n    {\n        \/\/Initialize Variant\n        pVariant = &Variant;\n        pVariant->vt = VT_EMPTY;\n\n        \/\/NOTE: The pVariant is really just a pointer to the data.  We don't free the data\n        \/\/since the vector data doesn't belong to us, we are just convering the given data to\n        \/\/a string.  The simplest way to do this is to dump into a variant and let our helper\n        \/\/function VariantToString deal with this...\n\n        \/\/Obtain the data from the vector...\n        switch(wType)\n        {\n        case VT_EMPTY:\n        case VT_NULL:\n            V_VT(pVariant) = wType;\n            break;\n\n        case VT_I2:\n        case VT_I4:\n        case VT_R4:\n        case VT_R8:\n        case VT_CY:\n        case VT_DATE:\n        case VT_BSTR:\n        case VT_DISPATCH:\n        case VT_ERROR:\n        case VT_BOOL:\n        case VT_UNKNOWN:\n        case VT_I1:\n        case VT_UI1:\n        case VT_UI2:\n        case VT_UI4:\n        case VT_I8:\n        case VT_UI8:\n        case VT_INT:\n        case VT_UINT:\n        {\n            LONG lTypeSize = GetDBTypeSize(wType);\n\n            V_VT(pVariant) = wType;\n            memcpy(&V_I4(pVariant), (BYTE*)pVector->ptr + (lTypeSize*iEle), (size_t)lTypeSize);\n            break;\n        }\n\n        case VT_DECIMAL:\n            \/\/DECIMAL is not part of the VARIANT union\n            V_VT(pVariant)\t\t= wType;\n            V_DECIMAL(pVariant) = *(DECIMAL*)((BYTE*)pVector->ptr + (sizeof(DECIMAL)*iEle));\n            break;\n\n        case VT_VARIANT:\n            \/\/just place directly into our variant.\n            pVariant = (VARIANT*)((BYTE*)pVector->ptr + (sizeof(VARIANT)*iEle));\n            break;\n\n\n        default:\n            \/\/Unable to handle this type...\n            TESTC_(hr = E_FAIL,S_OK);\n        }\n\n        \/\/Convert VARIANT To String\n        TESTC_(hr = VariantToString(pVariant, pwsz, (ULONG)(pwszEnd - pwsz)),S_OK);\n        pwsz += wcslen(pwsz);\n\n        \/\/Vector Seperator\n        if(iEle<pVector->size-1 && (pwsz < pwszEnd))\n        {\n            *pwsz = L',';\n            pwsz++;\n        }\n    }\n\nCLEANUP:\n    return hr;\n}","docstring":"\/\/Everything complete successfully...","function_name":"StringToSafeArray"},"id":369,"seed":"HRESULT VectorToString(DBVECTOR* pVector, DBTYPE wType, WCHAR* pwszBuffer, DBLENGTH ulMaxSize)\n{\n    ASSERT(pVector);\n    ASSERT(pwszBuffer);\n    HRESULT hr = S_OK;\n\n    \/\/No-op\n    if(!ulMaxSize)\n        return S_OK;\n\n    VARIANT Variant;\n    VARIANT* pVariant = NULL;\n    WCHAR* pwsz = pwszBuffer;\n    WCHAR* pwszEnd = pwsz + ulMaxSize;\n    pwsz[0] = L'\\0';\n\n    \/\/Make sure we are dealing with the base type...\n    wType &= ~DBTYPE_VECTOR;\n\n    \/\/Loop over the vector...\n    for(ULONG iEle=0; iEle<pVector->size; iEle++)\n    {\n        \/\/Initialize Variant\n        pVariant = &Variant;\n        pVariant->vt = VT_EMPTY;\n\n        \/\/NOTE: The pVariant is really just a pointer to the data.  We don't free the data\n        \/\/since the vector data doesn't belong to us, we are just convering the given data to\n        \/\/a string.  The simplest way to do this is to dump into a variant and let our helper\n        \/\/function VariantToString deal with this...\n\n        \/\/Obtain the data from the vector...\n        switch(wType)\n        {\n        case VT_EMPTY:\n        case VT_NULL:\n            V_VT(pVariant) = wType;\n            break;\n\n        case VT_I2:\n        case VT_I4:\n        case VT_R4:\n        case VT_R8:\n        case VT_CY:\n        case VT_DATE:\n        case VT_BSTR:\n        case VT_DISPATCH:\n        case VT_ERROR:\n        case VT_BOOL:\n        case VT_UNKNOWN:\n        case VT_I1:\n        case VT_UI1:\n        case VT_UI2:\n        case VT_UI4:\n        case VT_I8:\n        case VT_UI8:\n        case VT_INT:\n        case VT_UINT:\n        {\n            LONG lTypeSize = GetDBTypeSize(wType);\n\n            V_VT(pVariant) = wType;\n            memcpy(&V_I4(pVariant), (BYTE*)pVector->ptr + (lTypeSize*iEle), (size_t)lTypeSize);\n            break;\n        }\n\n        case VT_DECIMAL:\n            \/\/DECIMAL is not part of the VARIANT union\n            V_VT(pVariant)\t\t= wType;\n            V_DECIMAL(pVariant) = *(DECIMAL*)((BYTE*)pVector->ptr + (sizeof(DECIMAL)*iEle));\n            break;\n\n        case VT_VARIANT:\n            \/\/just place directly into our variant.\n            pVariant = (VARIANT*)((BYTE*)pVector->ptr + (sizeof(VARIANT)*iEle));\n            break;\n\n\n        default:\n            \/\/Unable to handle this type...\n            TESTC_(hr = E_FAIL,S_OK);\n        }\n\n        \/\/Convert VARIANT To String\n        TESTC_(hr = VariantToString(pVariant, pwsz, (ULONG)(pwszEnd - pwsz)),S_OK);\n        pwsz += wcslen(pwsz);\n\n        \/\/Vector Seperator\n        if(iEle<pVector->size-1 && (pwsz < pwszEnd))\n        {\n            *pwsz = L',';\n            pwsz++;\n        }\n    }\n\nCLEANUP:\n    return hr;\n}"}
{"content":{"code":"IL2CPP_METHOD_ATTR bool IIteratorToIEnumeratorAdapter_1_System_Collections_IEnumerator_MoveNext_m877948275_gshared (IIteratorToIEnumeratorAdapter_1_t2558291098 * __this, const RuntimeMethod* method)\n{\n\tstatic bool s_Il2CppMethodInitialized;\n\tif (!s_Il2CppMethodInitialized)\n\t{\n\t\til2cpp_codegen_initialize_method (IIteratorToIEnumeratorAdapter_1_System_Collections_IEnumerator_MoveNext_m877948275_MetadataUsageId);\n\t\ts_Il2CppMethodInitialized = true;\n\t}\n\tException_t * __last_unhandled_exception = 0;\n\tNO_UNUSED_WARNING (__last_unhandled_exception);\n\tException_t * __exception_local = 0;\n\tNO_UNUSED_WARNING (__exception_local);\n\tint32_t __leave_target = -1;\n\tNO_UNUSED_WARNING (__leave_target);\n\t{\n\t\tbool L_0 = (bool)__this->get_hadCurrent_2();\n\t\tif (L_0)\n\t\t{\n\t\t\tgoto IL_000a;\n\t\t}\n\t}\n\t{\n\t\treturn (bool)0;\n\t}\n\nIL_000a:\n\ttry\n\t{ \/\/ begin try (depth: 1)\n\t\t{\n\t\t\tbool L_1 = (bool)__this->get_initialized_1();\n\t\t\tif (L_1)\n\t\t\t{\n\t\t\t\tgoto IL_002c;\n\t\t\t}\n\t\t}\n\nIL_0012:\n\t\t{\n\t\t\tRuntimeObject* L_2 = (RuntimeObject*)__this->get_iterator_0();\n\t\t\tNullCheck((RuntimeObject*)L_2);\n\t\t\tbool L_3 = InterfaceFuncInvoker0< bool >::Invoke(1 \/* System.Boolean Windows.Foundation.Collections.IIterator`1<UnityEngine.Playables.PlayableBinding>::get_HasCurrent() *\/, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 0), (RuntimeObject*)L_2);\n\t\t\t__this->set_hadCurrent_2(L_3);\n\t\t\t__this->set_initialized_1((bool)1);\n\t\t\tgoto IL_003d;\n\t\t}\n\nIL_002c:\n\t\t{\n\t\t\tRuntimeObject* L_4 = (RuntimeObject*)__this->get_iterator_0();\n\t\t\tNullCheck((RuntimeObject*)L_4);\n\t\t\tbool L_5 = InterfaceFuncInvoker0< bool >::Invoke(2 \/* System.Boolean Windows.Foundation.Collections.IIterator`1<UnityEngine.Playables.PlayableBinding>::MoveNext() *\/, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 0), (RuntimeObject*)L_4);\n\t\t\t__this->set_hadCurrent_2(L_5);\n\t\t}\n\nIL_003d:\n\t\t{\n\t\t\tbool L_6 = (bool)__this->get_hadCurrent_2();\n\t\t\tif (!L_6)\n\t\t\t{\n\t\t\t\tgoto IL_0056;\n\t\t\t}\n\t\t}\n\nIL_0045:\n\t\t{\n\t\t\tRuntimeObject* L_7 = (RuntimeObject*)__this->get_iterator_0();\n\t\t\tNullCheck((RuntimeObject*)L_7);\n\t\t\tPlayableBinding_t354260709  L_8 = InterfaceFuncInvoker0< PlayableBinding_t354260709  >::Invoke(0 \/* T Windows.Foundation.Collections.IIterator`1<UnityEngine.Playables.PlayableBinding>::get_Current() *\/, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 0), (RuntimeObject*)L_7);\n\t\t\t__this->set_current_3(L_8);\n\t\t}\n\nIL_0056:\n\t\t{\n\t\t\tgoto IL_0071;\n\t\t}\n\t} \/\/ end try (depth: 1)\n\tcatch(Il2CppExceptionWrapper& e)\n\t{\n\t\t__exception_local = (Exception_t *)e.ex;\n\t\tif(il2cpp_codegen_class_is_assignable_from (Exception_t_il2cpp_TypeInfo_var, il2cpp_codegen_object_class(e.ex)))\n\t\t\tgoto CATCH_0058;\n\t\tthrow e;\n\t}\n\nCATCH_0058:\n\t{ \/\/ begin catch(System.Exception)\n\t\t{\n\t\t\tIL2CPP_RUNTIME_CLASS_INIT(Marshal_t1757017490_il2cpp_TypeInfo_var);\n\t\t\tint32_t L_9 = Marshal_GetHRForException_m813614142(NULL \/*static, unused*\/, (Exception_t *)((Exception_t *)__exception_local), \/*hidden argument*\/NULL);\n\t\t\tif ((!(((uint32_t)L_9) == ((uint32_t)((int32_t)-2147483636)))))\n\t\t\t{\n\t\t\t\tgoto IL_006f;\n\t\t\t}\n\t\t}\n\nIL_0064:\n\t\t{\n\t\t\tInvalidOperationException_t56020091 * L_10 = (InvalidOperationException_t56020091 *)il2cpp_codegen_object_new(InvalidOperationException_t56020091_il2cpp_TypeInfo_var);\n\t\t\tInvalidOperationException__ctor_m237278729(L_10, (String_t*)_stringLiteral1621028992, \/*hidden argument*\/NULL);\n\t\t\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_10, NULL, IIteratorToIEnumeratorAdapter_1_System_Collections_IEnumerator_MoveNext_m877948275_RuntimeMethod_var);\n\t\t}\n\nIL_006f:\n\t\t{\n\t\t\tIL2CPP_RAISE_MANAGED_EXCEPTION(__exception_local, NULL, IIteratorToIEnumeratorAdapter_1_System_Collections_IEnumerator_MoveNext_m877948275_RuntimeMethod_var);\n\t\t}\n\t} \/\/ end catch (depth: 1)\n\nIL_0071:\n\t{\n\t\tbool L_11 = (bool)__this->get_hadCurrent_2();\n\t\treturn L_11;\n\t}\n}","docstring":"\/\/ end catch (depth: 1)","function_name":"IIteratorToIEnumeratorAdapter_1_System_Collections_IEnumerator_MoveNext_m506314125_gshared"},"id":372,"seed":"IL2CPP_METHOD_ATTR bool IIteratorToIEnumeratorAdapter_1_System_Collections_IEnumerator_MoveNext_m877948275_gshared (IIteratorToIEnumeratorAdapter_1_t2558291098 * __this, const RuntimeMethod* method)\n{\n\tstatic bool s_Il2CppMethodInitialized;\n\tif (!s_Il2CppMethodInitialized)\n\t{\n\t\til2cpp_codegen_initialize_method (IIteratorToIEnumeratorAdapter_1_System_Collections_IEnumerator_MoveNext_m877948275_MetadataUsageId);\n\t\ts_Il2CppMethodInitialized = true;\n\t}\n\tException_t * __last_unhandled_exception = 0;\n\tNO_UNUSED_WARNING (__last_unhandled_exception);\n\tException_t * __exception_local = 0;\n\tNO_UNUSED_WARNING (__exception_local);\n\tint32_t __leave_target = -1;\n\tNO_UNUSED_WARNING (__leave_target);\n\t{\n\t\tbool L_0 = (bool)__this->get_hadCurrent_2();\n\t\tif (L_0)\n\t\t{\n\t\t\tgoto IL_000a;\n\t\t}\n\t}\n\t{\n\t\treturn (bool)0;\n\t}\n\nIL_000a:\n\ttry\n\t{ \/\/ begin try (depth: 1)\n\t\t{\n\t\t\tbool L_1 = (bool)__this->get_initialized_1();\n\t\t\tif (L_1)\n\t\t\t{\n\t\t\t\tgoto IL_002c;\n\t\t\t}\n\t\t}\n\nIL_0012:\n\t\t{\n\t\t\tRuntimeObject* L_2 = (RuntimeObject*)__this->get_iterator_0();\n\t\t\tNullCheck((RuntimeObject*)L_2);\n\t\t\tbool L_3 = InterfaceFuncInvoker0< bool >::Invoke(1 \/* System.Boolean Windows.Foundation.Collections.IIterator`1<UnityEngine.Playables.PlayableBinding>::get_HasCurrent() *\/, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 0), (RuntimeObject*)L_2);\n\t\t\t__this->set_hadCurrent_2(L_3);\n\t\t\t__this->set_initialized_1((bool)1);\n\t\t\tgoto IL_003d;\n\t\t}\n\nIL_002c:\n\t\t{\n\t\t\tRuntimeObject* L_4 = (RuntimeObject*)__this->get_iterator_0();\n\t\t\tNullCheck((RuntimeObject*)L_4);\n\t\t\tbool L_5 = InterfaceFuncInvoker0< bool >::Invoke(2 \/* System.Boolean Windows.Foundation.Collections.IIterator`1<UnityEngine.Playables.PlayableBinding>::MoveNext() *\/, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 0), (RuntimeObject*)L_4);\n\t\t\t__this->set_hadCurrent_2(L_5);\n\t\t}\n\nIL_003d:\n\t\t{\n\t\t\tbool L_6 = (bool)__this->get_hadCurrent_2();\n\t\t\tif (!L_6)\n\t\t\t{\n\t\t\t\tgoto IL_0056;\n\t\t\t}\n\t\t}\n\nIL_0045:\n\t\t{\n\t\t\tRuntimeObject* L_7 = (RuntimeObject*)__this->get_iterator_0();\n\t\t\tNullCheck((RuntimeObject*)L_7);\n\t\t\tPlayableBinding_t354260709  L_8 = InterfaceFuncInvoker0< PlayableBinding_t354260709  >::Invoke(0 \/* T Windows.Foundation.Collections.IIterator`1<UnityEngine.Playables.PlayableBinding>::get_Current() *\/, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 0), (RuntimeObject*)L_7);\n\t\t\t__this->set_current_3(L_8);\n\t\t}\n\nIL_0056:\n\t\t{\n\t\t\tgoto IL_0071;\n\t\t}\n\t} \/\/ end try (depth: 1)\n\tcatch(Il2CppExceptionWrapper& e)\n\t{\n\t\t__exception_local = (Exception_t *)e.ex;\n\t\tif(il2cpp_codegen_class_is_assignable_from (Exception_t_il2cpp_TypeInfo_var, il2cpp_codegen_object_class(e.ex)))\n\t\t\tgoto CATCH_0058;\n\t\tthrow e;\n\t}\n\nCATCH_0058:\n\t{ \/\/ begin catch(System.Exception)\n\t\t{\n\t\t\tIL2CPP_RUNTIME_CLASS_INIT(Marshal_t1757017490_il2cpp_TypeInfo_var);\n\t\t\tint32_t L_9 = Marshal_GetHRForException_m813614142(NULL \/*static, unused*\/, (Exception_t *)((Exception_t *)__exception_local), \/*hidden argument*\/NULL);\n\t\t\tif ((!(((uint32_t)L_9) == ((uint32_t)((int32_t)-2147483636)))))\n\t\t\t{\n\t\t\t\tgoto IL_006f;\n\t\t\t}\n\t\t}\n\nIL_0064:\n\t\t{\n\t\t\tInvalidOperationException_t56020091 * L_10 = (InvalidOperationException_t56020091 *)il2cpp_codegen_object_new(InvalidOperationException_t56020091_il2cpp_TypeInfo_var);\n\t\t\tInvalidOperationException__ctor_m237278729(L_10, (String_t*)_stringLiteral1621028992, \/*hidden argument*\/NULL);\n\t\t\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_10, NULL, IIteratorToIEnumeratorAdapter_1_System_Collections_IEnumerator_MoveNext_m877948275_RuntimeMethod_var);\n\t\t}\n\nIL_006f:\n\t\t{\n\t\t\tIL2CPP_RAISE_MANAGED_EXCEPTION(__exception_local, NULL, IIteratorToIEnumeratorAdapter_1_System_Collections_IEnumerator_MoveNext_m877948275_RuntimeMethod_var);\n\t\t}\n\t} \/\/ end catch (depth: 1)\n\nIL_0071:\n\t{\n\t\tbool L_11 = (bool)__this->get_hadCurrent_2();\n\t\treturn L_11;\n\t}\n}"}
